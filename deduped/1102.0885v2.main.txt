## Acknowledgments

Thanks to all the people, I met on the way of my PhD education, for
introducing me to new ways of thinking, inspiring me by fascinating
ideas, and helping me in so many other ways. Thanks to all the people
that stayed with me on this way without questioning these very same
aspects. To mention just a few @xmath

@xmath special thanks to my supervisors Ivan Damgård—who taught me so
much about cryptography—and Louis Salvail—who taught me so much about
quantum—and often vice versa. Thanks to my co-authors Christian
Schaffner, Jesper Buus Nielsen, and Serge Fehr for their support
throughout my PhD studies and for teaching me many fascinating details.

@xmath thanks to Prof. Claude Crépeau from McGill University in Montréal
and Prof. Stefan Wolf from ETH Zürich as well as Prof. Susanne Bødker
from Aarhus University for agreeing to constitute the evaluation
committee for my PhD thesis.

@xmath thanks for proof-reading some parts of the thesis to Chris,
Dorthe, and Jesper as well as for valuable comments to Claude and Louis.

@xmath thanks to the Crypto-Group with all its members that left, stayed
or newly arrived. This environment is a great place to do research in
(while drinking espresso and eating cake), and many non-research
activities (like launching julefrokost, fridaybaring, dancing danske
folkedanse, and often absurd discussions about everything under the sun)
are unforgettable. Thanks to the always helpful staff at the department,
especially to Dorthe, Ellen, and Hanne.

@xmath thanks to Aarhus University for enabling me to travel around the
world, and in that respect also to IACR, Université de Montréal, INTRIQ,
and Princeton University. Furthermore, my studies were supported by the
MOBISEQ research project, which is funded by Det Strategiske
Forskningsråds Programkomite for Nanovidenskab og -teknologi,
Bioteknologi og IT (NABIIT). Many thanks also to Institut Mittag-Leffler
of the Royal Swedish Academy of Sciences for providing time, grant, and
space to think—as well as to prepare the defense and to revise the
thesis. Thanks to Prof. Mary Beth Ruskai for pointing to the quantum
information program at the institute.

@xmath thanks to Prof. Christoph Kreitz from the University of Potsdam
for sparking my interest in crypto in the first place.

@xmath and thanks to my family and many friends for their support, often
from the distance. Grazie a Claudio, with whom I went through all phases
of ever-changing three years of PhD studies. Vielen Dank an MaPa,
Steffi, und Dande, whose support and (blind) acceptance was most helpful
during my education. And last but not least, mange tak til Jesper.

Carolin Lunemann

Århus, August 31, 2010

###### Contents

-    Abstract
-    Acknowledgments
-    1 Introduction
    -    1.1 On Cryptography
    -    1.2 On the Quantum World
    -    1.3 Contributions
        -    1.3.1 The Importance of Mixed Commitments
        -    1.3.2 Improving the Security of Quantum Protocols
        -    1.3.3 Classical Coin-Flipping in the Quantum World
        -    1.3.4 Applications
-    I Setting The Stage
    -    2 Cryptographic Toolbox
        -    2.1 Players
        -    2.2 Security Flavors, Assumptions, and Models
        -    2.3 Worlds
        -    2.4 Primitives
            -    2.4.1 Commitments
            -    2.4.2 Oblivious Transfer
            -    2.4.3 Password-Based Identification
            -    2.4.4 Coin-Flipping
            -    2.4.5 Zero-Knowledge
            -    2.4.6 Secure Secret Sharing
    -    3 Quantum Tools
        -    3.1 Postulates and Terminology
        -    3.2 Distance, Distinguishability, and Dependence
        -    3.3 Entropies
        -    3.4 Information Reconciliation and Privacy Amplification
        -    3.5 Rewinding
            -    3.5.1 Problems with General Rewinding
            -    3.5.2 Quantum Rewinding
        -    3.6 Definition of Security
            -    3.6.1 Correctness
            -    3.6.2 Information-Theoretic Security
            -    3.6.3 Computational Security
-    II Quantum Cryptography
    -    4 Introduction
        -    4.1 Mixed Commitments
            -    4.1.1 Motivation
            -    4.1.2 Idea
            -    4.1.3 Instantiations
            -    4.1.4 Extended Construction
    -    5 Improved Security for Quantum Protocols
        -    5.1 Motivation
        -    5.2 Introducing @xmath
            -    5.2.1 Initial situation
            -    5.2.2 Security against Benign Bob
            -    5.2.3 From Benign to Computational Security
            -    5.2.4 Proof of Bounds on Entropy and Memory Size
        -    5.3 In the Presence of Noise
        -    5.4 Bounded-Quantum-Storage Security
        -    5.5 Composability
            -    5.5.1 Sequential Composition
            -    5.5.2 General Composition
    -    6 Applications
        -    6.1 Oblivious Transfer
            -    6.1.1 Motivation and Related Work
            -    6.1.2 The Protocol
        -    6.2 Password-Based Identification
            -    6.2.1 Motivation and Related Work
            -    6.2.2 The Protocol
        -    6.3 Man-in-the-Middle Security for Identification
            -    6.3.1 Motivation
            -    6.3.2 The Set-Up
            -    6.3.3 The Protocol
-    III Cryptography in the Quantum World
    -    7 Introduction
        -    7.1 Regular Bit Commitment
        -    7.2 Extended Construction for Mixed Commitments
        -    7.3 Trapdoor Opening for Mixed Commitments
    -    8 Quantum-Secure Coin-Flipping
        -    8.1 Motivation and Related Work
        -    8.2 The Protocol
        -    8.3 Composability
            -    8.3.1 Sequential Composition
            -    8.3.2 General Composition
    -    9 Amplification Framework for Strong Coins
        -    9.1 Motivation
        -    9.2 Security Notions
        -    9.3 Amplification Theorems
            -    9.3.1 From Short Outcomes to Long Outcomes
            -    9.3.2 From @xmath to @xmath
            -    9.3.3 From @xmath to @xmath
    -    10 Applications
        -    10.1 Interactive Quantum Zero-Knowledge
            -    10.1.1 Motivation and Related Work
            -    10.1.2 Formal Definition of Zero-Knowledge Proofs
            -    10.1.3 The Transformation
        -    10.2 Zero-Knowledge Proof of Knowledge
            -    10.2.1 Motivation and Related Work
            -    10.2.2 Simulatable Witness Encodings of @xmath
            -    10.2.3 The Protocol
        -    10.3 Generation of Commitment Keys
            -    10.3.1 Motivation
            -    10.3.2 The Generation

### Chapter 1 Introduction

#### 1.1 On Cryptography

The multiple human needs and desires that demand privacy among two or
more people

in the midst of social life must inevitably lead to cryptology wherever
men thrive

and wherever they write.

— David Kahn

Cryptography is the art of secret writing (from Greek @xmath and @xmath
) and may be considered almost as old as writing itself. Cryptography
played a crucial role throughout the history of any society that
depended on information, from the Greek Scytale and the Roman Caesar
cipher, over the Vigenère cipher, electromechanical rotor machines and
encryption standards, to forming the backbone of electronic
infrastructures in modern life (see e.g. [ Sin00 ] for a historic survey
of cryptography).

The first cryptographic methods are known as secret-key cryptography ,
based on one secret key shared between the communicating parties and
used both for encryption and decryption. Already apparent from this
description derives its main problem, which lies in the logistics of
distributing the key securely: Prior to any secret communication, the
involved parties must be in possession of the same secret key.
Nevertheless, secret-key cryptography was in use for thousands of years,
adjusting its complexity to ever-increasing developments in technique
and technology.

Public-key cryptography was the technological revolution, solving the
key distribution problem. The idea was independently discovered by
Diffie and Hellman in [ DH76 ] with Rivest, Shamir, and Adleman,
providing the first implementation [ RSA78 ] , and slightly earlier but
in secrecy, by Ellis, followed by Cocks’ and Williamson’s practical
application (e.g. [ Coc08 ] ). Public-key cryptography is based on a
pair of keys for each communicating party, namely a public key for
encryption and a corresponding secret key for decryption, where it must
hold that it is computationally infeasible (in polynomial time) of
deriving the secret key from the public one. Then, we require a family
of trapdoor one-way functions defining the encryption and decryption
procedure. Informally, that means that encryption is a one-way
operation, which is efficiently computable, given the public key,
whereas the decryption function is hard to compute, unless the trapdoor
is known, i.e. the secret key. Thus, the public key can be published
without compromising security, and hence, public-key cryptography does
not suffer from key distribution problems. Due to that and to the fact
that the technique additionally allows for digital signatures that are
verifiable with the public key and yet unforgeable without the secret
key, the concept of public-key cryptography is highly used and required
in the age of the Internet and the proliferation of electronic
communication systems.

New potential in cryptography emerged with quantum cryptography ,
starting with Wiesner’s groundbreaking paper [ Wie83 ] ¹ ¹ 1 The paper
was written in the early 1970ies but rejected and only published
retroactively in 1983. , suggesting that “quantum mechanics allows us
novel forms of coding without analogue [in classical physics]” (p. 78).
His approach of conjugate coding did not only lay the foundations of the
new cryptographic technique but also suggested a system for sending “two
mutually exclusive messages” (p. 83), which is today known as the
powerful primitive of oblivious transfer. It took several years (and the
Caribbean sea) to establish quantum cryptography as a scientific
discipline, accomplished by Bennett and Brassard, mainly by the
BB84-protocol for quantum key distribution (QKD) in [ BB84 ] after
preceding work such as [ BBBW82 , BB83 ] , culminating in the first
practical realizations [ BB89 , BBB @xmath 92 ] . An alternative QKD
scheme was independently proposed by Ekert in [ Eke91 ] , based on a
different approach using quantum entanglement. Since then, QKD was
further researched, both on a theoretical and an experimental level.
Today, conjugate BB84-coding also forms the basis for various more
general quantum cryptographic tasks other than key distribution.

Modern cryptography concerns, besides the secrecy and authenticity of
communication, also the security of various other task. For instance,
theoretical research in the sub-field of cryptographic protocol theory
covers cryptographic primitives with fundamental properties for secure
multi-party computation. Each primitive can be seen as a building block
that implements some basic functionality. Composition of such primitives
within outer protocols yield applications that implement a specific task
securely over a distance.

#### 1.2 On the Quantum World

Anyone who is not shocked by quantum theory has not understood it.

— Niels Bohr

In the quantum world, we consider the behavior of systems at the
smallest scale, which cannot be explained nor described by classical
physics. A quantum ² ² 2 quantus (Latin) - how much is the smallest unit
of a physical entity, and the fundamental concept in quantum information
theory is a quantum bit, or short, a qubit. Quantum information theory
was established at the beginning of the last century, but has been
subject to different interpretations ever since—both scientific and
philosophical. This thesis is divided into two subareas of quantum
information theory, constituting the following two main parts, Part II
and Part III (Part I is dedicated to preliminaries).

Part II is in the realm of quantum cryptography, where—informally
speaking—the transmission of qubits followed by some classical
post-processing is employed to accomplish a cryptographic task. The
security is mainly derived by the special properties of the qubits
during and after transmission, and therewith, directly from physical
laws.

Part III on cryptography in a quantum world refers to the study of
cryptography with completely classical messages exchange, but where the
environment around is quantum. In other words, the security of the
classical schemes must withstand powerful quantum computing
capabilities.

We now present—in brief and on a (counter-)intuitive level—the aspects
unique to the quantum world, which are relevant in the context of this
work. Interestingly, these quantum features can be exploited to the
benefit of quantum cryptography. However, the very same properties
impose intriguingly new challenges in classical cryptography. In other
words, “what quantum mechanics takes away with one hand, it gives back
with the other” [ NC00 , p. 582] . And so, this work lies right at the
heart of the conflict between highly potential effects, but likewise
rather demanding conditions.

###### Information gain vs. disturbance.

This aspect might be argued to constitute the most outstanding advantage
of quantum cryptography over the classical world, and forms “the engine
that powers quantum cryptography” [ Fuc96 , p. 1] . In the classical
case, a bit can simply be read in transmission, and the information gain
solely depends on the security of the respective encryption used. In
quantum cryptography, information is typically encoded in two
complementary types of photon polarization or, in other words, a qubit
is prepared in one out of two conjugate bases with orthogonal basis
states. To gain information about such an unknown qubit, it must be
observed, but observing in the quantum world means measuring. Measuring,
or more precisely distinguishing between two non-orthogonal quantum
states, is destructive and therewith any measurement disturbes the
system. This is explained in the Heisenberg uncertainty principle ,
which states that certain pairs of quantum properties are complementary
in that measuring one of them necessarily disturbs the other.

Consequently, eavesdropping on a qubit transmission disturbs the system,
and can therefore be noticed in a statistically detectable way.
Moreover, the quantitative trade-off between information gain and
disturbance is useful not only against an external adversary, but it is
also a main ingredient when proving security against a dishonest player.
This fact is inherent in the basic security aspects of all our quantum
two-party protocols, discussed later in Part II .

###### An unknown quantum state cannot be copied.

This fact—unheard of in the case of classical data—is formalized in the
no-cloning theorem [ WZ82 ] . The peculiar property constitutes another
major security feature in quantum communications and underlies all our
quantum protocols in Part II . However, it also sets severe restriction
in the theory of quantum computing. This becomes apparent in Part III ,
where the commonly used classical proof technique rewinding , which is
also shortly discussed below, requires to copy certain data, and so has
to be carefully reviewed in the quantum world.

###### Quantum memory is limited.

A more practical issue concerns the limitation of the amount of qubits
that can be stored and then retrieved undisturbed. This may be seen as a
snapshot of current state of the art. However, ongoing research strongly
suggest that it is—and will be—much easier to transmit and measure
qubits than it is to store them for a non-negligible time.

We will make use of this given fact in our quantum protocols in Chapter
6 , which are designed such that dishonest parties would need large
quantum memory to attack successfully—a security property that classical
protocols cannot achieve. Yet, we do not exclusively rely on this
condition only, but investigate a wider diversification of security that
is not threatened by potential breakthroughs in developing quantum
storage.

###### Quantum rewinding is tricky.

As already indicated, this statement is a key aspect in Part III , and
originates from most of the above mentioned properties “all wrapped up
together”. Rewinding is a very powerful technique in simulation-based
proofs against a classical dishonest party: We can prove security
against a cheating player by showing that a run of a protocol between
him and the honest player can be efficiently simulated without
interacting with the honest player, but with a simulator instead. A
simulator is a machine which does not know the secrets of the honest
party but yet it sends messages like the honest player would do but with
more freedom, e.g. in how and when to generate these. Then to conclude
the proof, we have to show that the running time of the simulation as
well as the distribution of the conversation are according to
expectations. A simulator basically prepares a valid conversation and
tries it on the dishonest party. Now, in case this party does not send
the expected reply, we need the possibility to rewind him. ³ ³ 3 More
precisely, we model the player—similar to the simulator—as a machine,
and thus, we can just set back this machine to an earlier status, i.e.,
erase parts of the memory and start a new conversation. In that sense,
rewinding can be thought of as, for instance, rebooting a computer after
it crashed.

Unfortunately, rewinding as a proof technique can generally not be
directly applied in the quantum world, i.e., if the dishonest machine is
a quantum computer. First, we cannot trivially copy and store an
intermediate state of a quantum system, and second, quantum measurements
are in general irreversible. In order to produce a classical transcript,
the simulator would have to partially measure the quantum system without
copying it beforehand, but then it would become impossible to
reconstruct all information necessary for correct rewinding.

Due to these difficulties, no simple and straightforward security proof
for the quantum case was known. However, Watrous recently showed that in
a limited setting an efficient quantum simulation, relying on the newly
introduced quantum rewinding theorem (see [ Wat09 ] and Section 3.5.2 ),
is possible. We will discuss this aspect in more detail in Chapters 8
and 9 : We will show that the quantum rewinding argument can also be
applied to classical non-constant round coin-flipping in the quantum
world, and propose a framework to weaken certain assumptions on the
coin, in quest for a quantum-secure constant round protocol.

###### Spooky actions at a distance.

This famous naming by Einstein ⁴ ⁴ 4 “Spooky actions at a distance” was
put down originally as “spukhafte Fernwirkung” in [ Ein71 ] . describes
the phenomenon of entanglement. Informally, two qubits are called
entangled, if their state can only be described with reference to each
other. This has the effect that a measurement on one particle has an
instantaneous impact on the other one—despite any distance separating
the qubits spatially.

Entanglement is definitely a unique resource to the quantum world only.
In the words of Schrödinger, entanglement is not “ one but rather the
characteristic trait of quantum mechanics, the one that enforces its
entire departure from classical lines of thought” [ Sch35 , p. 555] .
Besides constituting a disturbing aspect—intuitively and
philosophically, entanglement opens up for interesting applications such
as quantum teleportation [ BBC @xmath 93 ] and superdense coding [ BW92
] , as well as for various aspects in quantum cryptography and
computing. We will use entanglement as a thought experiment in our
quantum protocols when analyzing an equivalent purified EPR-version ⁵ ⁵
5 An EPR-pair denotes a pair of entangled qubits. The name (ironically)
originates from the paper [ EPR35 ] by Einstein, Podolsky, and Rosen, in
which they criticized quantum mechanics as an incomplete theory—due to
entanglement. (Chapter 5 ).

#### 1.3 Contributions

This dissertation is based on research done during the three years of my
PhD studies at the Department of Computer Science, Aarhus University,
Denmark. Part of the research was conducted while visiting Université de
Montréal, Québec, Canada. The realm of this work is quantum cryptography
and classical cryptography in the quantum world. More specifically, the
thesis covers aspects of (quantum) cryptographic protocol theory, based
on cryptographic primitives. The main results are outlined in the
following sections and pictorially represented in Figure 1.1 .

##### 1.3.1 The Importance of Mixed Commitments

Classical mixed (or dual-mode) commitments are of great significance for
most constructions discussed in this work. Here, we explain the
challenges that the quantum world imposes on commitments in general and
summarize the results of [ DFL @xmath 09 , DL09 , LN10 ] in that aspect.

Security for classical constructions in the quantum world means that
quantum computation does not jeopardize the underlying mathematical
assumption that guarantees the security, for instance, in the context of
commitments, the hiding and binding property. However, we encounter even
more setbacks in the context of actually proving such constructions
secure in an outer protocol, which, in regard of this work with its main
focus on simulation-based security, are mostly due to the strong
restrictions on rewinding in the quantum world.

The first difficulty in any attempt to rewind the adversary regards the
fact that the reduction from the computational security of an outer
protocol to the computationally binding property of a commitment does
not simply translate from the classical to the quantum world.
Computational binding means that if a dishonest party can open a
commitment to two different values, then the computational assumption
does not hold. In the classical case, a simulator simulates a run of the
outer protocol with the committer, such that the latter outputs a valid
commitment at some point during the execution. Later in the protocol he
must then provide a correct opening. The simulator has the possibility
to rewind the player to any step in the protocol execution, e.g. to a
point after the commitment was sent. Then it can repeat the simulation
of the outer protocol, which can now be adapted to the simulator’s
knowledge of the committed value. If the dishonest committer opened the
same commitment to a different value than previously, he could break the
underlying assumption guaranteeing computational binding. In other
words, two valid openings of the same commitment imply the inversion of
the underlying one-way function, which concludes the proof. Such a
technique, however, is impossible to justify in the quantum world, since
we cannot trivially copy and store an intermediate state, and
measurements are in general irreversible. In order to succeed, the
simulator would have to partially measure the quantum system without
copying it beforehand to obtain the first transcript, but then it would
become impossible to reconstruct all information necessary for correct
rewinding.

The second challenge we encounter is to prove an outer protocol with an
embedded computationally hiding commitment secure. Generally speaking,
in a classical simulation of the outer protocol, the simulator aims
e.g. at hitting an ideal outcome to a function of which it then commits.
Then, if the reply from the possibly dishonest counterpart matches this
prepared function such that both sides conclude on the ideal value as
their result and the transcript is indistinguishable from a real run of
the protocol, the simulation was successful. Otherwise, the simulator
rewinds the dishonest player completely and repeats the simulation. We
show a natural and direct translation of this scenario to the quantum
world in Chapter 8 , where we use a technique that allows quantum
rewinding in this very setting when using bit commitments (see Section
1.3.3 ). In case of string commitments however, we cannot rewind the
other player in poly-time to hit the guess, since that guess consists of
a bit-string. A possible solutions for simulating against a classical
adversary is to let him commit to his message before the simulator
commits. Then the player’s message can be extracted and the simulation
can be matched accordingly. This technique, however, is again doomed to
fail in the quantum realm, since it reduces to the previous case where
the simulator cannot preserve the other party’s intermediate status as
required during such a simulation.

We will circumvent both of the above aspects by introducing mixed
commitment schemes in our protocols. Generally speaking, the notion of
mixed commitments requires some trapdoor information, given to the
simulator in the ideal world. Depending on the instantiation, the
trapdoor provides the possibility for extraction of information out of
the commitments or for equivocability when opening the commitments. This
allows us to circumvent the necessity of rewinding in the proof, while
achieving high security in the real protocol. The idea of mixed
commitment schemes is described in more detail in Section 4.1.2 and a
quantum-secure instantiation is proposed in Section 4.1.3 . Various
extensions are then discussed to match the construction to respective
requirements in different outer protocols (Sections 4.1.4 , 7.2 , and
7.3 ).

##### 1.3.2 Improving the Security of Quantum Protocols

The following results are joint work with Damgård, Fehr, Salvail, and
Schaffner [ DFL @xmath 09 ] and will be addressed in detail in Chapter 5
.

We propose a general compiler for improving the security of a large
class of two-party quantum protocols, implementing different
cryptographic tasks and running between mutually distrusting players
Alice and Bob. Our main result states that if the original protocol is
secure against a so-called benign Bob, who is only required to treat the
qubits “almost honestly” but can deviate arbitrarily afterwards, then
the compiled protocol is secure against a computationally bounded
quantum Bob. The unconditional security against Alice is preserved
during compilation and it requires only a constant increase of
transmitted qubits and classical messages.

The consequences of such a compiler are twofold. First, the basic
assumption in designing new protocols for any two-party functionality is
reduced to the relatively weak assumption on benignity. On the other
hand, the proofs for already existing protocols within the specific
class typically go through under the assumption (at least after some
minor adaptions). And second, security in the bounded-quantum-storage
model implies benign security. Therefore, by compilation of such
protocols, we can achieve hybrid security , which means that the
adversary now needs both large quantum memory and large quantum
computing power to break these new protocols.

In more detail, the protocols we consider here start with a qubit
transmission from Alice to Bob, where each qubit is encoded in one of
two conjugate bases. This implies that, whenever Bob measures in the
complementary basis, he obtains a random outcome. The second part of the
protocol consist of arbitrary classical messages and local computations,
depending on the task at hand but typically relying on the fact that a
dishonest Bob has high uncertainty about a crucial piece of information.

The basic technique to construct the compiler was already suggested in
the first quantum oblivious transfer protocol [ CK88 ] . We want to
force Bob to measure by asking him to commit (using a classical scheme)
to all his basis choices and measurement results, and then require him
to open some of them later. While classical intuition suggests that the
commitments should force Bob to measure (almost) all the qubits, it was
previously very unclear what exactly it would achieve in the quantum
world. To our best knowledge, it was never formally proven that the
classical intuition also holds for a quantum Bob. We now give a full
characterization of the commit&open approach in general quantum
settings, namely that it forces Bob to be benign.

We propose a formal definition for benignity , which might be of
independent interest. A benign Bob is characterized by the following two
conditions, which must be satisfied after the qubit transmission. First,
his quantum storage is very small, and second, there exists a
basis-string such that the uncertainty about Alice’s encoded bit is
essentially one bit whenever the encoding basis does not match the basis
indicated in that string. These two conditions imply that a successfully
passed opening of his commitments for a random test subset puts Bob in a
situation, which is close to a scenario in which he measured as supposed
to: His quantum memory is essentially of size zero, and furthermore,
measuring the untested qubits in a basis complementary to the one Bob
(claims to have) used, leads to a result with large uncertainty. The
bounds on Bob’s uncertainty and his quantum memory are proven for an
ideal state that is negligible close to the real state. For the ideal
state, we can then show that the remaining subsystem after the test is a
superposition of states with relative Hamming distance upper bounded by
the test estimate .

To conclude the proof, we assume that the original protocol implements
some ideal functionality with statistical security against benign Bob.
Then we show that the compiled protocol with the commitments also
implements that functionality but now with security against any
computationally bounded (quantum) Bob. To preserve the unconditional
security of the original protocol, we require an unconditionally hiding
commitment scheme. Since the common reduction from the computational
security of the protocol to the computational binding property of a
commitment would require rewinding, we use a mixed dual-mode commitment,
which allows us to avoid rewinding Bob in this step (see also Section
1.3.1 ).

We generalize our result to noisy quantum communication and show that
the compilation does not render sequential composability insecure. We
then extend the underlying commitment scheme for a more general
composability guarantee and obtain that any compiled protocol
computationally quantum-UC-emulates its corresponding ideal
functionality.

##### 1.3.3 Classical Coin-Flipping in the Quantum World

The result on quantum-secure single coin-flipping is based on [ DL09 ] ,
co-authored with Damgård, and will be fully discussed in Chapter 8 . The
proposed amplification framework for obtaining strong coin-strings from
weak initial assumption on the coins is joint work with Nielsen [ LN10 ]
and will be addressed in more detail in Chapter 9 .

We first investigate the standard coin-flipping protocol with classical
messages exchange but where the adversary is assumed to be capable of
quantum computing. The output of the protocol is a uniformly random
unbiased bit, and the construction does not require any set-up
assumptions. Therewith, the communicating parties can interactively
generate true randomness from scratch in the quantum world. Our result
constitutes the most direct quantum analogue of the classical security
proof by using a recent result of Watrous [ Wat09 ] that allows for
quantum rewinding in this restricted setting and when flipping a single
coin.

The full potential of coin-flipping lies in the possibility of flipping
a string of coins instead of a bit, such that the parties can
interactively generate a common random string from scratch. Therewith,
it is possible, for instance, to implement the theoretical assumption of
the common-reference-string-model, which then implies that various
interesting applications can be realized in a simple manner without any
set-up assumptions.

We show that with our definitions, the single coin-flipping protocol
composes sequentially. Additionally, we sketch an extended construction
of the underlying commitment scheme, allowing for efficient simulation
on both sides, with which we achieve more general composition
guarantees. Both compositions, however, are not fully satisfactory.
Sequential coin-flipping allows for implementations without set-up
assumptions but leads to a non-constant round application. In contrast,
parallel composition achieves much better efficiency with constant round
complexity but requires some set-up assumptions in our proposed
construction here. Unfortunately, we do not know how to extend Watrous
quantum rewinding to the case of bit-strings, while keeping the running
time of the simulator polynomial. The proof technique in the purely
classical setting is impossible to apply in the quantum world (see also
Section 1.3.1 ). Other techniques to achieve constant round
coin-flipping are not known to date.

Our framework in Chapter 9 can be understood as a step towards constant
round coin-flipping . We first investigate different security degrees of
a string of coins. We then propose protocol constructions that allow us
to amplify the respective degrees of security such that weaker coins are
converted into very strong ones. The final result constitutes an
amplification towards a coin-flipping protocol with long outcomes, which
is fully poly-time simulatable on both sides against quantum
adversaries. The protocol can be implemented with quantum-computational
security in the plain model without any set-up assumptions. It only
assumes mixed commitment schemes, which we know how to construct with
quantum security, and no other assumptions are put forward. With this
solution, we still have to compose the single coin-flip as sketched
above sequentially to obtain long outcomes, but we achieve coins with
stronger security.

Our method of amplifying the security strength of coins also applies to
potential constant round coin-flipping. If the underlying weak protocol
already produces string outcomes and is constant round, then the
resulting strong protocol is also constant round, and we consider it a
contribution in itself to define the weakest security notion for any
potential candidate that allows to amplify to the final strong protocol
using a constant round reduction.

##### 1.3.4 Applications

We consider our applications in both parts of the thesis (Chapters 6 and
10 ) well suited as examples for the respective precedent main results,
since they all have some special properties. Depending on the context
they are proposed in, they appeared in [ DFL @xmath 09 , DL09 , LN10 ] .

The first quantum protocol in Section 6.1 implements oblivious transfer
(OT), which constitutes a highly relevant cryptographic primitive that
is complete for general two-party computation. Interestingly, the idea
behind this primitive was introduced in the context of quantum
cryptography, namely, in the pioneering paper of Wiesner [ Wie83 ] that
also paved the way for quantum cryptography by introducing the concept
of conjugate coding. The very nature of conjugate coding implies
oblivious transfer, and with that, it can be understood as a natural
quantum primitive.

Classical and quantum OT cannot be implemented without any additional
restrictions. However, in contrast to classical OT, quantum OT reduces
to classical commitment. The idea of using a classical commitment within
quantum protocols was already suggested in the first quantum oblivious
transfer protocol [ CK88 ] and its follow-up work in [ BBCS91 ] .
Various partial results followed, such as assuming a perfect ideal
commitment [ Yao95 , May96 , Unr10 ] or a (theoretical) quantum string
commitment [ CDMS04 ] . Based on the analysis of our compilation
(sketched in Section 1.3.2 ), we can now rather simply apply our
compiler to (a variant of) the original quantum OT-protocol, and
therewith, give a complete proof for a concrete commitment scheme.

In a rather straightforward way, oblivious transfer as a building block
easily extends to password-based identification , which is needed for
any authenticated set-up. The quantum identification scheme in Section
6.2 allows for identification by solely proving the knowledge of a
secret password without actually announcing it in clear. Furthermore, it
has some special properties, which indicates its utility value in
practice. First, the only option without being in possession of the
password is to guess it, which implies that the same password may be
safely reused for a long time. Second, the scheme tolerates a possibly
non-uniform password, which translates to a realistic assumption of
user-memorizable passwords. And last, a typical setting for
identification is not necessarily required to run over large distances
to be considered useful, and as such, it can actually be implemented
with existing technology. Naturally, an identification scheme, secure
under diversified assumptions and against any external adversary, is an
important step towards an actual implementation.

The classical generation of commitment keys in Section 10.3 nicely
combines the above applications with the results on quantum-secure
coin-flipping, fulfilling the requirement on our mixed commitment
construction. By running a coin-flipping protocol as an initial step in
the quantum protocols above, the communicating players can interactively
generate their commitment keys for compilation. This allows us to avoid
the common-reference-string-model and yields implementations of entire
protocols in the quantum world without any set-up assumptions.

The two application in the context of zero-knowledge are interesting in
that the interactive generation of coins at the beginning or during
outer protocols allows for quantum-secure realizations of classical
schemes from scratch. First in Section 10.1 , we show a simple
transformation from non-interactive zero-knowledge to interactive
quantum zero-knowledge . Then in Section 10.2 , we propose a
quantum-secure zero-knowledge proof of knowledge , which relies not only
on initial randomness but also on enforceable randomness and is based on
a witness encoding scheme providing a certain degree of extractability,
defined for the quantum context to resemble special soundness of
classical schemes. Both zero-knowledge constructions nicely highlight
that the realization of coin-flipping as a stand-alone tool allows for
using it rather freely in various contexts.

## Part I Setting The Stage

### Chapter 2 Cryptographic Toolbox

In this work, we are interested in classical and quantum cryptographic
two-party protocols, i.e., our focus lies on enabling two players to
accomplish a specific task securely by communicating over a distance. In
a perfect world of gentlemen, we could, of course, just communicate over
a distance without using cryptographic security precautions. In an ideal
world, we can simply assume a “black-box” that solves what we want while
not leaking anything of importance. However, we operate in the real
world. This means that we do not only have to take various dishonest
players into account when implementing our protocols, but also that we
have to work within a restricted framework of given conditions and
existing resources. ¹ ¹ 1 Note that, throughout this work, we will use
the terms ideal world and real world also in the more formal context of
the so-called two-world paradigm (see Section 2.3 ) for simulation-based
proofs.

In the following sections we formalize this intuitive description in
cryptographic terms. The chapter is not intended to provide a full
introduction to cryptographic protocol theory, but rather to give a
brief but complete overview of notation, tools, conditions, and settings
we will use, and to fix terminology that may vary in standard
literature. In short, we are setting the stage for the results in this
thesis.

#### 2.1 Players

Our main characters are Alice and Bob, who are subject to different
roles and cheating capabilities. The correctness of our two-party
protocols is ensured, if they implement the task at hand in the desired
way. This scenario only concerns honest parties Alice and Bob, who may
have different roles, such as sender, receiver, committer, verifier,
user and server, depending on the respective functionality to be carried
out. An honest player is denoted by @xmath .

Security is shown by investigating the case where one of the parties is
dishonest . More precisely, a dishonest party @xmath can try, for
instance, to bias the outcome of the protocol or to succeed
illegitimately.

Between these two extremes, there are various nuances of cheating. For
instance, the common notion of semi-honest describes an
“honest-but-curious” player who is curious enough in trying to gain
additional information while following the protocol honestly. We will in
Chapters 5 and 6 use another intermediate notion that captures benignly
dishonest behavior in quantum protocols. The protocols consist of a
quantum transmission phase and some classical post-processing. A benign
receiver of qubits is assumed to treat these “almost honestly”, which
means he immediately measures most of the qubits upon reception in the
specified bases. Afterwards during the classical post-processing, he can
deviate arbitrarily. Thus, in some sense, he wants to cheat but is
incapable of mastering the quantum information in any other way than
simply measuring it. We will define this newly introduced notion in
greater detail later on, as it forms the foundation of our improved
quantum protocols.

A very different external adversary is the so-called man-in-the-middle
Eve (denoted by @xmath ), who tries to eavesdrop on the classical and
quantum communication between Alice and Bob, with the intention to break
the protocol—or at least gain some information—without being detected.
Quantum cryptography provides its protocols with automatic intrusion
detection , due to the fact that here any kind of intrusion will
inevitably disturb the system. However, we have to thoroughly implement
the testing of qubits for interference as well as investigate the
potential information leakage of the classical communication.

#### 2.2 Security Flavors, Assumptions, and Models

The purpose and objective of theoretical cryptography is to design
protocols with the highest security possible under any condition, this
means without any restriction on adversarial resources such as computing
power and memory size. However, this unconditional security is extremely
hard to obtain for both players simultaneously in the classical and in
the quantum world. In fact, some tasks are proven to be impossible to
achieve with unconditional security for both players. The most
well-known example thereof might be the impossibility results on
unconditionally secure classical and quantum bit commitment (proven in
the quantum case by [ May97 , LC97 ] ). Furthermore, for two distrusting
parties, the only applications actually proven to be unconditionally
secure regarding confidentiality are Vernam’s symmetric one-time pad
encryption [ Ver26 , Sha49 ] as well as quantum key distribution [ BB84
, SP00 ] .

Thus, the level of security has to be lowered for implementing other
functionalities, and we have to achieve a reasonable balance between
realistic assumptions under consideration of current and future
technology—as weak as possible—and yet meaningful security—as strong as
possible. For that purpose, we specify cryptographic models to capture
various notions of security and to impose realistic restrictions on the
adversary. To mention just a few, such models consider limited computing
power, limited memory size [ Mau92 , DFSS05 ] , a common resource with
special properties (e.g. initially shared randomness), noisy storage [
WST08 ] or restricted quantum measurement (e.g. a limited set of
measurements [ KMP04 ] or a limited set of qubits to be measured at the
same time [ Sal98 ] ).

###### Computational Security.

Restricting the adversarial classical computing power and time is
currently the most applied model in practical public-key cryptography.
Thus, it is known as the plain model , achieving computational security
based on classical hardness assumptions that some problems are
computationally infeasible to solve in polynomial time ² ² 2 An
algorithm is poly-time, if its running time is upper bounded by a
polynomial in the size of its input, i.e. @xmath . In more detail, there
exist constants @xmath and @xmath such that @xmath for all @xmath . As
synonyms, we often use feasible or efficient . . Usually, security is
shown by reducing the security of the actual scheme to that of a
well-known mathematical problem. However, the hardness of such
complexity assumptions is unproven.

It should also not go unnoted that with the emergence of quantum
computers which, due to their speed-up in running time, have great
potential to solve several of the basic assumptions in polynomial time,
security of various crypto-systems would fold. To give examples, Shor
showed algorithms for efficiently factoring large integers [ Sho97 ] ,
which would jeopardize the RSA assumption, and for the related problem
of computing discrete logarithms underlying e.g. the ElGamal encryption
system. Grover’s algorithm for conducting a search through some
unstructured search space shows a quadratic speed-up over classical
computation. This, for instance, also affects the time of performing
exhaustive search over the set of possible keys, used in symmetric
crypto-systems (e.g. DES). Of course, these algorithms only yield
profitable results, if large-scale quantum computers can be built.
Interestingly, the very quantum effects that makes them so powerful,
also makes them so difficult to control—so far.

###### Quantum-Computational Security.

Recently, the new sub-field of so-called post-quantum cryptography has
emerged within public-key cryptography. ³ ³ 3 The common classification
might be slightly confusing, in that the notion “post-quantum” relates
to the time after the successful development of large-scale quantum
computers as opposed to quantum cryptography. There, the focus lies on
researching assumptions which are believed to be hard even on a quantum
computer, and thus, on achieving quantum-computational security .
Post-quantum crypto-schemes include, for instance, the McEliece
crypto-system based on a coding-theoretic problem [ McE78 ] and
lattice-based crypto-systems (e.g. [ Ajt96 , Reg05 ] ). The latter
provide, besides good efficiency when en- and decoding, the merit that
breaking the security of such protocols implies to solve a hard lattice
problem in the worst case . However, we should stress also in this
context that this hardness is again assumed; formal proofs are still to
come. In this work, we will use lattice-based crypto-systems for
implementing mixed commitment schemes, secure in the quantum world
(Chapters 5 and 9 ).

###### Quantum Security.

In contrast to security through mathematical hardness assumptions in
classical cryptography, the security in quantum cryptography is based on
quantum mechanical laws. Proofs for physical limitations are not by
reduction as for computational limitations but in information-theoretic
terms. That means that in such models, an adversary does not learn any
information, except with at most negligible probability. ⁴ ⁴ 4
Negligible in @xmath means that any function of @xmath is smaller than
the inverse of any polynomial, provided @xmath is sufficiently large,
i.e., for all constants @xmath there exists a constant @xmath such that
@xmath for all @xmath .

###### Bounded-Quantum-Storage Model.

In the quantum cryptographic setting, one such physical limitation is
formalized in the bounded-quantum-storage model (BQSM), proposed in [
DFSS05 ] . The intuitive idea behind the model is that the most
sensitive information is encoded in qubits that are transmitted in the
first phase of the protocol. Then, at some later point, typically an
announcement of the encoding bases follows to complete the task at hand.
Now, under the assumption that an adversary’s quantum memory size is
limited, he cannot store all of the qubits but has to measure some
fraction. Thus, by converting quantum information into classical
information without complete knowledge of the right bases, information
gets irreversibly destroyed.

The protocols in this model achieve unconditional protection against
cheating by one of the players, while if the other is corrupted, the
protocols are secure under the sole assumption that his quantum storage
is of limited size, namely of size at most a constant fraction of the
qubits sent. Such a bound can also be applied to an external
eavesdropper’s quantum memory by slightly extending the respective
original protocol. The underlying motivation for the BQSM is the fact
that transmission and measurement of qubits is well within reach of
current technology. Storing quantum information however requires keeping
the qubit state stable under controlled conditions for a non-negligible
time, which still constitutes a major technological challenge, and an
attack would require large quantum storage with a long lifetime. In
contrast, honest parties, following the protocol, do not need quantum
memory at all. Furthermore, neither honest nor dishonest parties are
bounded with respect to their classical storage or computing power. We
want to stress that the impossibility results against the
bounded-classical-storage model (see e.g. [ Mau90 , Mau92 , CCM98 , DM04
] ) do not hold in the quantum setting. ⁵ ⁵ 5 The
bounded-classical-storage model ensures security as long as the
adversary’s memory size is at most quadratic in the memory size of the
honest players. A favorably larger gap between the storage assumptions
on honest and dishonest parties was shown to be impossible [ DM04 ] .
Hence, the BQSM is realistic for fundamental physical reasons and
potentially useful in practice.

Many two-party applications investigated in the BQSM (like
identification) are not necessarily required to run over large distances
to be considered useful. Thus, such protocols can actually be
implemented with existing devices, and many applications have been
proven BQSM-secure [ DFSS05 , DFSS07 , Sch07 ] . We will work in this
model in Chapter 6 , where it constitutes one of the security layers in
our quantum protocols.

###### Common-Reference-String-Model.

Another useful model, which we will consider, is the
common-reference-string-model (CRS-model). In this model, as the name
suggests, the parties are provided with a classical common public string
before communication, taken from some fixed distribution that only
depends on the security parameter. For efficiency and composability, we
will often assume the model to allow for techniques, which require an
initially shared random string. However, we consider a random string “in
the sky” a set-up, which is only theoretically useful. To meet more
practical demands, we suggest in Chapter 8 a quantum-secure
implementation of the CRS-model “from scratch”.

#### 2.3 Worlds

###### Classical vs. Quantum World.

We are interested in cryptography in the quantum world, covering both
quantum and classical cryptographic protocol theory, which is evident in
the separation of the thesis in the two main parts, Part II on quantum
cryptography and Part III on classical cryptography in the quantum
world. Thus, throughout this work, we consider quantum
potential—achieving very high security in the first case but also
imposing new demands in the latter. In contrast, the (pure) classical
world of cryptography does traditionally not assume adversarial quantum
effects. However, we emphasize our very strong requirement also for all
classical protocols and proofs to be quantum-computationally secure,
which implies both the exclusive use of post-quantum crypto-schemes, and
the avoidance or carefully adaption of classical proof techniques.

###### Ideal vs. Real World.

For the definition of security, we work in two different worlds, which
are captured in the two-world paradigm of simulation-based proofs. The
basic idea of the paradigm is to first specify the ideal functionality
@xmath that models the intended behavior of the protocol, or in other
words, the properties we would have in an ideal world . The ideal
functionality can be thought of as a trusted third party or simply a
black-box that gets private inputs from the players, accomplishes a
specific task without leaking any information, and then outputs the
result to the respective player. Honest and dishonest players in the
ideal world are modeled by probabilistic poly-time machines, denoted by
@xmath and @xmath , respectively. The real world captures the actual
protocol @xmath , consisting of message exchange between the parties and
local computations. Recall that real-world players are indicated by
honest @xmath and dishonest @xmath .

Now, the input-output behavior of @xmath defines the required
input-output behavior of @xmath . Intuitively, if the executions are
indistinguishable, security of the protocol in real life follows. In
other words, a dishonest real-world player @xmath that attacks protocol
@xmath cannot achieve (significantly) more than an ideal-world adversary
@xmath , attacking the corresponding ideal functionality @xmath . We
will make this aspect more formal in Section 3.6 .

#### 2.4 Primitives

In the following, we will describe those two-party cryptographic
primitives, along with some known facts about them, that are relevant in
the context of this work. Primitives are fundamental problems that are
later used as basic building blocks in larger outer protocols. Discussed
on their own, primitives might seem to be somewhat limited but still
constitute intriguing thought experiments. For clarification, an
identification scheme, as discussed in Section 2.4.3 , may commonly not
count as a primitive per se, although it may well constitute a building
block in a larger outer protocol. Our prime purpose for introducing it
in the context of primitives, however, is the close relation to
oblivious transfer in its construction.

##### 2.4.1 Commitments

Commitment schemes constitute a very important building block within
cryptographic protocols. In fact, all our protocols proposed here
implementing a wide range of cryptographic tasks, make use of various
types of commitment schemes, which may indicate the significance of the
construction. Commitments can be realized with classical schemes or
through quantum communication. Here, we will only discuss and construct
commitments from classical crypto schemes, but with a strong requirement
of quantum-computational security.

Intuitively, a commitment scheme allows a player to commit to a value
while keeping it hidden ( hiding property ), yet preserving the
possibility to reveal the value fixed at commitment time later during
the so-called opening phase ( binding property ). More formally, a basic
commitment scheme @xmath takes a message @xmath and some random variable
@xmath as input. Depending on the respective scheme, the message @xmath
can be a single bit ( bit commitment ) or a bit sequence ( string
commitment ). The length of the randomness @xmath is polynomial in the
security parameter. It is also possible to construct a so-called keyed
commitment schemes of the form @xmath , which takes key @xmath as
additional input. The most common way of opening commitment @xmath to
reveal the committed message @xmath when time is ripe, is to send values
@xmath and @xmath in plain, so that the receiver of the commitment can
check its validity. In Chapter 9 , we will change this way of opening a
commitment, due to the special requirements of the particular
construction there.

The hiding property is formalized by the non-existence of a
distinguisher able to distinguish with non-negligible advantage between
two commitments, i.e., we have indistinguishability between two
commitments with @xmath . The binding property is fulfilled, if it is
infeasible for a forger to open a commitment to more than one valid
value, i.e., we have @xmath for @xmath . Each property, hiding and
binding, can be satisfied unconditionally or subject to a complexity
assumption. The ideal case of unconditionally secure commitments,
i.e. unconditionally hiding and unconditionally binding at the same
time, is impossible. Consequently, we have to decide on one of the two
flavors of commitment schemes, namely unconditionally hiding and
computationally binding or unconditionally binding and computationally
hiding. ⁶ ⁶ 6 Note that certain applications—beyond the scope of this
work—have computational security simultaneously for both properties
hiding and binding. For completeness, it is worth noting that the same
applies in quantum cryptography [ May97 , LC97 ] , where perfect
commitments can only be achieved when assuming some restrictions on the
adversary, for instance, the BQSM-model [ DFSS05 , DFR @xmath 07 ] .

In the context of oblivious transfer (OT; see Section 2.4.2 ), we know
that a classical commitment does not imply classical OT without any
additional requirement (such as key agreement). In contrast, a classical
commitment implies quantum OT, which is all the more interesting as OT
is complete for secure two-party computation. This implication in the
quantum case was realized in [ CK88 ] and proven partially in [ Yao95 ,
May96 , CDMS04 ] . We will give the first full proof in Section 6.1 .

Commitments are equivalent to one-way functions, i.e., a function @xmath
for which it is easy to compute @xmath , given @xmath . But given only
@xmath where @xmath is random, it is computationally infeasible in
poly-time to compute any element in @xmath . Thus, from an appropriate
one-way function, secure against quantum adversaries, we can construct
quantum-secure commitment schemes (e.g. [ Nao91 ] ). Bit commitments, in
turn, imply a quantum-secure coin-flip, which we will show in Chapter 8
. Naturally, the hiding, respectively binding, property holds with
unconditional security in the classical and the quantum setting, if the
distinguisher, respectively the forger, is unrestricted with respect to
his (quantum) computational power. Recall that in case of a poly-time
bounded classical distinguisher, respectively forger, the commitment is
computationally hiding, respectively binding. The computationally hiding
property translates to the quantum world by simply allowing the
distinguisher to be quantum. However, the case of a quantum forger
cannot be handled in such a straightforward manner, since the commonly
used classical proof technique relies on rewinding the possibly
dishonest committer, which is in general prohibited by the laws of
quantum mechanics.

Another restriction on rewinding occurs when committing to a string
instead of a single bit. Solutions for proving string commitments secure
are known for the classical case, but they cannot be adapted to the
quantum world. Thus, solutions for quantum-secure constant round
coin-flipping are yet to come (see Chapter 9 and also Section 2.4.4 ).

##### 2.4.2 Oblivious Transfer

As already indicated, another highly relevant primitive in cryptography
is oblivious transfer, commonly abbreviated by OT. Interestingly, the
basic idea for OT was first proposed by Wiesner in the context of
quantum cryptography, where he suggests conjugate coding as ”a means for
transmitting two messages either but not both of which may be received”
[ Wie83 , p. 79] . OT as a cryptographic concept was then introduced by
Rabin ( @xmath in [ Rab81 ] ) and Even, Goldreich, and Lempel ( @xmath
in [ EGL85 ] ). OT is a complete cryptographic primitive, i.e., it is
sufficient for secure two-party computation [ Kil88 ] , meaning that
secure 1-2 OT allows for implementing any cryptographic two-party
functionality.

In this work, we are mainly interested in @xmath ,
i.e. one[message]-out-of-two[messages] oblivious transfer, with message
length @xmath . In an @xmath protocol, the sender sends two @xmath -bit
strings @xmath and @xmath to the receiver. The receiver can choose which
string to receive, i.e. @xmath according to his choice bit @xmath , but
does not learn anything about the other message @xmath . At the same
time, the sender does not learn @xmath , i.e., he does not learn which
string the other party has chosen.

As in the classical case, quantum OT cannot be implemented without any
additional restrictions, such as bounded quantum memory in the BQSM [
DFSS05 , DFR @xmath 07 ] . However, in contrast to classical OT, quantum
OT reduces to classical commitment, as already discussed before (more in
Section 6.1 ).

@xmath is a randomized variation of general @xmath and essentially
coincides, except that the sender does not input the two messages
himself, rather they are generated uniformly at random during the
protocol (and then output to the sender). For completeness, we note that
@xmath is another slightly varied but equivalent version of @xmath ,
where the sender transmits a message @xmath with probability @xmath .
However, he remains oblivious about whether or not the receiver actually
got @xmath . Thus, @xmath can be seen as a secure erasure channel .

We conclude this introduction by mentioning two natural generalizations
of @xmath . First, @xmath allows the receiver to obtain exactly one
element out of a set of @xmath elements. This application is similar to
private information retrieval in database settings but constitutes a
stronger notion than the latter, as it additionally requires that the
user is oblivious to all other items (as in database privacy). An even
further generalization is @xmath , in which the receiver can choose a
subset of @xmath elements out of the entire set of size @xmath .
Interestingly, @xmath underlies the construction of a quantum
identification scheme in [ DFSS05 ] , which exemplifies the significance
of the primitive. More details on this transformation are given in
Section 2.4.3 .

##### 2.4.3 Password-Based Identification

A password-based identification scheme (ID, in short) allows a user to
identify himself to a server by proving his knowledge of a previously
agreed secret password. In addition, we will put forward the following
security requirement: Any party that is not in possession of the valid
password can (essentially) not succeed by any other means but trying to
guess. This means that a user without password—or in other words, a user
who pretends to be someone else—cannot delude the server with a
probability that exceeds the probability of guessing the respective
password. Similarly, the server can only guess a user’s password and
then learn whether the guess is correct or not—but no information beyond
that. This in particular implies that the same password may be safely
reused in further runs of the protocol. Furthermore, our aim is to
develop a scheme that tolerates a possibly non-uniform password, or in
short, a realistic user-memorizable password (such as a PIN code)
without jeopardizing security.

For reasons of their significance in any authenticated set-up, a wide
range of classical and quantum ID-schemes can be found in the literature
(see Section 6.2 ). Here, we will however focus on the quantum
identification scheme, proposed in [ DFSS05 ] and proven secure against
any dishonest server with bounded quantum storage. Interestingly, in the
context of primitives, it is constructed out of an extension of a
randomized @xmath to a randomized @xmath . We will briefly sketch the
intuitive idea here: Recall that such a @xmath supplies the user with
@xmath random @xmath -bit strings but yields only one of the strings on
the server’s side. Such a scheme can then be used for the purpose of
identification, when the server “chooses” the one specific string
indexed by the password, and the user proves which of the @xmath strings
obtained is the one with indices matching the password. Note that this
last step of comparison must be secured by another cryptographic
technique such as a hash-function and the strings must have large
Hamming distance, which is not covered by the OT application itself.
However, by the nature of secure OT, a dishonest user does not gain any
information on the server’s choice and thus, does not know which string
is the one getting accepted. A dishonest server can likewise not do
better than guessing a choice, and so the string he later receives from
the user is most probably random to him and hence, contains no
information on the password. We want to stress again that for
simplicity, we skip many subtle but important details of the final
ID-scheme as well as the means regarding better efficiency. More details
are given in Section 6.2 , where we propose an extension of the scheme
towards higher and more diverse security.

##### 2.4.4 Coin-Flipping

True randomness is a crucial ingredient in cryptographic applications.
Therefore, coin-flipping (or coin-tossing) is yet another essential
primitive in this work. Secure coin-flipping allows two parties to agree
on a uniformly random bit in a fair way, which means that neither party
can influence the value of the coin to his advantage. Intuition suggest
that this should be easily obtainable for an actual coin-toss if the
parties met, flipped a coin together and simply looked at the outcome.
Now, we want to achieve a similar fairness even when the parties are
communicating over a distance. This problem was first formalized in
cryptographic terms by Blum as coin-flipping by telephone [ Blu81 ] .

An ideal coin-flip can be modeled as follows: Each player inputs a bit
of his choice, independently of each other, and the box then outputs the
exclusive disjunction of the two bits as the coin. When implementing the
primitive however, we must consider that one party must make a first
move during communication, and therefore the other one may choose his
bit accordingly. The most straightforward way to achieve fairness also
over a distance is by bit commitments as follows. The first player
chooses a random bit @xmath and commits to it, the other one then sends
his bit @xmath in plain, then the commitment is opened, and the
resulting coin is @xmath . Thus, bit commitment implies secure
coin-flipping, since the first player is bound to his bit, but can still
keep it hidden until the second player makes his move.

Secure implementations for coin-flipping have been proposed also by
means of quantum communication. For instance, solutions for a strong
coin-flip with a potential, optimal coin bias of approx. @xmath and for
the weaker notation with arbitrary small bias. Note that in the quantum
literature, “strong” or “weak” indicates weather the dishonest party
cannot bias the coin more than specified or the dishonest party can
influence the coin entirely towards one outcome but only by the
specified bias towards the other value, respectively (see e.g. [ Weh08 ]
for an overview). We want to stress that throughout this work, we use
the (intuitive) literal interpretation of a “weak” and “strong” coin,
indicating its degrees of security.

We are interested in the standard coin-flipping protocol with classical
messages exchange, but where the adversary is assumed to be capable of
quantum computing. Even when basing the embedded commitment on a
computational assumption that withstands quantum attacks, the security
proof of the entire coin-flipping and its integration into other
applications could previously not be naturally translated from the
classical to the quantum world. We will propose a solution based on
Watrous’ quantum rewinding in Chapter 8 . Certainly, the desirable
protocol would be constant round, meaning that a string of coins can be
flipped in a constant number of rounds, instead of having the number of
rounds depending on the number of coins. Towards this aim, we present a
framework that transforms weaker demands on the coins into very strong
properties, with the final result of a fully simulatable coin-flipping
protocol, secure against poly-sized quantum adversaries, which can be
implemented in the plain model from scratch (see Chapter 9 ). On a side
note, implementing constant round coin-flipping is an open problem in
the quantum setting. Interestingly, the first quantum application,
namely quantum key distribution (QKD), enables two parties to produce a
secret random bit-string (which is then used as a key in symmetric
crypto-systems). However, by assumption on its purpose, the QKD-setting
does not have to hold against an internal dishonest party. The
requirements for secure coin-flipping are much stronger in this sense,
and it turns out that in a typically QKD-protocol, the key could
theoretically always be biased by one of the parties.

We conclude here by stressing the importance of truly random, fair coins
for cryptographic purposes. Namely, by producing a string of coins, the
communicating parties can interactively generate a common random string
from scratch. The generation can then be integrated into other
(classical or quantum) cryptographic protocols that work In the
common-reference-string-model. This way, various interesting
applications can be implemented entirely in a simple manner without any
set-up assumptions. We will discuss some examples thereof in Chapter 10
.

##### 2.4.5 Zero-Knowledge

Informally, a zero-knowledge (ZK) proof system is “both convincing and
yet yield nothing beyond the validity of the assertion” [ Gol10 ]
[p. 1]. Thus, only this one bit of knowledge is communicated from prover
to verifier. Such building blocks are typically used in outer
cryptographic protocols for enforcing that potentially dishonest players
behave according to the protocol specification, namely, they are
required to prove in zero-knowledge the correctness of a secret-based
action without leaking the secret. As examples, we want to mention
zero-knowledge proofs for Graph Isomorphism and Graph 3-Coloring, proven
secure in the classical and quantum setting by [ GMW91 ] and [ Wat09 ] ,
respectively. For a survey about zero-knowledge, we refer e.g. to [
Gol01 , Gol02 , Gol10 ] .

On a very intuitive level, such proof systems typically proceed in
several rounds of a protocol. In each round, the prover must answer a
challenge from the verifier which he does not know beforehand. In order
to be able to answer all challenges in all rounds, the prover must know
whatever he claims. We differentiate between proofs and proofs of
knowledge . The respective definitions are given by two properties,
which vary and are informally stated below. Loosely speaking, the
distinction between proofs and proofs of knowledge is drawn in the
content of the assertion: In a proof the prover claims the existence of
an object. In contrast, in a proof of knowledge, he claims knowledge of
an object. We stress that a proof of existence cannot be modeled via an
ideal functionality in the natural way, whereas a proof of knowledge
can. The third property of zero-knowledge does not differ in both
systems.

###### Zero-Knowledge Proofs.

Informally, a zero-knowledge proof for set @xmath on common input @xmath
yields no other knowledge than the validity of membership @xmath , which
holds if the following three requirements are satisfied. First, if the
statement is true, i.e. @xmath , an honest verifier will be convinced of
this fact by an honest prover, and thus accept the proof ( completeness
). This holds with overwhelming probability. Second, if the statement is
false, i.e. @xmath , a dishonest prover cannot convince an honest
verifier of the contrary, except with low probability ( soundness ). And
last, if the statement is true, a dishonest verifier learns nothing
beyond this fact ( zero-knowledge ). The latter is shown by formally
arguing that, given only the statement, a simulator can (by itself)
produce a transcript that is indistinguishable from a real interaction
between honest prover and dishonest verifier. The degree of
indistinguishability then specifies the flavor of zero-knowledge. Note
also that the first two properties are general aspects of interactive
proof systems. However, in this context, they are defined in
probabilistic terms, and we require the completeness and the soundness
error to be negligible, at least after sufficient (sequential)
repetitions.

The notion of (interactive) zero-knowledge first appeared in [ GMR85 ]
by Goldwasser et al. Then in [ GMW86 ] , it was shown that ZK proofs
exist for any @xmath -language under the assumption that commitments
exist, which in turn is implied in the existence of one-way functions [
Nao91 , HILL99 ] . ⁷ ⁷ 7 As in standard literature, @xmath (
non-deterministic polynomial time ) refers to the set of all decision
problems, where the ”yes”-instances can be recognized in polynomial time
by a non-deterministic Turing machine. The class @xmath ( deterministic
polynomial time ) contains all decision problems which can be solved by
a deterministic Turing machine in polynomial time. Note that every set
in @xmath has a trivial zero-knowledge proof in which the verifier
proves membership by himself. Blum et al. showed that the interaction
between prover and verifier in any ZK proof can be replaced by sharing a
short common reference string available to all parties from the start of
the protocol [ BFM88 ] . Note that a reference string is a weaker
requirement than interaction. The requirement for non-interactive
zero-knowledge is simpler than for general zero-knowledge, since all
information is communicated mono-directional from prover to verifier.
The verifier does not influence the distribution in the real world.
Thus, in the ideal world, we require a simulator that only produces
output that is indistinguishable from the real distribution of the
output. We will use such a generic construction in Section 10.1 , where
we show a simple transformation from non-interactive zero-knowledge to
interactive zero-knowledge in the quantum world.

###### Zero-Knowledge Proofs of Knowledge.

Intuitively, a zero-knowledge proof of knowledge for relation @xmath
with common instance @xmath and prover’s private witness @xmath yields
no other knowledge to the verifier than the validity of @xmath .
Especially, it holds that witness @xmath is not leaked. This is
formulated by the following three requirements. First, if the prover
follows the protocol and knows @xmath , such that @xmath , he will
always convince the verifier. Note that this holds with probability 1,
or in other words, completeness is defined deterministically rather than
probabilistically. Second, if the (possibly dishonest) prover can with
whatever strategy convince the verifier to accept, then he knows @xmath
. This holds, except with probability determined by the knowledge error,
which again must be negligible in the length of the challenge ( special
soundness ). Note here that in the context of machines, we interpret
knowledge via behavior. In more detail, to define knowledge, we specify
a knowledge extractor for which it holds that if the extractor can
extract @xmath from the prover, for instance, by simulating two
accepting conversations via rewinding, we say that the prover knows
@xmath . This idea prevents the prover to output the knowledge itself,
and therewith, the last requirement, i.e. the property of zero-knowledge
, capturing that a dishonest verifier learns (essentially) nothing,
remains unchanged from the description above.

The concept of proofs of knowledge was first introduced also in [ GMR85
] and formulated in greater detail in [ BG92 ] . We will propose a
quantum-secure zero-knowledge proof of knowledge based on simulatable
witness encoding in Section 10.2 .

###### @xmath-protocols.

A @xmath -protocol is a special case of the above, in that it is an
honest-verifier zero-knowledge proof of knowledge. Such a protocol is of
three-move-form, starting with the prover’s message @xmath , followed by
the verifier’s challenge @xmath , and concluded with the prover’s
response @xmath . Its name originates from this form, as the “ @xmath ”
visualizes first the common input @xmath , and then the flow of
communication (from top to bottom). The flavor of honest-verifier
zero-knowledge (HVZK), although weaker than general zero-knowledge,
still allows for useful building blocks, which would be impossible to
implement with a stronger notion in certain settings. As the name
suggests, it captures a scenario in which, instead of covering any
feasible verifier strategy, the verifier behaves honest (or rather
honest-but-curious), and maintains and outputs a transcript of the
entire interaction.

By its nature of being a proof of knowledge, special soundness holds for
a @xmath -protocol, and therewith, that from two accepting conversations
with different challenges a @xmath can be extracted such that @xmath .
We will use an honest-verifier simulator as a black-box in Sections
4.1.4 and 7.2 to receive, on input @xmath , a valid conversation @xmath
. Intuitively, the purpose of using @xmath -protocols then lies in the
fact that only one valid conversation could have been produced
unequivocally without knowing the witness.

##### 2.4.6 Secure Secret Sharing

Secure secret sharing refers—as the name suggests—to a method for
distributing one secret in several shares amongst the players. The
secret can only be reconstructed by combining a sufficient number of
shares (threshold), but any individual share or any number of shares
below the threshold does not contain any useful information on its own.

Classical secret sharing schemes were introduced independently in [
Sha79 ] and [ Bla79 ] , and quantum secret sharing was first proposed in
[ HBB99 , CGL99 ] . Classical secret sharing is an extremely powerful
primitive and is widely used in multi-party computation. We will use
secret sharing as a building block for equipping our mixed commitments
with trapdoor openings (Section 7.3 ). This extended construction will
then constitute one essential step in bootstrapping fully simulatable
coin-flipping from weak coin-flipping (Chapter 9 ).

### Chapter 3 Quantum Tools

Quantum refers to a discrete unit of a physical quantity at the smallest
scale, for which quantum mechanics constitutes the underlying
mathematical framework. For the main part of this thesis, we will work
with abstract mathematical objects, as our focus lies on theory, as
opposed to realizing, for instance, a qubit as an actual physical system
such as a “light quantum”, encoded by polarization of a photon.

In this chapter, we give an overview of the aspects of quantum
mechanics, essential for this work. The connection between the
mathematical description and physical reality is best reflected in the
postulates of quantum mechanics, which are covered in Section 3.1 . This
section is also intended to fix the terminology we will use later on.
Next, we will describe distance measures (Section 3.2 ) and uncertainty
measures (Section 3.3 ). Then we will discuss the concept of information
reconciliation and privacy amplification (Section 3.4 ) as well as the
problems of rewinding in general quantum systems and the technique of
quantum rewinding (Section 3.5 ). Finally in Section 3.6 , we will
introduce the definitions of security, which underlie all our following
main results.

#### 3.1 Postulates and Terminology

We now briefly introduce the field of quantum mechanics on the basis of
its postulates, capturing quantum-physical events and processes in
mathematical formalisms. We will closely follow the descriptions given
in [ NC00 ] and refer thereto for more details.

###### Description of an isolated system.

A general @xmath -dimensional quantum state, where @xmath , is described
mathematically by a positive semi-definite density matrix @xmath defined
in the complex Hilbert space of dimension @xmath , i.e., a complete
inner product space denoted by @xmath . The standard notation to write a
pure quantum state is represented in Dirac’s bra-ket notation by a
vector as @xmath , and is given, for complex coefficients @xmath , as

  -- -------- -- -------
     @xmath      (3.1)
  -- -------- -- -------

The orthonormal basis is denoted by the set @xmath , i.e. the linearly
independent spanning set of mutually orthogonal unit vectors. The form
of a pure state as given in Eq. ( 3.1 ) as linear combinations nicely
reflects an interference phenomenon unique to the quantum world, namely
the superposition of basis states. Informally speaking, it highlights
the fact that a quantum particle is in all possible basis states at
once. And thus, a complete description of such a particle must include
the description of every possible state as well as the probability of
the particle being in that state, given by @xmath for each respective
@xmath . By the normalization condition, the total sum of probabilities,
i.e. @xmath , equals 1.

A mixed quantum state is a statistical ensemble of pure states @xmath ,
where again @xmath forms a basis, and can be represented as density
matrix by

  -- -------- -- -------
     @xmath      (3.2)
  -- -------- -- -------

with eigenvalues @xmath and eigenstates @xmath . Again, it holds that
the system is in state @xmath with probability @xmath , where @xmath
and, by the normalization condition, we have @xmath .

More specifically, a qubit is a two-dimensional pure quantum state
living in @xmath . The computational basis (also called @xmath -basis,
standard basis, canonical basis, or rectilinear basis) is defined by the
pair @xmath , where

  -- -------- -- -------
     @xmath      (3.3)
  -- -------- -- -------

The pair @xmath denotes the diagonal basis (also named the @xmath -basis
or Hadamard basis), where

  -- -------- -- -------
     @xmath      (3.4)
     @xmath      (3.5)
  -- -------- -- -------

Another common denotation is @xmath for the computational basis and
@xmath for the diagonal basis. We use @xmath as shorthand to refer to
the set of these two most commonly used conjugate bases .

###### Evolution in a closed system.

The dynamics that apply in a closed systems as described above are
captured in the description of a unitary transform @xmath . @xmath is
unitary, if it holds that @xmath . Unitary operations preserve inner
products between vectors, which yields their more intuitive expression
in outer product representation as follows. Define @xmath to be the
transformation from “input” basis @xmath into “output” basis @xmath .
Then,

  -- -------- -- -------
     @xmath      (3.6)
  -- -------- -- -------

From the requirement of unitarity, it is evident that such a
transformation must be reversible . That means that undoing operation
@xmath on @xmath corresponds to applying its inverse @xmath on @xmath
and recreates @xmath .

For completeness we note that, although part of this postulate, we will
not consider the refined version of time evolution, defined by the
Schrödinger equation.

In the more specific case of single qubits, the transformation from the
computational basis to the diagonal basis, and vice versa, is obtained
by applying the Hadamard operation @xmath , where

  -- -------- -- -------
     @xmath      (3.7)
  -- -------- -- -------

and note that @xmath . The two-dimensional Identity operator @xmath is
represented by matrix

  -- -------- -- -------
     @xmath      (3.8)
  -- -------- -- -------

other important operations are described by the Pauli matrices

  -- -------- -- -------
     @xmath      (3.9)
  -- -------- -- -------

Operator @xmath describes a bit-flip . Matrix @xmath defines a
phase-flip operation, adding a phase factor of  -1 for non-zero entries,
and otherwise leaving the bit invariant. For completeness, we also
explicitly state

  -- -------- -- --------
     @xmath      (3.10)
  -- -------- -- --------

but note that @xmath .

The controlled-NOT operation @xmath is a combination of @xmath and
@xmath and is defined for two input qubits as

  -- -------- -- --------
     @xmath      (3.11)
  -- -------- -- --------

Thus, if the control qubit is 1, @xmath flips the target qubit.
Otherwise, @xmath is applied to the target qubit. Or in other words, the
value of the second output qubit corresponds to the classical exclusive
disjunction (XOR).

###### Quantum measurements.

To extract information of a quantum system, it must be measured. The
following descriptions of measurements illustrate the irreversible
nature of quantum measurements in general, and therewith, the
disturbance caused by observation. In other words, some information
about a state before measurement is lost after measurement. This fact
stands in sharp contrast to the reversible transformations within a
closed system as described previously.

Quantum measurements are described by a collection of measurement
operators @xmath , where @xmath denotes the measurement outcome. The
probability @xmath to obtain outcome @xmath when measuring state @xmath
with @xmath is given by

  -- -------- -- --------
     @xmath      (3.12)
  -- -------- -- --------

with completeness equation @xmath , or equivalent, @xmath . Conditioned
on having obtained @xmath , the post-measurement state must be
renormalized to

  -- -------- -- --------
     @xmath      (3.13)
  -- -------- -- --------

We also want to stress that quantum measurements do not necessarily
commute, that means that different measurement orders may yield
different measurement outcomes.

If all operators @xmath are orthogonal projectors, denoted by @xmath ,
we call the measurement projective and @xmath its observable . The
respective probability and post-measurement state are then given by

  -- -------- -- --------
     @xmath      (3.14)
  -- -------- -- --------

and

  -- -------- -- --------
     @xmath      (3.15)
  -- -------- -- --------

Measuring in basis @xmath means to apply a projective measurement
defined by projectors @xmath .

When only specifying mappings @xmath , we obtain an expression in the
positive operator-valued measure formalism (POVM), similar to Eq. ( 3.12
), namely,

  -- -------- -- --------
     @xmath      (3.16)
  -- -------- -- --------

where @xmath is the POVM, denoting the set of Hermitian operators such
that @xmath and @xmath . This formalism is simpler than the general
expressions in Eqs. ( 3.12 ) and ( 3.13 ), but sufficient for many
purposes, as it yields simple measurement statistics. It also becomes
evident here that for a complete description of measuring the observable
of a quantum system, the formulation of a quantum system must include
uncertainty in that the probability for all possible outcomes must be
encoded in it.

Again more specifically, measuring a single qubit in the computational
or diagonal basis means applying the measurement described by projectors
@xmath and @xmath or projectors @xmath and @xmath , respectively. We
want to point out a very important consequence of using such conjugate
bases (also called mutually unbiased bases). Measuring a qubit, prepared
in one of two conjugate bases, is equivalent to distinguishing between
two non-orthogonal quantum states. Non-orthogonal states however cannot
be distinguished (with arbitrary precision), which can be derived from
the above formalisms. Thus, any measurement must destroy information and
therewith disturb the system—except, of course, a measurement of a basis
state in its own basis. In other words, a state with fixed measurement
outcome in one basis implies maximal uncertainty about the measurement
outcome in the other basis.

###### Composite systems.

The joint state of a multipartite system in @xmath is given by the
tensor product @xmath . For simplicity, we consider a bipartite joint
state @xmath shared between Alice and Bob, i.e.,

  -- -------- -- --------
     @xmath      (3.17)
  -- -------- -- --------

with orthonormal bases @xmath for @xmath and @xmath for @xmath . The
form of the state in Eq. ( 3.17 ) indicates a product state , which is
separable , since it can be decomposed into two definite pure states.

For string @xmath , encoded in bases @xmath , we write @xmath . For
@xmath of size @xmath , we define @xmath and @xmath to be the
restrictions @xmath and @xmath , respectively. If all qubits are encoded
in the same basis @xmath , then @xmath .

In contrast to the product states of Eq. ( 3.17 ), we can also have pure
composite systems in some entangled states of the form

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (3.18)
  -- -------- -------- -------- -- --------

with @xmath . Entangled components mean that they can only be described
with reference to each other. Special cases thereof are the maximally
entangled EPR-pairs (or Bell states):

  -- -------- -- --------
     @xmath      (3.19)
  -- -------- -- --------

Important for cryptographic purposes are the following observations.
First, as Eq. ( 3.18 ) indicates, upon observing one of the two
particles, entangled in one single state, the system will collapse, and
thus, the other particle will at least partially be determined—even
though the particles may be spatially separated. On a side note, the
outcome of the first measurement is random, and therewith the state, to
which the composite system collapses into, is so as well. Hence,
information (i.e. a non-random message) cannot be transmitted faster
than the speed of light by shared entanglement. Second, entanglement is
basis-independent, e.g. @xmath . And last, if an entangled state @xmath
is pure, then it cannot be entangled with any other state, for instance,
one in Eve’s hands, so it holds that @xmath . Thus, under the assumption
of it being pure, entanglement is monogamic.

Subsystems of a composite system can be described by the reduced density
operator computed by the partial trace . Let @xmath and assume that only
subsystem @xmath is accessible. Then, we have

  -- -------- -- --------
     @xmath      (3.20)
  -- -------- -- --------

Trivially, when tracing system @xmath out of a product state, we have
@xmath . However, the reduced density operator in an entangled EPR-pair
is a complete mixture with trace distance @xmath (see next Section 3.2
). Thus interestingly, the joint state of two entangled qubits is pure
and can be completely determined, yet its subsystems alone are
completely mixed.

#### 3.2 Distance, Distinguishability, and Dependence

We will need various measures to determine the distance between
classical and quantum states. Distance measures possess an important
operational meaning in the context of distinguishability between two
systems.

###### Distance.

For classical information, the distance between two binary strings of
equal length can be measured by means of the Hamming distance @xmath ,
which is the number of positions at which the strings differ, or more
formally, for strings @xmath , we have

  -- -------- -- --------
     @xmath      (3.21)
  -- -------- -- --------

We will also need the relative Hamming distance

  -- -------- -- --------
     @xmath      (3.22)
  -- -------- -- --------

For completeness, we note that the Hamming weight @xmath is the Hamming
distance to @xmath from the all-zero string (of same length), i.e.
@xmath .

In the classical world, the statistical or variational distance between
two classical probability distributions @xmath and @xmath over the same
finite set @xmath with events @xmath is determined by

  -- -------- -- --------
     @xmath      (3.23)
  -- -------- -- --------

A measure of proximity is given by the fidelity

  -- -------- -- --------
     @xmath      (3.24)
  -- -------- -- --------

The classical notions of distance and fidelity can be generalized to the
distance and proximity of two quantum states @xmath and @xmath . The
quantum analogue to the classical distance in Eq. ( 3.23 ) is the trace
distance , given as

  -- -------- -- --------
     @xmath      (3.25)
  -- -------- -- --------

where @xmath is the trace norm of any operator @xmath . The notion of
fidelity translates to quantum fidelity by

  -- -------- -- --------
     @xmath      (3.26)
  -- -------- -- --------

The relation between classical variational distance and quantum trace
distance can be made more explicit by

  -- -------- -- --------
     @xmath      (3.27)
  -- -------- -- --------

where the maximum is taken over all POVMs @xmath , and @xmath indicate
the probability distributions obtained when measuring @xmath or @xmath
using @xmath . Moreover, it is worth pinpointing that, for mixtures of
pure quantum states @xmath and @xmath with same orthonormal basis @xmath
but potentially different eigenstates @xmath and @xmath , the quantum
measure naturally reduces to the classical one between the eigenvalue
distributions @xmath and @xmath by

  -- -- -- --------
           (3.28)
  -- -- -- --------

A similar reduction can be obtained for the fidelity.

Trace distance and quantum fidelity are, in general, equivalent
concepts—but with partly different characteristics and properties, so we
will use one or the other, depending on the respective context (see [
FvdG99 ] or [ NC00 ] for a more detailed discussion). However, they are
closely related in that we have

  -- -------- -- --------
     @xmath      (3.29)
  -- -------- -- --------

For pure states @xmath and @xmath , expressions ( 3.25 ) and ( 3.26 )
simplify to

  -- -------- -- --------
     @xmath      (3.30)
  -- -------- -- --------

where the latter can be seen as transition probability. Furthermore, the
fidelity measure for a pure state @xmath and an arbitrary quantum state
@xmath is given by

  -- -------- -- --------
     @xmath      (3.31)
  -- -------- -- --------

and shows that the square root of the overlap between the states
determines the fidelity.

###### Distinguishability.

The importance of both quantum measures is due to their operational
meaning of distinguishability. The fidelity can be seen as an “upside
down” trace distance in that the limits 0 and 1 in @xmath meaning
perfectly distinguishable and perfectly indistinguishable, respectively.
In contrast, the trace distance @xmath increases for decreasing
indistinguishability, such that we get @xmath for @xmath and @xmath for
@xmath orthogonal to @xmath .

Coming back to Eq. ( 3.27 ) in this context, it is worth noting that the
POVM @xmath that achieves the maximum is the optimal POVM for
distinguishing @xmath and @xmath . Furthermore, we want to single out
two important properties by means of the trace distance. First, we have
unitary invariance with @xmath , meaning that the distance between the
states does not change when a unitary operation @xmath is applied to
both of them. And second, any trace-preserving quantum operation @xmath
is contractive (monotonicity under quantum operations) with @xmath .
Informally, no physical process can achieve an increased distance, or in
other words, no modification on the states can help to better
distinguish two states. An important special case relating the partial
trace shows that @xmath , which again informally states that two systems
are at least as hard to distinguish when only a part of them is
accessible.

Two families of probability distributions @xmath and @xmath are called
perfectly indistinguishable, denoted by @xmath , if their output
distributions on each input are identical, namely @xmath for all @xmath
. In other words, an unbounded adversary cannot distinguish the
outcomes, which holds with probability 1. Relaxing this condition
defines statistical indistinguishability ( @xmath ), which holds if the
statistical distance @xmath is negligible (in the length of the input).
This covers the setting, in which an unbounded adversary cannot
distinguish the outcomes, except with negligible probability. For @xmath
, and therewith, indistinguishability except with probability @xmath ,
we also call the distributions @xmath -close . Thus, perfect and
statistical indistinguishability are defined in the
information-theoretic sense and we call the resulting security flavor
unconditional .

In the computational setting, we require that the two distributions
cannot be distinguished by any computationally efficient procedure. More
formally, let
@xmath denote the probability that an algorithm @xmath is successful in
that it outputs “P”, if the input @xmath comes from @xmath , and
analogue for @xmath . To claim computational indistinguishability
between @xmath and @xmath , denoted by @xmath , for any probabilistic
poly-time algorithm @xmath , it must hold that the (distinguishing)
advantage @xmath , i.e.,

  -- -------- --
     @xmath   
  -- -------- --

is negligible in the length of the input. Quantum-computational
indistinguishability ( @xmath ) is defined similarly for the case of a
quantum algorithm @xmath . In other words, (quantum) computational
security holds with overwhelming probability against a poly-time
(quantum) adversary.

Consider a quantum algorithm consisting of a uniform family @xmath of
quantum circuits, which is said to run in polynomial time, if the number
of gates of @xmath is polynomial in @xmath . Then, two families of
quantum states @xmath and @xmath are called perfectly indistinguishable
with @xmath , if @xmath in the case of unrestricted running time. We
have statistical indistinguishability with @xmath , if @xmath , for
@xmath negligible in @xmath , and without any restriction on the running
time. Again, for @xmath , we call the quantum states @xmath -close—or
indistinguishable, except with probability @xmath . Then, to prove
sufficient closeness between an ideal system and the real state, we
require @xmath to be negligible (in the security parameter). Last, we
have quantum-computationally indistinguishable, denoted by @xmath , if
any polynomial-time quantum algorithm has negligible advantage @xmath of
distinguishing @xmath from @xmath .

###### Dependence.

We will often use upper case letters for random variables (for proofs)
that describe respective values (in the actual protocol). Let @xmath
denote the probability distribution of a classical random variable
@xmath over finite set @xmath .

Let

  -- -------- -- --------
     @xmath      (3.32)
  -- -------- -- --------

denote the quantum representation of the classical random variable
@xmath . Let @xmath denote a state in register @xmath , depending on
value @xmath of random variable @xmath over @xmath with distribution
@xmath . Then, from the view of an observer, who holds register @xmath
but does not know @xmath , the system is in state

  -- -------- -- --------
     @xmath      (3.33)
  -- -------- -- --------

where @xmath depends on @xmath in the sense that @xmath is in state
@xmath exactly iff @xmath .

Independence in a bipartite joint state with classical and quantum parts
can be expressed as

  -- -------- -- --------
     @xmath      (3.34)
  -- -------- -- --------

Such a state is formally called a cq-state . Note that naturally, @xmath
, and that the notation can be extended to states depending on more
classical variables, i.e. ccq-states , cccq-states etc. Full
independence of classical and quantum parts within one state is given
iff @xmath for any @xmath and therewith @xmath . This means in
particular that no information on @xmath is gained by observing only
@xmath . However, full independence is often too strong a requirement.
For our purposes, it suffices that the real state is close to the ideal
situation.

Last in this context, we want to express that a random variable @xmath
is independent of a quantum state @xmath when given a random variable
@xmath . Independence in this case means that, when given @xmath , the
state @xmath gives no additional information on @xmath . Yet another way
to understand conditional independence is that @xmath is obtained from
@xmath and @xmath by solely processing @xmath . Formally, adopting the
notion introduced in [ DFSS07 ] , we require that @xmath equals @xmath ,
where the latter is defined as

  -- -------- -- --------
     @xmath      (3.35)
  -- -------- -- --------

where @xmath . In other words, @xmath precisely if @xmath for all @xmath
and @xmath .

#### 3.3 Entropies

Entropies are useful measures of “information, choice and uncertainty”.
We will give a brief recap here, only covering the concepts most
important in the context of this work. For a general introduction we
refer to e.g. [ NC00 , Ren05 , Sch07 ] for more details and proofs.

The Shannon entropy [ Sha48 ]

  -- -------- -- --------
     @xmath      (3.36)
  -- -------- -- --------

applies to a classical probability distribution @xmath over @xmath with
probabilities @xmath , and as such quantifies the information gain on
average after learning @xmath , or complementary, the average
uncertainty before learning @xmath . ¹ ¹ 1 Note that the logarithmic
base is 2 for a result in bits. The binary version thereof, namely the
binary entropy function , is defined for the case of two possibilities
as

  -- -------- -- --------
     @xmath      (3.37)
  -- -------- -- --------

with @xmath . We will use that, given the ball of all @xmath -bit
strings at Hamming distance at most @xmath from @xmath , denoted as
@xmath , we have that @xmath .

For a cryptographic scenario with not necessarily independent
repetitions, its generalization is given by the Rényi entropy [ Rén61 ]
of order @xmath as

  -- -------- -- --------
     @xmath      (3.38)
  -- -------- -- --------

for @xmath . Note that the Shannon entropy is the special case for limit
@xmath .

The joint entropy of a pair of random variables @xmath measures the
total uncertainty about the pair and is naturally defined as

  -- -------- -- --------
     @xmath      (3.39)
  -- -------- -- --------

Assume now that @xmath is learned, and therewith, @xmath bits of
information about @xmath . Then, the remaining uncertainty of @xmath ,
conditioned on knowing @xmath , is given by the conditional entropy

  -- -- -- --------
           (3.40)
  -- -- -- --------

Rényi entropies can also be defined for the quantum world, i.e., where a
density matrix @xmath replaces the probability distribution, and we have

  -- -- -- --------
           (3.41)
  -- -- -- --------

for @xmath . The von Neumann entropy is then given by

  -- -------- -- --------
     @xmath      (3.42)
  -- -------- -- --------

which corresponds to the Shannon entropy when measuring quantum state
@xmath in basis @xmath , or in other words @xmath , where @xmath are the
eigenvalues of @xmath . Thus, it naturally holds that @xmath , whenever
classical variable @xmath is encoded in quantum state @xmath .

A special entropy measure is obtained when taking the limit @xmath ,
namely the min-entropy . The notion of min-entropy is used in the
context of randomness extraction and privacy amplification in the
presence of a dishonest receiver or an eavesdropper on the transmission
(see Section 3.4 ). Intuitively, the (classical) min-entropy is
determined by the highest peak in a distribution, and therewith,
describes the maximum amount of potentially leaked information, which in
turn formalizes security for cryptographic applications in the worst
case. In other words, the min-entropy measures the probability of an
adversary’s best guess about an unknown value.

###### Definition 3.1 (Min-Entropy)

Let @xmath be a random variable over alphabet @xmath with probability
distribution @xmath . The min-entropy of @xmath is defined as

  -- -------- --
     @xmath   
  -- -------- --

Another important special case is the max-entropy with values for @xmath
approaching zero. Its definition captures a Rényi entropy, in which all
possible events are considered equally, regardless of their
probabilities. Its operational meaning lies in information
reconciliation (see also Section 3.4 ).

###### Definition 3.2 (Max-Entropy)

The max-entropy of a density matrix @xmath is defined as

  -- -------- --
     @xmath   
  -- -------- --

For completeness, we note that another notion of Rényi entropies with a
(non-negative) smoothing parameter @xmath was introduced in [ Ren05 ,
RW05 ] . Intuitively, it holds that for two random variables @xmath and
@xmath with almost the same probability distribution (e.g. @xmath with
high probability), the difference between @xmath and @xmath is small.
However, in this work we will only use the “un-smoothed” Rényi entropies
as discussed above.

Last, we conclude with the following lemma, which we will need in the
context of oblivious transfer. Informally, it states that if the joint
entropy of two random variables @xmath and @xmath is large, then at
least one of them has half of the original entropy—in a randomized
sense.

###### Lemma 3.1 (Min-Entropy-Splitting Lemma [Wul07, Dfr@xmath07])

Let @xmath be random variables with @xmath . Then, there exists a binary
random variable @xmath such that @xmath .

#### 3.4 Information Reconciliation and Privacy Amplification

Errors and eavesdropping affect the communication in our quantum
protocols such that the honest parties might end up with bit-strings of
measurement outcomes that differ or have leaked in some positions.
Countermeasures were proposed already in the first practical
implementation of QKD [ BBB @xmath 92 ] . The honest parties first
reconcile their shared data by public discussion to obtain consistent
strings. Note that this process has to be accomplished without revealing
more information than absolutely necessary to an adversary eavesdropping
on the public (classical) channel. The simplest procedure involves a
test on a subset of all shared (qu)bits to compute the error rate, i.e.,
the relative number of all positions with different outcomes. In that
case, these publicly announced bits must later be discarded, which in
turn means that more qubits have to be sent at the beginning of the
protocol. According to the error rate in the testset, error correction
must be applied to the untested remaining set. Since the transmission of
qubits is very efficient in practice and good error correction
techniques are known, we will use this simple technique in our quantum
protocols.

After successful reconciliation, the honest parties are in possession of
identical bit-strings. To turn these strings into completely secure
ones, privacy amplification [ BBR88 ] can be applied, which intuitively
distills a shorter but (essentially) private shared string. More
concretely, privacy amplification employs two-universal hashing (see
Definition 3.3 ) to transform a partially secret string into a highly
secure “hashed down” string, about which any adversary only has
negligible information and which looks essentially random to him. Note
that two-universal hashing also works against quantum adversaries, i.e.,
in the case when the attacker holds quantum information about the
initial string [ KMR05 , RK05 , Ren05 ] . In fact, it is essentially the
only efficient way to perform privacy amplification against quantum
adversaries.

###### Definition 3.3 (Two-Universal Hashing)

A class @xmath of hashing functions is called two-universal , if for any
pair @xmath with @xmath , and @xmath uniformly chosen from @xmath , it
holds that

  -- -------- --
     @xmath   
  -- -------- --

In the slightly stronger notion of strongly two-universal
hash-functions, we require the random variables @xmath and @xmath to be
independent and uniformly distributed over @xmath .

Let classical @xmath be correlated with classical part @xmath and
quantum part @xmath , i.e., @xmath . Let @xmath be a hash-function
chosen uniformly from @xmath . After applying @xmath to @xmath , we
obtain the cccq-state @xmath of form

  -- -------- -- --------
     @xmath      (3.43)
  -- -------- -- --------

The basic theorem for privacy amplification in the quantum world was
introduced in [ RK05 ] and [ Ren05 ] , and confined in [ Sch07 ] . Here,
we give the version from [ Sch07 , Corollary 2.25] but in its
un-smoothed form and tailored to our context.

###### Theorem 3.1 (Privacy Amplification)

Let @xmath be a ccq-state with classical @xmath distributed over @xmath
, classical @xmath in the finite domain @xmath , and quantum state
@xmath . @xmath and @xmath may depend on @xmath . Let @xmath be the
random and independent choice of a member of a universal-2 class of
hash-functions @xmath . Then,

  -- -------- --
     @xmath   
  -- -------- --

Note that if the rightmost term of the theorem is negligible, then we
are in a situation where @xmath is essentially uniform and independent
of @xmath and @xmath .

#### 3.5 Rewinding

We require for classical schemes in the quantum world that quantum
computation does not jeopardize the underlying mathematical assumption
that guarantees the security. But we encounter even more setbacks in the
context of actually proving a cryptographic protocol secure in a quantum
environment, which in the realm of this work are mostly due to the
strong restrictions on general rewinding—a common proof technique for
showing the security of different protocols in the computational
setting.

##### 3.5.1 Problems with General Rewinding

Recall that in the context of simulation-based security, we prove
security against a cheating player by showing that a run of a protocol
between him and the honest player can be efficiently simulated without
interacting with the honest player but with a simulator instead.
Basically, such a simulator prepares a valid conversation and tries it
on the dishonest party. In case this party does not send the expected
replies, a classical simulator rewinds the machine of the corrupted
player to an earlier status and repeats the simulation. Note that if the
dishonest party sends an invalid reply, the simulation is aborted. To
conclude the proof, we then show that the running time of the simulation
as well as the distribution of the conversation are according to
expectations.

Such a technique, however, is impossible to justify in the quantum
world. Generally speaking, the simulator had to partially measure the
quantum system without copying it beforehand to obtain the protocol
transcript. But then it would become impossible to reconstruct all
information necessary for correct rewinding. The problem of rewinding in
general quantum systems was originally observed in [ Gra97 ] , detailed
discussions can also be found e.g. in [ DFS04 , Wat09 ] . In the context
of this work, there are two relevant rewinding settings.

The first setting applies to simulations intended to collect several
transcripts of conversations. An example thereof is the classical
simulation for protocols with embedded computationally binding
commitments. Recall that computational binding means that if a dishonest
party can open a commitment to two different values, then the
computational assumption does not hold. In a classical simulation, the
simulator simulates a run of the outer protocol with the committer, such
that the latter outputs a valid commitment and later provides a correct
opening. Now, the simulator has the possibility to rewind the player to
a point after the commitment was sent and repeat the simulation, which
can be adapted to the simulator’s knowledge of the committed value. The
event of obtaining a different opening for the same commitment in this
second run implies the inversion of the underlying one-way function,
which is assumed to be infeasible. In such a simulation, the simulator
must store the previous transcript before rewinding. Another example of
this setting occurs when proving special soundness in a proof of
knowledge. There, a classical simulator simulates a run of a protocol
against a dishonest prover. It then keeps a transcript of the simulation
and rewinds him. From two accepting conversations, the simulator can
extract the prover’s witness. Again, the simulator must store
transcripts of the communication before rewinding.

The second setting requires the simulator to rewind the dishonest player
to the beginning of a protocol, if the reply from the dishonest party
does not match the prepared outcome of the protocol such that both sides
conclude on the ideal values as their result. This setting applies, for
instance, when proving an outer protocol with an embedded
computationally hiding commitment secure. Fortunately, if such a
simulation complies with a restricted setting, the newly introduced
quantum rewinding lemmas of [ Wat09 ] can be applied. Therewith,
rewinding is possible in a restricted quantum setting. We will discuss
this technique in more detail in the following section, but in short, it
requires a one bit reply from the dishonest party (e.g. a bit reply to a
previous bit commitment), the simulation circuit must be unitary, and in
case of rewinding, we do not intend to keep intermediate transcripts nor
collect all possible results (see Section 3.5.2 ). Unfortunately, we do
not know how to translate this technique to a multi-bit reply, while
keeping the running time of the simulator polynomially bounded. In that
case, the classical simulation would again reduce to the first setting
above, in which the simulator must store previous transcripts, namely a
previous message from the dishonest party that commits him to his
multi-bit reply beforehand.

##### 3.5.2 Quantum Rewinding

Recall that we consider the second setting of the previous section. In a
classical simulation against dishonest Bob, a poly-time simulator
guesses, for instance, a valid reply @xmath of dishonest Bob and
prepares the protocol transcript according to it. When the simulator
finally receives Bob’s actual reply @xmath , it checks if the values
coincide ( @xmath ), i.e., if its guess was correct and therewith, if
the simulation was successful. If that is not the case, the simulator
rewinds Bob and repeats the simulation until @xmath . No previous
information has to be stored nor collected.

Recently, Watrous proposed a quantum analogue of such a simulator with
the potential of rewinding, and proved therefore, that quantum
zero-knowledge is possible in an unrestricted model. We will sketch the
most important aspects of his construction here but refer to [ Wat09 ]
for further details and proofs. More specifically, Watrous proved how to
construct a quantum zero-knowledge proof system for Graph Isomorphism
and introduced two so-called quantum rewinding lemmas ; one for an exact
setting and one that holds for slightly weaker assumptions and therewith
covers a scenario with perturbations. The investigated protocol proceeds
as a @xmath -protocol, i.e., a protocol in three-move form, where the
verifier flips a single coin in the second step and sends this challenge
to the prover. Thus, the setting applies to the case where the reply
@xmath from above is a single bit. This will also be the case for our
simulation in Chapter 8 , and therefore, we can use Watrous’ result in a
black-box manner. Unfortunately, we do not know how to translate his
technique to a multi-bit reply, while keeping the running time of the
simulator polynomially bounded.

The quantum rewinding procedure is implemented by a general quantum
circuit @xmath , which receives Bob’s input registers @xmath , where
@xmath contains any @xmath -qubit auxiliary input @xmath and @xmath is a
working register, initialized to the all-zero state of size @xmath . As
a first step, @xmath applies a unitary quantum circuit @xmath to all
registers to simulate the conversations, obtaining as output a
multi-qubit register @xmath and a single-qubit register @xmath .
Register @xmath contains the outcome of the @xmath -operation on the
dishonest party’s bit @xmath (as control) and the simulator’s guess
@xmath . Thus, by measuring this register in the computational basis,
the simulator can determine whether the simulation was successful.

In more detail, the transformation from @xmath to @xmath by applying
@xmath can be written as

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath denotes the state, we want the system to be in
for a successful simulation. The qubit in register @xmath is then
measured with respect to the standard basis, which indicates success or
failure of the simulation. A successful execution (where @xmath )
results in outcome 0 with probability @xmath . In that case, @xmath
outputs @xmath . A measurement outcome 1 indicates @xmath , and hence,
implies an unsuccessful simulation. In that case, @xmath quantumly
rewinds the system by applying the reverse circuit @xmath , and then a
phase-flip transformation (on register @xmath ) before another iteration
of @xmath is applied, i.e.,

  -- -- -------- -------- --
                 @xmath   
        @xmath   @xmath   
  -- -- -------- -------- --

Thus, after this rewinding, the amplitudes of the “good” and the “bad”
states are increased and decreased, respectively. Thus, a measurement of
register @xmath in the computational basis will result in outcome @xmath
with higher probability @xmath . Note that for the special case where
@xmath equals @xmath and is independent of @xmath , the simulation
terminates after at most one rewinding.

Watrous’ ideal quantum rewinding lemma (without perturbations) then
states the following: Under the condition that the probability @xmath of
a successful simulation is non-negligible and independent of any
auxiliary input, @xmath is poly-time and its output @xmath has
square-fidelity close to 1 with state @xmath of a successful simulation,
i.e.,

  -- -------- --
     @xmath   
  -- -------- --

with error bound @xmath .

However, we cannot apply the exact version of Watrous’ rewinding lemma
in our simulation in Chapter 8 , since we simulate against a dishonest
party with an underlying commitment that only provides
quantum-computational hiding against this party. Therefore, we can only
claim that the party’s input is close to independent from the
probability @xmath . In other words, we must allow for small
perturbations in the quantum rewinding procedure and the slightly weaker
notion of Watrous’ quantum rewinding lemma, as stated below, applies.

###### Lemma 3.2 (Quantum Rewinding Lemma with small
perturbations [Wat09])

Let @xmath be the unitary @xmath -quantum circuit and let @xmath be the
general quantum circuit describing the quantum rewinding procedure. Let
@xmath and @xmath be real numbers such that

1.  @xmath

2.  @xmath , and

3.  @xmath

for all n-qubit states @xmath . Then there exists @xmath of size

  -- -------- --
     @xmath   
  -- -------- --

such that, for every @xmath -qubit state @xmath , the output @xmath of
@xmath satisfies

  -- -------- --
     @xmath   
  -- -------- --

where @xmath .

Intuitively, Requirement (1.) allows for small perturbation between the
actual probability @xmath and the ideal probability @xmath . Thus,
@xmath can be understood as the advantage of the dishonest party. It
follows that if @xmath is negligible, we can argue that @xmath is close
to @xmath and therefore, close to independent of the auxiliary input.
Probability @xmath in Requirement (3.) denotes the lower bound on the
actual probability, for which the procedure guarantees correctness and
terminates in poly-time. Instead of using @xmath in circuit @xmath , we
use @xmath . Furthermore, @xmath is replaced by @xmath with @xmath .
Lemma 3.2 reflects these replacements. On a very intuitive level, the
general input state @xmath is analyzed in more detail, i.e. @xmath
leading to

  -- -------- --
     @xmath   
  -- -------- --

and similar for @xmath . This more detailed description allows that in
any position, the probability is only near-independent of the input. The
slight variations must then be addressed by an operator @xmath , such
that @xmath is close to @xmath but satisfies the exact case of
rewinding. In other words, applying @xmath on the perturbed input state
gives the ideal outcome

  -- -------- --
     @xmath   
  -- -------- --

Transformation @xmath can therewith be understood as a correction. The
bound in Requirement (2.) follows from proof details which will not be
addressed here. Finally, note that the bounds are not necessarily tight.
Important for our proof is, however, that all operations can be
performed by polynomial-size circuits, and thus, the simulator has
polynomial size (in the worst case). Furthermore, for negligible @xmath
, it follows that the “closeness” of output @xmath with good state
@xmath is slightly reduced, but quantum rewinding remains possible and
the output @xmath of @xmath has still square-fidelity close to 1 with
state @xmath of a successful simulation.

#### 3.6 Definition of Security

We will now define security for our two-party protocols, along the lines
informally described in Section 2.2 . To this end, we will work in the
framework put forward by Fehr and Schaffner in [ FS09 ] . There, they
propose general definitions for correctness and security for any quantum
protocol that implements a classical non-reactive two-party
functionality , meaning that in- and output must be classical. We stress
that the framework also allows functionalities which behave differently
in case of a dishonest player. They then show that such a quantum
protocol, complying with the framework, composes sequentially in a
classical environment, or in other words, within an outer classical
protocol. Their security definitions are phrased in simple
information-theoretic conditions, depending on the functionality, which
implies strong simulation-based security. For the sake of simplicity,
the framework does not assume additional entities such as e.g. an
environment, without of course compromising correctness in the given
setting.

Throughout this work, we are interested in quantum and classical
protocols that implement classical functionalities. As already
mentioned, such primitives are often used as building blocks in more
complicated classical (multi-party) protocols which implement more
advanced tasks. Therefore, it can be justified in Part II to restrict
the focus to such quantum protocols that run in a classical environment
and have classical in- and outputs. Furthermore, although the framework
was originally proposed for quantum protocols that compose in a
classical environment, we adapt it here for classical protocols against
quantum attacks, composing equally well when imposing the suggesting
restriction regarding the in- and outputs. Thus, we will use it also in
Part III for defining security of our classical protocols.

Although various other security and composition frameworks have been
proposed (such as [ BM04 , Unr04 , Unr10 , WW08 ] ), we consider the
security level achieved in this framework as a reasonable balance
between weak demands and yet meaningful security. Furthermore, its
structure is as simple and clear as possible and compliance with the
definitions gives us sequential composition. Towards a general
composition, we must, of course, extend the basic protocols as shown in
Sections 5.5 and 8.3 .

We will now introduce the framework more formally for a general
functionality. We will use information-theoretic definitions in our
notions of unconditional security as investigated in [ FS09 ] . In
addition, we will also show that computational security can be defined
similarly, although with some modifications.

##### 3.6.1 Correctness

A protocol @xmath consists of an infinite family of interactive quantum
circuits for players Alice and Bob, indexed by the security parameter.
For instance, in our quantum protocols this security parameter @xmath
corresponds to the number of qubits transmitted in the first phase.
However, to ease notation, we often leave the dependence on the security
parameter implicit.

Since we assume the common input state @xmath to be classical, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

for some probability distribution @xmath , we understand @xmath as
random input variables. The same holds for the classical output state
@xmath with output @xmath . The input-output behavior of the protocol is
uniquely determined by @xmath , and we write @xmath . Then, a classical
non-reactive two-party ideal functionality @xmath is given by a
conditional probability distribution @xmath with @xmath denoting the
ideal-world execution, where the players forward their inputs @xmath to
@xmath and output whatever they obtain from @xmath . The definition of
correctness of a protocol is now straightforward.

###### Definition 3.4 (Correctness)

A protocol @xmath correctly implements an ideal classical functionality
@xmath , if for every distribution of the input values @xmath and @xmath
, the resulting common output satisfies

  -- -------- --
     @xmath   
  -- -------- --

##### 3.6.2 Information-Theoretic Security

We define information-theoretic security based on [ FS09 , Proposition
4.3] . Note that in the following, we simplify the joint output
representation (compared to [ FS09 ] ) in that we denote the output in
the real world by @xmath (which is equivalent to @xmath ), and the
output in the ideal world by @xmath (equivalent to @xmath ).

Recall that @xmath denotes honest Alice’s classical input, and let
@xmath and @xmath denote dishonest Bob’s classical and quantum
information. Then, any input state @xmath is restricted to be of form

  -- -------- --
     @xmath   
  -- -------- --

where it holds here that @xmath . This implies that Bob’s quantum part
@xmath is correlated with Alice’s part only via his classical @xmath .

###### Definition 3.5 (Unconditional security against dishonest Bob)

A protocol @xmath implements an ideal classical functionality @xmath
unconditionally securely against dishonest Bob, if for any real-world
adversary @xmath , there exists an ideal-world adversary @xmath such
that, for any input state with @xmath , it holds that the outputs in the
real and the ideal world are statistically indistinguishable, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

For completeness, we state these output states explicitly, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

which shows that Bob’s possibilities in the ideal world are limited. He
can produce some classical input @xmath for @xmath from his quantum
input state @xmath , and then he can obtain a quantum state @xmath by
locally processing @xmath and possibly @xmath ’s classical reply @xmath
. This description is also depicted in Figure 3.1 .

Analogously, we can define unconditional security for honest Bob against
dishonest Alice. In this case, we assume a classical @xmath and a
quantum state @xmath as dishonest Alice’s input and a classical input
@xmath of honest Bob.

###### Definition 3.6 (Unconditional security against dishonest Alice)

A protocol @xmath implements an ideal classical functionality @xmath
unconditionally securely against dishonest Alice, if for any real-world
adversary @xmath , there exists an ideal-world adversary @xmath such
that, for any input state with @xmath , it holds that the outputs in the
real and the ideal world are statistically indistinguishable, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

Note that in the definitions above, we do not require the running time
of ideal-world adversaries to be polynomial whenever the real-life
adversaries run in polynomial time. This way of defining unconditional
security can lead to the (unwanted) effect that unconditional security
does not necessarily imply computational security. However, as mentioned
before, by extending our basic constructions we can achieve efficient
ideal-life adversaries.

Intuitively, the composition theorem below states that if quantum
protocols @xmath securely implement ideal functionalities @xmath , then
a protocol @xmath is essentially as secure as a classical hybrid
protocol @xmath with sequential calls to @xmath . Note that for the
hybrid protocol to be classical , we mean that it has classical in- and
output (for the honest players), but also that all communication between
the parties is classical. ² ² 2 We want to stress that a hybrid protocol
is a protocol that makes sequential calls to ideal functionalities. This
term should not be confused with the notion of hybrid security in
Chapter 5 , which refers to quantum protocols providing twofold security
in case of an adversary who is either bounded in quantum storage or
bounded in quantum-computational power. The above facts imply that such
protocols compose sequentially. Below, we state (a simplified variant
of) the theorem in [ FS09 ] . We omit its proof here but note that it
proceeds along similar lines as the proof of Theorem 3.3 , translating
sequential composition to the case of computational security.

###### Theorem 3.2 (Composition Theorem I [Fs09])

Let @xmath be a classical hybrid protocol which makes at most @xmath
calls to @xmath , and for every @xmath , let protocol @xmath be an
@xmath -secure implementation of @xmath against @xmath and @xmath . Then
the output of @xmath is at distance at most @xmath to the output
produced by @xmath .

We want to explicitly state here that if the hybrid protocol is secure,
then so is the real-life protocol, and as such it could itself be use as
a sub-protocol in yet another classical outer protocol.

###### Corollary 3.1

If @xmath is a @xmath -secure implementation of @xmath against @xmath
and @xmath , and if @xmath is an @xmath -secure implementation of @xmath
against @xmath and @xmath for every @xmath , then @xmath is a @xmath
-secure implementation of @xmath .

##### 3.6.3 Computational Security

One can define security against a computationally bounded dishonest Bob
in the CRS-model analogously to information-theoretic security, with the
two differences that the input given to the parties has to be sampled by
an efficient quantum algorithm and that the output states of Definition
3.5 should be computationally indistinguishable. Recall that in the
CRS-model, all participants in the real world have access to a classical
public common reference string @xmath , which is chosen before any
interaction starts, according to a distribution only depending on the
security parameter. On the other hand, the participants in the
ideal-world execution @xmath , interacting only with the ideal
functionality, do not make use of string @xmath . Hence, an ideal-world
adversary @xmath that operates by simulating a real-world adversary
@xmath is free to choose @xmath in any way he wishes.

In order to define computational security against a dishonest Bob in the
CRS-model, we consider a polynomial-size quantum circuit, called input
sampler , which takes as input the security parameter and the common
reference string @xmath (chosen according to its distribution) and which
produces the input state @xmath . Again, @xmath , @xmath , and @xmath
denote Alice’s classical, Bob’s classical, and Bob’s quantum
information, respectively, and we require from the input sampler that
@xmath . In the following, we let @xmath be the family of all
polynomial-time strategies for dishonest Bob.

###### Definition 3.7 (Computational security against dishonest Bob)

A protocol @xmath implements an ideal classical functionality @xmath
computationally securely against dishonest Bob, if for any real-world
adversary @xmath , who has access to the common reference string @xmath
, there exists an ideal-world adversary @xmath , not using @xmath , such
that, for any efficient input sampler as described above, it holds that
the outputs in the real and the ideal world are quantum-computationally
indistinguishable, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

Protocols fulfilling the definition above provide sequential composition
in a naturally weaker but otherwise similar notion as unconditionally
secure protocols. We can therefore adapt the original composition
theorem to the case of computational security. For completeness, we will
include its proof as given in [ DFL @xmath 09 ] .

Consider a dishonest @xmath and the common state @xmath at any point
during the execution of the hybrid protocol when a call to functionality
@xmath is made. The requirement for the oracle protocol to be classical
is now expressed in that there exists a classical @xmath —to be
understood as consisting of @xmath ’s classical communication with
@xmath and with the @xmath ’s up to this point—such that given @xmath ,
Bob’s quantum state @xmath is not entangled with Alice’ classical input
and auxiliary information: @xmath . Furthermore, we require that we may
assume @xmath to be part of @xmath in the sense that for any @xmath
there exists @xmath such that @xmath is part of @xmath . This definition
is motivated by the observation that if Bob can communicate only
classically with Alice, then he can entangle his quantum state with
information on Alice’s side only by means of the classical
communication.

We also consider the protocol we obtain by replacing the ideal
functionalities by quantum two-party sub-protocols @xmath with classical
in- and outputs for the honest parties, i.e., whenever @xmath instructs
@xmath and @xmath to execute @xmath , they instead execute @xmath and
take the resulting outputs. We then write @xmath for the real quantum
protocol we obtain this way.

Recall that we require from the input sampler that @xmath , i.e., that
@xmath is correlated with Alice’s part only via the classical @xmath .
When considering classical hybrid protocols @xmath in the real world,
where the calls are replaced with quantum protocols using a common
reference string, it is important that every real protocol @xmath uses a
separate instance (or part) of the common reference string which we
denote by @xmath .

###### Theorem 3.3 (Composition Theorem II)

Let @xmath be a classical two-party hybrid protocol which makes at most
@xmath calls to the functionalities, and for every @xmath , let protocol
@xmath be a computationally secure implementation of @xmath against
@xmath .

Then, for every real-world adversary @xmath who accesses the common
reference string @xmath there exists an ideal-world adversary @xmath who
does not use @xmath such that for every efficient input sampler, it
holds that the outputs in the real and the ideal world are
quantum-computationally indistinguishable, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

Note that we do not specify what it means for the hybrid protocol to be
secure. In fact, Theorem 3.3 guarantees that whatever the hybrid
protocol achieves, an indistinguishable output is produced by the
real-life protocol with the functionality calls replaced by protocols.
Of course, if the hybrid protocol is secure in the sense of Definition
3.7 , then so is the real-life protocol.

###### Corollary 3.2

If @xmath is a computationally secure implementation of @xmath against
@xmath , and if @xmath is a computationally secure implementation of
@xmath against @xmath for every @xmath , then @xmath with at most @xmath
oracle calls is a computationally secure implementation of @xmath
against @xmath .

Proof.

We prove the claim in Theorem 3.3 by induction on @xmath . If no calls
are made, we can set @xmath and the claim holds trivially. Consider now
a protocol @xmath with at most @xmath oracle calls. For simplicity, we
assume that the number of oracle calls equals @xmath , otherwise we
instruct the players to make some “dummy calls”. Let @xmath be the
common state right before the @xmath -th, and thus, last call to one of
the sub-protocols @xmath in the execution of the real protocol @xmath .
To simplify notation in the rest of the proof, we omit the index @xmath
and write @xmath instead (see Figure 3.2 ). We know from the induction
hypothesis for @xmath that there exists an ideal-world adversary @xmath
not using the common reference string such that @xmath where @xmath is
the common state right before the @xmath -th call to a functionality in
the execution of the hybrid protocol @xmath with input @xmath . As
described, @xmath and @xmath are to be understood as follows. @xmath
denotes @xmath ’s (respectively @xmath ’s) input to the sub-protocol
(respectively functionality) that is to be called next. @xmath collects
the classical communication dictated by @xmath as well as @xmath ’s
classical inputs to and outputs from the previous calls and @xmath
denotes the dishonest player’s current quantum state. Note that the
existence of @xmath is guaranteed by our formalization of classical
hybrid protocols and @xmath .

Let @xmath be the common reference string used in protocol @xmath . For
simplicity, we assume that the index @xmath , which determines the
sub-protocol @xmath (or functionality @xmath ) to be called next, is
fixed and we just write @xmath and @xmath for @xmath and @xmath ,
respectively.

It follows from Definition 3.7 of computational security that there
exists @xmath (independent of the input state) not using @xmath such
that the corresponding output states @xmath and @xmath produced by
@xmath (as prescribed by the oracle protocol) and @xmath run on the
state @xmath are quantum-computationally indistinguishable.

The induction step is then completed with

  -- -------- --
     @xmath   
  -- -------- --

where @xmath should be understood as running protocol @xmath with input
@xmath .

Note that the strategy of @xmath does not depend on the state @xmath ,
and hence, the overall ideal-world adversary @xmath does not depend on
the input state either. Furthermore, the concatenation of two
polynomially bounded players is polynomially bounded, i.e. @xmath .
@xmath

## Part II Quantum Cryptography

### Chapter 4 Introduction

In this part of the thesis, we present our research in quantum
cryptography, which offers a secure alternative to some conventional
cryptographic schemes that are rendered insecure by the potential emerge
of large-scale quantum-computing. We also want to mention an actual
implementation of quantum protocols within the research project MOBISEQ
(“Mobile Quantum Security”), which is a joint project of the cryptology
group from the computer science department and the iNano center at the
physics department, both at Aarhus University. The main goal of MOBISEQ
is the development of technology for secure quantum communication that
can compete with conventional methods on practicality, velocity and
security and that can be integrated into existing infrastructures.
However, at the time of writing, the implementation is still “under
construction”.

In the next sections, we will introduce the concept of mixed (classical)
commitment schemes, since they are an important underlying construction
in our quantum protocols.

In Chapter 5 , we discuss our main result on improving the security of
quantum protocols via a commit&open step, based on these mixed
commitments. We first introduce the setting and then propose a general
compiler therein. We further show that the construction remains secure
in the case of noisy communication. We then proceed with combining the
compilation technique with the bounded-quantum-storage model. Last, we
show sequential composability and further use the extended commitment
construction, discussed in Section 4.1.4 , towards a more general
composition.

In Chapter 6 , we discuss that the compiler can be applied to known
protocols and show two example applications, with the result of
achieving hybrid-secure protocols.

#### 4.1 Mixed Commitments

Commitments were introduced on an intuitive level in Section 2.4.1 and
capture the process of a party being committed to his message by the
binding characteristic without immediately revealing it to the other
party due to the hiding aspect.

##### 4.1.1 Motivation

Our compiler construction in the following chapters requires a classical
yet quantum-secure commitment from @xmath to @xmath . Since we aim at
preserving the unconditional security against @xmath in the outer
quantum protocols, the commitment can only be quantum-computationally
binding. As described in Section 3.5 , the standard reduction from the
computational security of the protocol to the computational binding
property of the commitment would require rewinding @xmath , which is not
possible in the assumed protocol scenario.

Therefore, we construct keyed commitment schemes, which are special in
that they are mixed commitments or dual-mode commitments . ¹ ¹ 1 The
notions are interchangeable. The term of mixed commitments was
introduced in [ DN02 ] . In [ DFL @xmath 09 ] , the name dual-mode
commitments was used to relate to the notion of a dual-mode
crypto-system [ PVW08 ] , which is similar in spirit, but slightly more
involved. Last we want to mention that our schemes are similar to the
commitment schemes used in [ DFS04 ] but with extensions. Generally
speaking, the notion of mixed commitments requires some trapdoor
information, related to the common reference string and given to the
simulator in the ideal world. This trapdoor provides the possibility for
extracting information out of the commitments, which finally allows us
to circumvent the necessity of rewinding @xmath . We will discuss this
in detail in Section 4.1.2 . Additionally, we require that the basic
mathematical assumption, which guarantees the hiding and binding
properties of the commitments, withstands quantum attacks. We will
propose an actual instantiation in Section 4.1.3 .

##### 4.1.2 Idea

Recall that a keyed bit or string commitment @xmath takes as input a
message @xmath and some randomness @xmath of size polynomial in the
security parameter, as well as a public key @xmath . The message @xmath
can be a single bit @xmath for the implementation of bit commitments or,
in order to achieve string commitments, a bit-string @xmath . In order
to open the commitment, message @xmath and random variable @xmath are
sent in plain and the receiver therewith checks the correctness of
@xmath . Hiding is typically formalized by the requirement @xmath with
different flavors of indistinguishability, while binding prohibits that
there exist @xmath , such that @xmath , but @xmath .

We construct our commitments in the CRS-model such that they provide
dual modes depending on the public key. In more detail, let @xmath
denote a (keyed) mixed commitment scheme. The commitment key @xmath is
generated by one of the two possible key-generation algorithms, @xmath
or @xmath . Generator @xmath takes as input the security parameter
@xmath and generates a key pair @xmath , where @xmath is a public key
and @xmath is the corresponding secret key. @xmath is a poly-time
extraction algorithm that takes @xmath and @xmath as input and produces
@xmath as output, i.e., @xmath , which must hold for all pairs @xmath
generated by @xmath and for all values @xmath . In other words, the
secret key @xmath allows to efficiently extract @xmath from @xmath , and
as such the commitment is unconditionally binding. We often denote this
type of key therefore by @xmath . For a key @xmath , the commitment
scheme is unconditionally hiding (and we often refer to this type as
@xmath ). Furthermore, we need the unconditionally binding key @xmath
and the unconditionally hiding key @xmath to be computationally
indistinguishable even against quantum attacks, i.e., @xmath .

We want to stress that we can even weaken the assumption on the hiding
key in that we merely require that there exists a public-key encryption
scheme where a random public key looks pseudo-random to poly-time
quantum circuits. Thus, @xmath does not require actual unconditionally
hiding keys, but we can use uniformly random strings from @xmath as
such. This is feasible in our proposed construction, sketched below, and
still provides unconditional hiding, except with negligible probability.
This fact also ensures that most keys of a specific domain are in that
sense unconditionally hiding keys.

Finally, to avoid rewinding we use the following proof method: In the
real-world protocol, @xmath uses the unconditionally hiding key @xmath
to maintain unconditional security against any unbounded @xmath . To
argue security against a computationally bounded @xmath , an
information-theoretic argument involving the simulator @xmath is given
to prove that @xmath cannot cheat with the unconditionally binding key
@xmath . Security in real life then follows from the
quantum-computational indistinguishability of @xmath and @xmath .

##### 4.1.3 Instantiations

As a candidate for instantiating our commitment construction, we propose
the lattice-based public-key encryption scheme of Regev [ Reg05 ] . The
crypto-system is based on the (conjectured) hardness of the learning
with error (LWE) problem, which can be reduced from worst-case hardness
of the approximation of the shortest vector problem (in its decision
version). Thus, breaking Regev’s crypto-system implies an efficient
algorithm for approximating the lattice problem in the worst-case, which
is assumed to be hard even with quantum computing power.

In more detail, the crypto-system uses dimension @xmath as security
parameter and is parametrized by two integers @xmath and @xmath , where
@xmath is a prime bounded by @xmath , and a probability distribution on
@xmath . A regular public key (in @xmath ) for Regev’s scheme is proven
to be quantum-computationally indistinguishable from the case where a
public key is chosen from the uniform distribution, and therewith,
independently from a secret key. In this case, the ciphertext carries
essentially no information about the message [ Reg05 , Lemma 5.4] . This
proof of semantic security for Regev’s crypto-system is in fact the
property we require for our commitment, as the public key of a regular
key pair can be used as the unconditionally binding commitment key
@xmath in the ideal-world simulation. Then, for the real protocol, an
unconditionally hiding commitment key @xmath can simply be constructed
by uniformly choosing numbers in @xmath . Both public keys will be of
size @xmath , and the encryption process involves only modular
additions, which makes its use simple and efficient. ² ² 2 The notation
@xmath is similar to the asymptotic Landau notation @xmath but ignores
logarithmic factors.

For simplicity and efficiency, we use a common reference string, which
allows us to use Regev’s scheme in a simple way and, since it is
relatively efficient, we get a protocol that is potentially practical.
More specifically, in the CRS-model we assume the key @xmath for the
commitment scheme, generated by @xmath , to be contained in the common
reference string. We want to stress however that we show in Part III ,
Section 10.3 , how to avoid the CRS-model at the cost of a non-constant
round construction, where we let the parties generate a common reference
string jointly by coin-flipping.

For the compiler construction here, we will use Regev’s original
version, as we require bit commitments. However, a multi-bit variant of
Regev’s scheme is given in the full version of [ PVW08 ] . All
requirements as described above are maintained in this more efficient
variant, which improves the performance of Regev’s scheme by essentially
a factor of @xmath , e.g., the scheme can encrypt @xmath bits using
@xmath bits. We use later in Part III , Chapter 9 , that this implies
that we can flip a @xmath -bit string using @xmath bits of communication
when @xmath is large enough. We also rely on this multi-bit version for
our extended commitment construction, which we will describe in the next
Section 4.1.4 and then use in Section 5.5.2 , where we show how to
achieve efficient simulation also against a dishonest @xmath .

##### 4.1.4 Extended Construction

To achieve efficient simulation against both players, i.e. additional
efficient simulation also against @xmath (in Section 5.5.2 ), we need to
extend our commitments by yet another trapdoor, which provides the
commitment with equivocability . Intuitively, this means that we now
enable the simulator in the ideal world that it can construct
commitments equivocally such that it can open them later to different
bits. As we still need in addition the properties of the mixed
commitment scheme of Section 4.1.2 in its multi-bit variant, we will
build the new scheme around it, such that its trapdoor can still be used
for extraction.

The new extension is based on the idea of UC-commitments [ CF01 ] and
requires a @xmath -protocol for a (quantumly) hard relation @xmath ,
i.e. an honest-verifier perfect zero-knowledge proof of knowledge with
instance @xmath and witness @xmath (see also Section 2.4.5 ).
Conversations are of form @xmath , where the prover sends @xmath , the
verifier challenges him with bit @xmath , and the prover replies with
@xmath . For practical candidates of @xmath , see e.g. [ DFS04 ] . By
special soundness, it holds that from two accepting conversations with
different challenges, i.e. @xmath and @xmath , the simulator can extract
@xmath such that @xmath .

In real life, the common reference string consists of commitment key
@xmath and instance @xmath . To commit to a bit @xmath , the committer
@xmath first runs the honest-verifier simulator to get, on input @xmath
, a conversation @xmath . Then, he commits by sending @xmath , where
@xmath and @xmath with randomness @xmath and @xmath . To open a
commitment, @xmath reveals @xmath and opens @xmath by sending @xmath ,
@xmath . The receiver checks that @xmath is a valid conversation and
that @xmath was correctly opened. Assuming that the @xmath -protocol is
honest-verifier perfect zero-knowledge and @xmath provides unconditional
hiding, the new commitment construction is again unconditionally hiding.

In the ideal world, we assume that the simulator (simulating against
@xmath ) knows @xmath such that @xmath (and public key @xmath ).
Therewith, it can compute two valid conversations @xmath and @xmath and
set @xmath and @xmath . This enables to open both ways, assuming the
knowledge of the trapdoor @xmath .

We maintain extraction, since in the respective simulation against
@xmath , the public key is chosen in a different but indistinguishable
way, namely as @xmath , where @xmath is the binding commitment key,
generated together with @xmath . Now, given a commitment @xmath , the
simulator can decrypt @xmath to determine which of them contains a valid
reply @xmath of the @xmath -protocol. The only way this could fail is in
the case where both @xmath and @xmath contain valid replies, which would
imply that the committer @xmath could compute a valid @xmath . For a
polynomial-time bounded committer and a (quantumly) hard relation @xmath
, however, this can occur only with negligible probability.

### Chapter 5 Improved Security for Quantum Protocols

Here, we propose a general compiler for improving the security of
two-party quantum protocols, implementing different cryptographic tasks
and running between mutually distrusting players Alice and Bob. The
compiler extends security against an “almost honest” adversary by
security against an arbitrary computationally bounded (quantum)
adversary. Furthermore, we can achieve hybrid security such that certain
protocols can only be broken by an adversary who has large quantum
memory and large computing power. The results in this chapter are joint
work with Damgård, Fehr, Salvail and Schaffner, and appeared in [ DFL
@xmath 09 ] .

#### 5.1 Motivation

Our proposed compiler applies to a large class of quantum protocols,
namely to so-called BB84-type protocols that follow a particular but
very typical construction design for quantum communication. Our main
result states that if the original protocol is secure against a
so-called benign Bob who is only required to treat the qubits “almost
honestly” but can deviate arbitrarily afterwards, then the compiled
protocol is secure against a computationally bounded quantum Bob. The
unconditional security against Alice that BB84-type protocols usually
achieve is preserved during compilation and it requires only a constant
increase of transmitted qubits and classical messages.

In other words, with our compiler, one can build a protocol for any
two-party functionality by designing a protocol that only has to be
secure if Bob is benign, which is a relatively weak assumption. On the
other hand, many protocols following the BB84-type pattern (at least
after some minor changes) have been proposed, e.g. for Oblivious
Transfer, Commitment, and Password-Based Identification [ CK88 , DFSS08
, DFR @xmath 07 , DFSS07 ] . Typically, their proofs go through under
our assumption. For instance, our compiler can easily be applied to
existing quantum protocols implementing ID and OT, which we will show as
example applications in Chapter 6 .

In more detail, the compiler incorporates the mixed commitment scheme,
discussed in Section 4.1 , into the basic protocols with Bob as
committer. Recall that we need such a mixed commitment to preserve the
unconditional security against Alice that BB84-type protocols typically
achieve but cannot apply the typical reduction from the computational
security of the protocol to the computational binding property of the
commitment, due to the restrictions on rewinding in the quantum world
(see Section 3.5 ). The idea of introducing a (plain) commitment in
quantum protocols has already been sketched in other works, for
instance, in [ CK88 , BBCS91 ] . Furthermore, there are partial results,
investigating this scenario, e.g. [ Yao95 , CDMS04 , May96 ] . We will
go into more details of preceding work in Section 6.1 .

Previously, it was very unclear what exactly such a @xmath -step would
achieve in the quantum world. The intuition is clearly that if Bob
passes the test, he must have measured most of his qubits, also in the
remaining untested subset. But—to our best knowledge—it was never
formally proven that the classical intuition also holds for a quantum
Bob. We now give a full characterization of @xmath in our quantum
setting, namely that it forces Bob to be benign, for which we propose a
formal definition and which might be of independent interest. These
aspects are covered in Section 5.2 . In this context, we want to mention
the follow-up work in [ BF10 ] . They phrase the @xmath -approach more
clearly as the quantum version of classical sampling, and additionally,
investigate sampling in quantum settings more generally.

In Section 5.3 , we generalize our result to noisy quantum
communication. Furthermore, security in the bounded-quantum-storage
model that assumes the adversary’s quantum storage to be of limited
size, implies benign security. Therefore by compilation of such
protocols, we can achieve hybrid security, which means that the
adversary now needs both large quantum memory and large quantum
computing power to break these new protocols. The preservation of
BQSM-security allows us to get security properties that classical
protocols cannot achieve, if the assumption on the limited quantum
memory holds—which definitely is the case with current state-of-the-art
(Section 5.4 ). However, if the assumption should fail and the adversary
could perfectly store all qubits sent, the known protocols can be easily
broken. Thus, by applying our compiler, we obtain another security layer
that equips such protocols with additional quantum-computational
security. Last, we sketch that the compiled protocols in their basic
form remain sequentially composable. Moreover, by using the extended
commitment construction of Section 4.1.4 , we achieve efficient
simulations on both sides, and therewith, a more general composition.
This result is discussed in Section 5.5 .

#### 5.2 Introducing @xmath

We now discuss our compiler construction in detail, starting from
describing the form of BB84-type protocols and formalizing our notion of
benignity. Then, we show the transformation from benign security towards
computational security and conclude with its proof.

##### 5.2.1 Initial situation

We consider quantum two-party protocols that follow a particular but
very typical construction design. These protocols consist of two phases,
called preparation and post-processing phase. We call such a protocol a
BB84-type protocol, as they have the same structure and the same
encoding scheme as the first (complete) quantum protocol by Bennett and
Brassard in 1984 for quantum key distribution [ BB84 ] . However, we
want to stress again that we are interested in protocols for
cryptographic tasks other than key distribution, and therewith, we also
consider the case of dishonest players. A generic BB84-type protocol
@xmath is specified in Figure 5.1 .

In the preparation phase, Alice transmits @xmath random BB84-qubits to
Bob. More specifically, Alice chooses a random bit string @xmath and a
random basis-string @xmath from a set of two conjugate bases, encodes
her qubits accordingly, i.e., @xmath is encoded in the state of the
@xmath th particle using basis @xmath , and sends them to Bob. Bob
chooses a basis-string @xmath and measures the @xmath th particle in
basis @xmath . If Bob plays honestly, he learns @xmath whenever the
bases match, i.e. @xmath . Otherwise, he gets a random independent
result. The second phase of the protocol, the post-processing, consist
of arbitrary classical messages and local computations, depending on the
task at hand.

However, the fact that all BB84-type protocols have in common is that
the classical post-processing typically relies on Bob’s subsets of
correct and random outcomes, or in other words, on the fact that a
dishonest Bob has high uncertainty about a crucial piece of information.
Thus, BB84-type protocols—in their basic form—may be broken by a
dishonest Bob, who does not measure the qubits immediately. This is due
to the fact that Alice typically reveals @xmath at a later stage so that
Bob knows the correct subset. However, a dishonest Bob could measure all
stored qubits in matching bases @xmath , and thus, learn more
information than he was supposed to.

This aspect is captured in our definition of security against a benign
Bob, or more precisely a “benignly dishonest” Bob, who treats the qubits
“almost honestly” in the preparation phase but can deviate arbitrarily
otherwise. Note that, in contrast to Bob’s situation, BB84-type
protocols typically achieve unconditional security against cheating by
Alice in their default form. On a very intuitive level, it should now be
evident that we want to enforce Bob’s measurement upon qubit reception
before any further announcement by Alice. In the next section, we will
make this definition more formal.

##### 5.2.2 Security against Benign Bob

The following security definition captures information-theoretic
security against a benign Bob. Recall that such a dishonest Bob is
benign in that, in the preparation phase, he does not deviate (too much)
from what he is supposed to do. In the post-processing phase, though, he
may be arbitrarily dishonest.

To make this description formal, we fix an arbitrary choice of @xmath
and an arbitrary value for the classical information, @xmath , which Bob
may obtain as a result of the preparation phase (i.e. @xmath in case Bob
is actually honest). Let @xmath denote the random variable describing
the bit-string @xmath , where we understand the distribution @xmath of
@xmath to be conditioned on the fixed choices for @xmath and @xmath .
Furthermore, let @xmath be the state of Bob’s quantum register @xmath
after the preparation phase. Note that, still with fixed @xmath and
@xmath , @xmath is of the form @xmath , where @xmath is the state of
Bob’s quantum register in case @xmath takes on the value @xmath . In
general, the @xmath may be mixed, but we can think of them as being
reduced pure states with @xmath for a suitable register @xmath and pure
states @xmath . We then call the state @xmath a point-wise purification
(with respect to @xmath ) of @xmath . Obviously, in case Bob is honest,
@xmath is fully random whenever @xmath , and we have

  -- -------- --
     @xmath   
  -- -------- --

for every @xmath and every @xmath , where @xmath denotes the
complementary set. In that case, Bob does not store any non-trivial
quantum state so that @xmath is “empty” and

  -- -------- --
     @xmath   
  -- -------- --

A benign Bob @xmath is now specified to behave close-to-honestly in the
preparation phase in that, after the preparation, he produces an
auxiliary output @xmath . Given this output, we are in a certain sense
close to the ideal situation where Bob really measured in basis @xmath
as far as the values of @xmath and @xmath are concerned. ¹ ¹ 1 The
reason why we consider the point-wise purification of @xmath is to
prevent Bob from artificially blowing up @xmath by locally generating a
large mixture or storing an unrelated mixed input state. Informally
speaking, the following definition states (under Point (1.)) that there
exists a string @xmath of @xmath ’s measurement bases, such that the
uncertainty about @xmath ’s bit @xmath is essentially 1 whenever @xmath
. Furthermore, @xmath ’s quantum storage is small.

###### Definition 5.1 (Unconditional security for Alice against benign
Bob)

A BB84-type quantum protocol @xmath securely implements @xmath against a
@xmath -benign @xmath for some parameter @xmath , if it securely
implements @xmath according to Definition 3.5 , with the following two
modifications:

1.   The quantification is over all @xmath with the following property:
    After the preparation phase @xmath either aborts, or else produces
    an auxiliary output @xmath . Moreover, the joint state of @xmath and
    @xmath after @xmath has been output is statistically
    indistinguishable from a state for which it holds that, for any
    fixed values for @xmath , @xmath and @xmath , for any subset @xmath
    , and for any @xmath ,

      -- -------- -- -------
         @xmath      (5.1)
      -- -------- -- -------

    where @xmath is a point-wise purification of @xmath with respect to
    @xmath .

2.  @xmath ’s running time is polynomial in the running time of @xmath .

##### 5.2.3 From Benign to Computational Security

We now show a generic compiler which transforms any BB84-type protocol
into a new quantum protocol for the same task. The compiler achieves
that, if the original protocol is unconditionally secure against
dishonest Alice and unconditionally secure against benign Bob, then the
compiled protocol remains to be unconditionally secure against dishonest
Alice but is now computationally secure against an arbitrary dishonest
Bob.

The idea behind the construction of the compiler is to incorporate a
commitment scheme and force Bob to behave benignly by means of the
@xmath -procedure. More precisely, we let Bob classically and
position-wise commit to all his measurement bases and outcomes. Then
Alice chooses a random test-subset of size @xmath and checks by Bob’s
openings that the bits coincide whenever the bases match. If the test is
passed, the post-processing is conducted on the remaining unopened
positions. Otherwise, Alice aborts. Figure 5.2 shows the compilation of
an arbitrary BB84-type protocol @xmath . The quantum communication is
increased from @xmath to @xmath qubits, where @xmath is an additional
parameter that can be arbitrarily chosen, and the compiled protocol
requires three more rounds of interaction.

Although apparently simple—intuition clearly suggests that if Bob passes
the measurement test, he must have measured most of his qubits, also in
the remaining untested subset—this @xmath approach is not trivial to
rigorously prove for a quantum Bob. Moreover, in order to preserve
unconditional security against dishonest Alice, the commitment scheme
needs to be unconditionally hiding, and so can be at best
quantum-computationally binding. For a plain commitment scheme however,
the common reduction from computational security of the protocol @xmath
to the computational binding property of a commitment scheme would
require rewinding, but we do not know of any technique for our protocol
structure (see also Section 3.5 for an elaborated discussion).

Therefore, we use our mixed dual-mode commitment construction @xmath
from Section 4.1 that allows use to circumvent the necessity of
rewinding. Recall that @xmath is a keyed dual-mode commitment scheme
with unconditionally hiding key @xmath , generated by @xmath , and
unconditionally binding key @xmath , generated by @xmath along with a
secret key @xmath that allows to efficiently extract @xmath from @xmath
. Furthermore, we have that @xmath . For simplicity and efficiency, we
consider the CRS-model, and we assume the key @xmath for the commitment
scheme, generated according to @xmath , to be contained in the common
reference string. We discuss in Section 10.3.2 how to avoid the
CRS-model, at the cost of a non-constant round construction where the
parties generate a common reference string jointly by coin-flipping.
Such an approach allows us to implement the entire application without
any set-up assumptions. With our dual-mode commitment scheme, we arrive
at the following theorem, capturing the compilation of any protocol from
benign security towards computational security.

###### Theorem 5.1 (Compiler)

Let @xmath be a BB84-type protocol, unconditionally secure against
dishonest Alice and against @xmath -benign Bob for some constant @xmath
. Consider the compiled protocol @xmath for arbitrary @xmath , where the
commitment scheme is instantiated by a dual-mode commitment scheme.
Then, @xmath is unconditionally secure against dishonest Alice and
quantum-computationally secure against dishonest Bob in the CRS-model.

Proof. We sometimes write @xmath for the compiled protocol @xmath to
stress that key @xmath , produced by @xmath , is used for the dual-mode
commitment scheme. Analogously, we write @xmath when key @xmath ,
produced by @xmath , is used instead.

Correctness is trivially checked. In order to show unconditional
security against @xmath , first note that the unconditionally hiding
property of the commitment ensures that @xmath does not learn any
additional information. Furthermore, as the ideal-world adversary @xmath
is not required to be poly-time bounded, according to Definition 3.6 ,
@xmath can break the binding property of the commitment scheme, and
thereby, perfectly simulate the behavior of honest @xmath towards @xmath
attacking @xmath . The issue of efficiency of the ideal-life adversaries
will be addressed in Section 5.5 .

As for computational security against dishonest Bob, according to
Definition 3.7 , we need to prove that for every real-world adversary
@xmath attacking @xmath , there exists a suitable ideal-world adversary
@xmath attacking @xmath such that

  -- -- -- -------
           (5.2)
  -- -- -- -------

First, note that by the computational indistinguishability of @xmath and
@xmath ,

  -- -------- -- -------
     @xmath      (5.3)
  -- -------- -- -------

Then, we construct an adversary @xmath who attacks the unconditional
security against benign Bob of protocol @xmath , and which satisfies

  -- -------- -- -------
     @xmath      (5.4)
  -- -------- -- -------

where @xmath honestly executes @xmath . We define @xmath in the
following way. Consider the execution of @xmath between @xmath and
@xmath . We split entity @xmath into two players @xmath and @xmath ,
where we think of @xmath as being placed in between @xmath and @xmath .
The splitted entities of this proof are also depicted in Figure 5.3 .
@xmath plays honest @xmath ’s part of @xmath . @xmath can be understood
as completing @xmath . More specifically, @xmath acts as follows. It
receives @xmath qubits from @xmath and produces @xmath random
BB84-qubits of its own. Then, it interleaves the produced qubits
randomly with the received qubits and sends the resulting @xmath qubits
to @xmath . @xmath then completes the verification step of @xmath with
@xmath , asking him to have the commitments opened which correspond to
@xmath ’s produced qubits. If this results in accept, @xmath lets @xmath
finish the protocol with @xmath . Note that pair @xmath does exactly the
same as @xmath .

However, we can also move the actions of @xmath to @xmath ’s side, and
define @xmath as follows. @xmath samples @xmath according to @xmath and
executes @xmath with @xmath by locally running @xmath and @xmath , using
@xmath as commitment key. If @xmath accepts the verification, then
@xmath outputs @xmath (as required from a benign Bob), obtained by
decrypting the unopened commitments with the help of @xmath . Otherwise,
@xmath aborts at this point. It is now clear that Eq. ( 5.4 ) holds.
Exactly the same computation takes place in both “experiments”, the only
difference being that they are executed partly by different entities.
The last step is to show that, for some @xmath ,

  -- -- -- -------
           (5.5)
  -- -- -- -------

Eq. ( 5.5 ) actually claims that @xmath and @xmath successfully simulate
@xmath and @xmath executing @xmath . This follows by assumption of
benign security of @xmath , if we can show that @xmath is @xmath
-benign, according to Definition 5.1 , for any @xmath . We show this in
the following subsection, or more precisely, we prove that the joint
state of @xmath after the preparation phase is statistically
indistinguishable from a state @xmath which satisfies the bounds in
Eq. ( 5.1 ) of Definition 5.1 . We conclude the current proof by
claiming that Theorem 5.1 follows from Eqs. ( 5.3 ) – ( 5.5 ) together.
@xmath

##### 5.2.4 Proof of Bounds on Entropy and Memory Size

Recall that @xmath executing @xmath with @xmath can equivalently be
thought of as @xmath executing @xmath with @xmath (Figure 5.3 ).
Furthermore, a joint state of @xmath is clearly also a joint state of
@xmath . To show the existence of @xmath for @xmath as promised above,
it therefore suffices to show such a state for @xmath . In other words,
we need to show that the execution of @xmath with honest @xmath and
arbitrarily dishonest @xmath —after verification—will be close to a
state where Eq. ( 5.1 ) holds.

To show this closeness, we consider an equivalent EPR-version, where
Alice creates @xmath EPR-pairs @xmath , sends one qubit in each pair to
Bob, and keeps the others in register @xmath . Then, Alice can measures
her qubits only when needed, namely, she measures the qubits within
@xmath in Step ( 2 .) of the verification phase, and the remaining
qubits at the end of the verification phase. With respect to the
information Alice and Bob obtain, this EPR-version is identical to the
original protocol @xmath based on single qubits, since the only
difference is the point in time when Alice obtains certain information.

We can further modify the procedure without affecting Eq. ( 5.1 ) as
follows. Instead of measuring her qubits in @xmath in her basis @xmath ,
Alice measures them in Bob’s basis @xmath . However, she still verifies
only whether @xmath for those @xmath with @xmath . Because the positions
@xmath with @xmath are not used in the protocol at all, this change has
no effect. As the commitment scheme is unconditionally binding, if key
@xmath is used, Bob’s basis @xmath is well defined by his commitments
(although hard to compute), even if Bob is dishonest. The resulting
scheme is given in Figure 5.4 .

We consider an execution of EPR- @xmath in Figure 5.4 with an honest
@xmath and a dishonest @xmath , and we fix @xmath and @xmath ,
determined by @xmath ’s commitments. Let @xmath be the state of the
joint system right before Step ( 2 .) of the verification phase. Since
we are anyways interested in the point-wise purification of @xmath ’s
state, we may indeed assume this state to be pure. If it is not pure, we
purify it and carry the purifying register @xmath along with @xmath .

Clearly, if @xmath had honestly done his measurements then, for some
@xmath ,

  -- -------- --
     @xmath   
  -- -------- --

In this case, the quantum memory @xmath would be empty, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

and the uncertainty about @xmath , obtained when measuring @xmath in
basis @xmath would be maximal in the sense that it would be exactly one
bit in each position with non-matching bases, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

We now show that the verification phase enforces these properties for an
arbitrary dishonest @xmath , at least approximately in the sense of
Eq. ( 5.1 ). Recall that @xmath is random subject to @xmath .
Furthermore, for fixed @xmath but randomly chosen @xmath , the subset
@xmath is a random subset (of arbitrary size) of @xmath . Let the random
variable @xmath describe the choice of @xmath as specified above, and
consider the state @xmath , consisting of the classical @xmath and the
quantum state @xmath with

  -- -- --
        
  -- -- --

Recall that @xmath denotes the relative Hamming distance between two
strings (see Eq. ( 3.22 )). The following lemma shows that, we are in
state @xmath close to an “ideal state” @xmath , capturing a situation ,
where for any choice of @xmath and @xmath and for any outcome @xmath
when measuring @xmath in basis @xmath , the relative error @xmath (the
test estimate) gives an upper bound (which holds with probability 1) on
the relative error @xmath one would obtain by measuring the remaining
subsystems @xmath with @xmath in basis @xmath .

###### Lemma 5.1

For any @xmath , @xmath and @xmath , the state @xmath is negligibly
close (in @xmath ) to a state

  -- -- --
        
  -- -- --

where for any @xmath , we have

  -- -------- --
     @xmath   
  -- -------- --

for @xmath and arbitrary coefficients @xmath .

We want to point out that the “ideal state” @xmath in the remaining
subsystem after the test is a superposition of states with relative
Hamming distance upper bounded by the test estimate (plus a small error
@xmath ). This is the case, since we sum over all @xmath restricted to
the set specifying exactly that, and also note that @xmath ’s subsystem
@xmath depends on @xmath , which means, informally speaking, only such
states survive. Yet in other words, we are indeed left with a
superposition over all strings that have relative Hamming distance
@xmath -close to the estimate of the test.

Proof. For any @xmath , we let @xmath be the renormalized projection of
@xmath into the subspace @xmath and we let @xmath be the renormalized
projection of @xmath into the orthogonal complement, such that @xmath
with @xmath and @xmath . By construction, @xmath is of the form as
required in the statement of the lemma. A basic property of the trace
norm of pure states leads to

  -- -- --
        
  -- -- --

This last term corresponds to the square root of the probability, when
given @xmath , to observe a string @xmath when measuring subsystem
@xmath of @xmath in basis @xmath . Furthermore, using elementary
properties of the trace norm with Jensen’s inequality ² ² 2 In this
context, we use Jensen’s inequality with @xmath , for positive @xmath
and real convex function @xmath . gives

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

where the last term is the probability to observe a string @xmath when
choosing @xmath according to @xmath and measuring subsystem @xmath of
@xmath in basis @xmath . This situation, though, is a classical sampling
problem, for which it is well known that for any measurement outcome
@xmath , the probability (over the choice of @xmath ) that @xmath is
negligible in @xmath (see e.g. [ Hoe63 ] ). Thus, it follows that state
@xmath is negligibly close (in @xmath ) to state @xmath . @xmath

Next, we need a preliminary lemma, stating that a pure state can be
written as a “small superposition” of basis vectors.

###### Lemma 5.2

Let @xmath be a state of the form @xmath , where @xmath is a basis of
@xmath and @xmath . Then, the following holds.

1.   Let @xmath , and let @xmath , and @xmath , be the outcome of
    measuring @xmath of @xmath , respectively of @xmath , in some basis
    @xmath . Then,

      -- -------- --
         @xmath   
      -- -------- --

2.   The reduced density matrix @xmath has max-entropy

      -- -------- --
         @xmath   
      -- -------- --

Note that when using Renner’s definition for conditional min-entropy of
[ Ren05 ] under Point ( 1 .), one can actually show that @xmath .

Proof. For Point ( 1 .), we may understand @xmath as being in state
@xmath with probability @xmath , so that we easily see that

  -- -------- -- --
     @xmath      
                 
  -- -------- -- --

where the inequality is Cauchy-Schwartz ³ ³ 3 In this context, we use
the inequality phrased as @xmath . The claim follows (with Definition
3.1 ).

For Point ( 2 .), note that @xmath . The claim follows immediately from
the sub-additivity of the rank, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

where we use that all @xmath have rank (at most) 1. @xmath

Now, combining the fact that it holds for the binary entropy @xmath that
@xmath for any @xmath and @xmath with Lemma 5.2 on “small superpositions
of product states”, we can conclude the following corollary.

###### Corollary 5.1

Let @xmath be of the form as in Lemma 5.1 (for given @xmath , @xmath and
@xmath ). For any fixed @xmath and for any fixed @xmath with @xmath ,
let @xmath be the state to which @xmath collapses when, for every @xmath
, subsystem @xmath is measured in basis @xmath and @xmath is observed,
where we understand @xmath in @xmath to be restricted to the registers
@xmath with @xmath . Finally, let @xmath and let the random variable
@xmath describe the outcome when measuring the remaining @xmath
subsystems of @xmath in basis @xmath . Then, for any subset @xmath and
any @xmath , ⁴ ⁴ 4 Below, @xmath (and similarly @xmath ) should be
understood as first restricting the @xmath -bit vector @xmath to @xmath
, and then restricting the resulting @xmath -bit vector @xmath to @xmath
: @xmath .

  -- -------- --
     @xmath   
  -- -------- --

and

  -- -------- --
     @xmath   
  -- -------- --

Thus, the number of errors between the measured @xmath and the given
@xmath gives us a bound on the min-entropy of the outcome, when
measuring the remaining subsystems of @xmath , and on the max-entropy of
the state of subsystem @xmath .

Proof. To simplify notation, we write @xmath and @xmath . By definition
of @xmath , for any fixed values of @xmath and @xmath , the state @xmath
is of the form @xmath , where @xmath . Recall here that @xmath .
Consider the corresponding mixture @xmath and define @xmath as the
random variable for the outcome when measuring register @xmath of @xmath
in basis @xmath . Note that @xmath , since any state @xmath , when
measured in basis @xmath , produces a random bit for every position
@xmath with @xmath (see also the definition of the min-entropy
(Definition 3.1 ) and note that there exist @xmath possible outcomes).
Lemma 5.2 allows us to conclude that

  -- -------- --
     @xmath   
  -- -------- --

and similarly,

  -- -------- --
     @xmath   
  -- -------- --

This proves the claim for @xmath . For arbitrary @xmath and @xmath , we
can consider the pure state, obtained by measuring the registers @xmath
with @xmath in basis @xmath , when @xmath is observed. This state is
still a superposition of at most @xmath vectors and thus we can apply
the exact same reasoning to obtain Eq. ( 5.1 ). @xmath

The initial claim to be shown now follows by combining Lemma 5.1 and
Corollary 5.1 . Indeed, the ideal state @xmath we promised, for which (
5.1 ) holds, is produced by putting @xmath and @xmath in state @xmath ,
defined in Lemma 5.1 , and then running Steps ( 2 .) and ( 3 .) of the
verification phase. This state is negligibly close to the real state,
since by Lemma 5.1 , we were negligibly close to the real state before
these operations. Corollary 5.1 ensures that the bounds for benign Bob
as stated in the definition of benignity in Eq. ( 5.1 ) are satisfied.

#### 5.3 In the Presence of Noise

In the description of the compiler and in its analysis in the previous
section, we assume the quantum communication to be noise-free. Indeed,
in the case of transmission errors, honest Alice is likely to reject an
execution with honest Bob. However, it is straightforward to generalize
the result to noisy quantum communication as follows.

In Step ( 2 .) in the verification phase of @xmath , Alice rejects and
aborts if the relative number of errors between @xmath and @xmath for
@xmath with @xmath exceeds the error probability @xmath , induced by the
noise in the quantum communication, by some small @xmath . By
Hoeffding’s inequality [ Hoe63 ] , this guarantees that honest Alice
does not reject honest Bob, except with exponentially small probability.
Furthermore, proving the security of this “noise-resistant” compiler
goes along the exact same lines as for the original compiler. The only
difference is that when applying Corollary 5.1 , the parameter @xmath
has to be chosen as @xmath , such that the bounds in Eq. ( 5.1 ) hold
for

  -- -------- --
     @xmath   
  -- -------- --

Thus, the claim of our compiler-theorem (Theorem 5.1 ) holds for any
@xmath -benign Bob with @xmath (by choosing @xmath small enough).

#### 5.4 Bounded-Quantum-Storage Security

In this section we show that our compiler preserves security in the
bounded-quantum-storage model. Recall that in the BQSM, one of the
players, in our case it is Bob, is assumed be able to store only a
limited number of qubits beyond a certain point in the protocol.
BQSM-secure OT- and ID-protocols are known [ DFSS07 ] , but can be
efficiently broken, if the memory bound does not hold. Therefore, we
show here that applying the compiler produces protocols with better
security, namely the adversary needs large quantum storage and large
computing power to succeed. In Chapter 6 , we will then discuss the
compiled protocols with hybrid security in more detail.

Consider a BB84-type protocol @xmath . For a constant @xmath , let
@xmath be the set of dishonest players @xmath that store only @xmath
qubits after a certain point in @xmath , where @xmath is the number of
qubits sent initially. Protocol @xmath is said to be unconditionally
secure against such a @xmath -BQSM Bob, if it satisfies Definition 3.5
with the restriction that the quantification is over all dishonest
@xmath .

###### Theorem 5.2

If protocol @xmath is unconditionally secure against @xmath -BQSM Bob,
then the compiled protocol @xmath is unconditionally secure against
@xmath -BQSM Bob, where @xmath .

Proof. The proof proceeds as the proof for our compiler-theorem (Theorem
5.1 ). We have a dishonest @xmath that attacks @xmath , and we construct
a @xmath that attacks the original protocol @xmath . The only difference
here is that we let @xmath generate the common reference string
“correctly” as @xmath sampled according to @xmath .

It follows by construction of @xmath that @xmath Furthermore, since
@xmath requires the same amount of quantum storage as @xmath but
communicates an @xmath -fraction fewer qubits, it follows that @xmath ,
if @xmath . Thus, it follows that there exists @xmath such that @xmath
This proves the claim. @xmath

#### 5.5 Composability

Several composition frameworks for the quantum setting have been
proposed, for instance, sequential composability in a classical
environment [ FS09 ] , sequential composability in a quantum environment
but restricted to the BQSM [ WW08 ] , or attempts of generalizing the
universal classical composability framework (UC in [ Can01 ] ) to
universal quantum composability [ BM04 , Unr04 , Unr10 ] . Here, we will
briefly investigate our protocols in the particular composition
frameworks, we consider most appropriate for our setting.

##### 5.5.1 Sequential Composition

All our definition for correctness and security of our two-party quantum
protocols comply with the composition framework of [ FS09 ] as described
in detail in Section 3.6 . In particular, we will show in the next
chapter that all of our quantum protocols @xmath securely implements
their corresponding ideal functionality @xmath . Thus, according to the
Composition Theorems 3.2 and 3.3 , we arrive at a situation where an
outer protocol @xmath , composed of possibly different inner
sub-protocols @xmath , is essentially as secure as any hybrid protocol
@xmath with sequential calls to the corresponding ideal functionalities
@xmath . Sequential composition in a classical environment follows
immediately.

##### 5.5.2 General Composition

Our strong simulation-based security approach is clearly closely related
to the concept of universal composability, but our definitions do not
imply UC-security. The definitions of unconditional security leading to
sequential composability do not require the running time of ideal-world
adversaries to be polynomial whenever the real-life adversaries run in
polynomial time. Fortunately, by extending our basic commitment
construction, we can achieve efficient ideal-life adversaries.
Therewith, we get efficient simulation on both sides without rewinding
any dishonest player.

Note that it might still be the case that our compilation preserves
efficiency of the simulator, namely if protocol @xmath is secure against
dishonest @xmath with efficient simulator @xmath , then so is @xmath .
Although this would be desirable, it does not seem to be the case for
our basic construction for the following reason. In order to show such a
result, we would need to simulate the pre-processing phase against
dishonest @xmath efficiently and without measuring the qubits that are
not opened during pre-processing. Then after preparation and
verification, we could give the remaining qubits to @xmath to simulate
the rest of the protocol as specified previously. However, the whole
point of the pre-processing is to ensure that a real Bob measures all
qubits, unless he can break the binding property of the commitments.
Thus, the only way to resolve this situation is to give the simulator
some trapdoor with which it can make commitments and open them any way
it wants, or in other words, to equip the simulator with the possibility
of equivocate its commitments.

With such a equivocability trapdoor, the simulation of the verification
phase is straightforward. @xmath just waits until @xmath reveals the
test subset, measures the qubits in the test subset, and opens the
commitments according to the measurement results. Then, @xmath simulates
the protocol with the remaining unopened qubits. Our basic commitment
construction, introduced in Section 4.1 , does not provide such an
equivocability trapdoor. However, we can extend the scheme as discussed
in Section 4.1.4 by first extending our mixed commitment to the
multi-bit crypto-system of [ PVW08 ] and then combining it with an HVZK-
@xmath -protocol construction for some quantumly hard @xmath -relation
@xmath . As previously shown, equivocability emerges in this
construction with the simulator’s knowledge of a valid witness @xmath
such that @xmath . In that case, the simulator can compute two accepting
conversations for the @xmath -protocol, and therewith, answer both
challenges. The extension preserves the different but indistinguishable
dual-modes of the underlying commitment scheme such that the committed
bit can still be extracted by a simulator @xmath , decrypting both
commitments @xmath to determine, which contains a valid reply in the
@xmath -protocol.

In [ Unr10 ] a special case of our generic construction, namely the
quantum oblivious transfer protocol of Section 6.1 is related to the
quantum-UC context. It is shown that the protocol statistically
quantum-UC-emulates its ideal functionality in the case of corrupted
Alice and corrupted Bob, if it is instantiated with an ideal commitment
functionality . Furthermore, it is established that security as
specified in [ FS09 ] implies quantum-UC-security in the case of our
OT-protocol. ⁵ ⁵ 5 The security we achieve here is called quantum
stand-alone security in [ Unr10 ] , but we prefer to describe the
statements in the terms used throughout this work. Last, the OT-protocol
in its randomized version and when instantiated by an unconditionally
binding commitment scheme implements its corresponding ideal
functionality with statistical security in the case of corrupted Bob.
Even though for the last result the protocol is based on an actual
commitment, the case considers only a dishonest Bob, and by using an
unconditionally binding scheme in the real world, we would loose
unconditional security against dishonest Alice.

However, by combining our extended construction as described above with
the results of Section 4.1.4 and with [ Unr10 , Theorem 20] , we get the
following stronger result that applies to our generic compiler
construction: Let @xmath be a BB84-type protocol as specified in Theorem
5.1 and let @xmath be its compilation, instantiated with an extended
mixed commitment construction in the CRS-model as described above. Then,
@xmath computationally quantum-UC-emulates its corresponding ideal
functionality @xmath for both dishonest players .

### Chapter 6 Applications

Our compiler, discussed in the previous chapter, can be easily applied
to known protocols. Here, we show two example applications, namely
oblivious transfer and password-based identification. Since the original
protocols are BQSM-secure, we also obtain hybrid security by
compilation. These results appeared in [ DFL @xmath 09 ] . We then show
that the compiled identification protocol is secure against
man-in-the-middle attacks, which was sketch in [ DFL @xmath 09 ] but
formal proofs were omitted.

#### 6.1 Oblivious Transfer

Oblivious transfer, as introduced in Section 2.4.2 , constitutes a
highly relevant cryptographic primitive, which is complete for general
two-party computation and reduces to classical commitment in its quantum
variant. As a building block it can be securely used in outer quantum or
classical protocols and extends, for instance, to quantum
identification.

##### 6.1.1 Motivation and Related Work

As mentioned already, the idea of introducing a @xmath -step to improve
the security of quantum protocols was suggested in the first quantum OT
protocol of Crépeau and Kilian [ CK88 ] , which—in its original
form—proposes a protocol for @xmath , and in the practical follow-up
work of Bennett, Brassard, Crépeau and Skubiszewska [ BBCS91 ] ,
implementing @xmath . The @xmath approach is sketched as a “conceptually
easy fix” [ BBCS91 , p. 14] in a situation where a dishonest Bob has
large quantum storage.

Various partial results for OT in that context followed. For instance,
in [ Yao95 ] such a construction is proven secure against any receiver
in the case of noiseless communication. To make the proof work, however,
an ideal black-box commitment scheme is assumed. This approach was then
generalized for noisy channels and perfect string commitments in [ May96
] . Another approach in the computational setting was taken in [ CDMS04
] . There it was shown that a computationally binding quantum string
commitment would enforce an apparent collapse of Bob’s quantum
information, which in turn would imply secure OT. The paper concludes
with the open question of how to construct an actual commitment scheme
as required to get an applicable protocol.

Based on our analysis of Section 5.4 , we can now rather simply apply
our compiler to (a variant of) the protocol in [ BBCS91 ] , and
therewith, give a complete proof for a concrete unconditionally hiding
commitment scheme.

##### 6.1.2 The Protocol

The variant we consider here achieves @xmath . Recall that in such a
protocol, the sender @xmath sends two @xmath -bit strings @xmath and
@xmath to the receiver @xmath . @xmath can select a string to receive,
@xmath , but he does not learn anything about @xmath . Finally, @xmath
does not learn @xmath ’s choice bit @xmath . The ideal oblivious
transfer functionality @xmath is shown in Figure 6.1 .

Our protocol is almost identical to @xmath introduced in [ BBCS91 ] ,
but instead of using parity values to mask the bits in the last protocol
message, we follow the approach of [ DFR @xmath 07 ] . Their BQSM-secure
protocol @xmath for the randomized version uses hash-functions that
allow for transferring an @xmath -bit string instead of a bit as final
message.

Let @xmath denote a suitable family of two-universal hash-functions with
range @xmath as specified in Definition 3.3 . Note that if the input to
the function is smaller than @xmath , we can pad it with zeros without
decreasing its entropy. We further assume that @xmath for some constant
@xmath . Then, after the modifications described above, we obtain the
basic @xmath protocol, depicted in Figure 6.2 .

###### Proposition 6.1

Protocol @xmath satisfies correctness and achieves unconditional
security against dishonest Alice, according to Definitions 3.4 and 3.6 ,
respectively.

Proof. Correctness for honest players is obvious: @xmath selects one
string to receive, which is masked by the hashed bit-string of outcomes,
measured in the matching basis. In the positions with non-matching
bases, he does not know the outcomes, and therewith he does not learn
anything about @xmath . Finally, @xmath does not learn which is the
“good” subset, and hence, which is @xmath ’s choice @xmath .

Security against dishonest Alice is derived in a straightforward way
from @xmath of [ DFR @xmath 07 ] as follows. Note that in @xmath , the
receiver measures all his qubits in one basis, depending on his choice
bit @xmath , i.e. @xmath . As described previously in Chapter 5 , our
compiler requires measurement in random bases @xmath . Otherwise, the
opened and tested positions during @xmath would obviously leak @xmath .

Due to the non-interactivity in @xmath , @xmath cannot learn @xmath ’s
choice bit @xmath , so the protocol is perfectly receiver-secure. More
formally, the proof compares the real output to an ideal output, which
is obtained by letting @xmath run the protocol with an unbounded
receiver who measures his qubits in @xmath ’s bases @xmath , samples
independent @xmath from the correct distribution, and sets @xmath
correspondingly. The only difference between the two executions is the
point in time and the choice of bases, in which positions @xmath is
measured. However, these parameters do not influence the output states,
once @xmath is fixed.

Now, the preparation phase combined with Step (2.) of the
post-processing in @xmath is equivalent to @xmath measuring all qubits
in the basis, dictated by @xmath . Thus, the same analysis can be
applied to @xmath , achieving unconditional security against @xmath .
@xmath

###### Theorem 6.1

Protocol @xmath is unconditionally secure against @xmath -benign Bob for
any @xmath .

Proof. For any given benign Bob @xmath , we construct @xmath the
following way: @xmath runs locally a copy of @xmath and simulates an
execution by running @xmath up to but not including Step (3.). Since
@xmath is benign, @xmath obtains @xmath after the preparation phase.
When the simulation of @xmath reaches the point just after the
announcement of @xmath and @xmath in Step (3.), @xmath finds @xmath such
that @xmath is minimum for @xmath . @xmath then calls @xmath with input
@xmath and obtains output @xmath . @xmath sets @xmath and @xmath before
sending @xmath to @xmath . Finally, @xmath outputs whatever @xmath
outputs.

We now argue that the state output by @xmath is statistically close to
the state output by @xmath when executing @xmath with the real @xmath .
The only difference is that, while @xmath outputs @xmath , @xmath
outputs @xmath . Thus, we simply have to show that @xmath is
statistically indistinguishable from uniform in the view of @xmath .

Note that, since @xmath and @xmath are independent and @xmath is a
uniform @xmath -bit string, we have that for any @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

except with negligible probability. We can now claim that with
overwhelming probability

  -- -------- --
     @xmath   
  -- -------- --

Now, since @xmath is @xmath -benign, we get with Definition 5.1 that

  -- -------- --
     @xmath   
  -- -------- --

It follows from privacy amplification (Theorem 3.1 ) that @xmath is
statistically indistinguishable from uniform for @xmath , provided that

  -- -------- --
     @xmath   
  -- -------- --

for any @xmath . Finally, by the properties of exclusive-OR, we can now
also conclude that @xmath is statistically close to uniform. Solving the
last inequality for @xmath , we obtain

  -- -------- --
     @xmath   
  -- -------- --

and Theorem 6.1 follows. @xmath

Informally, the next Corollary 6.1 states that, when compiling the basic
protocol @xmath , we obtain an improved protocol @xmath with hybrid
security , such that a dishonest Bob is required to have large quantum
computing power and large quantum storage to succeed. For completeness,
@xmath is given explicitly in Figure 6.3 .

###### Corollary 6.1

If @xmath , then protocol @xmath is computationally secure against
dishonest Bob and unconditionally secure against @xmath -BQSM Bob with
@xmath . Correctness and unconditional security against dishonest Alice
is maintained during compilation.

Proof. The corollary is obtained by the following steps: First, we
sketch that the analysis of protocol @xmath in [ DFR @xmath 07 ] can be
almost analogously applied to @xmath . Then, we combine this result with
our BQSM-theorem (Theorem 5.2 ). And finally, we apply Theorem 6.1 with
our compiler-theorem (Theorem 5.1 ). Note that, by definition, all these
transformations do not touch correctness nor unconditional security
against @xmath .

In more detail, the main difference from @xmath to @xmath is that @xmath
measures all his qubits in the basis corresponding to his choice bit
@xmath , i.e. @xmath . Since we require these measurements to be in
random bases @xmath , we loose the non-interactivity and must include
the additional message @xmath from @xmath to @xmath in Step (2.), so
that @xmath obtains the same partitions. However, the partitions are
send in fixed order and do not allow to conclude on the “good” subset
@xmath . No other message is sent by @xmath . Furthermore, recall that
in randomized OT, @xmath does not input the two messages @xmath herself
by masking them with the hashed output of the measurement outcomes.
Instead, only these hash-values, generated uniformly at random during
the protocol, are output. However, due to the characteristic of
exclusive-OR, the security properties in this aspect do not change.

Thus, @xmath inherits the BQSM-security of @xmath , and we can claim
that @xmath is unconditionally secure against @xmath -BQSM Bob for all
@xmath strictly smaller than @xmath . Then, by Theorem 5.2 , we obtain
unconditional security for @xmath against @xmath -BQSM Bob.

Last, we know from Theorem 6.1 that @xmath is unconditionally secure
against a @xmath -benign Bob for @xmath . It follows with Theorem 5.1
that @xmath , instantiated by our dual-mode commitment scheme, leads to
quantum-computational security for @xmath against any @xmath . @xmath

#### 6.2 Password-Based Identification

Password-based identification is introduced in Section 2.4.3 , where we
also describe a construction from randomized @xmath , and the therewith
inherited OT-security aspects. Secure identification is highly
significant in any authenticated set-up of outer protocols, and may
provide re-usability of the initial user-memorizable passwords, if
cleverly implemented.

##### 6.2.1 Motivation and Related Work

There exist various approaches for classical and quantum identification,
based on different techniques, e.g. on zero-knowledge [ FS86 , FFS87 ] ,
on password-based key-agreement [ KOY01 ] , and on quantum memory
restrictions [ DFSS07 ] . Here, we will subject the quantum
identification scheme of [ DFSS07 ] , denoted in the following by @xmath
, to our compiler technique, yielding more diverse security assumptions.
@xmath was proven to be unconditionally secure against arbitrary
dishonest Alice and against quantum-memory-bounded dishonest Bob by
using quantum-information-theoretic security definitions. In [ FS09 ] it
was then shown that these security definitions imply simulation-based
security as considered here, with respect to the functionality @xmath
given in Figure 6.4 . Actually, the definition and proof from [ DFSS07 ]
guarantee security only for a slightly weaker functionality, which gives
some unfair advantage to dishonest Alice in case she guesses the
password correctly. However, as discussed in [ FS09 ] , the protocol
from [ DFSS07 ] does implement functionality @xmath .

##### 6.2.2 The Protocol

Recall that we require from an identification scheme that a user @xmath
succeeds in identifying herself to a server @xmath , if she knows an
initial, secret password @xmath . Additionally, a dishonest user @xmath
should not succeed with higher probability than at a guess, and
similarly, a dishonest server @xmath should be only able to guess @xmath
’s password without learning anything beyond the (in)correctness of his
guess. These last requirements provide re-usability of the password. To
achieve security under realistic assumptions, we further want to allow
memorizable passwords with low entropy.

Let @xmath be the set of possible keys, not necessarily large in size,
with @xmath denoting the initially shared password. For clarity, we will
often use @xmath and @xmath to indicate @xmath ’s and @xmath ’s input to
the protocol, and only accept if @xmath , which implies equality to
@xmath . Let @xmath be the encoding function of a binary code of length
@xmath with @xmath codewords and minimal distance @xmath . Families of
codes as required for our subsequent results, correcting a constant
fraction of errors efficiently and with constant information rate are
indeed known [ SS96 ] . And finally, let @xmath and @xmath denote
suitable families of (strongly) two-universal hash-functions, as
specified in Definition 3.3 , with range @xmath and @xmath ,
respectively. Again we stress that we can pad the input to the functions
with zero, if it is smaller than expected.

We cannot directly apply our compiler to the original @xmath , since it
is not a BB84-type protocol. Similar to @xmath described in the previous
Section 6.1 , @xmath does not measure the qubits in a random basis but
in a basis-string @xmath determined by his password @xmath by @xmath .
After @xmath ’s basis announcement, both players compute set @xmath with
the positions on which they base the last steps of the post-processing.

We briefly sketch now the transformation from @xmath into a BB84-type
protocol, without affecting security and without loosing efficiency. The
first step is naturally to let @xmath measure in random basis @xmath .
The most straightforward next step would be to include a new message
from @xmath to @xmath during post-processing, in which @xmath announces
@xmath . Then, @xmath sends @xmath and the remaining post-processing
could be conducted on @xmath . Note, however, that this solution here is
less efficient than in the original protocol, since only approx. @xmath
of all measurement outcomes could be used. So instead, we let Bob apply
a random shift @xmath to the code, which @xmath announces to @xmath in
the post-processing phase, namely @xmath with @xmath and @xmath and
@xmath for computing the @xmath -operation. Then, we define @xmath .
Finally, after @xmath ’s announcements of @xmath the protocol is
completed with the shifted code, i.e., based on positions in @xmath .
This has the effect that the post-processing is actually based on
positions @xmath with @xmath , and thus, on approx. @xmath of all qubits
as in protocol @xmath . Our resulting protocol @xmath is described in
Figure 6.5 . We show in the following proofs that the modification does
not affect security as given in [ DFSS07 ] (and [ FS09 ] ).

###### Proposition 6.2

Protocol @xmath satisfies correctness and achieves unconditional
security against dishonest Alice, according to Definitions 3.4 and 3.6 ,
respectively.

Proof. Correctness for honest players is obvious: If both @xmath and
@xmath know @xmath , i.e. @xmath , they can compute @xmath and @xmath .
Following the last steps as supposed to, they conclude with @xmath .

Security against dishonest @xmath is derived in a straightforward way
from @xmath as follows. Recall that in @xmath , @xmath measures all his
qubits in one basis, depending on @xmath . In @xmath , the preparation
phase combined with Step (1.) of the post-processing, where @xmath sends
@xmath , can be seen as an equivalent situation from the view of @xmath
. The important positions are now defined by @xmath , which is however
only deducible if @xmath is known in addition, since otherwise, @xmath
looks completely random. All subsequent steps are exactly as in @xmath ,
and thus, the same analysis can be applied to @xmath . In the following,
we will sketch the intuitive idea thereof. @xmath runs the protocol with
a memory-unbounded server who measures his qubits in @xmath ’s bases
@xmath and therefore obtains @xmath . He then computes @xmath for all
codewords @xmath , where @xmath would be expected from @xmath for an
accepting run of the protocol. By the strongly universal-two property of
@xmath , all @xmath are pairwise independent, and thus, it follows that
all @xmath ’s are distinct, except with some negligible probability.
Assume that the accepting message is one of the @xmath ’s for a random
variable @xmath , i.e. @xmath . @xmath will only succeed, if @xmath ,
and @xmath does not learn anything beyond that. A further analysis of
@xmath ’s state before the final accept/reject-message shows its
independence from @xmath , given @xmath and conditioned on @xmath and on
the pairwise distinction of all @xmath ’s. And finally, for @xmath ’s
state after the final message it is shown that the event of all distinct
@xmath ’s is independent of @xmath and @xmath . Statistical security
against @xmath follows. @xmath

###### Theorem 6.2

If @xmath has minimal distance @xmath and is polynomial-time decodeable,
then protocol @xmath is unconditionally secure against @xmath -benign
Bob for any @xmath .

Proof. For any given benign Bob @xmath , we construct @xmath as follows.
@xmath runs locally a copy of @xmath and simulates Alice’s actions by
running @xmath faithfully except for the following modifications.

After the preparation phase, @xmath gets @xmath and @xmath from @xmath .
It then computes @xmath such that @xmath has minimal Hamming distance to
@xmath . Note that this can be done in polynomial-time by assumption on
the code. Then, @xmath submits @xmath as input @xmath to @xmath and
receives output @xmath . If @xmath , then @xmath faithfully completes
@xmath ’s simulation using @xmath as @xmath . Otherwise, @xmath
completes the simulation by using a random @xmath instead of @xmath . In
the end, @xmath outputs whatever @xmath outputs.

We need to show that the state output by @xmath (respectively @xmath )
above is statistically close to the state output by @xmath when
executing @xmath with real @xmath . For simpler notation, we use @xmath
for honest Alice’s input @xmath . Note that if @xmath , then the
simulation of @xmath is perfect and thus the two states are equal. If
@xmath then the simulation is not perfect, as the real @xmath would use
@xmath instead of random @xmath . It thus suffices to argue that @xmath
is statistically close to random and independent of the view of @xmath
for any fixed @xmath . Note that this is also what had to be proven in [
DFSS07 ] , but under a different assumption, namely that @xmath has
bounded quantum memory, rather than that he is benign. Nevertheless, we
can recycle part of the proof.

Recall from the definition of a benign Bob that the common state after
the preparation phase is statistically close to a state for which it is
guaranteed that @xmath for any @xmath , and @xmath . By the closeness of
these two states, switching from the real state of the protocol to the
ideal state satisfying these bounds, has only a negligible effect on the
state output by @xmath . Thus, we may assume these bounds to hold.

Recall that @xmath is at Hamming distance at most @xmath from @xmath .
Since the distance from here to the (distinct) codeword @xmath is
greater than @xmath , we see that @xmath is at least @xmath away from
@xmath . It follows that @xmath has Hamming distance at least @xmath
from @xmath . Furthermore, for arbitrary @xmath and except with
negligible probability, the Hamming distance between @xmath and @xmath
is at least @xmath . Therefore, we can conclude that

  -- -------- --
     @xmath   
  -- -------- --

We require @xmath to be positive and linear in @xmath , which is the
case here for parameters

  -- -------- --
     @xmath   
  -- -------- --

We conclude by privacy amplification that @xmath and therewith @xmath
are close to random and independent of @xmath , conditioned on @xmath .
This concludes the proof. @xmath

The next corollary informally states that, when applying our compiler to
the basic protocol @xmath , we obtain a hybrid-secure protocol @xmath .
Thus, any dishonest Bob needs large quantum computing power and large
quantum storage to launch a successful attack. For completeness, we
again give @xmath explicitly in Figure 6.6 .

###### Corollary 6.2

If @xmath , and if @xmath has minimal distance @xmath for @xmath and is
polynomial-time decodeable, then protocol @xmath is computationally
secure against dishonest Bob and unconditionally secure against @xmath
-BQSM Bob with @xmath . Correctness and unconditional security against
dishonest Alice is maintained during compilation.

Proof. We can show hybrid security by first adapting and connecting the
results of [ DFSS07 ] with our BQSM-Theorem 5.2 , and then combining
Theorem 6.2 with our compiler theorem (Theorem 5.1 ). All definitions
preserve correctness and unconditional security against @xmath .

In more detail, the main difference from @xmath of [ DFSS07 ] to @xmath
is that @xmath measures all his qubits in the bases corresponding to
@xmath . Then after @xmath ’s basis announcement, both players base the
remaining post-processing on @xmath . In @xmath instead, @xmath measures
in random bases, computes @xmath , and announces @xmath to @xmath . Then
after @xmath ’s basis announcements, the protocol is completed based on
positions in @xmath with @xmath . Note that both situations however are
equivalent. First, the important positions are those @xmath where @xmath
in both cases. And second, @xmath looks completely random and is of no
value without the knowledge of @xmath .

Thus, @xmath inherits the BQSM-security of @xmath , and we can claim
that @xmath is unconditionally secure against @xmath -BQSM Bob for all
@xmath . From Theorem 5.2 unconditional security of @xmath against
@xmath -BQSM Bob follows. @xmath is guaranteed by Theorem 6.2 to achieve
unconditional security against a @xmath -benign Bob for @xmath and it
follows with Theorem 5.1 that @xmath , instantiated by our dual-mode
commitment scheme, yields quantum-computational security for @xmath
against any @xmath . @xmath

#### 6.3 Man-in-the-Middle Security for Identification

In a man-in-the-middle attack, we assume an external adversary who
attacks an execution of the protocol with honest communicating parties,
while having full control over the classical and the quantum
communication.

##### 6.3.1 Motivation

The compiled quantum protocols from Sections 6.1 and 6.2 protect against
(arbitrary) dishonest Alice and against (computationally or
quantum-storage bounded) dishonest Bob. However, in particular in the
context of identification, it is also important to protect against a
man-in-the-middle attacker Eve ( @xmath ). Both, @xmath and @xmath , are
insecure in this model. Eve might measure one of the transmitted qubits,
say, in the @xmath -basis, and this way learn information on the basis
@xmath used by @xmath , and thus on the password @xmath , simply by
observing if @xmath accepts or rejects in the end. ¹ ¹ 1 Note that this
attack does not immediately apply to the scheme sketched in the previous
section, but similar, however more sophisticated, attacks may still
apply.

In [ DFSS07 ] it was shown how to enhance @xmath in order to obtain
security (in the bounded-quantum-storage model) against
man-in-the-middle attacks. The very same techniques can also be used to
obtain hybrid security against man-in-the-middle attacks for @xmath .
The techniques from [ DFSS07 ] consist of the following two add-on’s to
the original protocol.

1.  A test on a random subset of qubits in order to detect disturbance
    of the quantum communication.

2.  Authentication of the classical communication.

First note that @xmath already does such a check as required in
Point (1.), namely in the verification phase, so this is already taken
care of here. Point (2.) requires that Alice and Bob, in addition to the
password, share a high-entropy key @xmath that could be stored, e.g. on
a smart-card. This key will be used for a so-called extractor MAC .
Besides being a MAC, i.e. a message authentication code, such a
construction has the additional property that it also acts as an
extractor. This means that if the message to be authenticated has high
enough min-entropy, then the key-tag pair is close to randomly and
independently distributed. As a consequence, the tag gives away (nearly)
no information on @xmath , and thus, @xmath can be re-used in the next
execution of the protocol. ² ² 2 This is in sharp contrast to the
standard way of authenticating the classical communication, where the
authentication key can only be used a bounded number of times. For
further details, we refer to [ DFSS07 , DKRS06 ] .

More specifically, in order to obtain hybrid security against
man-in-the-middle attacks for @xmath , @xmath will, in her last move of
the protocol, use the extractor MAC to compute an authentication tag on
all the classical messages exchanged plus the string @xmath . This,
together with the test of a random subset, prevents Eve from interfering
with the (classical and quantum) communication without being detected,
and security against Eve essentially follows from the security against
impersonation attacks. Note that including the @xmath into the
authenticated message guarantees the necessary min-entropy, and as such
the re-usability of the key @xmath .

We emphasize that the protocol is still secure against impersonation
attacks (i.e. dishonest Alice or Bob), even if the adversary knows
@xmath , but with slightly weaker parameters due to the “entropy-loss”
within @xmath , caused by the additional information for authentication
and private error correction that is now available.

##### 6.3.2 The Set-Up

In addition to the previous setting in Section 6.2 , we now have the
following assumptions. Let @xmath be the extractor MAC with arbitrary
key space @xmath , message space @xmath and error probability @xmath .
Its extractor property guarantees that for any message @xmath and
quantum state @xmath (which may depend on @xmath ), the tag @xmath of
@xmath is such that @xmath is @xmath -close to @xmath . Recall that
@xmath is the encoding function of a binary code with minimal distance
@xmath , and we have strongly universal-2 classes of hash-functions
@xmath and @xmath .

In order to do error correction, let @xmath be the family of syndrome
functions ³ ³ 3 Note that we have the following convention: For a bit
string @xmath of arbitrary length, @xmath is to be understood as @xmath
with enough padded zeros if its bit length is smaller than @xmath , and
as @xmath , where @xmath consist of the first @xmath and @xmath of the
remaining bits of @xmath , if its bit length is bigger than @xmath . ,
corresponding to a family @xmath of linear error correcting codes of
size @xmath , where @xmath . We require the property that any @xmath
allows to efficiently correct a @xmath -fraction of errors for some
constant @xmath . For a random @xmath , the syndrome of a string with
@xmath bits of min-entropy is @xmath -close to uniform given @xmath and
any quantum state with max-entropy at most @xmath . We refer to [ DS05 ,
DFSS07 , FS08 ] for the existence of such families and example
constructions. Protocol @xmath can tolerate a noisy quantum
communication up to any error rate @xmath . We stress that for security
against man-in-the-middle attacks, error correction with @xmath needs to
be done even if we assume perfect quantum communication (with @xmath ),
as should become clear from the analysis of the protocol given below.
Finally, we let @xmath be a constant such that @xmath .

The ideal functionality @xmath is given in Figure 6.7 . The following
definition captures unconditional security against a man-in-the-middle
attacker, where @xmath gets classical @xmath and quantum state @xmath as
input and both honest players @xmath and @xmath get classical input
@xmath and @xmath . The joint state is then of the form

  -- -------- --
     @xmath   
  -- -------- --

Note that we require that the adversary’s quantum register @xmath is
correlated with the honest players’ parts only via her classical input
@xmath , conditioned on @xmath .

###### Definition 6.1 (Unconditional security against a
Man-in-the-middle)

A protocol
@xmath implements an ideal classical functionality @xmath
unconditionally securely against a man-in-the-middle attacker, if for
any real-world adversary @xmath , there exists an ideal-world adversary
@xmath , such that, for any input state as specified above, it holds
that the outputs in the real and the ideal world are statistically
indistinguishable, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

Computational security against a man-in-the-middle is defined as
follows. For a given value of the security parameter @xmath , the common
reference string @xmath is chosen at first. The polynomial-size input
sampler takes as input @xmath and @xmath and samples an input state of
the form

  -- -------- --
     @xmath   
  -- -------- --

where honest Alice gets as input password @xmath , honest Bob gets
@xmath , and Eve’s quantum register @xmath is correlated with the honest
player’s part only via her classical input @xmath . In addition to their
passwords @xmath , the honest players are given high-entropy keys @xmath
. We restrict the input sampler to choose @xmath uniformly at random
from @xmath and guarantee that @xmath whenever @xmath .

###### Definition 6.2 (Computational Security against a
Man-in-the-middle)

A protocol @xmath implements an ideal classical functionality @xmath
computationally securely against a man-in-the-middle attacker, if for
any poly-time real-world adversary @xmath who has access to the common
reference string @xmath , there exists a poly-time ideal-world adversary
@xmath , not using @xmath , such that for any input sampler as described
above, it holds that the outputs in the real and the ideal world are
quantum-computationally indistinguishable, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

##### 6.3.3 The Protocol

The extended and compiled protocol @xmath is depicted in Figure 6.8 .
Corollary 6.3 states hybrid security against man-in-the-middle attacks,
such that a computationally or quantum-storage bounded Eve can do no
better than trying to guess the password. If the guess is incorrect, she
learns (essentially) nothing.

###### Corollary 6.3

Assume that @xmath and that @xmath has minimal distance @xmath for
@xmath and is polynomial-time decodeable. Then, protocol @xmath is
computationally secure against Eve with @xmath , and unconditionally
secure against @xmath -BQSM Eve with @xmath .

We split the proof of Corollary 6.3 into two parts. First, we show
computational security in Proposition 6.3 , and second, we show
unconditional security in the bounded-quantum-storage model in
Proposition 6.4 .

###### Proposition 6.3

Let @xmath have minimal distance @xmath and be polynomial-time
decodeable. Then, @xmath is computationally secure against Eve with
@xmath , according to Definition 6.2 .

Proof. We start with the real-life execution of @xmath with honest
@xmath and @xmath with respective inputs @xmath and @xmath , and a
man-in-the-middle attacker @xmath . We then modify it step by step
without (essentially) changing the common output state, such that in the
end we have a simulation of the protocol as required.

First, we change the action of @xmath in that we assume that @xmath
learns in the final step of @xmath “by magic” whether one of the
classical messages communicated was modified by @xmath and whether
@xmath or not. He accepts the execution if none of the messages was
modified, if @xmath , and if @xmath verifies correctly. This changes the
outcome of the protocol only by a negligible amount. Indeed, if @xmath ,
the restriction on the input sampler guarantees that @xmath and the
claim follows from the security of the MAC. If @xmath , then @xmath
rejects anyway in both versions, except with negligible probability.

Next, we further change the action of @xmath in that @xmath accepts the
execution in the final step of @xmath if none of the messages was
modified and if @xmath (without verifying @xmath ). We argue that this
modification does not change the common output state, up to a negligible
amount. Note that by Lemma 5.1 , we may replace the real state
consisting of the qubits obtained by @xmath and the choice of @xmath and
@xmath by a negligibly close ideal state (with the same @xmath and
@xmath ) such that the error rate within @xmath , i.e. the fraction of
@xmath with @xmath , gives an exact upper bound on the error rate
outside of @xmath . Thus, it follows that if @xmath does not reject
during verification, then @xmath will recover the correct string @xmath
in the final step (except with negligible probability) and correctly
verify @xmath if and only if @xmath .

The next modification is that @xmath runs the modified protocol with
some “dummy input” instead of his real input @xmath , but he still
accepts only if @xmath equals his real input @xmath and no transmitted
message was modified by @xmath . Since @xmath does not reveal any
information on his input before the last step, this modification does
not change the common output state at all. We write @xmath for this
modified @xmath .

As last modification, we choose an unconditionally binding key @xmath as
reference string, together with the decryption key @xmath . The new
common output state is computationally indistinguishable from the
previous one by assumption on the commitment keys.

Now, this modified protocol can be simulated by an ideal-life adversary
@xmath via the following two arguments.

(1) @xmath can simulate @xmath as @xmath does in the proof of security
against dishonest Bob (see Theorem 6.2 ) by sampling unconditionally
binding key @xmath , such that @xmath also knows the decryption key
@xmath , extracting @xmath from @xmath ’s commitments, and inquiring the
ideal functionality @xmath . In more detail, upon receiving @xmath from
@xmath , @xmath attempts to decode the string @xmath . If this is
successful (a codeword at distance at most @xmath is returned), it
computes the password @xmath such that @xmath is the decoded codeword.
If decoding fails, @xmath chooses an arbitrary @xmath . It then sends
@xmath to @xmath .

If the functionality replies by @xmath , then @xmath completes the
simulation by following the protocol with inputs @xmath and @xmath . In
that case, the simulation is perfect and the final outputs are equal.

In case the extracted password @xmath does not match @xmath , @xmath
follows the protocol but uses random values @xmath , @xmath and @xmath .
Note that the real @xmath would use @xmath instead of random @xmath .
Thus, we have to argue that @xmath is statistically close to random and
independent of the view of @xmath (for any fixed @xmath ). Recall that
the common state after the verification phase is statistically close to
a state for which it is guaranteed that @xmath for any @xmath , and
@xmath . Hence, switching between these two states has only a negligible
effect on the final output, and thus we may assume these bounds also to
hold here. By the way @xmath was chosen, it is guaranteed that @xmath
has Hamming distance at most @xmath from @xmath , which is at distance
greater than @xmath from @xmath . Thus, the Hamming distance between
@xmath and @xmath is at least @xmath , except with negligible
probability. The same holds if decoding fails, since @xmath is at least
@xmath away from any codeword and @xmath has distance at least @xmath
from @xmath . It follows that the Hamming distance between @xmath and
@xmath is at least @xmath . Therefore, we can conclude that @xmath .

Finally, note that by the property of the code family as described
previously, it follows that if @xmath with a linear gap, then @xmath is
close to uniformly distributed from @xmath ’s point of view. Then, from
the extractor property of @xmath , it follows that @xmath is essentially
random and independent of @xmath and @xmath , conditioned on @xmath .
And further, privacy amplification guarantees that @xmath is uniformly
distributed and thus @xmath is close to random and independent of @xmath
(conditioned on @xmath ). Now, given the two @xmath -bit strings @xmath
and @xmath , the bound on the min-entropy is slightly reduced by @xmath
.

(2) @xmath can also simulate modified @xmath up to before the final
step, as @xmath uses a “dummy input”. If simulated @xmath rejects in the
verification, or @xmath has modified one of the communicated messages,
then @xmath sends “override bit” @xmath to the ideal functionality.
Otherwise, it sends @xmath and therewith learns, whether @xmath or not.
In both cases, @xmath can easily complete the simulation for @xmath .
The claim follows. @xmath

###### Proposition 6.4

If @xmath , then protocol @xmath is unconditionally secure against
@xmath -BQSM Eve with @xmath , according to Definition 6.1 .

Proof. Here, we can reason similarly to the proof in [ DFSS07 ] against
a man-in-the-middle. By the security of the MAC, @xmath cannot modify
any classical message without being detected (and the extractor property
guarantees re-usability). Therefore, one can show security against
@xmath up to the point before @xmath announces whether to accept the
protocol execution or not.

In order to show security even after @xmath has announced his decision,
one can make the following case distinction. If @xmath modifies the
quantum communication in such a way that she only introduces a few
errors in the test set, then she also only introduced a few errors in
the remaining positions, except with small probability. Those positions
will be corrected by the error correction, and thus, @xmath
accepts—independent of what @xmath is. In the other case, namely if
@xmath modifies the quantum communication in such a way that she
introduces many errors in the test set, then @xmath rejects already
early in the protocol—independent of what @xmath is. Hence, this case
distinction does not depend on @xmath . It follows that @xmath ’s
announcement of whether he accepts or rejects gives away no information
on @xmath .

Let @xmath denote @xmath ’s guess on the password. Then, if @xmath ,
@xmath has @xmath bits of entropy, given @xmath , @xmath and @xmath .
Furthermore, given @xmath and @xmath , the min-entropy is reduced by
@xmath . By the properties of the code family and the privacy
amplification property of @xmath and the hash-function, we get that
@xmath as well as @xmath and @xmath are essentially random and
independent, conditioned on @xmath , for @xmath . @xmath

## Part III Cryptography in the Quantum World

### Chapter 7 Introduction

In this part of the thesis, we want to investigate classical
cryptography in the quantum world, which means that we consider the
security of classical protocols subject to quantum attacks. This
scenario is of practical importance and independent of any progress
towards large-scale quantum computing. In the following sections, we
introduce various commitment schemes and extended variants thereof,
which we will use as underlying constructions of the protocols in the
subsequent chapters.

In Chapter 8 , we show that a quantum-secure bit commitment, as
discussed in Section 7.1 , implies a quantum-secure single coin-flip.
Then, we will use the mixed commitments, described in Part II , Section
4.1 , together with a variation of its extended construction (described
in Section 7.2 ) to equip the underlying commitment construction with
extraction and equivocability such that we achieve an efficiently
simulatable and more general composable single coin-flip.

In Chapter 9 , we propose a framework for the quantum-secure
amplification of the security degree of coins, where we rely on the
mixed commitments of Section 4.1 . One step towards a fully simulatable
coin-flipping protocol, however, requires an extended construction
allowing for an untypical way of opening a commitment in that, instead
of sending the plaintext, we do a trapdoor opening (Section 7.3 ).

In Chapter 10 , we show different example applications, where the
interactive generation of coins at the beginning or during outer
protocols results in implementations without set-up assumptions and
allows for quantum-secure realizations of classical schemes.

#### 7.1 Regular Bit Commitment

In Chapter 8 , we will show a natural and direct translation of standard
coin-flipping to the quantum world. Recall from Section 2.4.1 that
commitments imply coin-flipping. More specifically, we require an
unconditionally binding and quantum-computationally hiding bit
commitment scheme from @xmath to @xmath that takes a bit and some
randomness @xmath of length @xmath as input, i.e. @xmath . As discussed,
the unconditionally binding property is fulfilled, if it is impossible
for any forger @xmath to open one commitment to both 0 and 1, i.e. to
compute @xmath such that @xmath . Quantum-computationally hiding is
ensured, if no quantum distinguisher @xmath can distinguish between
@xmath and @xmath for random @xmath with non-negligible advantage. Note
that we will use this simple notation for the commitments in the
following sections. For a specific scheme, the precise notation has to
be naturally adapted.

For an actual instantiation we can use, for instance, Naor’s commitment
based on a pseudorandom generator [ Nao91 ] . A pseudorandom generator
is a function that maps a short, randomly chosen seed to a long
pseudorandom sequence, which is computationally indistinguishable from a
truly random string for any polynomial-time bounded adversary.
Informally speaking, pseudorandomness ensures unpredictability of the
next bit in the sequence after learning the previous one. There are two
main arguments for commitments based on pseudorandomness. First, this
construction does not require any initially shared information between
the players. This aspect is of particular importance, when we later
propose sequential coin-flipping for actually implementing the CRS-model
assumption, and therewith, implementing other functionalities from
scratch without any set-up assumptions. The second reason relates to our
claim of quantum security. Given any one-way function, pseudorandom
generators can be constructed, where its security parameter is defined
by the length of the seeding key. A brute-force search through the key
space would find all seeds, and thus, all pseudorandom sequences could
be computed. Now, under the assumption of a quantum-secure one-way
function, Grover’s optimal quantum search algorithm provides only
quadratic speed-up for brute-searching. More efficient attacks are not
known, and therewith, we claim that for any poly-time bounded quantum
adversary, we achieve quantum-secure schemes.

More formally [ Nao91 ] , let @xmath denote a function with @xmath .
Then, @xmath defines a pseudorandom generator, if for all
polynomial-time (quantum) distinguisher @xmath , it holds that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath , @xmath , and @xmath is negligible in the security
parameter @xmath . A bit commitment scheme using pseudorandomness is now
constructed as follows. Let @xmath be the bit to which Alice wants to
commit, and let @xmath denote the @xmath th bit of the pseudorandom
sequence on seed @xmath . To ensure the binding property, the receiver
Bob sends a random vector @xmath where @xmath for @xmath . Alice selects
@xmath and sends the vector @xmath , where

  -- -------- --
     @xmath   
  -- -------- --

To open the commitment, Alice sends @xmath and Bob then verifies that
for all @xmath , @xmath for @xmath and @xmath for @xmath .

Assuming that a dishonest receiver is polynomial-time bounded, he cannot
learn anything about @xmath . Otherwise, he could be used to construct a
distinguisher @xmath between pseudorandom and truly random outputs. This
also holds in the quantum world, since the reduction does not require
rewinding. It follows that any quantum-computationally bounded receiver
can only guess @xmath with probability essentially @xmath , so the
commitment scheme is quantum-computationally hiding .

For any (unbounded) dishonest committer, opening a commitment to both
values 0 and 1, requires a seed pair @xmath , such that sequences @xmath
and @xmath agree for all @xmath where @xmath and disagree for all @xmath
where @xmath , i.e. @xmath for exactly one @xmath chosen by the other
player. The probability for the existence of such a pair is at most
@xmath . It follows that the committer can reveal only one possible
@xmath , except with probability less than @xmath , which satisfies
statistical binding .

#### 7.2 Extended Construction for Mixed Commitments

We will, also in the context of a single coin-flip, need an extended
construction, which is similar to the extension of Section 4.1.4 but
adapted to the case of an underlying commitment from @xmath to @xmath
with flavors unconditionally binding and quantum-computationally hiding
. We again aim at providing the respective simulator with a trapdoor for
either extraction to efficiently simulate in case of @xmath or
equivocability to avoid rewinding @xmath . As in Section 4.1.4 , we
require a @xmath -protocol for a (quantumly) hard relation @xmath with
conversations @xmath . Furthermore, we will also use the keyed dual-mode
commitment scheme described in Section 4.1.2 , based on the multi-bit
version of [ PVW08 ] with keys @xmath and @xmath , where it holds that
@xmath .

In the real protocol, the common reference string consists of commitment
key @xmath and an instance @xmath for which it holds that @xmath such
that @xmath , where we assume that @xmath . To commit to bit @xmath ,
@xmath runs the honest-verifier simulator to get a conversation @xmath .
She then sends @xmath and two commitments @xmath to @xmath , where
@xmath and @xmath with randomness @xmath and @xmath . Then, @xmath is
send to open the relevant commitment @xmath , and @xmath checks that
@xmath is an accepting conversation. Assuming that the @xmath -protocol
is honest-verifier zero-knowledge and @xmath leads to unconditionally
binding commitments, the new commitment construction is again
unconditionally binding.

During simulation, @xmath chooses a @xmath such that it knows the
matching decryption key @xmath . Then, it can extract @xmath ’s choice
bit @xmath by decrypting both @xmath and @xmath and checking which
contains a valid @xmath . Again, not both @xmath and @xmath can contain
a valid reply, since otherwise, @xmath would know a @xmath such that
@xmath . In order to simulate in case of @xmath , @xmath chooses @xmath
and @xmath . Hence, the commitment is unconditionally hiding in this
simulation. Furthermore, it can be equivocated, since now @xmath with
@xmath and therefore, @xmath can both be computed with valid replies,
i.e. @xmath and @xmath . Quantum-computational security against @xmath
follows from the indistinguishability of the keys @xmath and @xmath and
the indistinguishability of the instances @xmath and @xmath , and
efficiency of both simulations is ensured, due to extraction and
equivocability.

#### 7.3 Trapdoor Opening for Mixed Commitments

The typical notion of mixed commitment schemes is stronger than we
require for our basic construction of mixed commitments, namely, it
postulates trapdoors for both extraction and equivocability. As
previously discussed, it suffices in our basic construction to only rely
on an extraction trapdoor. This aspect is very convenient, since it
allows us to weaken the assumption on its underlying construction, i.e.,
we can build it from a public-key crypto-system with regular keys @xmath
and @xmath as binding commitment key and extraction key, and require
only an indistinguishable hiding key, generated as a random string in
the key space. This, in turn, offers the possibility of generating the
hiding key solely by a precedent interactive coin-flipping procedure
without any set-up assumptions. For a more advanced usage of commitments
as in our strong coin-flipping notion in Chapter 9 , however, we have
(in some sense) the requirement of equivocability. We want to maintain
the interactive generation of the key at any rate, which means that we
do not have enough control of its generation and even less control to
equip it with a trapdoor (as done in Sections 4.1.4 and 7.2 ).

We therefore develop a special notion of trapdoor opening, where the
ability to do a trapdoor opening is not associated to a special
knowledge of the hiding key, but is rather done by cheating in the
opening phase. Specifically, we do the opening not by sending the
plaintext and the randomness, committed to in the first phase but
instead by sending only the plaintext and then doing an interactive
proof that this plaintext is indeed what was committed to. The ability
to do trapdoor openings will then be associated with being able to
control the challenge in the interactive proof. We will get this control
by using a weak coin-flipping protocol as sub-protocol. This will be one
of the essential steps in bootstrapping fully simulatable strong
coin-flipping from weak coin-flipping.

As before, we denote the mixed string commitment scheme of Section 4.1
by @xmath . Let @xmath be the security parameter defining the key space
@xmath and let @xmath be the secondary security parameter controlling
the soundness error in the interactive proof, which we want to be
negligible in @xmath when @xmath is unconditionally binding. We equate
the plaintext space @xmath of @xmath with the Galois field @xmath . The
new extended commitment scheme, equipped with the possibility to do
trapdoor openings, is denoted by @xmath . We assume its plaintext space
to be @xmath and denote by @xmath a secret sharing scheme over @xmath .

Given message @xmath and randomizer @xmath , let @xmath denote the
unique polynomial of degree @xmath , for which @xmath for @xmath and
@xmath for @xmath . Furthermore, we “fill up” positions @xmath , where
@xmath , by letting @xmath . The shares are now @xmath . The new
commitment scheme @xmath is described in Figure 7.1 .

We stress two simple facts about this scheme. First, for any message
@xmath and any subset @xmath of size @xmath , the shares @xmath are
uniformly random in @xmath , when @xmath is chosen uniformly at random
in @xmath and independent of @xmath . This aspect is trivial for @xmath
, as we defined it that way, and it extends to the other subsets using
Lagrange interpolation. And second, if @xmath are two distinct messages,
then @xmath and @xmath have Hamming distance at least @xmath . Again,
this follows by Lagrange interpolation, since the polynomial @xmath has
degree at most @xmath , and hence, can be computed from any @xmath
shares @xmath using Lagrange interpolation. The same holds for @xmath .
Thus, if @xmath shares are the same, then @xmath and @xmath are the
same, which implies that the messages @xmath and @xmath are the same.

First note that if the underlying commitment @xmath is unconditionally
hiding, then so is @xmath . In the following, we investigate the
extraction property of @xmath , under the assumption that we work in the
unconditionally binding mode of @xmath . Given any commitment @xmath ,
we extract

  -- -------- --
     @xmath   
  -- -------- --

Assume @xmath is the consistent sharing closest to @xmath . That means
that @xmath is the vector which is consistent with a polynomial @xmath
of degree at most @xmath and which at the same time differs from @xmath
in the fewest positions. Note that we can find @xmath in poly-time when
using a Reed Solomon code, which has efficient minimal distance
decoding. We then interpolate this polynomial @xmath , let @xmath , and
define @xmath to be the message committed to by @xmath . Any other
sharing @xmath must have Hamming distance at least @xmath to @xmath .
Now, since @xmath is closer to @xmath than to any other consistent
sharing, it must, in particular, be closer to @xmath then to @xmath .
This implies that @xmath is at distance at least @xmath to @xmath .

We will use this observation for proving soundness of the opening phase.
To determine the soundness error, assume that @xmath does not open to
the shares @xmath consistent with @xmath . As observed, this implies
that @xmath has Hamming distance at least @xmath to @xmath . However,
when @xmath is unconditionally binding, all @xmath can only be opened to
@xmath . From the above two facts, we have that there are at least
@xmath values @xmath such that the receiver cannot open @xmath to @xmath
for @xmath . Since @xmath , these @xmath bad indices (bad for a
dishonest sender) account for a fraction of @xmath of all points in
@xmath . Thus, the probability that none of the @xmath points in @xmath
is a bad index is at most @xmath , which is negligible. Lemma 7.1
follows.

###### Lemma 7.1

If @xmath is unconditionally binding, then the probability that an
unbounded cheating committer can open @xmath to a plaintext different
from @xmath is at most @xmath , assuming that the challenge @xmath is
picked uniformly at random and independent of @xmath .

In the context of simulation, we will use the challenge @xmath as the
simulators trapdoor, allowing him to equivocally open his commitments.
In such a simulation, the ideal-world adversary @xmath can—by means
discussed later—enforce a specific challenge, i.e., it is guaranteed
that this will be the challenge in the opening phase. Thus, for
simplicity, we assume here that it simply gets a fixed challenge @xmath
as input. The simulation is described in Figure 7.2 . Lemma 7.2 follows
via a hybrid argument, which relies on the quantum-computational
indistinguishability in switching unconditionally binding and
unconditionally hiding commitment keys. We omit a proof here but refer
to Chapter 9 , where the construction will be explicitly proven within
its outer construction.

###### Lemma 7.2

If @xmath , then the transcript of the protocol is identical to that of
an honest commitment to @xmath , followed by an honest opening phase to
@xmath , and run with a uniformly random challenge @xmath .

If @xmath , then the transcript of the protocol is
quantum-computationally indistinguishable to that of an honest
commitment to @xmath , followed by an honest opening phase to @xmath ,
and run with a uniformly random challenge @xmath .

### Chapter 8 Quantum-Secure Coin-Flipping

Coin-flipping is introduced in Section 2.4.4 and allows two parties to
agree on a uniformly random bit in a fair way. Security for both parties
follows, if neither party can influence the value of the coin to his
advantage. Thus, it enables the parties to interactively generate true
randomness from scratch. The chapter is based on parts of [ DL09 ] .

#### 8.1 Motivation and Related Work

We are interested in the standard coin-flipping protocol [ Blu81 ] with
classical message exchange but we here assume that the adversary is
capable of quantum computing. As already mentioned, bit commitment
implies a secure coin-flipping, but even when basing the embedded
commitment on a computational assumption that withstands quantum
attacks, the security proof of the entire coin-flipping (and its
integration into other applications) could previously not be translated
from the classical to the quantum world.

Typically, security against a classical adversary is argued in such a
context by rewinding the adversary in a simulation. Recall that, in
general, rewinding as a proof technique cannot be directly applied in
the quantum world. Based on a recent result of Watrous [ Wat09 ] , which
originally allowed to prove unconditionally that quantum zero-knowledge
of certain interactive proofs is possible and that the classical
definitions can be translated into the quantum world, we show the most
natural and direct quantum analogue of the classical security proof for
standard coin-flipping.

We want to mention an alternative approach, which was independently
investigated but never published [ Smi09 ] . They propose a classical
protocol for zero-knowledge proofs of knowledge secure against quantum
adversaries. The protocol consists of a commitment phase and two
zero-knowledge proofs. Instead of opening the commitment, the committer
claims the value of the committed coins and gives the first
zero-knowledge proof that the claim is correct. To simulate this
zero-knowledge proof, Watrous’ technique is used. Note that this
approach allows for flipping a string of coins in the commitments, and
thus, arrives at a coin-flipping protocol with round complexity
independent of the length of the flipped string at first. However, the
required zero-knowledge proof has round complexity depending on the
security parameter, i.e. how many proofs must be completed to achieve a
negligible soundness error. Finally, the coin-string is used as key to
encode the witness and the second zero-knowledge proof is given that
this statement is actually true. As encryption scheme, they suggest a
scheme with similar properties as in our mixed commitment
constructions—but at least to our best knowledge, the question of its
actual secure implementation was left open.

We stress that we aim at establishing coin-flipping as a stand-alone
tool that can be used in several contexts and different generic
constructions. Some example applications thereof are discussed in
Chapter 10 , including an independently proposed zero-knowledge proof of
knowledge. In order to include coin-flipping securely in other
applications, we conclude this chapter by proving the basic construction
secure under sequential composition and propose an extended construction
for general composability.

#### 8.2 The Protocol

The standard coin-flipping protocol @xmath is shown in Figure 8.1 ,
allowing players @xmath and @xmath to interactively generate a random
and fair @xmath in one execution without any set-up requirements. As
underlying commitment scheme, we use the unconditionally binding and
quantum-computationally hiding scheme described in Section 7.1 with
security parameter @xmath . We will use its simpler notation here,
namely @xmath with input @xmath , randomness @xmath and output in @xmath
. To indicate the opening phase, where @xmath sends @xmath and @xmath ,
we will write @xmath . The corresponding ideal coin-flipping
functionality @xmath is depicted in Figure 8.2 . Note that dishonest
@xmath may refuse to open @xmath in the real world after learning @xmath
’s input. For this case, @xmath allows her a second input @xmath ,
modeling the abort of the protocol.

###### Proposition 8.1

Protocol @xmath satisfies correctness, according to Definition 3.4 .

Correctness is obvious by inspection of the protocol: If both players
are honest, they independently choose random bits @xmath and @xmath .
These bits are then combined via exclusive disjunction, resulting in a
uniformly random @xmath .

###### Theorem 8.1

Protocol @xmath is unconditionally secure against any unbounded
dishonest Alice according to Definition 3.6 , provided that the
underlying commitment scheme is unconditionally binding.

Proof. We construct an ideal-world adversary @xmath , such that the real
output of the protocol is statistically indistinguishable from the ideal
output produced by @xmath , @xmath and @xmath . The ideal-world
simulation is depicted in Figure 8.3 .

First note that @xmath and @xmath are chosen and computed as in the real
protocol. From the statistically binding property of the commitment
scheme, it follows that @xmath ’s choice bit @xmath is uniquely
determined from @xmath , since for any @xmath , there exists at most one
pair @xmath such that @xmath , except with probability negligible in the
security parameter @xmath . Hence in the real world, @xmath is
unconditionally bound to her bit before she learns @xmath ’s choice bit,
which means @xmath is independent of @xmath . Therefore in Step ( 2 .),
the simulator can correctly (but not necessarily efficiently) compute
@xmath (and @xmath ). Note that, in the case of unconditional security,
we do not have to require the simulation to be efficient. However, we
show in Section 8.3.2 how to extend the underlying commitment in order
to extract @xmath ’s inputs. This extraction requires a extraction
trapdoor and yields an efficient simulation in the CRS-model. Finally,
due to the properties of XOR, @xmath cannot tell the difference between
the random @xmath computed from the ideal, random @xmath in the
simulation in Step ( 3 .) and the randomly chosen @xmath of the real
world. It follows that the simulated output is statistically
indistinguishable from the output in the real protocol. @xmath

To prove security against any dishonest quantum-computationally bounded
@xmath , we will follow the lines of argument as in Section 3.6.3 , in
particular Definition 3.7 , with slight modifications. More
specifically, we do not require a common reference string, so we can
omit this part of the definition. Thus, we show that there exists an
ideal-world simulation @xmath with output quantum-computationally
indistinguishable from the output of the protocol in the real world. For
the ideal world, we consider the poly-size input sampler, which takes as
input only the security parameter and produces a valid input state
@xmath as specified in Section 3.6.3 .

In a simulation against a classical adversary, a classical poly-time
simulator would work as follows. It inquires @xmath from @xmath ,
chooses random @xmath and @xmath , and computes @xmath as well as @xmath
. It then sends @xmath to @xmath and receives @xmath ’s choice bit
@xmath . If @xmath , the simulation was successful. Otherwise, the
simulator rewinds @xmath and repeats the simulation. For a security
proof against any quantum adversary, we construct a poly-time quantum
simulator proceeding similarly to its classical analogue. However, it
requires quantum registers as work space and relies on Watrous’ quantum
rewinding lemma (see Lemma 3.2 ). Recall from Section 3.5.2 that Watrous
constructs the quantum simulator for a @xmath -protocol, i.e. a protocol
in three-move form, where the verifier flips a single coin in the second
step and sends this challenge to the prover. Since these are the
essential aspects also in our protocol @xmath , we can apply Watrous’
quantum rewinding technique (with slight modifications) as a black-box
to our protocol. We also follow his notation and line of argument here.
For a more detailed description and proofs, we refer to [ Wat09 ] and
Section 3.5.2 .

###### Theorem 8.2

For @xmath , protocol @xmath is quantum-computationally secure against
any poly-time bounded dishonest Bob (according to Definition 3.7 but
with the modification described above), provided that the underlying
commitment scheme is quantum-computationally hiding.

Proof. Let @xmath denote @xmath ’s @xmath -qubit auxiliary input. Let
@xmath denote @xmath ’s auxiliary input register, containing @xmath .
Let @xmath and @xmath denote @xmath ’s work space, where @xmath is an
arbitrary polynomial-size register and @xmath is a single qubit
register. @xmath ’s classical messages are considered in the following
as being stored in quantum registers @xmath and @xmath . In addition,
the quantum simulator uses registers @xmath , containing all possible
choices of a classical simulator, and @xmath , representing its guess
@xmath on @xmath ’s message @xmath in the second step. Finally, let
@xmath denote a working register of size @xmath , which is initialized
to the state @xmath and corresponds to the collection of all registers
as described above except @xmath .

The quantum rewinding procedure is implemented by a general quantum
circuit @xmath with input @xmath . As a first step, it applies a unitary
@xmath -quantum circuit @xmath to @xmath to simulate the conversation,
obtaining registers @xmath . Then, a test takes place to observe whether
the simulation was successful. In that case, @xmath outputs the
resulting quantum register. Otherwise, it quantumly rewinds by applying
the reverse circuit @xmath on @xmath to retrieve @xmath and then a
phase-flip transformation on @xmath before another iteration of @xmath
is applied. Note that @xmath is essentially the same circuit as @xmath
described in [ Wat09 ] (and Section 3.5.2 ), but in our application it
depends on the value of a given @xmath , i.e., we apply @xmath or @xmath
for @xmath or @xmath , respectively.

In more detail, @xmath transforms @xmath to @xmath by the following
unitary operations:

1.  It constructs a superposition over all possible random choices of
    values in the real protocol, i.e.,

      -- -------- --
         @xmath   
      -- -------- --

    where @xmath . Note that the state of registers @xmath corresponds
    to a uniform distribution of possible transcripts of the interaction
    between the players.

2.  For each possible @xmath , it simulates @xmath ’s possible actions
    by applying a unitary operator to @xmath with register @xmath as
    control, i.e.,

      -- -------- --
         @xmath   
      -- -------- --

    where @xmath and @xmath describe modified quantum states. Note that
    register @xmath now includes @xmath ’s reply @xmath .

3.  Finally, a @xmath -operation is applied to pair @xmath with @xmath
    as control to check whether the simulator’s guess of @xmath ’s
    choice was correct. The result of the @xmath -operation is stored in
    register @xmath .

      -- -------- --
         @xmath   
      -- -------- --

Note that the qubit in register @xmath gives the information about
success or failure of the simulated run, and the other registers are
combined in the residual @xmath -qubit register @xmath .

Since the commitment scheme in the protocol is only
quantum-computationally hiding, we must allow for small perturbations in
the quantum rewinding procedure, according to Lemma 3.2 : Bound @xmath
indicates @xmath ’s advantage over a random guess on the committed value
with @xmath (and therefore, his advantage to bias the outcome), due to
his computing power, i.e. @xmath . From the hiding property of the
commitment scheme, it follows that @xmath is negligible in the security
parameter @xmath . Thus, we can argue that probability @xmath is close
to independent of the auxiliary input. As a lower bound on the success
probability, we chose @xmath , which matches our setting.

Thus, we have circuit @xmath as described above and our setting achieves
the given bounds. Lemma 3.2 applies. We can now construct an ideal-world
quantum simulator @xmath (see Figure 8.4 ), interacting with @xmath and
the ideal functionality @xmath and executing Watrous’ quantum rewinding
algorithm. We then compare the output states of the real process and the
ideal process. In case of indistinguishable outputs,
quantum-computational security against @xmath follows.

First note that the superposition constructed as described above in
circuit @xmath in Step (1.) corresponds to all possible random choices
of values in the real protocol. Furthermore, the circuit models any
possible strategy of quantum @xmath in Step (2.), depending on control
register @xmath . The @xmath -operation on @xmath in Step (3.), followed
by a standard measurement of @xmath , indicate whether the guess @xmath
on @xmath ’s choice @xmath was correct. If that was not the case (i.e.
@xmath and measurement result 1), the system gets quantumly rewound by
applying reverse transformations (3)-(1), followed by a phase-flip
operation. The procedure is repeated until the measurement outcome is 0
and hence @xmath . Watrous’ technique then guarantees that, for
negligible advantage @xmath and a lower bound @xmath , @xmath is
negligible. Thus, the final output of the simulation is close to the
“good” state of a successful simulation. More specifically, the output
@xmath of @xmath has square-fidelity close to 1 with state @xmath of a
successful simulation, i.e.

  -- -------- --
     @xmath   
  -- -------- --

where @xmath . Last, note that all operations in @xmath (and therewith
in @xmath ) can be performed by polynomial-size circuits, and thus, the
simulator has polynomial size (in the worst case). It follows that the
output of the ideal simulation is indistinguishable from the output in
the real world for any quantum-computationally bounded @xmath . @xmath

#### 8.3 Composability

As already discussed in the previous part, there are several composition
frameworks proposed for the quantum setting, but for sequential
composition we will argue along the lines of our security framework
(Section 8.3.1 ). In Section 8.3.2 , we will use an extend commitment
construction to achieve a more general composability in the CRS-model.
Note that only sequential composition allows us to do coin-flipping from
scratch.

##### 8.3.1 Sequential Composition

Recall that we prove correctness and security for our single coin-flip
according to the security framework as described in Section 3.6 , with
the one modification that we do not assume a common reference string in
the simulation against a dishonest Bob (see Theorem 8.2 ). However, we
can still apply the Composition Theorems I and II (Theorems 3.2 and 3.3
), where we also omit the reference string in the latter. We will state
the composition result explicitly here.

###### Corollary 8.1

Let @xmath and @xmath , and let @xmath be a classical two-party hybrid
protocol which makes at most @xmath calls to the functionalities. Then,
for every @xmath , each protocol @xmath is a statistically secure
implementation of @xmath against @xmath and a computationally secure
implementation of @xmath against @xmath .

It holds that there exists an ideal-world adversary @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

and an ideal-world adversary @xmath such that for every efficient input
sampler, we have

  -- -------- --
     @xmath   
  -- -------- --

The ideal functionality for sequential coin-flipping, i.e. @xmath , is
depicted in Figure 8.5 . Note that @xmath is in fact derived from
composing the functionality @xmath of a single coin-flip sequentially
but interpreted more directly, e.g. it does not output the bits one
after another but as a string, and thus, does not output the precedent
coins in case of an intermediate abort.

##### 8.3.2 General Composition

For our coin-flipping protocol without set-up, we cannot claim universal
composability. We do not require (nor obtain) an efficient simulator in
case of unconditional security against dishonest Alice and furthermore,
we allow rewinding in case of dishonest Bob. These two aspects
contradict the universal composability framework.

Efficient simulation requires some trapdoor information in the
commitment construction, which is available only to a simulator, so that
it is able to extract dishonest Alice’s choice bit efficiently.
Therefore, we have to extend the commitment scheme by including an
extraction trapdoor. To circumvent the necessity of rewinding dishonest
Bob, we further extend the scheme with respect to equivocability, i.e.,
the simulator can now construct a valid commitment, which can later be
opened to both bit values as desired. Note that with such requirements,
the CRS-model seems unavoidable.

An appropriate extended construction is proposed in Section 7.2 . The
real-world key consists of commitment key @xmath and (invalid) instance
@xmath . During simulation against @xmath , @xmath chooses @xmath with
matching decryption key @xmath and therefore, it can extract @xmath ’s
choice bit @xmath by decrypting both commitments @xmath and @xmath . In
both worlds, the commitment is unconditionally binding. During
simulation against @xmath , @xmath chooses commitment key @xmath and
(valid) instance @xmath . Hence, the commitment is unconditionally
hiding and can be equivocated by using @xmath to compute two valid
replies in the underlying @xmath -protocol. Quantum-computational
security in real life follows from the indistinguishability of the keys
@xmath and @xmath and the indistinguishability of the instances @xmath
and @xmath , and efficiency of both simulations is ensured due to
extraction and equivocability.

Again, by combining our extended construction in the CRS-model providing
efficient simulations on both sides with the results of Section 7.2 and
[ Unr10 , Theorem 20] , we get the following result that @xmath
computationally quantum-UC-emulates its corresponding ideal
functionality @xmath for both dishonest players . In the next Chapter 9
, we will show another method of achieving fully simulatability in the
plain model without any set-up assumption, when both players are
poly-time bounded.

### Chapter 9 Amplification Framework for Strong Coins

Here, we present a framework that amplifies weak security requirements
on coins into very strong properties, with the final result of a
quantum-secure and fully simulatable coin-flipping protocol, which can
be implemented in the plain model from scratch. The results in this
chapter are joint work with Nielsen [ LN10 ] .

#### 9.1 Motivation

Coin-Flipping of a single coin is in itself an intriguing and prolific
primitive in cryptographic protocol theory. Its full potential is tapped
in the possibility of flipping a string of coins, which opens up for
various applications and implementations without any set-up assumptions.
We will later in Chapter 10 discuss some examples thereof.

In this chapter, we first investigate the different degrees of security
that a string of coins can acquire. Then, we propose and prove
constructions that allow us to amplify the respective degrees of
security such that weaker coins are converted into very strong ones in a
straightforward way. ¹ ¹ 1 For the sake of clarity, we note that we use
the (intuitive) literal interpretation of “weak” and “strong” coins
related to their degrees of security, which differs from their
definitions in the quantum literature (see also Section 2.4.4 ). Our
method only assumes mixed commitment schemes, which we know how to
construct with quantum security, no other assumptions are put forward.
Our final result is a coin-flipping protocol, which is fully simulatable
in polynomial time, even against poly-sized quantum adversaries on both
sides, and which can be implemented with quantum-computational security
in the plain model from scratch.

Our method of amplifying the security of coin-flipping also applies to
potential constant round coin-flipping. Such a strong and efficient
construction would require a basic quantum-secure coin-flip protocol
with long outcomes (in constant round), and poly-time simulatability on
one side. Its construction, however, is still a fascinating open problem
in the quantum world.

#### 9.2 Security Notions

We denote a generic protocol with a @xmath -bit coin-string as output by
@xmath , corresponding to an ideal functionality @xmath . Recall that
the outcome of such a protocol is @xmath , i.e., either an @xmath -bit
string or an error message. ² ² 2 We want to stress that throughout the
chapter, a reference to any coin-flip is understood as one run of
coin-flipping with a coin-string outcome. We will use several security
parameters, indicating the length of coin-strings for different
purposes. The length of a coin-flip yielding a key and a challenge are
denoted by @xmath and @xmath , respectively, and the length of a final
coin-flip is indicated by @xmath , i.e., we allow that @xmath is a
function of the respective parameter, e.g. @xmath , but we write @xmath
instead.

Throughout this chapter, we restrict both players Alice and Bob to the
families @xmath and @xmath of classical polynomial-time strategies,
i.e. for the honest case, we require @xmath and @xmath , as well as for
possibly quantum dishonest entities, we demand @xmath and @xmath . We
want to stress here that, in contrast to previous chapters, both players
are poly-time bounded. This means, in particular, that the ideal
functionality is defined symmetric such that always the respective
dishonest party has an option to abort. For clarity, we will explicitly
show the ideal functionalities in the case of both players being honest
(Figure 9.1 ) and in the case of dishonest Alice and honest Bob (Figure
9.2 ). The latter then also applies to honest Alice and dishonest Bob by
simply switching sides and names.

Recall that the joint output representation of a protocol execution is
denoted by @xmath with @xmath and given here for the case of honest
players. The same notation with @xmath and @xmath applies in the ideal
world as @xmath , where the players invoke the ideal functionality
@xmath and output whatever they obtain from it. We need an additional
notation here, describing the outcome of a protocol run between
e.g. honest @xmath and @xmath , namely @xmath .

We will define three flavors of security for coin-flipping protocols,
namely uncontrollable (uncont) , random and enforceable (force) . The
two sides can have different flavors. Then, if a protocol @xmath is, for
instance, enforceable against Alice and random against Bob, we write
@xmath , and similarly for the eight other combinations of security.
Note that for simplicity of notation, we will then omit the indexed name
as well as the length of the coin, as they are clear from the context.
Similar to the ideal functionality for the case of dishonest Alice, we
define all three flavors for Alice’s side only, as the definitions for
Bob are analogue. The flavors are defined along the lines of the
security framework introduced in Section 3.6 but with adaptions to
reflect the particular context here. Recall that @xmath , @xmath , and
@xmath denote dishonest Alice’s quantum and classical input, and honest
Bob’s classical input, respectively. Note that an honest player’s input
is empty but models the invocation @xmath . Any input state @xmath is
restricted to @xmath , such that Alice’s quantum and Bob’s classical
part are only correlated via Alice’s classical @xmath . We assume again
a poly-size input sampler, which takes as input the security parameter,
and then produces a valid input state @xmath (and analogous @xmath in
case of dishonest Bob).

We stress that we require for all three security flavors and for all
@xmath that

  -- -------- --
     @xmath   
  -- -------- --

which implies that when both parties are honest, then the coin is
unbiased. Below we only define the extra properties required for each of
the three flavors.

We call a coin-flip uncontrollable against Alice, if she cannot force
the coin to hit some negligible subset, except with negligible
probability.

###### Definition 9.1 (Uncontrollability against dishonest Alice)

We say that the protocol @xmath implements an uncontrollable coin-flip
against dishonest Alice, if it holds for any poly-sized adversary @xmath
with inputs as specified above and all negligible subsets @xmath that
the probability

  -- -------- --
     @xmath   
  -- -------- --

Note that we denote by @xmath a family of subsets @xmath for security
parameter @xmath . Then we call @xmath negligible, if @xmath is
negligible in @xmath . In other words, we call a subset negligible if it
contains a negligible fraction of the elements in the set in which it
lives.

We call a coin-flip random against Alice, if she cannot enforce a
non-uniformly random output string in @xmath , except by making the
protocol fail on some chosen runs. That means she can at most lower the
probability of certain output strings compared to the uniform case.

###### Definition 9.2 (Randomness against dishonest Alice)

We say that protocol @xmath implements a random coin-flip against
dishonest Alice, if it holds for any poly-sized adversary @xmath with
inputs as specified above that there exists an event E such that @xmath
and for all @xmath it holds that

  -- -------- --
     @xmath   
  -- -------- --

It is obvious that if a coin-flip is random against Alice, then it is
also an uncontrollable coin-flip against her. We will later discuss a
generic transformation going in the other direction from uncontrollable
to random coin-flipping.

We call a coin-flip enforceable against Alice, if it is possible, given
a uniformly random @xmath , to simulate a run of the protocol hitting
exactly the outcome @xmath , though we still allow that the corrupted
party forces abort on some outcomes.

###### Definition 9.3 (Enforceability against dishonest Alice)

We call a protocol @xmath enforceable against dishonest Alice, if it
implements the ideal functionality @xmath against her.

In more detail, that means that for any poly-sized adversary @xmath ,
there exists an ideal-world adversary @xmath that simulates the protocol
with @xmath as follows. @xmath requests output @xmath from @xmath . Then
it simulates a run of the coin-flipping protocol with @xmath and tries
to enforced output @xmath . If @xmath succeeds, it inputs @xmath as
@xmath ’s second input to @xmath . In that case, @xmath outputs @xmath .
Otherwise, @xmath inputs @xmath to @xmath as second input and @xmath
outputs @xmath . The simulation is such that the ideal output is
quantum-computationally indistinguishable from the output of an actual
run of the protocol, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath .

Note that an enforceable coin-flip is not necessarily a random
coin-flip, as it is allowed that the outcome of an enforceable coin-flip
is only quantum-computationally indistinguishable from uniformly random,
whereas a random coin-flip is required to produce truly random outcomes
on the non-aborting runs.

We defined an enforceable coin-flip against dishonest Alice to be a
coin-flip, simulatable on her side and implementing the corresponding
ideal functionality against her. The same result with switched sides
also holds for any poly-time bounded Bob. Thus, we obtain a coin-flip
protocol, for which we can simulate both sides in polynomial time.
Corollary 9.1 follows.

###### Corollary 9.1

Let @xmath be an enforceable coin-flip against both parties Alice and
Bob with @xmath and @xmath , i.e. @xmath . Then @xmath is a fully
poly-time simulatable coin-flipping protocol for the ideal functionality
@xmath with quantum-computational indistinguishability between the real
and the ideal output.

Combining the part regarding simulatability in Corollary 8.1 , where we
again omit the common reference string, in contrast to the original
Composition Theorem II (Theorem 3.3 ), with the results of Corollary 9.1
, we can show that each protocol @xmath is a computationally secure
implementation of @xmath against both @xmath and @xmath .

###### Corollary 9.2

Protocol @xmath composes sequentially.

#### 9.3 Amplification Theorems

We now propose and prove theorems, which allow us to amplify the
security strength of coins. Ultimately, we aim at constructing a strong
coin-flipping protocol @xmath with outcomes of any polynomial length
@xmath in @xmath from any weaker coin-flip protocol, i.e., either from a
protocol @xmath producing one-bit outcomes (Section 9.3.1 ), or from a
protocol @xmath giving outcomes of length @xmath , as described in
Section 9.3.2 . In both cases, the first step towards @xmath is to build
a protocol @xmath with outcomes of length @xmath .

We want to stress that if the underlying protocol already produces
@xmath -bit outcomes and is constant round, then the resulting protocol
@xmath will also be constant round. If we start from a protocol only
producing constant-sized outcomes, then @xmath will use @xmath times the
number of rounds used by the underlying scheme.

We note here that we do not know of any candidate protocol with flavor
@xmath but not @xmath . However, we consider it as a contribution in
itself to find the weakest security notion for coin-flipping that allows
to amplify to the final strong @xmath notion using a constant round
reduction.

##### 9.3.1 From Short Outcomes to Long Outcomes

To obtain long coin-flip outcomes, we can repeat a given protocol @xmath
with one-bit outcomes @xmath times in sequence to get a protocol @xmath
with @xmath -bit outcomes. A candidate for @xmath with one-bit outcomes
is the protocol of Chapter 8 , which is—in terms of this
context—enforceable against one side in poly-time and random on the
other side, with empty event @xmath according to Definition 9.2 , and
the randomness guarantee even withstanding an unbounded adversary. The
protocol was argued to be sequentially composable according to Corollary
8.1 .

Note that this protocol is previously described and proven as @xmath .
However, due to the symmetric coin-flip definitions here and the
restriction of entities to families of classical polynomial-time
strategies, we can easily switch sides between @xmath and @xmath .

##### 9.3.2 From @xmath to @xmath

Assume that we are given a protocol @xmath , that only guarantees that
Bob cannot force the coin to hit a negligible subset (except with
negligible probability). We now amplify the security on Bob’s side from
to and therewith obtain a protocol @xmath , in which Bob cannot enforce
a non-uniformly random output string, except by letting the protocol
fail on some occasions. The stronger protocol @xmath is given in Figure
9.3 . The underlying commitment @xmath denotes the commitment algorithm
of the keyed mixed string commitment scheme as described in Section 4.1
. Recall that @xmath does not require actual unconditionally hiding
keys, but rather it suffices to use uniformly random strings from @xmath
, which unconditionally hide the plaintext, except with negligible
probability. The possibility of using random strings ensures that most
keys of the given domain are in that sense unconditionally hiding keys.

###### Proposition 9.1

Protocol @xmath satisfies correctness, according to Definition 3.4 .

Correctness is obvious by inspection of the protocol. If both players
are honest, they independently choose random strings @xmath and @xmath .
The result of these strings combined by the XOR-operation gives a
uniformly random coin @xmath of length @xmath .

###### Theorem 9.1

If @xmath is enforceable against Alice and uncontrollable against Bob,
then protocol @xmath is enforceable against Alice and random for Bob.

Proof ( Enforceability against Alice ). In case of corrupted @xmath ,
@xmath samples @xmath as input. It then requests a uniformly random
value @xmath from @xmath . It runs @xmath with @xmath , in which @xmath
enforces the outcome @xmath in the first step. When @xmath sends
commitment @xmath , @xmath uses @xmath to decrypt @xmath to learn the
unique string @xmath that @xmath can be opened to. @xmath computes
@xmath and sends @xmath to @xmath . If @xmath opens commitment @xmath
correctly, then the result is @xmath as desired. In case she does not
open correctly, @xmath aborts with result @xmath . Otherwise, @xmath
outputs whatever @xmath outputs.

Since @xmath is uniformly random and independent of @xmath and @xmath ,
it follows that @xmath is uniformly random and independent of @xmath ,
exactly as in the protocol. Therefore, the transcript of the simulation
has the same distribution as the real protocol, except that @xmath is
uniform in @xmath and not in @xmath . This is, however,
quantum-computationally indistinguishable, as otherwise, @xmath could
distinguish random access to samples from @xmath from random access to
samples from @xmath . The formal proof proceeds through a series of
hybrids as described in full detail in the proof for Theorem 9.2 in the
next Section 9.3.3 .

The above two facts, that first we hit @xmath when we do not abort, and
second that the transcript of the simulation is quantum-computationally
indistinguishable from the real protocol, show that the resulting
protocol is enforceable against Alice and simulatable on Alice’s side
for functionality @xmath , according to Definition 9.3 combined with
Theorem 9.3 . @xmath

Proof ( Randomness against Bob ). For any @xmath , @xmath is
uncontrollable, i.e. @xmath , except with negligible probability, as
@xmath is negligible in @xmath . This, in particular, means that the
commitment @xmath is perfectly hiding the value @xmath . Therefore,
@xmath is uniformly random and independent of @xmath , and thus, @xmath
is uniformly random. This proves that the resulting coin-flip is random
against Bob, according to Definition 9.2 . @xmath

##### 9.3.3 From @xmath to @xmath

We now show how to obtain a coin-flipping protocol, which is enforceable
against both parties. Then, we can also claim by Corollary 9.1 that this
protocol is a strong coin-flipping protocol, poly-time simulatable on
both sides for the natural ideal functionality @xmath . The protocol
@xmath is described in Figure 9.4 .

Note that the final protocol makes two calls to a subprotocol with
random flavor on one side and enforceability on the other side, but
where the sides are interchanged for each instance, i.e. @xmath and
@xmath . That means that we switch the players’ roles as well as the
direction of the messages. Furthermore, note that we use here the
possibility of trapdoor openings in our extended commitment construction
@xmath , based on secret sharing and mixed commitments, as described in
detail in Section 7.3 .

###### Proposition 9.2

Protocol @xmath satisfies correctness, according to Definition 3.4 .

Again, correctness can be trivially checked, first by observing that
honest players independently input uniformly random strings @xmath and
@xmath , and second by verifying that these strings combined by XOR
result in a uniformly random coin @xmath of length @xmath .

###### Theorem 9.2

If @xmath is enforceable against Alice and random against Bob, then
protocol @xmath is enforceable against both Alice and Bob.

Proof ( Enforceability against Alice ). If @xmath is corrupted, @xmath
samples @xmath as input and enforces @xmath in the first step to hit the
outcome @xmath . It then requests value @xmath from @xmath . When @xmath
sends commitments @xmath , @xmath uses @xmath to extract @xmath with
@xmath . @xmath then sets @xmath , and sends @xmath to @xmath . Then
@xmath finishes the protocol honestly. In the following, we will prove
that the transcript is quantum-computationally indistinguishable from
the real protocol and that if @xmath , then @xmath , except with
negligible probability.

First, we show indistinguishability. The proof proceeds via a hybrid
argument. ³ ³ 3 Briefly, a hybrid argument is a proof technique to show
that two (extreme) distributions are computationally indistinguishable
via proceeding through several (adjacent) hybrid distributions. If all
adjacent distributions are pairwise computationally
indistinguishability, it follows by transitivity that the two end points
are so as well. We want to point out that we are not subject to any
restrictions in how to obtain the hybrid distributions as long as we
maintain indistinguishability. Let @xmath denote the distribution of the
output of the simulation as described. We now change the simulation such
that, instead of sending @xmath , we simply choose a uniformly random
@xmath and then output the corresponding @xmath . Let @xmath denote the
distribution of the output of the simulation after this change. Since
@xmath is uniformly random and independent of @xmath in the first case,
it follows that then @xmath is uniformly random. Therefore, the change
to choose a uniformly random @xmath in the second case actually does not
change the distribution at all, and it follows that @xmath .

By sending a uniformly random @xmath , we are in a situation where we do
not need the decryption key @xmath to produce @xmath , as we no longer
need to know @xmath . So we can now make the further change that,
instead of forcing @xmath to produce a random public key @xmath , we
force it to hit a random public key @xmath . This produces a
distribution @xmath of the output of the simulation. Since @xmath and
@xmath only differ in the key we enforce @xmath to hit and the
simulation is quantum poly-time, there exists a poly-sized circuit
@xmath , such that @xmath and @xmath , where @xmath and @xmath denote
the uniform distribution on @xmath and the uniform distribution on
@xmath , respectively. As @xmath and @xmath are quantum-computationally
indistinguishable, and @xmath is poly-sized, it follows that @xmath and
@xmath are quantum-computationally indistinguishable, and therewith,
@xmath .

A last change to the simulation is applied by running @xmath honestly
instead of enforcing a uniformly random @xmath . Let @xmath denote the
distribution obtained after this change. As given in Definition 9.3 ,
real runs of @xmath and runs enforcing a uniformly random value are
quantum-computationally indistinguishable. Using a similar argument as
above, where @xmath is the part of the protocol following the run of
@xmath , we get that @xmath . Finally by transitivity, it follows that
@xmath . The observation that @xmath is the distribution of the
simulation and @xmath is the actual distribution of the real protocol
concludes the first part of the proof.

We now argue the second part, i.e., if @xmath , then @xmath , except
with negligible probability. This follows by arguing soundness of the
commitment scheme @xmath , according to Lemma 7.1 . Recall that, if
@xmath , then the probability that @xmath can open any @xmath to a
plaintext different from @xmath is at most @xmath when @xmath is picked
uniformly at random and independent of @xmath . The requirement on
@xmath is however guaranteed (except with negligible probability) by the
flavor of the underlying protocol @xmath producing @xmath . This
concludes the proof of enforceability against Alice, as given in
Definition 9.3 . @xmath

Proof ( Enforceability against Bob ). To prove enforceability against
corrupted @xmath , we construct a simulator @xmath as shown in Figure
9.5 . It is straightforward to verify that the simulation always ensures
that @xmath , if @xmath does not abort. However, we must explicitly
argue that the simulation is quantum-computationally indistinguishable
from the real protocol.

Indistinguishability follows by first arguing that the probability for
@xmath is negligible. This follows from @xmath being negligible in
@xmath and @xmath produced with flavor against @xmath by @xmath being
uniformly random in @xmath , except with negligible probability.

Second, we have to show that if @xmath , then the simulation is
quantum-computationally close to the real protocol. This can be shown
via the following hybrid argument. Let @xmath be the distribution of the
output of the simulation and let @xmath be the distribution of the
output of the simulation where we send all @xmath for all @xmath at the
end of Step ( 4 .). Since commitments by @xmath are unconditionally
hiding in case of @xmath , commitments by @xmath are unconditionally
hiding as well. Furthermore, both @xmath and @xmath are uniformly
random, so we obtain statistical closeness between @xmath and @xmath .
Note further that distributions @xmath and @xmath can be produced by a
poly-sized circuit applied to either @xmath or @xmath , it holds that
@xmath .

Now, let @xmath be the distribution obtained by not simulating the
opening via the trapdoor, but instead doing it honestly to the value
committed to, i.e. @xmath . We still use the challenge @xmath from the
forced run of @xmath though. However, for uniformly random challenges,
real runs are quantum-computationally indistinguishable from simulated
runs, and we get @xmath .

Next, let @xmath be the distribution of the output of the simulation
where we run @xmath honestly instead of enforcing outcome @xmath . We
then use the honestly produced @xmath in the proof in Step ( 6
.) instead of the enforced @xmath . We can do this, as we modified the
process leading to @xmath towards an honest opening without any
trapdoor, so we no longer need to enforce a particular challenge. Under
the assumption that @xmath is enforceable against @xmath , and observing
that real runs are quantum-computationally indistinguishable from runs
enforcing uniformly random outcomes, we obtain @xmath .

Finally, we get by transitivity that @xmath and conclude the proof by
observing that after our changes, the process producing @xmath is the
real protocol. This concludes the proof of enforceability against Bob,
according to Definition 9.3 with switched sides. @xmath

### Chapter 10 Applications

Coin-flipping as a stand-alone tool allows us to use it rather freely in
several contexts. Shared randomness is a crucial ingredient in many
cryptographic implementations. Applications in the
common-reference-string-model, that assumes a random public string
before communication, achieve great efficiency and composability, and
many protocols have been proposed in the model. In this chapter, we will
discuss example applications that rely on shared randomness. Two
applications relate to the context of zero-knowledge. First, we show a
simple transformation from non-interactive zero-knowledge to interactive
quantum zero-knowledge. This result appeared in [ DL09 ] . Then, we
propose a quantum-secure zero-knowledge proof of knowledge, which is
interesting also in that the construction relies not only on initial
randomness but also on enforceable randomness as discussed in Chapter 9
. This construction is part of the results in [ LN10 ] . Last, we
discuss the interactive generation of a common reference string for the
proposed lattice-based instantiation of the compiler construction,
proposed in Chapter 5 and applied in Chapter 6 . This result appeared in
[ DFL @xmath 09 ] and [ DL09 ] .

#### 10.1 Interactive Quantum Zero-Knowledge

Zero-knowledge proofs, as described in Section 2.4.5 , are an important
building block for larger cryptographic protocols, capturing the
definition of convincing the verifier of the validity of a statement
with no information beyond that.

##### 10.1.1 Motivation and Related Work

As in the classical case, where ZK protocols exist if one-way functions
exist, quantum zero-knowledge (QZK) is possible under the assumption
that quantum one-way functions exist. In [ Kob03 ] , Kobayashi showed
that a common reference string or shared entanglement is necessary for
non-interactive quantum zero-knowledge. Interactive quantum
zero-knowledge protocols in restricted settings were proposed by Watrous
in the honest-verifier setting [ Wat02 ] and by Damgård et al. in the
CRS-model [ DFS04 ] , where the latter introduced the first @xmath
-protocols for QZK withstanding even active quantum attacks. In [ Wat09
] , Watrous then proved that several interactive protocols are
zero-knowledge against general quantum attacks.

It has also been shown that any honest-verifier zero-knowledge protocol
can be made zero-knowledge against any classical and quantum verifier [
HKSZ08 ] . In more detail, they showed how to transform a @xmath
-protocol with stage-by-stage honest-verifier zero-knowledge into a new
@xmath -protocol that is zero-knowledge against all verifiers. Special
bit commitment schemes are proposed to limit the number of rounds, and
each round is viewed as a stage in which an honest-verifier simulator is
assumed. Then, by using a technique of [ DGW94 ] , each stage can be
converted to obtain zero-knowledge against any classical verifier.
Finally, Watrous’ quantum rewinding lemma is applied in each stage to
prove zero-knowledge also against any quantum verifier. We now show a
simple transformation from non-interactive (quantum) zero-knowledge to
interactive quantum zero-knowledge by combining the coin-flip protocol
with any non-interactive ZK protocol. Note that a non-interactive
zero-knowledge proof system can be trivially turned into an interactive
honest-verifier zero-knowledge proof system by just letting the verifier
choose the reference string, and therefore, this consequence of our
result also follows from [ HKSZ08 ] . However, our proof is much simpler
and the coin-flipping is not restricted to a specific zero-knowledge
construction. In addition, we obtain the corollary that if there exist
mixed commitments, then we can achieve interactive quantum
zero-knowledge against any poly-sized quantum adversary without any
set-up assumptions.

##### 10.1.2 Formal Definition of Zero-Knowledge Proofs

In Section 2.4.5 , we gave an intuitive introduction to zero-knowledge
proof systems. Here, we make this description formal. Recall that a
zero-knowledge proof for set @xmath on common input @xmath yields no
other knowledge than the validity of membership @xmath . An interactive
proof system must fulfill completeness and soundness, as given in
Definitions 10.1 and 10.2 , and is quantum zero-knowledge (IQZK), if in
addition Definition 10.3 holds. Note that in the following, we let
@xmath be the prover and let @xmath denote the verifier.

###### Definition 10.1 (Completeness)

If @xmath , the probability that @xmath rejects @xmath is negligible in
the length of @xmath .

###### Definition 10.2 (Soundness)

If @xmath , then for any unbounded prover @xmath , the probability that
@xmath accepts @xmath is negligible in the length of @xmath .

###### Definition 10.3 (Zero-Knowledge)

An interactive proof system @xmath for language @xmath is quantum
zero-knowledge, if for any quantum verifier @xmath , there exists a
simulator @xmath with output quantum-computationally indistinguishable
from the real output, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

on common input @xmath and arbitrary additional (quantum) input to
@xmath .

According to [ BFM88 ] , the interaction between prover and verifier can
be replaced by a common reference string. Then, there is only a single
message sent from prover to verifier, who makes the final decision
weather to accept or not. More precisely, both parties @xmath and @xmath
get common input @xmath . A common reference string @xmath of size
@xmath allows the prover @xmath , who knows a witness @xmath , to give a
non-interactive zero-knowledge proof @xmath to a (possibly quantum)
verifier, poly-time bounded in @xmath . For simplicity, we consider the
proof of a single theorem of size smaller than @xmath (and @xmath , i.e.
@xmath . The extension to a more general notion is rather
straightforward (see [ BFM88 ] for details).

Completeness and soundness hold as defined above, but we explicitly
state the definitions as given in [ BFM88 ] and adapted to our context.

###### Definition 10.4 (Completeness in NIZK)

There exists a constant @xmath such that for all @xmath , the acceptance
probability is overwhelming, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is negligible in @xmath (and @xmath ).

###### Definition 10.5 (Soundness in NIZK)

There exists a constant @xmath such that for all @xmath and for all
provers @xmath , the acceptance probability is negligible, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is negligible in @xmath (and @xmath ).

The non-interactive zero-knowledge requirement is simpler than for
general zero-knowledge for the following reason. Since all information
is communicated mono-directional from prover to verifier in the
protocol, the verifier does not influence the distribution in the real
world. Thus, in the ideal world, we require a simulator that only
outputs pairs that are (quantum) computationally indistinguishable from
the distribution of pairs @xmath in the real world, where @xmath is
generated with uniformly chosen @xmath and random @xmath . ¹ ¹ 1
Indistinguishability, in turn, implies that the proof construction
withstands quantum-computationally bounded verifiers. In other words, we
can eliminate the quantification over all @xmath in the zero-knowledge
definition.

###### Definition 10.6 (Non-Interactive Zero-Knowledge)

There exist a constant @xmath and a simulator @xmath with output
quantum-computationally indistinguishable from the real output, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath .

##### 10.1.3 The Transformation

We obtain a generic transformation of non-interactive zero-knowledge
into interactive quantum zero-knowledge as follows. In each invocation,
protocol @xmath generates a truly random @xmath even in the case of a
malicious quantum @xmath . A string of such coins, obtained by
sequential composition as described in Section 8.3.1 by the ideal
functionality in Figure 8.5 , is then used as reference string in any (
@xmath )-subprotocol with properties as defined previously.

The final protocol @xmath is shown in Figure 10.3 . To prove that it is
an interactive quantum zero-knowledge protocol, we first construct an
intermediate protocol @xmath (see Figure 10.1 ) that runs with the ideal
functionality @xmath . Then we prove that @xmath satisfies completeness,
soundness and zero-knowledge according to Definitions 10.1 - 10.3 . To
complete the proof, the calls to @xmath are replaced with actual
invocations of @xmath , and we arrive at @xmath .

###### Claim 10.1

Protocol @xmath satisfies completeness, according to Definition 10.1 .

Proof. From the ideal functionality @xmath it follows that @xmath is
uniformly random. Then by Definition 10.4 of any ( @xmath )-subprotocol,
we know that, for @xmath , @xmath accepts, except with negligible
probability (in the length of @xmath . Thus, completeness for the @xmath
follows. @xmath

###### Claim 10.2

Protocol @xmath satisfies soundness, according to Definition 10.2 .

Proof. Assume that @xmath . Any dishonest @xmath might stop @xmath at
any point during execution. For example, she can block the output in
Step ( 1 .) or she can refuse to send a proof @xmath in @xmath .
Furthermore, @xmath can use an invalid @xmath (or @xmath ) for @xmath .
In all of these cases, @xmath will abort without even checking the
proof.

Therefore, @xmath ’s best strategy is to “play the entire game”, i.e. to
execute @xmath without making obvious cheats. @xmath can only convince
@xmath in the @xmath -subprotocol of a @xmath for any given
(i.e. normally generated) @xmath with a probability that is negligible
in the length of @xmath (see Definition 10.5 ). Therefore, the
probability that @xmath can convince @xmath in the full @xmath in case
of @xmath is also negligible and its soundness follows. @xmath

###### Claim 10.3

Protocol @xmath is an interactive zero-knowledge proof, according to
Definition 10.3 .

Proof. We construct a simulator @xmath , interacting with dishonest
@xmath and a simulator @xmath . As given in Definition 10.6 , such a
simulator generates, on input @xmath , a randomly looking @xmath
together with a valid proof @xmath for @xmath (without knowing witness
@xmath ). @xmath , described in Figure 10.2 , receives a random string
@xmath from @xmath , which now replaces the coin-string @xmath produced
by @xmath in protocol @xmath . By assumption on @xmath , this is
quantum-computationally indistinguishable for @xmath . Thus, the
simulated proof @xmath is indistinguishable from a real proof, which
proves that the @xmath is zero-knowledge. @xmath

It would be natural to think that @xmath could be proven secure simply
by showing that @xmath implements some appropriate functionality and
then use a composition theorem from Section 3.6 . Recall, however, that
a zero-knowledge protocol—which is not necessarily a proof of
knowledge—cannot be modeled by a functionality in a natural way.
Instead, we prove the standard properties of a zero-knowledge proof
system explicitly and therewith the following Theorem 10.1 .

###### Theorem 10.1 (Interactive Quantum Zero-Knowledge)

Protocol @xmath is an interactive proof system, satisfying completeness
and soundness. Since, for any quantum verifier @xmath , there exists a
simulator @xmath with output quantum-computationally indistinguishable
from the real output, we additionally achieve quantum zero-knowledge.

Proof. From the analysis of protocol @xmath , its sequential
composability, and the indistinguishability from the ideal functionality
@xmath , it follows that if both players are honest @xmath is a random
common reference string of size @xmath and the acceptance probability of
the @xmath -subprotocol as given previously holds. Completeness of
@xmath follows.

To show soundness, we again only consider the case where @xmath executes
the entire protocol without making obvious cheats, since otherwise,
@xmath immediately aborts. Assume that @xmath could cheat in @xmath ,
i.e., @xmath would accept an invalid proof with non-negligible
probability. Then we could combine @xmath with simulator @xmath of
protocol @xmath (Figure 8.3 ) to show that @xmath was not sound. This,
however, is inconsistent with the previously given soundness argument in
the proof of Claim 10.2 , and thus proves by contradiction that @xmath
is sound.

To further prove that the interactive proof system is also quantum
zero-knowledge, we compose a simulator @xmath of simulator @xmath
(Figure 10.2 ) and simulator @xmath of protocol @xmath (Figure 8.4 ). In
more detail, @xmath gets classical input @xmath as well as quantum input
@xmath and @xmath . It then receives a valid proof @xmath and a random
string @xmath from @xmath . @xmath is split into @xmath . For each
@xmath , it will then invoke @xmath to simulate one coin-flip execution
with @xmath as result. In other words, whenever @xmath asks @xmath to
output a bit (Step ( 2 .), Figure 8.4 ), it instead receives this @xmath
. We see that the transcript of the simulation is indistinguishable from
the transcript of the protocol @xmath for any quantum-computationally
bounded @xmath . This concludes the proof. @xmath

We conclude this section by the corollary, immediately following from
the previous proof and stating that quantum-secure commitments, as
defined in Section 7.1 , imply interactive quantum zero-knowledge.

###### Corollary 10.1

If there exist quantum-secure commitment schemes, then we can obtain
interactive quantum zero-knowledge against any quantum adversary @xmath
without any set-up assumptions.

#### 10.2 Zero-Knowledge Proof of Knowledge

A zero-knowledge proof of knowledge is a special case of zero-knowledge
proof systems, introduced in Section 2.4.5 . Here, we propose a
quantum-secure construction based on witness encoding, which we define
in the context of simulation.

##### 10.2.1 Motivation and Related Work

Recall that the purpose of a zero-knowledge proof of knowledge is to
verify in classical poly-time in the length of the instance, whether
@xmath is a valid witness for instance @xmath in relation @xmath , i.e.
@xmath . We call @xmath an @xmath -relation, as the language @xmath is
seen to be an @xmath -language. Interestingly, such a zero-knowledge
proof of knowledge, in contrast to zero-knowledge proofs, can be modeled
by an ideal functionality.

Our protocol is based on a witness encoding scheme, providing a certain
degree of extractability and simulatability, defined in Section 10.2.2 .
We want to stress that the extractability requirement resembles special
soundness in proof systems, which are secure in the classical world and
typically come along with a knowledge error negligible in the length of
the challenge. We have to reformulate this aspect in stronger terms in
the quantum world, since special soundness seems to be impossible to use
in the quantum realm, due to the restrictions within rewinding. However,
we obtain a similar result also with knowledge error negligible in the
length of the challenge.

Furthermore, our construction requires a mixed bit commitment (see
Section 4.1 ) and two calls to the coin-flip protocol @xmath , described
in Figure 9.4 , Chapter 9 , which is poly-time simulatable for both
sides even against quantum adversaries. Since this protocol only assumes
mixed commitments as well, we get the corollary that if there exists a
mixed commitment scheme, then we can construct a classical
zero-knowledge proof of knowledge against any poly-sized quantum
adversary. This is of particular interest, as the problems of rewinding
in the quantum realm complicate implementing proofs of knowledge from
scratch.

As already mentioned in Chapter 8 , the unpublished approach of [ Smi09
] suggest another solution for this concept. Instead of composing the
coin-string from single coins, they use a string commitment with special
opening and compose the subsequent zero-knowledge proof. The coin-string
is used as key to encode the witness and the second zero-knowledge proof
is given to prove it.

##### 10.2.2 Simulatable Witness Encodings of @xmath

We first specify a simulatable encoding scheme for binary relation
@xmath , which consists of five classical poly-time algorithms @xmath .
Then, we define completeness, extractability and simulatability for such
a scheme in terms of the requirements of our zero-knowledge proof of
knowledge.

Let @xmath denote an encoder , such that for each @xmath , the @xmath
-bit output @xmath is a random encoding of @xmath , with randomness
@xmath and polynomials @xmath and @xmath . The corresponding decoder
@xmath takes as input an instance @xmath and an encoding @xmath and
outputs @xmath with @xmath .

Next, let @xmath denote a selector with input @xmath (with polynomial
@xmath ) specifying a challenge, and output @xmath defining a poly-sized
subset of @xmath corresponding to challenge @xmath . We will use @xmath
to select which bits of an encoding @xmath to reveal to the verifier.
For simplicity, we use @xmath to denote the collection of bits @xmath .

We denote with @xmath the judgment that checks a potential encoding
@xmath by inspecting only bits @xmath . In more detail, @xmath takes as
input instance @xmath , challenge @xmath and the @xmath bits @xmath ,
and outputs a judgment @xmath with @xmath .

Finally, the simulator is called @xmath . It takes as input instance
@xmath and challenge @xmath and outputs a random collection of bits
@xmath . Again for simplicity, we let @xmath . Then, if this set has the
same distribution as bits of an encoding @xmath in positions @xmath ,
the bits needed for the judgment to check an encoding @xmath can be
simulated given just instance @xmath (see Definition 10.9 ).

###### Definition 10.7 (Completeness)

If an encoding @xmath is generated correctly, then @xmath for all @xmath
.

We will call an encoding @xmath admissible for @xmath , if there exist
two distinct challenges @xmath for which @xmath and @xmath .

###### Definition 10.8 (Extractability)

If an encoding @xmath is admissible for @xmath , then @xmath .

We want to stress that extractability is similarly defined to the
special soundness property of a classical @xmath -protocol, which allows
to extract @xmath from two accepting conversations with different
challenges. Such a requirement would generally be inapplicable in the
quantum setting, as the usual rewinding technique is problematic and in
particular in the context here, we cannot measure two accepting
conversations during rewinding in the quantum world. Therefore, we
define the stronger requirement that if there exist two distinct
answerable challenges for one encoding @xmath , then @xmath can be
extracted given only @xmath . This condition works nicely in the quantum
world, since we can obtain @xmath without rewinding, as we will show in
our quantum-secure proof construction.

###### Definition 10.9 (Simulatability)

For all @xmath and all @xmath , the distribution of @xmath restricted to
positions @xmath is identical to the distribution of @xmath , i.e.,

  -- -------- --
     @xmath   
  -- -------- --

There are several commit&open proofs for @xmath . One can, for instance,
start from the commit&open protocol for circuit satisfiability, where
the bits of the randomized circuit committed to by the sender is easy to
see as a simulatable encoding of a witness being a consistent evaluation
of the circuit to output @xmath . The challenge in the protocol is one
bit @xmath and the prover replies by showing either the bits
corresponding to some positions @xmath or positions @xmath . The details
can be found in [ BCC88 ] . This gives us a simulatable witness encoding
for any @xmath -relation @xmath with @xmath , using a reduction from
@xmath to circuit simulatability. By repeating it @xmath times in
parallel we get a simulatable witness encoding for any @xmath . For
@xmath , compute an encoding @xmath of @xmath and let @xmath . Then for
@xmath , let @xmath specify that the bits @xmath should be shown in
@xmath and check these bits. Note, in particular, that if two distinct
@xmath and @xmath passes this judgment, then there exists @xmath such
that @xmath , so @xmath passes the judgment for both @xmath and @xmath ,
which by the properties of the protocol for circuit satisfiability
allows to compute a witness @xmath for @xmath from @xmath . One can find
@xmath from @xmath simply by trying to decode each @xmath for @xmath and
check if @xmath .

##### 10.2.3 The Protocol

We now construct a quantum-secure zero-knowledge proof of knowledge from
prover @xmath to verifier @xmath . Recall that we are interested in the
@xmath -language @xmath , where @xmath has input @xmath and @xmath , and
both @xmath and @xmath receive positive or negative judgment of the
validity of the proof as output. We assume in the following that on
input @xmath , honest @xmath aborts. The final protocol @xmath is
describe in Figure 10.5 .

As already mentioned, unlike zero-knowledge proofs, proofs of knowledge
can be modeled by an ideal functionality, given as @xmath in Figure 10.4
. @xmath can be thought of as a channel which only allows to send
messages in the language @xmath . It models zero-knowledge , as it only
leaks instance @xmath and judgment @xmath but not witness @xmath .
Furthermore, it models a proof of knowledge , since Alice has to know
and input a valid witness @xmath to obtain output @xmath .

Protocol @xmath is based on our fully simulatable coin-flip protocol
@xmath , which we analyze here in the hybrid model by invoking the ideal
functionality of sequential coin-flipping twice (but with different
output lengths). Note that in the hybrid model, a simulator can enforce
a particular outcome to hit also when invoking the ideal coin-flipping
functionality. We can then use Definition 9.3 to replace the ideal
functionality by the actual protocol @xmath .

One call to the ideal functionality @xmath with output length @xmath is
required to instantiate a mixed bit commitment scheme @xmath as
discussed in Section 7.3 . Recall that it is therewith possible to
sample an unconditionally binding key @xmath along with an extraction
key @xmath . Since such keys are quantum-computationally
indistinguishable from random values in @xmath , the latter serves us as
unconditionally hiding instantiations of @xmath . The second call to the
functionality @xmath produces @xmath -bit challenges for a simulatable
witness encoding scheme with @xmath as specified in the previous Section
10.2.2 .

###### Theorem 10.2 (Zero-Knowledge Proof of Knowledge)

For any simulatable witness encoding scheme @xmath , satisfying
completeness, extractability, and simulatability according to
Definitions 10.7 - 10.9 , and for negligible knowledge error @xmath ,
protocol @xmath is a zero-knowledge proof of knowledge and securely
implements @xmath .

Completeness is obvious. A honest party @xmath , following the protocol
with @xmath and any valid encoding @xmath , will be able to open all
commitments in the positions specified by any challenge @xmath . Honest
Bob then outputs @xmath .

Proof ( Security against dishonest Alice ). To prove security in case of
corrupted @xmath , we construct a simulator @xmath that simulates a run
of the actual protocol with @xmath and @xmath . The proof is then
twofold. First, we show indistinguishability between the distributions
of simulation and protocol. And second, we verify that the
extractability property of the underlying witness encoding scheme (see
Definition 10.8 ) implies a negligible knowledge error. Note that if
@xmath sends at any point during the protocol, @xmath sends some input
@xmath to @xmath to obtain output @xmath with @xmath , and the
simulation halts. Otherwise, the simulation proceeds as shown in Figure
10.6 .

Note that the only difference between the real protocol and the
simulation is that @xmath uses a random public key @xmath sampled along
with an extraction key @xmath , instead of a uniformly random @xmath .
It then enforces @xmath to hit @xmath . However, by assumption on the
commitment keys and by the properties of the ideal coin-flipping
functionality, the transcripts of simulation and protocol remain
quantum-computationally indistinguishable under these changes.

Next, we analyze the output in more detail. It is clear that whenever
honest @xmath would output in the actual protocol, also @xmath aborts,
namely, if @xmath does deviate in the last steps of protocol and
simulation, respectively. Furthermore, @xmath accepts if and only if
@xmath or in other words, the judgment of the functionality is positive,
denoted by @xmath .

It is therefore only left to prove that the case of @xmath but @xmath is
negligible, where the later denotes the judgment of algorithm @xmath as
in the protocol. In that case, we have @xmath . This means that @xmath
is not extractable from @xmath , which in turn implies that @xmath is
not admissible. Thus, there are no two distinct challenges @xmath and
@xmath , in which @xmath could correctly open her commitment to @xmath .
It follows by contradiction that there exists at most one challenge
@xmath which @xmath can answer. We produce @xmath uniformly at random,
from which we obtain an acceptance probability of at most @xmath . Thus,
we conclude the proof with negligible knowledge error, as desired.
@xmath

Proof ( Security against dishonest Bob ). To prove security in case of
corrupted @xmath , we construct simulator @xmath as shown in Figure 10.7
. Our aim is to verify that this simulation is quantum-computationally
indistinguishable from the real protocol. The key aspect will be the
simulatability guarantee of the underlying witness encoding scheme,
according to Definition 10.9 .

The proof proceeds via a hybrid argument. Let @xmath be the distribution
of the simulation as described in Figure 10.7 . Let @xmath be the
distribution obtained from the simulation but with the following change:
We inspect @xmath to get a valid witness @xmath for instance @xmath ,
and let @xmath be the corresponding encoding. Note that this is possible
as a thought experiment for any adjacent distribution in a hybrid
argument. From @xmath we then use bits @xmath for the same @xmath as
previously, instead of bits @xmath sampled by @xmath . All other steps
are simulated as before. By the simulatability of the encoding scheme
(Definition 10.9 ), it holds that the bits @xmath in @xmath and the bits
@xmath in @xmath have the same distribution. Thus, we obtain @xmath .

We further change the simulation in that we compute the bits in all
positions @xmath by @xmath of the encoding @xmath defined in the
previous step. Again, all other steps of the simulation remain
unchanged. Let @xmath denote the new distribution. The only difference
now is that for @xmath , the commitments @xmath are to the bits @xmath
of a valid @xmath and not to uniformly random bits @xmath . This,
however, is quantum-computationally indistinguishable to @xmath for
@xmath , as @xmath is quantum-computationally hiding towards @xmath .
Note that @xmath is guaranteed to be random by an honest call to @xmath
and recall that we do not have to open the commitments in these
positions. Hence, we get that @xmath .

Note that after the two changes, leading to distributions @xmath and
@xmath , the commitment step and its opening now proceed as in the
actual protocol, namely, we commit to the bits of @xmath and open the
subset corresponding to @xmath . The remaining difference to the real
protocol is the enforcement of challenge @xmath , whereas @xmath is
chosen randomly in the protocol. Now, let @xmath be the distribution of
the modified simulation, in which we implement this additional change of
invoking @xmath honestly and then open honestly to the resulting @xmath
. Note that both processes, i.e., first choosing a random @xmath and
then enforcing it from @xmath , or invoking @xmath honestly and
receiving a random @xmath , result in a uniformly random distribution on
the output of @xmath . Thus, we obtain @xmath .

By transitivity, we conclude that @xmath , and therewith, that the
simulation is quantum-computationally indistinguishable from the actual
protocol. @xmath

We conclude this section by the corollary that follows straightforward
from the above construction and proof and states that mixed commitments,
as defined in Section 7.3 , imply classical zero-knowledge proofs of
knowledge against any poly-sized quantum adversary.

###### Corollary 10.2

If there exist mixed commitment schemes, then we can construct a
classical zero-knowledge proof of knowledge against any quantum
adversary @xmath without any set-up assumptions.

#### 10.3 Generation of Commitment Keys

Here, we briefly describe the initial generation of a common reference
string for the proposed lattice-based instantiation of the generic
compiler, introduced in Chapter 5 , according to the specific
requirements of its underlying mixed commitment scheme, discussed in
Section 4.1 .

##### 10.3.1 Motivation

The compiler is constructed in the CRS-model to achieve high efficiency.
We now aim at circumventing the CRS-assumption to achieve the potential
of allowing the implementation of complete protocols in the quantum
world without any set-up assumptions. More specifically, we integrate
the generation of a common reference string from scratch based on our
quantum-secure coin-flipping, which will then be used during compilation
as commitment key. We want to stress, however, that implementing the
entire process comes at the cost of a non-constant round construction,
added to otherwise very efficient protocols under the CRS-assumption.

##### 10.3.2 The Generation

Recall that the argument for computational security in Section 5.2
proceeds along the following lines. After the preparation phase @xmath
commits to all his measurement bases and outcomes. The keyed dual-mode
commitment scheme has the special properties that the key can be
generated by one of two possible key-generation algorithms @xmath or
@xmath . Depending on the key in use, the scheme provides both flavors
of security. Namely, with key @xmath generated by @xmath , respectively
@xmath produced by @xmath , the commitment scheme is unconditionally
hiding respectively unconditionally binding. Furthermore, the commitment
is secure against a quantum adversary and it holds that @xmath . In the
real-world protocol, @xmath uses the unconditionally hiding key @xmath
to maintain unconditional security against any unbounded @xmath . To
argue security against a computationally bounded @xmath , an
information-theoretic argument involving the simulator @xmath is given
(in the proof of Theorem 5.1 ) to prove that @xmath cannot cheat with
the unconditionally binding key @xmath . Security in real life then
follows from the quantum-computational indistinguishability of @xmath
and @xmath .

We want to repeat that we can even weaken the assumption on the hiding
key in that we do in fact not require an actual unconditionally hiding
key, if the public-key encryption scheme guarantees that a random public
key looks pseudo-random to poly-time quantum circuits. As discussed in
Section 4.1 , the lattice-based crypto-system of Regev [ Reg05 ] , which
is considered to withstand quantum attacks, is a good candidate to
construct such a dual-mode commitment scheme. The public key of a
regular key pair can be used as the unconditionally binding key @xmath
in our commitment scheme for the ideal-world simulation, and for the
real protocol, an unconditionally hiding commitment key @xmath can
simply be constructed by uniformly choosing numbers in the same domain.

The idea is now the following. Let @xmath denote the length of a regular
key @xmath . We add (at least) @xmath executions of our protocol @xmath
as a first step to the compiler-construction to generate a uniformly
random sequence @xmath . These @xmath random bits produce a @xmath as
sampled by @xmath , except with negligible probability. Hence, in the
real world, Bob can use key @xmath for committing with @xmath on all
positions @xmath . Since an ideal-world adversary @xmath is free to
choose any key, it can generate @xmath , i.e., a regular public key
together with a secret key according to Regev’s crypto-system. For the
security proof, write @xmath . In the simulation, @xmath (as described
in the proof of Theorem 5.1 ) first invokes @xmath (Figure 8.4 ) for
each @xmath to simulate one coin-flip with @xmath as result. Whenever
@xmath asks @xmath to output a bit, it instead receives this @xmath .
Then @xmath has the possibility to decrypt dishonest @xmath ’s
commitments @xmath during simulation, which binds @xmath unconditionally
to his committed measurement bases and outcomes. Finally, since we
proved in the analysis of protocol @xmath that @xmath is a uniformly
random string, Regev’s proof of semantic security applies, namely that a
random public key, chosen independently from a secret key, is
indistinguishable to a regular key and that such encodings carry
essentially no information about the message. Thus, we obtain @xmath and
quantum-computational security in real life follows.