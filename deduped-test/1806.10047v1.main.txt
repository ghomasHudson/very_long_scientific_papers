# 1 Introduction

In [ 22 ] and [ 23 ] , Van Oosten shows how the Lifschitz realizability
topos can be viewed as a category of sheaves over a particular
Lawvere-Tierney topology constructed in the effective topos. Although a
remarkable result, it has some shortcomings:

1.  The construction refers explicitly to computable functions and
    Lifschitz’s encoding of finite sets. This makes it appear that the
    construction is unique to the effective topos and cannot be carried
    out in other toposes.

2.  The construction relies on many technical definitions and techniques
    from topos theory.

3.  The construction is not guaranteed to work predicatively.

In this paper we will give a new presentation of this result. Instead of
topos theory we work in the set theory @xmath , which is regarded as a
predicative theory for mathematics. Instead of Lawvere-Tierney
topologies, we will use formal topologies and a predicative notion of
topological model due to Gambino.

Aside from this difference in presentation, our results are more general
than Van Oosten’s in two ways (although the first of these does relate
to some more recent results by Lee and Van Oosten in [ 10 ] ).

Firstly, instead of considering just one formal topology, we will
consider an infinite family of formal topologies @xmath for each natural
number @xmath , with the original Lifschitz realizability model just
corresponding to the formal topology @xmath . The topologies @xmath
correspond to certain variants of @xmath , which were first studied by
Richman in [ 19 ] , and are denoted @xmath . We will use these models to
give a new proof of a theorem due to Hendtlass and Lubarsky in [ 9 ] :
@xmath is strictly weaker than @xmath . This answers positively a
question raised by Hendtlass: is there a variant of Lifschitz
realizability that separates @xmath from @xmath ?

Secondly, we identify axioms, @xmath that hold in the McCarty
realizability model @xmath that suffice to carry out internally the
construction of the formal topologies @xmath we will use in the models.
This can be done entirely in @xmath , without any explicit reference to
computable functions. This enables us to easily generate variants of
Lifschitz realizability by simply checking that the same axioms @xmath
hold in other realizability models. By using realizability with truth in
this way we will show that the theories @xmath have certain variants of
the numerical existence property. By using realizability over @xmath in
this way we will show that @xmath is consistent with certain (but not
all) Brouwerian continuity principles.

A more traditional version of Lifschitz realizability for @xmath similar
to that in [ 5 ] can be recovered by a two step process of interpreting
the topological model @xmath in the McCarty realizability model @xmath ,
itself constructed in @xmath as illustrated below.

  -- -------- --
     @xmath   
  -- -------- --

## 2 Constructive Set Theory

We will consider the intuitionistic set theories @xmath and @xmath , as
described for instance in [ 1 ] or [ 2 ] .

We will use the following set theoretic formulations of Markov’s
principle and Church’s thesis.

###### Definition 2.1.

Markov’s principle , @xmath , is the following axiom. Let @xmath be a
function. Then,

  -- -------- --
     @xmath   
  -- -------- --

###### Definition 2.2.

Church’s thesis , @xmath is the following axiom. Let @xmath be any
formula. Then, writing @xmath to mean the result of running the @xmath
th Turing machine with input @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

Church’s thesis for functions , @xmath is the axiom that every function
from @xmath to @xmath is computable.

We recall the following definitions and theorems on finite sets, as
appear in [ 2 , Chapters 6 and 8] . The theorems will often be used
implicitly while working with finitely enumerable sets.

###### Definition 2.3.

A set @xmath is finite if for some @xmath there exists a bijection from
@xmath to @xmath .

A set @xmath is finitely enumerable if for some @xmath there exists a
surjection from @xmath to @xmath .

###### Theorem 2.4 (@xmath).

Suppose that @xmath is a formula of arithmetic, where all quantifiers
are bounded, and the only free variables are amongst @xmath . Then we
can prove the following instance of excluded middle.

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

See [ 2 , Theorem 6.6.2] . ∎

###### Theorem 2.5 (@xmath).

“The Pigeonhole Principle for Finitely Enumerable Sets.” Let @xmath be a
finitely enumerable set. Every injective function @xmath is also a
surjection.

###### Proof.

See [ 2 , Theorem 8.2.10] . ∎

###### Theorem 2.6 (@xmath).

“The Finite Axiom of Choice.” Suppose @xmath is a finite set, @xmath is
any set, and @xmath is a relation such that @xmath .

Then there is a function @xmath such that for all @xmath , @xmath .

###### Proof.

See [ 2 , Theorem 8.2.8] . ∎

We can also prove a finite version of @xmath :

###### Theorem 2.7 (@xmath).

For every finitely enumerable set @xmath and every @xmath , either there
exists some @xmath such that @xmath or for all @xmath , @xmath .

###### Proof.

Show by induction on @xmath that if there is a surjection @xmath then
the result holds for @xmath . ∎

## 3 Formal Topologies and Heyting Valued Models of @xmath

### 3.1 Basic Definitions

We recall the basic definitions of formal topology and Gambino’s Heyting
valued interpretation of @xmath . For details see [ 8 ] . The basic idea
here is that to each formula in set theory, we assign an open set, which
we think of as the “truth value” of the formula. We use Gambino’s
presentation of topological models since it can be formalised in, and
provides models for @xmath .

###### Definition 3.1.

If @xmath is a poset, and @xmath is a subset of @xmath , we write @xmath
for the downwards closure of @xmath . That is,

  -- -------- --
     @xmath   
  -- -------- --

###### Definition 3.2.

A formal topology is @xmath such that @xmath is a poset, and @xmath is a
(class) relation between elements and subsets of @xmath , such that

1.  if @xmath , then @xmath

2.  if @xmath and @xmath , then @xmath

3.  if @xmath and @xmath , then @xmath

4.  if @xmath and @xmath , then @xmath

###### Definition 3.3.

Let @xmath be a formal topology. A set-presentation for @xmath is a
(set) function @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

If @xmath has a set-presentation, we say it is set-presentable .

###### Definition 3.4.

Let @xmath be a set presentable formal topology. We define the nucleus
of @xmath to be the following class function @xmath . For @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

We extend @xmath to an operation, @xmath , on subclasses of @xmath by

  -- -------- --
     @xmath   
  -- -------- --

###### Definition 3.5.

We say a formal topology @xmath is proper if for all @xmath , @xmath .
(Or equivalently if @xmath .)

###### Definition 3.6.

Let @xmath be a set presentable formal topology. The class @xmath is
defined inductively as the smallest class such that @xmath whenever
@xmath is a function with @xmath and for all @xmath , @xmath is a @xmath
-closed subset of @xmath .

For each sentence @xmath in the language of set theory with parameters
from @xmath , we assign a @xmath -closed class denoted @xmath , which we
define by induction on formulas as follows. For bounded @xmath , @xmath
will be a set.

We first define a complete Heyting algebra structure on the class of
@xmath -closed classes as follows. For @xmath and @xmath @xmath -closed
classes,

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

We define the interpretation of atomic sentences @xmath and @xmath by
simultaneous induction on @xmath and @xmath :

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

We then extend this to all formulas as below.

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

We write @xmath to mean @xmath . For a collection of formulas, @xmath ,
we write @xmath to mean @xmath for all @xmath .

###### Theorem 3.7 (Gambino).

Let @xmath be a set presentable formal topology. Then

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

See [ 8 ] . ∎

### 3.2 Some Absoluteness Lemmas

For some of the results later, it will be important that under certain
conditions statements that hold in the background universe also hold
internally in the topological model and vice versa. To this end, we
prove a series of absoluteness lemmas below.

First note that any set @xmath can be viewed as an element of @xmath ,
@xmath as follows.

  -- -------- -------- -------- --
     @xmath   @xmath            
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

###### Lemma 3.8.

In the below, let @xmath and @xmath be any formulas, possibly with
parameters from @xmath .

1.   We can prove in @xmath that for any set @xmath , @xmath holds for
    all @xmath in @xmath if and only if @xmath holds.

2.  @xmath if and only if @xmath .

3.  @xmath and @xmath if and only if @xmath .

4.   For proper formal topologies, @xmath .

5.   If @xmath then @xmath .

6.   If @xmath or @xmath then @xmath .

###### Proof.

For 1, 2 and 3 note that joins and implications in the Heyting algebra
on @xmath -closed classes are exactly the usual joins and implications
for the Heyting algebra of subsets of a set. 1, 2 and 3 follow by the
basic properties of Heyting algebras.

4 is just by unfolding definitions.

For 5, note that we have

  -- -------- --
     @xmath   
  -- -------- --

However, we also have

  -- -------- --
     @xmath   
  -- -------- --

Then 5 easily follows.

One can then prove 6 by a similar argument. ∎

###### Lemma 3.9.

Suppose that @xmath . Then @xmath . Suppose that @xmath . Then @xmath .

###### Proof.

Suppose that @xmath . Then we have

  -- -------- --
     @xmath   
  -- -------- --

However, @xmath is already @xmath -closed, so @xmath . But then it
easily follows that @xmath and so @xmath .

The other part can be proved by a similar argument. ∎

###### Lemma 3.10.

Let @xmath and @xmath be sets and let @xmath . Then,

  -- -------- -------- -- -----
     @xmath   @xmath      (1)
     @xmath   @xmath      (2)
  -- -------- -------- -- -----

###### Proof.

We first check ( 1 ). Unfolding definitions we have that both @xmath and
@xmath are equal to @xmath . It easily follows that ( 1 ) holds.

We now check ( 2 ). Unfolding definitions we have the following.

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

By monotonicity of @xmath and union we have @xmath . We now check @xmath
. By axiom 3 of the definition of formal topology, it suffices to check
that @xmath . Let @xmath . Then for some @xmath , we have @xmath . But
now @xmath by monotonicity of @xmath , as required. ∎

###### Lemma 3.11.

The natural numbers are absolute, in the following sense.

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

First note that @xmath but this is equal to @xmath by lemma 3.10 and the
fact that @xmath for every @xmath . We also easily have @xmath . But we
have now shown one half of the bi-implication:

  -- -------- --
     @xmath   
  -- -------- --

Now assume that for some @xmath , @xmath . Then using the soundness of
the laws of equality, we have @xmath . Hence @xmath . But we now apply
both parts of lemma 3.9 to deduce

  -- -------- --
     @xmath   
  -- -------- --

which is the other half of the bi-implication we require. ∎

###### Lemma 3.12.

Suppose that @xmath is a proper formal topology. Then equality and
membership are absolute for the natural numbers in the following sense.
For every @xmath , we have that either @xmath or @xmath , @xmath if and
only if @xmath , either @xmath or @xmath and @xmath if and only if
@xmath .

###### Proof.

These are proved simultaneously by induction on @xmath and @xmath . ∎

###### Lemma 3.13.

Finite tuples are absolute, in the following sense. We can show in
@xmath that for every set @xmath and every @xmath and every set @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

This can be proved by induction on @xmath . ∎

###### Lemma 3.14.

Let @xmath be a set. Then function application for @xmath is absolute,
in the sense that for @xmath , @xmath and @xmath , @xmath if and only if
@xmath .

###### Proof.

Note that the formula @xmath is equivalent to the following

  -- -------- --
     @xmath   
  -- -------- --

This is clearly absolute by the previous lemmas. ∎

###### Remark 3.15.

In [ 8 ] it is stated that all restricted formulas are absolute. This is
not provable in @xmath or @xmath , since the converses to parts 5 and 6
of lemma 3.8 do not hold in general and atomic formulas are not in
general absolute. The double negation formal topology provides a
counterexample, as do the formal topologies @xmath considered in this
paper. Also note that properness is necessary to show that @xmath is
absolute.

## 4 @xmath and @xmath

### 4.1 An Alternative Formulation of @xmath

We will first show how @xmath can be formulated in terms of the poset
@xmath defined below. This formulation will motivate the definition of
the formal topology as the simplest one making @xmath true in the
topological model (based on an observation of Van Oosten in [ 22 ] ).

###### Definition 4.1.

Let @xmath be the set of decreasing binary sequences, i.e.

  -- -------- --
     @xmath   
  -- -------- --

We will consider @xmath as a poset with the pointwise ordering, i.e.
@xmath if for all @xmath , @xmath .

###### Proposition 4.2.

If @xmath , then the join @xmath exists and is defined pointwise, i.e.
for @xmath

  -- -------- --
     @xmath   
  -- -------- --

Hence, if @xmath is a finitely enumerable subset of @xmath , then @xmath
exists and is defined pointwise.

The top element of @xmath is the function constantly equal to @xmath .
We’ll write this function as @xmath .

###### Lemma 4.3.

For all @xmath , we have @xmath .

###### Proof.

Suppose @xmath . For each @xmath , we have that @xmath is either @xmath
or @xmath . But if @xmath , then we would have @xmath , contradicting
@xmath . Hence @xmath for all @xmath , and so @xmath . ∎

###### Lemma 4.4.

Assume Markov’s principle. Suppose that @xmath is a finitely enumerable
set such that @xmath . Then for some @xmath , @xmath .

###### Proof.

Suppose @xmath . Then by Markov’s principle, there is some @xmath such
that @xmath . However, we now clearly have @xmath for some @xmath (since
@xmath is a finitely enumerable set of natural numbers), and hence
@xmath . ∎

###### Lemma 4.5.

Assume Markov’s principle. Suppose that @xmath is a finitely enumerable
set such that for each @xmath , @xmath . Then @xmath .

###### Proof.

Since @xmath is finitely enumerable, we can write @xmath . By Markov’s
principle we have for each @xmath , @xmath such that @xmath . Take
@xmath . Then we have that @xmath and therefore @xmath . ∎

Recall that @xmath is usually formulated as below.

###### Definition 4.6.

The lesser limited principle of omniscience ( @xmath ) is the following
axiom. Let @xmath be a binary sequence such that for all @xmath , if
@xmath then @xmath . Then either for all @xmath , @xmath , or for all
@xmath @xmath .

We now obtain the equivalent presentations of @xmath below.

###### Proposition 4.7.

The following are equivalent:

1.  @xmath

2.   for all @xmath , if @xmath , then @xmath or @xmath

3.   for all inhabited finitely enumerable sets @xmath , if @xmath ,
    then there exists @xmath such that @xmath

###### Proof.

To show @xmath , let @xmath be such that @xmath . Then define @xmath as
below.

  -- -------- --
     @xmath   
  -- -------- --

Then by applying @xmath to @xmath , we can show either @xmath or @xmath
.

Now to show @xmath , let @xmath be such that for all @xmath if @xmath ,
then @xmath . Define @xmath and @xmath as follows.

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

Then one can easily check that @xmath , and if @xmath then @xmath for
all @xmath , and if @xmath then @xmath for all @xmath .

Finally note that @xmath is a special case of @xmath , and that @xmath
follows from @xmath by showing by induction on @xmath that the result
holds for all @xmath that admit a surjection @xmath . ∎

### 4.2 Generalising to @xmath

In [ 19 ] , Richman considered for each @xmath a variant of @xmath ,
that he denoted @xmath . These axioms were also studied by Hendtlass and
Lubarsky, who showed (amongst other results) that @xmath is strictly
weaker than @xmath . In this section we show that like @xmath , @xmath
can also be formulated using @xmath .

###### Definition 4.8.

Let @xmath . @xmath is the following statement: Let @xmath be a binary
sequence such that for all @xmath , @xmath implies @xmath . Then there
is some @xmath with @xmath such that for all @xmath , @xmath .

###### Remark 4.9.

In [ 3 ] Akama, Hayashi, Berardi and Kohlenbach studied a separate
hierarchy of variants of @xmath , denoted @xmath . They show (amongst
other results) that for each @xmath , @xmath is strictly stronger than
@xmath . Another variant of Lifschitz realizability (relativised to
@xmath functions) was used for one of their separation results.

We now give the equivalent formulation using @xmath .

###### Proposition 4.10.

Let @xmath . The following are equivalent:

1.  @xmath

2.   Let @xmath be such that for all @xmath with @xmath , @xmath . Then
    there exists @xmath such that @xmath .

###### Proof.

Similar to the proof of proposition 4.7 . ∎

We now aim towards another characterisation of @xmath analogous to part
3 of proposition 4.7 that will be useful later.

###### Definition 4.11.

For each @xmath , we define the set of @xmath -trees by the following
recursive definition.

1.  There is an @xmath -tree @xmath .

2.  If we have a list of @xmath -trees @xmath and a list of decreasing
    sequences @xmath , then @xmath is an @xmath -tree.

###### Definition 4.12.

An @xmath -tree is defined to be good according to the following
recursive definition.

1.  @xmath is good.

2.  @xmath is good if for any @xmath , @xmath , and for any @xmath , if
    @xmath then @xmath is good.

###### Definition 4.13.

An @xmath -tree is defined to be very good according to the following
inductive definition.

1.  @xmath is very good.

2.  @xmath is very good if it is good, and for some @xmath , @xmath and
    @xmath is very good.

###### Theorem 4.14.

@xmath is equivalent to the statement that every good @xmath -tree is
very good.

###### Proof.

We first assume that every good @xmath -tree is very good and deduce
@xmath . Let @xmath be such that for any @xmath , @xmath . Then note
that we can form a good @xmath -tree @xmath . If @xmath is very good,
then for some @xmath , @xmath , as required.

For the converse, we assume @xmath and prove by induction that for every
@xmath -tree, @xmath , if @xmath is good then @xmath is very good.

For @xmath , this is clear.

For @xmath , assume that @xmath is good. Then for @xmath we have @xmath
. Hence, for some @xmath , @xmath by @xmath . Since @xmath is good and
@xmath , we have that @xmath is good. But by induction we may assume now
that @xmath is very good. Hence, @xmath is also very good. ∎

###### Definition 4.15.

@xmath is the following statement. Let @xmath be a surjective pairing
function, and let @xmath be a binary sequence such that @xmath for at
most one @xmath . Then for some @xmath , and for all @xmath @xmath .

###### Proposition 4.16.

@xmath is equivalent to the following statement. Let @xmath be such that
@xmath for each @xmath . Suppose further that for @xmath , @xmath . Then
for some @xmath , @xmath .

### 4.3 Absoluteness Results for @xmath-Trees

We next show how to encode @xmath -trees as functions @xmath .

###### Definition 4.17.

Let @xmath be an @xmath -tree. We define the shape of @xmath , @xmath as
follows. Assume that we have a standard way of encoding lists of natural
numbers as natural numbers such that encoding and decoding can be done
in a primitive recursive manner and the code for a list is greater than
each of its elements, and write this using brackets @xmath .

1.  @xmath is defined to be @xmath .

2.  @xmath is defined to be @xmath .

We define the data for @xmath , @xmath as follows.

1.  @xmath for all @xmath .

2.  We define @xmath as follows. For any @xmath , @xmath can be written
    uniquely as either @xmath or @xmath where @xmath . We define

      -- -------- -------- --
         @xmath   @xmath   
         @xmath   @xmath   
      -- -------- -------- --

###### Lemma 4.18.

There are primitive recursive functions @xmath , @xmath , @xmath ,
@xmath and @xmath such that an @xmath -tree @xmath is good if and only
if

  -- -------- -- -----
     @xmath      (3)
  -- -------- -- -----

###### Proof.

We define @xmath to be @xmath . We can then take @xmath to be anything
(e.g. constantly equal to @xmath ).

We now deal with the case @xmath . We define

  -- -------- --
     @xmath   
  -- -------- --

Now given @xmath we have one of the following two cases (and we can
decide which in a primitive recursive manner).

1.  For some (unique) @xmath and @xmath , @xmath .

2.  For some @xmath and @xmath , @xmath , and this is unique when we
    require furthermore that @xmath is the greatest such value.

For case 1, we take @xmath . The value of @xmath now makes no
difference, so we take it to be constantly @xmath . Now write @xmath for
@xmath if @xmath and @xmath if @xmath (so that in any case we have
@xmath and @xmath ). We define

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

(This corresponds to ensuring that @xmath )

For case 2, we define @xmath . Let @xmath and @xmath be as in the
description of case 2. We split into cases on whether or not @xmath . If
@xmath , then define

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

If @xmath , then define

  -- -------- --
     @xmath   
  -- -------- --

In either case, we define

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

(This corresponds to ensuring that if @xmath for all @xmath then @xmath
is good.) ∎

###### Theorem 4.19.

Let @xmath . Then the statement “ @xmath is the code of a good tree” is
absolute in @xmath , for any proper formal topology @xmath .

###### Proof.

Note that if @xmath is a primitive recursive function, then the formula
@xmath is equivalent to one built from bounded universal quantifiers,
conjunctions, @xmath and implication, and hence is absolute. Note that
formula ( 3 ) is built from formulas of this form together with function
application, bounded universal quantification implication and negation.
Hence it is absolute. We showed in lemma 4.18 that the statement that
@xmath codes a good tree is equivalent to this formula and so that is
also absolute. ∎

###### Lemma 4.20.

There are primitive recursive functions @xmath and @xmath such that for
any @xmath -tree @xmath , @xmath is very good if and only if there is
@xmath such that for all @xmath @xmath . Furthermore, assuming Markov’s
principle, if for all @xmath , there exists @xmath such that @xmath ,
then @xmath is not good.

###### Proof.

For @xmath we define @xmath to be @xmath , so we can take @xmath to be
anything.

For @xmath , we define

  -- -------- --
     @xmath   
  -- -------- --

Then, note that for @xmath , @xmath can be written as

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath and this is unique if we require the greatest
such @xmath .

Then splitting into cases depending on whether the input to @xmath is
odd or even, we define

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

∎

###### Corollary 4.21 (@xmath).

For any @xmath -tree @xmath , and any list of @xmath -trees @xmath , we
have

1.   If @xmath is good, then the double negation of “ @xmath is very
    good” is true.

2.   Suppose the following statement is false: @xmath is very good for
    every @xmath . Then for some @xmath , @xmath is not good.

###### Proof.

Note that part 1 follows directly from lemma 4.20 .

We now show part 2.

Suppose that it is false that @xmath is very good for every @xmath . We
define a finite sequence @xmath using @xmath from lemma 4.20 by,

  -- -------- --
     @xmath   
  -- -------- --

Note that we cannot have @xmath for all @xmath , since then each @xmath
would be very good. Hence by Markov’s principle, there is some @xmath
such that @xmath . We then define @xmath by

  -- -------- --
     @xmath   
  -- -------- --

Then, repeating the same argument as before, we find @xmath such that
@xmath . We continue this process until reach @xmath such that @xmath .
At this point, we have found @xmath such that @xmath for every @xmath
and hence can apply lemma 4.20 to show that @xmath is not good. ∎

## 5 Some Special Cases of Independence of Premisses

In this section we define a family of variants of independence of
premisses ( @xmath ). The motivation for this it that it allows us to
easily state some special cases of @xmath that hold in certain
realizability models and are needed to construct the formal topologies
we will use later.

###### Definition 5.1.

Let @xmath be a formula with only @xmath and @xmath free variables and
@xmath a formula with only @xmath as a free variable. We will think of
@xmath as a class, and write @xmath to mean @xmath . We think of @xmath
as a class of pairs and write @xmath to mean @xmath .

Write @xmath for the following axiom schema. For any formula @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

###### Lemma 5.2.

Let @xmath and @xmath be definable sets. By viewing them as classes in
the usual way, we can define @xmath and @xmath . If there are (provably
and definably) functions @xmath and @xmath such that @xmath , then
@xmath implies @xmath .

###### Proof.

We want to show

  -- -------- --
     @xmath   
  -- -------- --

So assume that @xmath and @xmath . Note that we can define a formula
@xmath equivalent to @xmath and show

  -- -------- --
     @xmath   
  -- -------- --

This is because for every @xmath , we have some @xmath such that @xmath
, but we can then take @xmath to be @xmath . Then since @xmath , we have
@xmath .

Now applying @xmath , we have

  -- -------- --
     @xmath   
  -- -------- --

Taking @xmath to be @xmath , we have

  -- -------- --
     @xmath   
  -- -------- --

But we have now proved @xmath , as required. ∎

### 5.1 The Schema @xmath

We now come to the special cases, @xmath , of @xmath that we will need
to construct the formal topologies later.

###### Definition 5.3.

Let @xmath . Define @xmath to be the class of pairs @xmath where @xmath
is of the form @xmath where @xmath such that for any @xmath , @xmath and
@xmath .

Then viewing @xmath as a class, we define @xmath according to definition
5.1 .

It is important to note that @xmath implies several variants, that will
also be used throughout this paper. Where it is clear from context, we
will write that we invoke @xmath when we actually mean one of the
variants listed below.

###### Proposition 5.4.

@xmath implies @xmath , @xmath , @xmath and @xmath where we write @xmath
for the set of finite lists of elements of @xmath and @xmath to mean the
set of @xmath -trees.

###### Proof.

One can easily define suitable functions to apply lemma 5.2 . For @xmath
-trees we use the “shape and data” encoding from definition 4.17 . ∎

###### Lemma 5.5.

@xmath implies @xmath for any @xmath (and in particular @xmath implies
@xmath ).

###### Proof.

Suppose that @xmath where @xmath for @xmath and such that for all @xmath
there exists @xmath such that @xmath .

By @xmath , we know that @xmath for some @xmath . However, this implies
that @xmath , so there must exist @xmath such that @xmath . Note that we
trivially have that @xmath implies @xmath , and so we have now proved
this instance of @xmath . ∎

### 5.2 @xmath in @xmath

We now check that @xmath actually holds in the most basic realizability
model for set theory, @xmath , developed by McCarty in [ 13 ] . The
proof uses a key idea that is already implicit in Lifschitz’s original
presentation of Lifschitz realizability [ 11 ] and also appears the
newer versions by Van Oosten [ 21 ] .

###### Lemma 5.6 (@xmath).

@xmath holds in @xmath . In fact, a more general version holds. Let
@xmath be the class of pairs @xmath with @xmath any subset of @xmath and
@xmath (writing @xmath for the function constantly equal to @xmath ).
Then @xmath holds in @xmath .

###### Proof.

Note firstly that we can show in @xmath that for any @xmath , @xmath
implies @xmath . Hence, we can replace @xmath by @xmath .

We are given @xmath such that

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

and need to construct computably @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

Note that for any formula @xmath , we have @xmath for some @xmath if and
only if @xmath for every @xmath . Hence, if @xmath for some @xmath ,
then @xmath .

Now let @xmath . Note that @xmath is a code for a total computable
function. We define a new computable function as follows. Given input
@xmath , in parallel, run the following two algorithms.

#### First algorithm:

For each @xmath in turn, evaluate @xmath . If @xmath , then halt and
return @xmath . Otherwise, continue running.

#### Second algorithm:

Try to evaluate @xmath . If this is successful, then try to evaluate
@xmath . If this is successful, then halt and return @xmath .

####

Let @xmath . Suppose that neither of these algorithms halts. Then in
particular, for all @xmath , @xmath . However, we would then have @xmath
and so @xmath must be defined, with @xmath a total computable function.
This implies that the second algorithm halts successfully, giving a
contradiction. Hence by @xmath one of the algorithms must halt, and so
we get a total computable function. Note that we did this uniformly in
@xmath , so in fact we have @xmath such that for each @xmath , @xmath
denotes and is a total computable function defined as above.

Now define @xmath such that for every @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

Note first that for any @xmath , @xmath , since @xmath and for any term
@xmath , @xmath denotes (even if @xmath does not). Furthermore, as shown
above, @xmath is always a total computable function. In particular, we
have @xmath , where @xmath is the function in @xmath represented by
@xmath , and @xmath is the standard implementation of @xmath in @xmath .

Now suppose that for some @xmath , @xmath . In particular, this implies
that for every @xmath , @xmath . Then the first algorithm above never
halts. Hence we must have that for every @xmath , @xmath , and so @xmath
. But, we also have @xmath . Therefore we have established that

  -- -------- --
     @xmath   
  -- -------- --

and so

  -- -------- --
     @xmath   
  -- -------- --

as required. Finally, note that we constructed @xmath uniformly in
@xmath , so we do indeed have a realizer for the implication

  -- -------- --
     @xmath   
  -- -------- --

∎

### 5.3 @xmath in Realizability with Truth

We now do the same thing for realizability with truth. For this to work
we this time need to assume that @xmath holds already in the background
universe (which was not needed for @xmath ).

###### Lemma 5.7 (@xmath).

@xmath holds in the realizability with truth model @xmath studied in [
16 ] .

###### Proof.

Let @xmath be the realizability with truth model from [ 16 ] . We will
construct, for each instance @xmath of @xmath a closed application term
@xmath such that @xmath .

Recall from the proof of lemma 5.6 , that each instance of @xmath is
equivalent to a formula of the following form.

  -- -------- -- -----
     @xmath      (4)
  -- -------- -- -----

Finding a realizer for this formula amounts to

1.  Showing that the implication is true

2.  Constructing @xmath such that whenever

      -- -------- -- -----
         @xmath      (5)
      -- -------- -- -----

    @xmath is defined, and

      -- -------- -- -----
         @xmath      (6)
      -- -------- -- -----

To show 1, we simply apply @xmath in the background.

For 2, let @xmath be as in ( 5 ). We need to construct a realizer as in
( 6 ). Since the formula is of the form @xmath , we need to show @xmath
and construct @xmath such that for any @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

For the truth part, we once again apply @xmath in the background. For
the realizability part, we follow the same proof as for lemma 5.6 to
construct a total computable function @xmath .

Finally, we need to construct a realizer for

  -- -------- --
     @xmath   
  -- -------- --

Since, this is an implication, it once again consists of both a
realizability part and a truth part. However, by [ 16 , Lemma 5.10] we
have that if @xmath is true, then @xmath . Hence, we can apply the proof
used in lemma 5.6 for both parts, and therefore the same realizer
constructed there still works for this case. ∎

###### Theorem 5.8.

Let @xmath be one of the theories @xmath , @xmath , @xmath , @xmath .
Then @xmath has the numerical existence property and is closed under
Church’s rule.

###### Proof.

Using lemma 5.7 , the proof of [ 16 , Theorem 1.2] now applies here. ∎

### 5.4 @xmath in Function Realizability Models

We now check that the same axioms, @xmath , also hold in function
realizability models.

###### Lemma 5.9 (@xmath).

There is @xmath such that the following holds. Suppose that @xmath is
such that for all @xmath if @xmath for all @xmath , then @xmath . Then,

1.  @xmath .

2.   For all @xmath , @xmath .

3.   If @xmath for all @xmath , then ( @xmath by assumption and) @xmath
    .

###### Proof.

We define @xmath so that for each @xmath , @xmath is as follows.

  -- -------- --
     @xmath   
  -- -------- --

Note that there is such an @xmath since this is clearly continuous in
@xmath and any continuous function is representable in @xmath . Also,
note that by unfolding the definition of application in @xmath and
applying @xmath one can show that @xmath is as required. ∎

###### Lemma 5.10 (@xmath).

Let @xmath be the function realizability model from [ 15 ] . Let @xmath
be the class of pairs @xmath with @xmath any subset of @xmath and @xmath
(writing @xmath for the function constantly equal to @xmath ). Then
@xmath (and hence also @xmath for each @xmath ) holds in @xmath .

###### Proof.

One can easily use lemma 5.9 to adapt the proof of lemma 5.6 to work
over @xmath . ∎

## 6 The Topological Models @xmath

We now define the topological models.

In this section, we will assume a fixed @xmath throughout, and refer to
@xmath -trees simply as trees.

### 6.1 Definition of @xmath

In this section we define the formal topologies that we will use for the
topological models and check that they are in fact formal topologies.
The basic idea is to use the formulation of @xmath in terms of trees to
produce the simplest formal topology where @xmath holds in the
respective topological model, even when it does not hold in the
background universe. This is based on the observation of Van Oosten in [
22 ] that the Lifschitz realizability topos is the largest subtopos of
the effective topos where an axiom equivalent to @xmath in the presence
of Church’s thesis holds.

###### Definition 6.1.

Let @xmath be a tree. Then we define the cover from @xmath , @xmath ,
inductively as follows.

1.  @xmath

2.  @xmath

###### Lemma 6.2.

Let @xmath be a good tree. Then @xmath if and only if @xmath is very
good.

###### Proof.

We show this by induction on trees.

For @xmath , we have both @xmath and @xmath is very good, so the result
is clear.

Now suppose that @xmath . If @xmath is very good then for some @xmath ,
@xmath and @xmath is very good. However, if @xmath is very good, then
@xmath by the induction hypothesis, and so, we have @xmath . We have
shown that if @xmath is very good then @xmath . Now suppose that @xmath
. Then for some @xmath , @xmath and @xmath . The latter implies @xmath
is very good by the induction hypothesis, and so by the former @xmath is
very good, as required. ∎

###### Proposition 6.3 (@xmath).

Let @xmath be a good tree. Then we have @xmath .

###### Proof.

Suppose that @xmath is a good tree and that @xmath . Since @xmath , we
have by lemma 6.2 that @xmath is not very good. Then by corollary 4.21
we have that @xmath is not good, giving us a contradiction. Hence we
have @xmath as required. ∎

###### Definition 6.4.

Let @xmath be the poset with @xmath . Define the relation @xmath as
follows. @xmath precisely if @xmath for some good tree, @xmath . Write
@xmath for the tuple @xmath (we will show that this is a formal
topology).

###### Lemma 6.5 (@xmath).

@xmath satisfies axioms 1, 2 and 4 in the definition of formal topology.

###### Proof.

1 and 2 are clear. It remains to prove 4, that is, that whenever @xmath
and @xmath , we have @xmath .

Fix a good tree, @xmath . We will show by induction that for any tree
@xmath , there is a tree @xmath such that @xmath , and that if @xmath is
good then @xmath is also good.

For @xmath , we just take @xmath to be @xmath .

Now suppose that @xmath . Then we have for each @xmath , a tree @xmath
such that @xmath and @xmath is good if @xmath is good. Define @xmath to
be the tree @xmath . Suppose that @xmath . Then for some @xmath we must
have @xmath and @xmath . Since @xmath , we also have @xmath and @xmath .
But, now recalling that @xmath , the former implies @xmath . Hence,
@xmath .

Now suppose that @xmath is good. Then we have that for any @xmath ,
@xmath . Also, for any @xmath , if @xmath , then @xmath is good. But
this then implies that @xmath is good. Hence @xmath is also good.

We can now easily deduce axiom 4. ∎

###### Theorem 6.6 (@xmath).

@xmath is a formal topology.

###### Proof.

We have already shown in lemma 6.5 that axioms 1, 2 and 4 hold. It
remains to show that axiom 3 holds. That is, whenever @xmath and @xmath
, we have @xmath .

Fix @xmath . We show the following by induction on trees. Let @xmath be
a tree. Suppose that @xmath is good and whenever @xmath we have @xmath .
Then there is a good tree @xmath such that @xmath .

First assume @xmath . Then @xmath , and so we have @xmath . Let @xmath
be any good tree such that @xmath .

Now assume that @xmath . Assume that @xmath is good and whenever @xmath
we have @xmath . Since @xmath is good, we have that for any @xmath ,
@xmath . Let @xmath be such that @xmath . Then @xmath is good, and
@xmath . The latter implies that whenever @xmath we have @xmath and so
we may apply the induction hypothesis, to show there exists @xmath such
that @xmath .

However, we can now apply @xmath to find for each @xmath , a tree @xmath
such that if @xmath then @xmath is good and @xmath . Define @xmath to be
@xmath . Then whenever @xmath is such that @xmath , we have that @xmath
is good, and so @xmath must be good. Suppose that @xmath . Then for some
@xmath we have @xmath and @xmath . Hence also @xmath . But we have now
shown @xmath as required. ∎

### 6.2 Some Basic Properties of @xmath and @xmath

###### Lemma 6.7 (@xmath).

If @xmath is true, then we have

1.  @xmath is isomorphic to the class of all sets, @xmath .

2.  @xmath if and only if @xmath is true.

###### Proof.

By @xmath , we know that every good @xmath -tree is very good. Hence, in
this case @xmath reduces to the trivial formal topology, where for every
@xmath , @xmath if and only if @xmath . The result clearly follows. ∎

###### Lemma 6.8 (@xmath).

For each @xmath , let @xmath be a subset of @xmath . Suppose that @xmath
. Then there is some finite set @xmath such that @xmath . (That is,
@xmath is countably compact .)

###### Proof.

We show by induction on trees, that for every tree @xmath , if @xmath is
good and @xmath then there exists a finite set @xmath and another good
tree @xmath such that @xmath .

For @xmath , we have @xmath and so for some @xmath , @xmath . Hence we
can just take @xmath and @xmath .

Now suppose @xmath . Note that if @xmath is such that @xmath , then
@xmath is good and @xmath . So by the induction hypothesis, there is a
finite set @xmath and a good tree @xmath such that @xmath . Hence we can
apply @xmath to find for each @xmath , a finite set @xmath and a tree
@xmath such that if @xmath then @xmath is good and @xmath . We then take
@xmath and @xmath and note these are as required. ∎

###### Lemma 6.9 (@xmath).

Suppose that @xmath . Then there is some finite @xmath such that @xmath
.

###### Proof.

Apply lemma 6.8 with @xmath for @xmath . ∎

The following lemma will be key to showing later that certain choice
axioms and existence properties hold. It appears to be related to the
constructions developed by Lee and Van Oosten in [ 10 , Sections 4 and
5] . We will return to this point in section 8.1 .

###### Lemma 6.10 (@xmath).

Let @xmath and for each @xmath , let @xmath be a subset of @xmath .
Suppose that @xmath (relative to @xmath ). Suppose further that for
every @xmath such that @xmath is finite and @xmath we have @xmath .

Then for some @xmath there exists a good @xmath -tree, @xmath such that
@xmath (where @xmath means round up @xmath to the next integer).

###### Proof.

We show by induction on trees that for every @xmath -tree, @xmath , if
@xmath is good and @xmath , then there exists @xmath and an @xmath -tree
@xmath such that @xmath .

For @xmath , we have @xmath . Hence for some @xmath we in fact have
@xmath . We can then take @xmath to be @xmath .

Now suppose that @xmath .

Suppose that @xmath . Then @xmath is good and @xmath . So there exist
@xmath and @xmath a good @xmath -tree such that @xmath .

Hence we can apply @xmath to find for each @xmath , @xmath and an @xmath
-tree @xmath such that if @xmath then @xmath is good and @xmath .

Now suppose that @xmath . Let @xmath be such that @xmath (which exists
by finite choice and decidability of equality for @xmath ). By
assumption, @xmath . Suppose that for all @xmath , @xmath . Then we
would have that each @xmath is good but @xmath , giving a contradiction
by corollary 4.21 and lemma 6.2 . Hence by lemma 4.4 , for some @xmath ,
@xmath . Let @xmath . Since @xmath , we vacuously have @xmath implies
that @xmath . Hence we may “replace” @xmath with @xmath .

By repeating the above argument we may assume without loss of generality
that in fact

  -- -------- --
     @xmath   
  -- -------- --

Write @xmath for the set @xmath .

Now note that we have

  -- -------- --
     @xmath   
  -- -------- --

Note that if @xmath is such that @xmath , then @xmath . To show this,
see that we can find @xmath with @xmath such that @xmath by Euclid’s
algorithm. We can then split into cases depending on whether or not
@xmath , by decidability of equality for @xmath . If @xmath , then
@xmath . If @xmath , then @xmath . So in either case @xmath .

Hence, if we had @xmath for all @xmath , this would imply @xmath ,
giving a contradiction. Hence, for some @xmath we must have @xmath .
Choose such a @xmath , and @xmath with @xmath and an enumeration of
@xmath . Then let @xmath be the @xmath -tree @xmath . Since @xmath is
good and @xmath is good when @xmath , @xmath must also be good. Now
suppose @xmath . This implies that for some @xmath , @xmath and @xmath .
But then also @xmath . So @xmath as required. ∎

###### Remark 6.11.

Note that in the above lemma we do not have @xmath relative to @xmath ,
because we require a good @xmath -tree @xmath , such that @xmath , but
have only a good @xmath -tree. We do however have @xmath .

###### Lemma 6.12 (@xmath).

Suppose that for each @xmath , @xmath is a subset of @xmath such that
@xmath and that for all @xmath we have @xmath . Then for some
(necessarily unique) @xmath we have @xmath .

###### Proof.

This is a special case of lemma 6.10 with @xmath . ∎

###### Lemma 6.13 (@xmath).

Suppose that @xmath . Then for some @xmath , @xmath .

###### Proof.

We define @xmath as follows. Let @xmath . For each @xmath , set @xmath .
Note that for @xmath , we have @xmath , so we can apply lemma 6.12 to
find @xmath such that @xmath . We take @xmath to be this @xmath .

Note that by construction we have @xmath , and so @xmath . ∎

###### Lemma 6.14 (@xmath).

Suppose that @xmath . Then for some @xmath , @xmath .

###### Proof.

First note that by lemma 6.13 we can show that @xmath is absolute, in
the sense that in @xmath we can show that @xmath is the set of functions
@xmath . However, we can now apply the same proof as in lemma 6.13 to
get the result. ∎

###### Lemma 6.15 (@xmath).

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Suppose that @xmath is such that @xmath . Then by lemma 6.13 there is
@xmath such that @xmath . Note that @xmath is equivalent to @xmath and
so is absolute. Hence we can apply @xmath in the background to find
@xmath such that @xmath . But then @xmath . Therefore @xmath holds in
@xmath . ∎

### 6.3 @xmath in @xmath

The motivation for the definition of @xmath was to try to write down the
simplest topology where @xmath holds in the topological model. We now
check that in fact it really is the case that @xmath holds in @xmath .
Note that we don’t need to assume @xmath holds in the background for
this to work, although we did need @xmath , even just to construct the
topological model.

###### Lemma 6.16 (@xmath).

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Suppose that @xmath is such that internally in @xmath , @xmath is a
function @xmath such that @xmath for at most one @xmath . Then by lemma
6.13 there must be some (unique) @xmath such that @xmath . Then by lemma
3.8 we must have that also @xmath for at most one @xmath . We now define
a tree by setting for @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

and then define

  -- -------- --
     @xmath   
  -- -------- --

We clearly have that @xmath is a good tree and by lemma 3.8 we know

  -- -------- --
     @xmath   
  -- -------- --

Hence

  -- -------- --
     @xmath   
  -- -------- --

But we now have that @xmath as required. ∎

### 6.4 Bounded Existential Formulas and Countable Choice in @xmath

Although countable choice fails in each @xmath , there are weaker
variants that we define below that do hold. To formulate them, we first
define some notation for certain bounded existential formulas.

###### Definition 6.17.

Let @xmath be a formula. We write @xmath as shorthand for the following
formula.

  -- -------- --
     @xmath   
  -- -------- --

Informally, this says that there exists a witness of @xmath in @xmath ,
but given any @xmath with @xmath it is false that every element of
@xmath is a witness of @xmath . In other words @xmath has at least one,
but at most @xmath witnesses.

###### Definition 6.18.

We define the following variants of the axiom of choice. Let @xmath be
any set.

1.  Write @xmath for the following principle. Let @xmath be a bounded
    formula (that may have parameters). Suppose that we have @xmath .
    Then there is a function @xmath such that for every @xmath , @xmath
    .

2.  Write @xmath for the following principle. Let @xmath be a bounded
    formula (that may have parameters). Suppose that we have @xmath .
    Then there is a function @xmath such that for every @xmath , there
    is a good @xmath -tree, @xmath such that if @xmath is very good then
    @xmath .

3.  Write @xmath for the following principle. Let @xmath be a bounded
    formula. Suppose that we have @xmath . Then there is a function
    @xmath such that for all @xmath , @xmath .

###### Proposition 6.19 (@xmath).

Let @xmath be any set. For all @xmath with @xmath , and all @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

For @xmath , note that @xmath is easily a special case of @xmath .

For @xmath , given any good @xmath -tree @xmath , we can generate a good
@xmath -tree by “choosing @xmath branches at each level.”

For @xmath , we just apply corollary 4.21 . ∎

###### Lemma 6.20 (@xmath).

Let @xmath and @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Let @xmath and suppose that @xmath . Then we have by unfolding the
interpretation of formulas in @xmath and the definition of @xmath that,

  -- -------- --
     @xmath   
  -- -------- --

and for every list @xmath

  -- -------- --
     @xmath   
  -- -------- --

Hence, applying lemma 6.10 with @xmath , we have that for every @xmath
there exists @xmath and a good @xmath -tree @xmath such that if @xmath
is very good then @xmath .

Now applying @xmath we get a choice function @xmath . That is, for every
@xmath , there exists a good @xmath -tree @xmath such that if @xmath is
very good then @xmath . For each @xmath , let @xmath be a code for the
tree @xmath as above. Then the statement that @xmath codes a good tree
is absolute by theorem 4.19 , so also holds internally.

Also, the statement that @xmath codes a very good tree is equivalent to
a formula of the form @xmath , where @xmath is negative by lemma 4.20 .
Hence by lemma 3.9 the statement “ @xmath codes a very good tree implies
@xmath ” must also hold internally. ∎

Finally, we define another variant of choice that will also hold in our
model. This will be denoted Herbrand choice , since it also holds in the
Herbrand topos developed by Van den Berg in [ 20 ] .

###### Definition 6.21.

We refer to the following principle as @xmath or Herbrand countable
choice . Let @xmath be a bounded formula (that may have parameters).
Suppose that we have @xmath . Then there exists a function @xmath from
@xmath to the set of finite subsets of @xmath , @xmath , such that for
all @xmath there exists @xmath such that @xmath .

One can easily show @xmath can be alternatively formulated as follows.

###### Proposition 6.22 (@xmath).

@xmath is true if and only if the following holds. Suppose that we have
@xmath . Then there exists a function @xmath such that for all @xmath
there exists @xmath such that @xmath .

###### Lemma 6.23 (@xmath).

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Suppose that @xmath . Then for every @xmath , we have @xmath . By lemma
6.9 there exists a finite set @xmath such that @xmath . Hence also there
exists @xmath such that @xmath . By @xmath , we deduce that there is a
function @xmath such that for all @xmath , @xmath . Finally by
absoluteness, we deduce @xmath , and thereby @xmath . ∎

## 7 Applications

### 7.1 Consistency of Church’s Thesis with @xmath

A hallmark of Lifschitz realizability, from Lifschitz’s original model
for arithmetic in [ 11 ] onwards is that it satisfies both Church’s
thesis and @xmath . We will recover the result from [ 5 ] that Church’s
thesis and @xmath are compatible over @xmath . Moreover, we will show
something even stronger. Certain variants of the axiom of countable
choice are compatible with Church’s thesis and @xmath , and as @xmath
increases, we can show that successively stronger forms of countable
choice are compatible with Church’s thesis and @xmath .

###### Lemma 7.1 (@xmath).

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

By lemma 6.13 it suffices to show that for every @xmath , the statement
that @xmath is computable holds in @xmath . For any @xmath , we have by
applying @xmath in the background that there exists @xmath such that
@xmath . For every @xmath , the statement that @xmath is of the form
@xmath where @xmath is primitive recursive. Since this holds in the
background universe we must also have for each @xmath , @xmath .
Therefore @xmath . Therefore @xmath as required. ∎

###### Theorem 7.2.

Assume that @xmath is consistent. Then for each @xmath , the following
theory is consistent.

  -- -------- --
     @xmath   
  -- -------- --

Assume that @xmath is consistent. Then for each @xmath , the following
theory is consistent.

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Let @xmath be either @xmath or @xmath and assume that @xmath is
consistent. It is already known that in both cases @xmath does not
change the consistency strength. ( @xmath is the same consistency
strength as @xmath by the main result in [ 6 ] and @xmath is the same
consistency strength as @xmath by [ 18 ] )

So we have that @xmath is consistent. Then so is the theory @xmath by
working in the McCarty realizability model @xmath and using the main
results in [ 13 ] and [ 17 ] together with lemma 5.6 .

However we now get the result by building the model @xmath in @xmath and
applying lemmas 6.15 , 6.16 , 6.20 , 6.23 and 7.1 . ∎

In [ 19 ] , Richman gave a proof in Bishop style constructive
mathematics that for each @xmath , @xmath is inconsistent with the
statement that all functions are computable (that in fact this is even
true for @xmath ). Richman’s argument does not hold in @xmath or even
@xmath , as is already clear from the earlier Lifschitz realizability
model in [ 5 ] . However, it turns out that the only obstacle is an
implicit use of countable choice, and one can use @xmath to carry out
Richman’s argument, as follows.

###### Theorem 7.3.

For each @xmath , the following theory is inconsistent.

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

For each @xmath with @xmath , we define @xmath as follows. @xmath is
equal to @xmath if the @xmath th Turing machine with input @xmath has
halted by stage @xmath with output @xmath , and @xmath is equal to
@xmath otherwise.

Note that for any @xmath and for any @xmath with @xmath we have @xmath
(since the @xmath th Turing machine on input @xmath can have at most
@xmath output). Hence we can apply @xmath to show that for some @xmath ,
@xmath .

Now we can apply @xmath to find a function @xmath such that for each
@xmath , @xmath . (In fact this implies that @xmath , but we don’t need
this.)

Now apply @xmath to find @xmath such that for all @xmath , @xmath . In
particular, the @xmath th Turing machine with input @xmath halts with
output @xmath . Hence, for sufficiently large @xmath we have @xmath and
so @xmath . However, @xmath was chosen so that @xmath . Therefore we get
a contradiction, as required. ∎

Hendtlass and Lubarsky showed in [ 9 ] that @xmath is independent of
@xmath over @xmath using topological models. We obtain here a similar
separation result.

###### Corollary 7.4.

For each @xmath @xmath does not imply @xmath over @xmath .

###### Proof.

@xmath is consistent by theorem 7.2 and proposition 6.19 but @xmath is
not by theorem 7.3 . ∎

In addition we get the following corollary by the same argument.

###### Corollary 7.5.

@xmath does not imply @xmath over @xmath .

###### Proof.

@xmath is consistent by theorem 7.2 and proposition 6.19 but @xmath is
not by theorem 7.3 . ∎

### 7.2 Existence Properties

###### Theorem 7.6.

Let @xmath be one of @xmath or @xmath . Let @xmath be a formula with one
free variable, @xmath . Suppose that

  -- -------- --
     @xmath   
  -- -------- --

Then there is a finite set @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Suppose that

  -- -------- --
     @xmath   
  -- -------- --

Then we have by lemma 6.16 that

  -- -------- --
     @xmath   
  -- -------- --

Fix a primitive recursive encoding of finite sets of naturals as
naturals. Then by lemma 6.9 , working in @xmath we can prove that there
exists a natural number encoding a finite set @xmath such that @xmath .
Now applying theorem 5.8 and absoluteness for primitive recursive
formulas we have a finite set @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

By lemma 5.5 we have in particular that,

  -- -------- --
     @xmath   
  -- -------- --

Finally we apply lemma 6.7 to get

  -- -------- --
     @xmath   
  -- -------- --

∎

###### Theorem 7.7.

Let @xmath be one of @xmath or @xmath . Let @xmath and @xmath , and let
@xmath be a formula with one free variable, @xmath . Suppose that

  -- -------- --
     @xmath   
  -- -------- --

Then for some @xmath we have

  -- -------- -------- -- -----
     @xmath   @xmath      (7)
     @xmath   @xmath      (8)
  -- -------- -------- -- -----

###### Proof.

Suppose that @xmath . Then we have by lemma 6.16 that

  -- -------- --
     @xmath   
  -- -------- --

Hence, applying lemma 6.10 with @xmath , and writing @xmath to mean
@xmath is a good @xmath tree and @xmath to mean @xmath is a very good
tree,

  -- -------- -- -----
     @xmath      (9)
  -- -------- -- -----

We now apply lemma 5.8 to find @xmath such that

  -- -------- -- ------
     @xmath      (10)
  -- -------- -- ------

By lemma 5.5 we have in particular that,

  -- -------- -- ------
     @xmath      (11)
  -- -------- -- ------

However, we also have by lemma 6.7 that

  -- -- --
        
  -- -- --

Finally, we deduce ( 7 ) by corollary 4.21 and deduce ( 8 ) by theorem
4.14 . ∎

###### Corollary 7.8.

Let @xmath be one of @xmath or @xmath . Let @xmath and @xmath , and let
@xmath be sentences. Suppose that

  -- -------- --
     @xmath   
  -- -------- --

Then for some @xmath we have

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

###### Corollary 7.9.

Let @xmath be one of @xmath or @xmath . Let @xmath and let @xmath be a
formula with one free variable, @xmath . Suppose that

  -- -------- --
     @xmath   
  -- -------- --

Then for some @xmath we have

  -- -------- -------- --
     @xmath   @xmath   
  -- -------- -------- --

###### Proof.

This is a special case of ( 8 ) in theorem 7.7 taking @xmath . ∎

By contrast, we see below that none of these theories can have the full
numerical existence property.

###### Theorem 7.10.

The numerical existence property does not hold for any consistent,
recursively axiomatisable extension of @xmath .

###### Proof.

Let @xmath be a consistent recursively axiomatisable extension of @xmath
. In fact, a similar proof works for any theory @xmath that interprets
enough first order arithmetic to state @xmath and carry out the
constructions used in Gödel’s incompleteness theorem. However, for
convenience we will use definitions and notation from set theory.

Assume that we are given a bijective pairing on @xmath with primitive
recursive pairing and projection functions, which we write as @xmath ,
@xmath and @xmath respectively, and let @xmath be a primitive recursive
provability predicate.

Construct by diagonalisation a formula @xmath , where @xmath is the only
free variable and such that

  -- -------- -- ------
     @xmath      (12)
  -- -------- -- ------

Write @xmath for the formula

  -- -------- -- ------
     @xmath      (13)
  -- -------- -- ------

Now define for each @xmath , @xmath as follows

  -- -------- --
     @xmath   
  -- -------- --

So that we can apply @xmath , we first show that for all @xmath we have
@xmath . For any @xmath , assume for a contradiction that @xmath .
Without loss of generality we may assume @xmath is the least such number
(since @xmath is primitive recursive and so decidable). By the
minimality of @xmath we must have either @xmath or @xmath . However, we
cannot have both of these since this would imply @xmath and @xmath .
Hence we have without loss of generality @xmath and since @xmath and
@xmath , there must be some @xmath such that @xmath . In particular we
have @xmath but also for all @xmath , @xmath , giving us a
contradiction. Therefore, @xmath as required.

We can now apply @xmath to show that @xmath . Note that this implies
@xmath .

Now if we assume that the numerical existence property holds for @xmath
then there must be some @xmath such that @xmath . So there must be
@xmath such that @xmath codes a proof for @xmath (by taking @xmath ).
Since the provability predicate is decidable, without loss of generality
we can take @xmath to be the least number such that @xmath codes a proof
for @xmath . By the minimality of @xmath we have that for all @xmath ,
@xmath . But this is a @xmath sentence, so by absoluteness for @xmath
sentences we have

  -- -------- --
     @xmath   
  -- -------- --

Again by absoluteness of @xmath sentences, we also have

  -- -------- --
     @xmath   
  -- -------- --

Hence we have @xmath , contradicting that @xmath and the consistency of
@xmath . Therefore the numerical existence property must fail for @xmath
. ∎

###### Corollary 7.11.

For every @xmath , there is a formula with one free variable, @xmath ,
such that @xmath but for every formula @xmath , @xmath .

###### Proof.

Let @xmath be the formula from the proof of theorem 7.10 . If @xmath was
provable, then by corollary 7.9 there would be some @xmath such that
@xmath . But in particular this gives @xmath contradicting theorem 7.10
. ∎

In [ 7 ] , Friedman showed that for every recursively axiomatisable
extension of Heyting arithmetic the disjunction property implies the
numerical existence property. He further remarks, without proof, that
there is a @xmath extension that satisfies the disjunction property but
not the numerical existence property. As a corollary of the above
results, we obtain a reasonably natural example of a @xmath theory with
the disjunction property but not the numerical existence property.

###### Corollary 7.12.

Assume classical logic in the meta theory. The theory @xmath (i.e. the
set of formulas provable in @xmath for every @xmath ) has the
disjunction property.

###### Proof.

Suppose that @xmath . Then, for each @xmath , @xmath . Hence either
@xmath or @xmath . Let @xmath and @xmath . @xmath and @xmath are
downwards closed subsets of @xmath such that @xmath . By classical logic
we therefore have either @xmath or @xmath . Without loss of generality,
say @xmath . Then we have that for every @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

But we have now shown the disjunction property for this theory. ∎

###### Theorem 7.13.

The theory @xmath (i.e. the set of formulas provable in @xmath for every
@xmath ) does not have the numerical existence property.

###### Proof.

Note that the statement @xmath can be formalised in set theory and holds
in each @xmath for each @xmath . However, for each @xmath , we have seen
that @xmath does not prove @xmath , so it is not provable in @xmath .
Hence @xmath proves @xmath but does not prove @xmath for any @xmath , so
the numerical existence property fails. ∎

### 7.3 Consistency of Brouwerian Continuity Principles

Recall that the fan theorem and bar induction are defined as below.

###### Definition 7.14.

Write @xmath for the set of finite binary sequences. If @xmath is an
infinite binary sequence, write @xmath for the finite binary sequence of
length @xmath obtained by restricting @xmath .

A subset @xmath of @xmath is a bar if for every @xmath , there exists
some @xmath such that @xmath .

A bar, @xmath , is uniform if there exists @xmath such that for all
@xmath , there exists @xmath such that @xmath .

The fan theorem , @xmath is the axiom that every bar is uniform.

A subset @xmath of @xmath is a bar if for every @xmath , there exists
some @xmath such that @xmath .

A bar, @xmath , is monotone if whenever @xmath and @xmath is a finite
binary sequence extending @xmath , then also @xmath .

If @xmath and @xmath are finite binary sequences, write @xmath for the
concatenation of @xmath and @xmath .

Monotone bar induction , @xmath , is the following axiom. Let @xmath be
such that there is a monotone bar @xmath with @xmath and @xmath has the
property that whenever @xmath for all @xmath also @xmath . Then @xmath .

###### Proposition 7.15 (@xmath).

Let @xmath be the function realizability model from [ 15 ] . Then @xmath
holds in @xmath .

###### Proof.

This can easily be checked by applying @xmath in the background and
noting that there is a continuous functional that takes as input @xmath
such that there exists @xmath with @xmath and returns the first @xmath
such that @xmath . ∎

###### Lemma 7.16 (@xmath).

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Let @xmath be such that the statement that @xmath is a bar holds in
@xmath . We first construct a set @xmath in the background universe and
check that @xmath is a bar. Let @xmath be the set of @xmath such that
@xmath .

To show that @xmath is a bar, let @xmath . Then @xmath , since @xmath is
internally a bar in @xmath . Hence by lemma 6.9 , there is a finite set
@xmath such that @xmath . Then set @xmath . We clearly have @xmath , and
so @xmath is a bar.

We can now apply @xmath in the background universe to find @xmath such
that for every @xmath there exists @xmath such that @xmath . But we now
have @xmath as required. ∎

###### Lemma 7.17 (@xmath).

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Suppose that @xmath are such that in @xmath the following holds: @xmath
, @xmath is a monotone bar and whenever @xmath contains every immediate
successor of @xmath , it also contains @xmath . We first define external
versions of @xmath and @xmath as follows:

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

Note that we can easily show @xmath and that @xmath is monotone. To
apply @xmath in the background, it only remains to check that @xmath is
a bar and that for any @xmath if @xmath contains every immediate
successor of @xmath it also contains @xmath .

To check that @xmath is a bar, let @xmath . Then @xmath . Hence by lemma
6.9 , there is a finite set @xmath such that @xmath . Then set @xmath .
By monotonicity we have that for each @xmath , @xmath . So we deduce
that @xmath and so @xmath . Therefore @xmath is a bar as required.

Now let @xmath be such that for all @xmath , @xmath . Then by
absoluteness, we have @xmath . Therefore, @xmath and so @xmath .

We can now apply @xmath in the background to deduce that @xmath .
Therefore @xmath . So we have confirmed @xmath holds in @xmath as
required. ∎

###### Lemma 7.18 (@xmath).

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

Suppose @xmath . Then by lemma 6.14 there is @xmath such that @xmath .
Let @xmath . By @xmath in the background, there exists @xmath such that
for any @xmath , @xmath implies @xmath . However, by absoluteness we
then have @xmath . But we now have that in @xmath , @xmath and so also
@xmath are continuous. We deduce @xmath in @xmath . ∎

###### Lemma 7.19 (@xmath).

Let @xmath and @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

By adapting the proof of lemma 6.20 and applying @xmath in the
background. ∎

###### Lemma 7.20 (@xmath).

  -- -------- --
     @xmath   
  -- -------- --

###### Proof.

By adapting the proof of lemma 6.23 and applying @xmath in the
background. ∎

###### Theorem 7.21.

Assume @xmath is consistent. Then for each @xmath , so is the following
theory.

  -- -------- -- ------
     @xmath      (14)
  -- -------- -- ------

Assume @xmath is consistent. Then for each @xmath , so is the following
theory.

  -- -------- -- ------
     @xmath      (15)
  -- -------- -- ------

###### Proof.

Using proposition 7.15 and lemma 5.10 one can easily adapt the proof of
[ 15 , Theorem 9.10] to show this. ∎

###### Theorem 7.22.

If @xmath is consistent then for each @xmath , the following theory is
also consistent.

  -- -- -- ------
           (16)
  -- -- -- ------

If @xmath is consistent then for each @xmath , the following theory is
also consistent.

  -- -- -- ------
           (17)
  -- -- -- ------

###### Proof.

We build @xmath in the theory @xmath , which is consistent by theorem
7.21 . We then have that @xmath models ( 16 ) by lemmas 6.15 , 7.19 ,
7.20 , 6.16 , 7.18 and 7.16 . To add monotone bar induction we also
apply lemma 7.17 . ∎

(There is already a similar result for @xmath over second order
arithmetic due to Van Oosten in [ 21 , Section 5] .)

###### Corollary 7.23.

@xmath does not prove @xmath or @xmath .

###### Proof.

@xmath is consistent, so it suffices to show @xmath and @xmath are not.

In both cases, we show the theories are inconsistent by first noting
that there is a surjection @xmath , defined as follows.

  -- -------- --
     @xmath   
  -- -------- --

By @xmath , there is @xmath for each @xmath such that @xmath . Let
@xmath be such that @xmath for all @xmath . By @xmath there is some
@xmath such that whenever @xmath , @xmath . However, we can now easily
find @xmath such that @xmath but @xmath to get a contradiction.
Similarly, we can use @xmath to get a function @xmath such that for all
@xmath , @xmath , contradicting @xmath . ∎

## 8 Connections to Other Formal Systems

### 8.1 Connections to Topos Theory

The @xmath considered in this paper appear to be strongly related to the
local operators in the effective topos previously considered by Lee and
Van Oosten in [ 10 ] , specifically to the local operators corresponding
to finitary sights. We expect that in fact these local operators can be
obtained by carrying out the construction of @xmath in the effective
topos. The realizability model @xmath corresponds to the topos @xmath
(as described, for example, in [ 23 , Section 4.3] ). Since we only
require computable functions, one might expect our constructions to work
also in the relative realizability topos @xmath (see [ 23 , Section 4.5]
). The realizability with truth model is related to the topos @xmath
obtained by gluing along the inclusion functor from @xmath to @xmath .
Putting this all together, we make the following conjecture.

###### Conjecture 8.1.

Some of the local operators in @xmath considered in [ 10 ] have
counterparts in the toposes @xmath , @xmath and @xmath .

(We again point out that Van Oosten has already shown that the original
Lifschitz realizability model has a counterpart in @xmath (see [ 23 ,
Section 4.3] ) and for @xmath -realizability (an ancestor of
realizability with truth) (see [ 21 , Proposition 3.5] )).

### 8.2 Connections to Type Theory

###### Definition 8.2.

Let @xmath be a context in type theory. We say that @xmath has
propositional canonicity for @xmath if whenever @xmath , there is some
@xmath and a term @xmath such that @xmath .

Suppose we are working in a variant of type theory that has a
propositional truncation operator (such as type theory with brackets, as
in [ 4 ] ). In such theories there are two different ways of formalising
@xmath depending on whether or not we use the propositional truncation
operator @xmath . We call these @xmath and @xmath and define them as
follows.

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

By adapting the proof of theorem 7.10 , we have,

###### Theorem 8.3.

The context @xmath does not have propositional canonicity for @xmath
over any variant of type theory for which it is consistent (that is,
there is no term of type @xmath in context @xmath ) and such that the
set of judgements is computably enumerable.

However, we expect by analogy with the results in this paper that the
following holds.

###### Conjecture 8.4.

The context @xmath has propositional canonicity for @xmath over type
theory with bracket types, as studied by Awodey and Bauer in [ 4 ] , or
similar systems studied by Maietti in [ 12 ] .

## Acknowledgements

This work was supported by the EPSRC project “Homotopical inductive
types” through grant No. EP/K023128/1 and by the Hausdorff Research
Institute for Mathematics in Bonn during the trimester “Types, Sets, and
Constructions” 2018. This publication was made possible through the
support of a grant from the John Templeton Foundation (“A new dawn of
intuitionism: mathematical and philosophical advances,” ID 60842). The
opinions expressed in this publication are those of the authors and do
not necessarily reflect the views of the John Templeton Foundation.