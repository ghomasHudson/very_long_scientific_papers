# Acknowledgements

I am grateful to everyone who helped and supported me during my PhD
studies here in Århus.

First of all, I want to cordially thank my supervisors and co-authors
Louis Salvail and Ivan Damgård and the whole cryptology group at DAIMI
for providing an excellent environment for cryptographic research.
Countless are the hours I have spent discussing scientific as well as
non-scientific issues with Louis, merci beaucoup ! I thank my other
co-authors Claude Crépeau, Serge Fehr, Renato Renner, George Savvides
and Jürg Wullschleger for many inspiring visits and discussions.

I appreciated very much being a PhD student in a well-organized and
well-funded research group and to be able to work in a brand-new
building with plenty of space, great infrastructure and always helpful
and friendly staff and secretaries: Ellen, Hanne, Karen, Lene, Michael,
and Uffe.

Studying in Århus has been a great experience mainly because of all the
friends from the constantly changing “gang” of foreign and Danish
fellows at DAIMI including Allan, Claudio, Claus, Doina, Gabi, Henrik,
Jan, Jesper, Jooyong, Johan, Kevin, Michael, Mikkel, Mirka, Rune, Tord,
Thomas M, Tomas, and Troels; but not to forget the ones who have left
Denmark and are now spread around the world: Barnie, Christopher,
Emanuela and Paolo, Fitzi, Gosia and Darek, Jens, Jesús, Karl, Kirill,
Marco, Nelly and Antonio, Philipp, Thomas P, and Saurabh. I thank you
all for the wonderful time, both at and off the table-soccer table.
Special thanks to Gosia and Henrik for constructive comments on the
introduction of this thesis and to Jürg and Serge for further comments.

I would also like to thank Claude Crépeau for hosting me for a fantastic
summer half-year at McGill university in Montréal where I had the chance
to meet many interesting people doing quantum research and experience
the exciting spot where the francophone part of North America meets the
anglophone rest of the continent.

I thank Prof. Andreas Winter from the University of Bristol and
Prof. Stefan Wolf from ETH Zürich as well as Prof. Susanne Bødker from
the University of Aarhus for agreeing to constitute the evaluation
committee for my PhD thesis.

Last but not least, I want to express my gratitude to my family for
their immense love and support from the distance. I am infinitely
grateful for the great childhood they gave me which was and still is an
invaluable source of self-confidence for me.

This research was partially supported by the EU Project SECOQC,
No: FP6-2002-IST-1-506813.

Christian Schaffner,

Århus, March 2, 2007.

###### Contents

-    Abstract
-    Acknowledgements
-    1 Introduction
    -    1.1 Cryptographic Models and Basic Primitives
    -    1.2 Classical Bounded-Storage Model
    -    1.3 Contributions
        -    1.3.1 Bounded-Quantum-Storage Model
        -    1.3.2 Characterization of Security of Classical 1-2 OT
        -    1.3.3 Quantum Security Definitions and Protocols
        -    1.3.4 Quantum Uncertainty Relations
        -    1.3.5 QKD against Quantum-Memory-Bounded Eavesdropper
    -    1.4 Outline of the Thesis
    -    1.5 Related Work
-    2 Preliminaries
    -    2.1 Notation and Basic Tools
    -    2.2 Probability Theory
    -    2.3 Quantum Information Theory
    -    2.4 Entropies
        -    2.4.1 Classical Rényi Entropy
        -    2.4.2 Smooth Rényi Entropy
        -    2.4.3 Min-Entropy-Splitting Lemma
        -    2.4.4 Entropy of Quantum States
    -    2.5 Two-Universal Hashing and Privacy Amplification
        -    2.5.1 History and Setting of Privacy Amplification
        -    2.5.2 Two-Universal Hashing
        -    2.5.3 Privacy Amplification against Quantum Adversaries
        -    2.5.4 Classical Privacy Amplification
-    3 Classical Oblivious Transfer
    -    3.1 Introduction and Outline
    -    3.2 Defining 1-2 OT
        -    3.2.1 Randomized 1-2 OT of Bits
        -    3.2.2 Randomized 1-2 OT of Strings
    -    3.3 Characterizing Sender-Security
        -    3.3.1 The Case of Bit OT
        -    3.3.2 The Case of String OT
    -    3.4 Applications
        -    3.4.1 Reducing 1-2 OT @xmath to Repetitions of Weak 1-2 OT
            s
        -    3.4.2 Reducing 1-2 OT @xmath to One Execution of UOT
        -    3.4.3 Quantitative Comparisons To Related Work
    -    3.5 Extension to 1-n OT @xmath
    -    3.6 1-2 OT in a Quantum Setting
-    4 Quantum Uncertainty Relations
    -    4.1 Preliminaries
        -    4.1.1 Operators and Norms
        -    4.1.2 Azuma’s Inequality
        -    4.1.3 Mathematical Tools
    -    4.2 History and Previous Work
        -    4.2.1 Mutually Unbiased Bases
        -    4.2.2 Uncertainty Relations Using Shannon Entropy
        -    4.2.3 Higher-Order Entropic Uncertainty Relations
    -    4.3 Two Mutually Unbiased Bases
    -    4.4 More Mutually Unbiased Bases
    -    4.5 Independent Bases for Each Subsystem
        -    4.5.1 A Classical Tool
        -    4.5.2 Quantum Uncertainty Relations
        -    4.5.3 The Overall Average Entropic Uncertainty Bound
-    5 RabinOT in the Bounded-Quantum-Storage Model
    -    5.1 The Definition
    -    5.2 The Protocol
    -    5.3 Modeling Dishonest Receivers
    -    5.4 Security Against Dishonest Receivers
    -    5.5 On the Necessity of Privacy Amplification
    -    5.6 Weakening the Assumptions
        -    5.6.1 Weak Quantum Model
    -    5.7 RabinOT of Strings
-    6 1-2 OT in the Bounded-Quantum-Storage Model
    -    6.1 The Definition
    -    6.2 The Protocol
    -    6.3 Security Against Dishonest Receivers
    -    6.4 Extensions
        -    6.4.1 1-2 OT @xmath with Longer Strings
        -    6.4.2 Weakening the Assumptions
        -    6.4.3 Reversing the Quantum Communication
-    7 Quantum Bit Commitment
    -    7.1 The Protocol
    -    7.2 Modeling Dishonest Committers
    -    7.3 Defining the Binding Property
        -    7.3.1 The “Standard” Binding Condition
        -    7.3.2 A Stronger Binding Condition
    -    7.4 Weak Binding of the Commitment Scheme
    -    7.5 Strong Binding of the Commitment Scheme
    -    7.6 Weakening the Assumptions
-    8 QKD Against Bounded Eavesdroppers
    -    8.1 Derivation of the Maximum Tolerated Noise Level
    -    8.2 The Binary-Channel Setting
    -    8.3 Possible Extensions
-    9 Conclusion
    -    9.1 Towards Practice
        -    9.1.1 More Imperfections
        -    9.1.2 Generalizing the Memory Model
    -    9.2 Conclusion
-    Notation

## Chapter 1 Introduction

In the quest for interesting cryptographic models, bounding the quantum
memory of adversarial players is a great assumption.

### 1.1 Cryptographic Models and Basic Primitives

It is a fascinating art to come up with protocols ¹ ¹ 1 A protocol
consists of clear-cut instructions for the participating players. that
achieve a cryptographic task like encryption, authentication,
identification, voting, secure function evaluation to name just a famous
few. To define a notion of security for such protocols, one needs to
specify a cryptographic model , i.e. an environment in which the
protocol is run. The model states for example the number of honest and
dishonest players, the allowed running time and amount of memory
available to honest and dishonest players, how dishonest players are
allowed to deviate from the protocol, the use of external resources like
(quantum) communication channels or other already established
cryptographic functionalities etc.

While coming up with more and more protocols for different models,
cryptographers realized that some basic primitives (i.e. precisely
defined cryptographic tasks) are useful as “benchmarks” of how powerful
a particular cryptographic model is. An example is the two-party
primitive Oblivious Transfer ( OT ). It comes in different flavors, but
all of these variants are equivalent in the sense that anyone of them
can be implemented using (possibly several instances of) an other. The
one-out-of-two variant 1-2 OT was originally introduced by Wiesner
around 1970 (but only published much later in [ Wie83 ] ) in the very
first paper about quantum cryptography, and later rediscovered by Even,
Goldreich, and Lempel [ EGL82 ] . It lets a sender Alice transmit two
bits to a receiver Bob who can choose which of them to receive. A secure
implementation of 1-2 OT does not allow a dishonest sender to learn
which of the two bits was received and it does not allow a dishonest
receiver to learn any information about the second bit. It was a
surprising insight when Kilian showed that this simple primitive is
complete for two-party cryptography [ Kil88 ] . In other words, a model
in which 1-2 OT can be securely implemented allows to implement any
cryptographic functionality between two players ² ² 2 If the model can
be reasonably extended to more players, this usually allows to implement
secure multi-party protocols as well. . Another variant we are concerned
with in this thesis was introduced by Rabin [ Rab81 ] and is hence
called Rabin Oblivious Transfer ( RabinOT ). It is basically a “secure
erasure channel”: the sender Alice sends a bit which with probability
one half is absorbed and with probability one half finds its way to the
receiver Bob. The security requirements are the following: whatever a
dishonest Alice does, she cannot find out whether the bit was received
or not; and whatever a dishonest receiver does, he does not get any
information about the bit with probability one half.

Yet another basic two-party primitive of interest is Bit Commitment ( BC
) which allows a player to commit himself to a choice of a bit @xmath by
communicating with a verifier. The verifier should not learn @xmath (we
say the commitment is hiding ), yet the committer can later choose to
reveal @xmath in a convincing way, i.e. only the value fixed at
commitment time will be accepted by the verifier (we say the commitment
is binding ). Bit Commitment is a fundamental building block of
virtually every more complicated cryptographic protocol. Implementing
secure BC with a secure 1-2 OT at hand is not difficult ³ ³ 3 To commit
to a bit @xmath , the committer sends random bits of parity @xmath via
(several instances of) 1-2 OT and the verifier picks randomly one of the
bits. To open, the committer sends all the random bits he was using, the
verifier checks whether these are consistent with what he received. . On
the other hand, there are cryptographic models allowing to securely
implement BC , but not 1-2 OT . Moran and Naor gave an example of such a
model by assuming the physical device of a tamper-proof seal [ MN05 ] .

It is not hard to see that the two security requirements for BC are in a
sense contradictory, so perfectly secure bit commitment cannot be
implemented ‘‘from scratch’’, that is if only error-free communication
is available and there is no limitation assumed on the computing power
and memory of the players. The informal reason for this is that the
hiding property implies that when 0 is committed to, exactly the same
information exchange could have happened when committing to 1. Hence,
even if 0 was actually committed to, the committer could always compute
a complete view of the protocol consistent with having committed to 1,
and pretend that this view was what he had in mind originally. By the
reduction of BC to 1-2 OT follows that also 1-2 OT and many other
cryptographic functionalities cannot be perfectly secure when built from
scratch.

One might hope that allowing the protocol to make use of quantum
communication would make a difference. Here, information is stored in
qubits, i.e., in the state of two-level quantum mechanical systems, such
as the polarization state of a single photon. Quantum information
behaves in a way that is fundamentally different from classical
information, enabling, for instance, unconditionally secure key exchange
between two honest players (so-called Quantum Key Distribution ).
However, in the case of two mutually distrusting parties, we are not so
fortunate: even with quantum communication, unconditionally secure BC
and 1-2 OT remain impossible. This is the infamous impossibility result
by Mayers and by Lo and Chau [ May97 , LC97 ] .

For this reason, cryptographers have tried hard to exhibit more
restricted models where these impossibility results do not apply. The
high art in this process is to find assumptions that are as realistic as
possible – thus only minimally restricting the model, but still strong
enough to allow for implementing interesting functionalities. There are
at least three kinds of possible assumptions, namely

-   bounding the computing power of players,

-   using the noise in the communication channel,

-   exploiting some physical limitation of the adversary, e.g., if the
    size of the available memory is bounded.

The first scenario is the basis of many well known solutions based on
plausible but unproven complexity assumptions, such as hardness of
factoring or discrete logarithms. A term often used for such schemes is
‘‘computational security”, meaning that it is not impossible for an
adversary to behave dishonestly, but it is computationally infeasible
for him to do so. Security proofs are usually done by reduction in the
sense that breaking the security of the protocol would imply solving a
hard problem like factoring the product of two large prime numbers. The
second scenario has been used to construct both BC and OT protocols in
various models for the noise by Crépeau, Kilian, Damgård, Salvail, Fehr,
Morozov, Wolf, and Wullschleger [ CK88 , DKS99 , DFMS04 , CMW04 , Wul07
] .

The third scenario is the focus of this thesis. In contrast to the first
scenario, we deal with ‘‘unconditional security” where (depending on the
task a protocol aims to achieve) an adversary has no way whatsoever to
gain illegal information. Proofs are not done by reduction, but we can
prove in information-theoretic terms that except with negligible
probability, the adversary does not learn any information that is meant
to remain secret.

### 1.2 Classical Bounded-Storage Model

In the classical bounded-storage model, we assume the players to use
classical error-free communication and to be computationally unbounded,
but on the other hand restrict the size of their memory. In the usual
setting, there is a large random source @xmath (often called the
randomizer ) which all players can access, but which is too large (or
transmitted too quickly) to store as a whole. One can think of @xmath as
a deep-space radio source or a satellite broadcasting random bits at a
very high rate.

When Maurer introduced the classical bounded-storage model in [ Mau90 ]
, the goal was secure message transmission . He showed that two honest
parties Alice and Bob sharing an initial key can expand that key unless
the eavesdropper Eve can store more than a large fraction of the
randomizer. The basic idea of the technique allowing Alice and Bob to
get an advantage over Eve is that their initial secret key indexes some
positions in the randomizer about which Eve has some uncertainty if she
cannot store the whole randomizer. Therefore, the bits at these
positions can be combined to yield more secure key bits and so to expand
the initial key.

A line of subsequent work by Maurer, Cachin, Aumann, Ding, Rabin,
Dziembowski, Lu, and Vadhan [ Mau92 , CM97 , ADR02 , DM04 , Lu04 , Vad04
] improved this original protocol in terms of efficiency and security.
Aumann, Ding and Rabin [ ADR02 ] noticed that protocols in this model
enjoy the property of ‘‘everlasting security” in the sense that the
newly generated key remains secure even when the initial key is later
revealed and Eve is no longer memory-bounded, under the sole condition
that the original randomizer cannot be accessed any more. Ding [ Din05 ]
showed how to do error correction in the bounded-storage model and
therefore how to cope with the situation when the honest parties do not
have exactly the same view on the randomizer.

Cachin, Crépeau and Marcil illustrated the power of the bounded-storage
model by exhibiting in [ CCM98 ] a protocol for 1-2 OT . Ding improved
on this [ Din01a ] and later showed a constant-round protocol for
oblivious transfer in joint work with Harnik, Rosen and Shaltiel [
DHRS04 ] .

All these protocols are shown secure as long as the adversary’s memory
size is at most quadratic in the memory size of the honest players.
Considering the ease and low cost of storing massive amounts of
classical data nowadays, it is questionable how practical such an
assumption on the memory size of the players is. It would be clearly
more satisfactory to have a larger than quadratic separation between the
memory size of honest players and that of the adversary. However, this
was shown to be impossible by Dziembowski and Maurer [ DM04 ] .

### 1.3 Contributions

In this section, we give an overview of the contributions of this
thesis. The results about classical oblivious transfer described in
Chapter 3 and summarized in Section 1.3.2 are joint work with Damgård,
Fehr and Salvail [ DFSS06 ] . All other results are based on two papers
co-authored with Damgård, Fehr, Salvail and Renner: [ DFSS05 ] and [ DFR
@xmath 07 ] . A journal version of [ DFSS05 ] is to appear in a special
issue of the SIAM Journal of Computing [ DFSS08 ] .

#### 1.3.1 Bounded-Quantum-Storage Model

In this thesis, we study for the first time protocols where quantum
communication is used and we place a bound on the adversary’s quantum
memory size. There are two reasons why this may be a good idea: first,
if we do not bound the classical memory size, we avoid the impossibility
result of [ DM04 ] . Second, the adversary’s typical goal is to obtain a
certain piece of classical information that we want to keep hidden from
him. However, if he cannot store all the quantum information that is
sent, he must convert some of it to classical information by measuring.
This may irreversibly destroy information, and we may be able to arrange
it in such a way that the adversary cannot afford to lose information
this way, while honest players can.

It turns out that this can be achieved indeed: we present protocols for
both BC and OT in which @xmath qubits are transmitted, where honest
players need no quantum memory , but where the adversary must store at
least a large fraction (typically @xmath or @xmath ) of the @xmath
transmitted qubits to break the protocol. We emphasize that no bound is
assumed on the adversary’s computing power, nor on his classical memory.
This is clearly much more satisfactory than the classical case, not only
from a theoretical point of view, but also in practice: while sending
qubits and measuring them immediately as they arrive is well within
reach of current technology, storing even a single qubit for more than a
fraction of a second is a formidable technological challenge.

Furthermore, we show that our protocols also work in a non-ideal setting
where we allow the quantum source to be imperfect and the quantum
communication to be noisy. We emphasize that what makes OT and BC
possible in our model is not so much the memory bound per se, but rather
the loss of information on the part of the adversary. Indeed, our
results also hold if the adversary’s memory device holds an arbitrary
number of qubits, but is imperfect in certain ways.

All these factors make the assumption of bounded quantum memory a very
attractive cryptographic model. On one hand, as for the classical
bounded-storage model, it is simple to work with and yields beautiful
theoretical results. On the other hand, it is much more reasonable to
assume the difficulty of storing quantum information compared to storing
classical one and hence, we are very close to the physical reality and
get schemes that can actually be implemented!

#### 1.3.2 Characterization of Security of Classical 1-2Ot

While the task of formally defining unconditional security of classical
protocols for RabinOT and BC is well understood, capturing the security
of 1-2 OT in information-theoretic terms is considerably more delicate,
as was pointed out by Crépeau, Savvides, Schaffner and Wullschleger [
CSSW06 ] . For 1-2 OT of bits, it is clear that the security for a
honest sender against a cheating receiver guarantees that the receiver
does not learn any information about the XOR of the two bits. Somewhat
surprisingly, the converse is true as well, not having any information
about the XOR of the two bits sent implies that we can point at one bit
which the dishonest receiver does not know (given the other).

This idea can be generalized to 1-2 OT of strings where the ignorance of
the XOR becomes ignorance of the outcome of all Non-Degenerate Linear
binary Functions (NDLFs) applied to the two strings sent. Such a
characterization of sender-security in terms of NDLF composes well with
strongly two-universal hashing and hereby yields a powerful technique to
improve the analyses of the standard reductions from 1-2 OT to weaker
variants of OT .

As a historical side note, the original motivation for this classical
characterization was the hope that it translates to the quantum setting
and thereby yields a security proof of the 1-2 OT scheme in the
bounded-quantum-storage model. We will point out why this approach does
not work.

#### 1.3.3 Quantum Security Definitions and Protocols

When the players are allowed to use quantum communication, the output of
a dishonest player is a quantum state even when the protocol implements
a classical primitive. Therefore, security definitions for RabinOT , 1-2
OT and BC have to be phrased in quantum terms. As an easy-to-use
composability framework has not yet been established for quantum
protocols ⁴ ⁴ 4 Some rather complicated frameworks are known. They have
been put forward by Ben-Or and Mayers [ BM04 ] and Unruh [ Unr02 ] . ,
various ad-hoc security requirements are commonly used. The definitions
in this thesis are the strongest so far proposed, and as they are based
on the (classical) considerations in [ CSSW06 ] , we believe that they
are best suited to provide sequential composability .

Most of the presented protocols in the bounded-quantum-storage model can
be cast in a non-interactive form, i.e. only one party sends information
when doing OT , commitment or opening. We show the following.

OT in the Bounded-Quantum-Storage Model: There exist non-interactive
protocols for RabinOT and 1-out-of-2 Oblivious Transfer ( 1-2 OT ) of
@xmath -bit messages, secure in the bounded-quantum-storage model
against adversaries with quantum-memory size at most @xmath for RabinOT
and @xmath for 1-2 OT . Here, @xmath is the number of qubits transmitted
in the protocol and @xmath can be a constant fraction of @xmath . Honest
players need no quantum memory at all.

For the case of bit commitment, the standard definition of the binding
property used in the quantum setting was introduced by Dumais, Mayers
and Salvail [ DMS00 ] . For @xmath , let @xmath denote the probability
that a dishonest committer successfully opens the commitment to value
@xmath . The binding condition then requires that the sum of @xmath and
@xmath does essentially not exceed 1. More formally, @xmath where @xmath
stands for a term which is negligible in @xmath such as @xmath (for a
constant @xmath ) which is exponentially small in @xmath . This is to
capture that a quantum committer can always commit to the values @xmath
and @xmath in superposition. We call this notion weakly binding in the
following. A shortcoming of this notion is that committing bit by bit is
not guaranteed to yield a secure string commitment—the argument that one
is tempted to use requires independence of the @xmath ’s between the
different executions, which in general does not hold.

Instead, we propose the following strong binding condition: After the
commitment phase, there exists a binary random variable @xmath such that
a dishonest committer cannot open the commitment to value @xmath except
with negligible probability. The point is that the distribution of
@xmath is not under control of the dishonest committer. We will point
out that using this definition, we can easily derive the security of a
string commitment from the security of the individual bits.

BC in the Bounded-Quantum-Storage Model: There exists a protocol for bit
commitment which is non-interactive. It is perfectly hiding and weakly
binding in the bounded-quantum-storage model against dishonest
committers with quantum-memory size at most @xmath . It is strongly
binding against memory sizes of at most @xmath . Here, @xmath is the
number of qubits transmitted in the protocol. Honest players need no
quantum memory at all.

Furthermore, the commitment protocol has the interesting property that
the only message is sent to the committer, i.e., it is possible to
commit while only receiving information. Such a scheme clearly does not
exist without a bound on the committer’s memory, even under
computational assumptions and using quantum communication: a corrupt
committer could always store (possibly quantumly) all the information
sent, until opening time, and only then follow the honest committer’s
algorithm to figure out what should be sent to convincingly open a 0 or
a 1.

Note that in the classical bounded-storage model, it has been shown by
Moran, Shaltiel and Ta-Shma [ MST04 ] how to do time-stamping that is
non-interactive in our sense: a player can time-stamp a document while
only receiving information. However, no reasonable protocol for BC or
for time-stamping a single bit exists in this model. It is
straightforward to see that any such protocol can be broken by an
adversary with classical memory of size twice that of an honest player,
while our protocol requires no quantum memory for the honest players and
remains secure against any adversary unable to store more than half the
size of the quantum transmission.

We also note that it has been shown earlier by Salvail [ Sal98 ] that BC
is possible using quantum communication, assuming a different type of
physical limitation, namely a bound on the size of coherent measurement
that can be implemented. This limitation is incomparable to ours: it
does not limit the total size of the memory, instead it limits the
number of bits that can be simultaneously operated on to produce a
classical result. Our adversary has a limit on the total quantum memory
size, but can measure all of it coherently. The protocol from [ Sal98 ]
is interactive, and requires a bound on the maximal measurement size
that is sub-linear in @xmath .

#### 1.3.4 Quantum Uncertainty Relations

A problem often encountered in quantum cryptography is the following:
through some interaction between the players, a quantum state is
generated and then measured by one of the players (we call her Alice in
the following). Assuming Alice is honest, we want to know how
unpredictable her measurement outcome is to the adversary. Once a lower
bound on the adversary’s uncertainty about Alice’s measurement outcome
is established, it is usually easy to prove the desired security
property of the protocol. Many existing constructions in quantum
cryptography have been proven secure following this paradigm.

Typically, Alice does not make her measurement in a fixed basis, but
chooses at random from a set of different bases. These bases are usually
chosen to be pairwise mutually unbiased , meaning that if the quantum
state is such that the measurement outcome in one basis is fixed, then
this implies that the uncertainty about the outcome of the measurement
in the other basis is maximal. In this way, one hopes to keep the
adversary’s uncertainty high, even if the state is (partially) under the
adversary’s control.

An inequality that lower bounds the adversary’s uncertainty in such a
scenario is called an uncertainty relation . There exist uncertainty
relations for different measures of uncertainty but cryptographic
applications typically require the adversary’s min-entropy to be bounded
from below. Such uncertainty relations are the key ingredient in the
security proofs of our protocols in the bounded-quantum-storage model.

In this thesis, we introduce new general and tight high-order entropic
uncertainty relations. Since the relations are expressed in terms of
lower bounds on the min-entropy or upper-bounds on large probabilities
respectively, they are applicable to a large class of natural protocols
in quantum cryptography.

The first uncertainty relation is concerned with the situation where a
@xmath -qubit state @xmath is measured in one out of two mutually
unbiased bases, say either in the computational basis (the @xmath
-basis) or in the diagonal basis (the @xmath -basis).

First Uncertainty Relation: Let @xmath be an arbitrary state of @xmath
qubits, and let @xmath and @xmath be the respective probability
distributions over @xmath of the outcome when @xmath is measured in the
@xmath -basis respectively the @xmath -basis. Then, for any two sets
@xmath and @xmath it holds that

  -- -------- --
     @xmath   
  -- -------- --

Another uncertainty relation is derived for situations where an @xmath
-qubit state @xmath has each of its qubits measured in a random and
independent basis sampled uniformly from a fixed set @xmath of bases.
@xmath does not necessarily have to be mutually unbiased, but we assume
a lower bound @xmath ---the so-called average entropic uncertainty bound
---on the average Shannon entropy of the distribution @xmath , obtained
by measuring an arbitrary one-qubit state in basis @xmath , meaning that
@xmath .

Second Uncertainty Relation (informal): Let @xmath be a set of bases
with an average entropic uncertainty bound @xmath as above. Let @xmath
denote the probability distribution defined by measuring an arbitrary
@xmath -qubit state @xmath in basis @xmath . For a uniform choice @xmath
, it holds except with negligible probability (over @xmath and over
@xmath ) that

  -- -------- -- -------
     @xmath      (1.1)
  -- -------- -- -------

Observe that ( 1.1 ) cannot be improved significantly since the
min-entropy of a distribution is at most equal to the Shannon entropy.
Our uncertainty relation is therefore asymptotically tight when the
bound @xmath is tight.

Any lower bound on the Shannon entropy associated to a set of
measurements @xmath can be used in ( 1.1 ). In the special case where
the set of bases is @xmath (i.e. the two BB84 bases named after Bennett
and Brassard who used them in the first quantum-key-distribution
protocol [ BB84 ] ), @xmath is known precisely using Maassen and
Uffink’s entropic relation [ MU88 ] , see ( 4.2 ). We get @xmath and (
1.1 ) results in @xmath . Uncertainty relations for the BB84 coding
scheme are useful, since this coding is widely used in quantum
cryptography. Its resilience to imperfect quantum channels, sources, and
detectors is an important advantage in practice.

A major difference between the first and second uncertainty relation is
that while both relations can be used to bound the min-entropy
conditioned on an event, this event happens in the latter case with
probability essentially 1 (on average) whereas the corresponding event
from the first relation (defined in Corollary 4.17 ) only happens with
probability about @xmath .

#### 1.3.5 Qkd against Quantum-Memory-Bounded Eavesdropper

We illustrate the versatility of our second uncertainty relation by
applying it to Quantum-Key-Distribution ( QKD ) settings. QKD is the art
of distributing a secret key between two distant parties, Alice and Bob,
using only a completely insecure quantum channel and authentic classical
communication. QKD protocols typically provide unconditional security,
i.e., even an adversary with unlimited resources cannot get any
information about the key. A major difficulty when implementing QKD
schemes is that they require a low-noise quantum channel. The tolerated
noise level depends on the actual protocol and on the desired security
of the key. Because the quality of the channel typically decreases with
its length, the maximum tolerated noise level is an important parameter
limiting the maximum distance between Alice and Bob.

We consider a model in which the adversary has a limited amount of
quantum memory to store the information she intercepts during the
protocol execution. In this model, we show that the maximum tolerated
noise level is larger than in the standard scenario where the adversary
has unlimited resources. For one-way QKD protocols which are protocols
where error-correction is performed non-interactively (i.e., a single
classical message is sent from one party to the other), we show the
following result:

QKD Against Quantum-Memory-Bounded Eavesdroppers: Let @xmath be a set of
orthonormal bases of the two-dimensional Hilbert space @xmath with
average entropic uncertainty bound @xmath . Then, a one-way QKD
-protocol produces a secure key against eavesdroppers whose
quantum-memory size is sublinear in the length of the raw key at a
positive rate, as long as the bit-flip probability @xmath of the quantum
channel fulfills @xmath where @xmath denotes the binary Shannon-entropy
function.

Although this result does not allow us to improve (compared to unbounded
adversaries) the maximum error-rate for the BB84 protocol (the 4-state
protocol), the 6-state (using three mutually unbiased bases) protocol
can be shown secure against adversaries with memory bound sublinear in
the secret-key length as long as the bit-flip error-rate is less than
@xmath . This improves over the maximal error-rate of @xmath for this
protocol against unbounded adversaries. We also show that the
generalization of the 6-state protocol to more bases (not necessarily
mutually unbiased) can be shown secure for a maximal error-rate up to
@xmath provided the number of bases is large enough. Note that the best
known one-way protocol based on qubits is proven secure against general
attacks for an error-rate of only up to roughly @xmath , and the
theoretical maximum is @xmath [ RGK05 ] .

The quantum-memory-bounded eavesdropper model studied here is not
comparable to other restrictions on adversaries considered in the
literature (e.g. individual attacks , where the eavesdropper is assumed
to apply independent measurements to each qubit sent over the quantum
channel as considered by Fuchs, Gisin, Griffiths, Niu, Peres, and
Lütkenhaus [ FGG @xmath 97 , Lüt00 ] ). In fact, these assumptions are
generally artificial and their purpose is to simplify security proofs
rather than to relax the conditions on the quality of the communication
channel from which secure key can be generated. We believe that the
quantum-memory-bounded eavesdropper model is more realistic.

### 1.4 Outline of the Thesis

In Chapter 2 , we introduce notation and present some basic concepts
from probability and quantum information theory like quantum states and
various kinds of their entropies. We prepare the stage by reproducing
and slightly extending the results about privacy amplification via
two-universal hashing from Renner’s PhD thesis [ Ren05 ] .

Chapter 3 is the only (almost) exclusively classical chapter. It
introduces the different flavors of oblivious transfer and gives a
characterization of the security for the sender of 1-2 OT in terms of
non-degenerate linear functions. It is cast in a stand-alone manner and
the rest of the thesis can be understood without reading this chapter.

In Chapter 4 , the basis for the security proofs of the following
chapters is laid by establishing the quantum min-entropic uncertainty
relations. The following Chapters 5 and 6 contain the quantum
definitions, protocols and security proofs for RabinOT and 1-2 OT ,
respectively. Chapter 7 treats quantum bit commitment. Two flavors of
the “binding property” are defined and the techniques from the two
previous chapters are used to prove security in the
bounded-quantum-storage model.

Chapter 8 is devoted to another application of the (second) uncertainty
relation, quantum key distribution against a quantum-memory-bounded
eavesdropper. The last Chapter 9 addresses some practical issues in
greater detail and concludes.

A short summary of the notation, the bibliography and an index can be
found at the end of the thesis.

### 1.5 Related Work

The classical bounded-storage model is described in Section 1.2 .
Besides work pointed out in the overview of the contributions in Section
1.3 above, it is worth mentioning that several protocols aiming at
achieving quantum oblivious transfer have been proposed. After Wiesner’s
original conjugate-coding protocol [ Wie83 ] , Bennett, Brassard,
Crépeau, and Skubiszewska proposed an interactive protocol for 1-2 OT [
BBCS91 ] , whose security was subsequently analyzed by Crépeau [ Cré94 ]
, Mayers, Salvail [ MS94 , May95 ] , and Yao [ Yao95 ] . The protocol
from [ BBCS91 ] is interactive and can be easily broken by a dishonest
receiver with unbounded quantum memory. To ensure that the receiver
actually performs a measurement, it was suggested to use (quantum)
bit-commitment schemes such as [ BCJL93 ] which were believed to be
secure against such adversaries at this point in time. After the
impossibility proofs of quantum bit-commitment by Lo and Chau [ LC97 ] ,
and Mayers [ May97 ] , and of oblivious transfer by Lo [ Lo97 ] , it
became clear that assumptions are necessary in order to securely realize
these primitives. Compared to these previous attempts, the protocols in
this thesis are simpler, non-interactive, and provably secure according
to stronger security definitions.

Work related to classical OT-reductions is referred to in the
introductory sections to Chapter 3 in Sections 3.1 and 3.4.1 . Previous
work about quantum uncertainty relations is described in Section 4.2 .

## Chapter 2 Preliminaries

In this chapter, we introduce notation and basic concepts used
throughout the rest of the thesis. In addition, most of the following
chapters have an individual preliminary section introducing concepts
that are exclusively used in those specific chapters.

This chapter does not give a thorough introduction to probability
theory, information theory and quantum information processing, but we
rather assume the reader familiar with the basic concepts from the
standard literature like [ CT91 , NC00 ] . Instead, we give a specific
overview of the concepts which are required for understanding this
thesis.

### 2.1 Notation and Basic Tools

For a sequence of variables @xmath , we use the abbreviation @xmath for
the collection of variables up to index @xmath , and we define @xmath to
be the empty string.

For a set @xmath and a @xmath -bit string @xmath , we define @xmath . It
is sometimes convenient that all substrings of this form have the same
length, irrespective of the actual size @xmath of the index set @xmath .
Therefore, we define the @xmath -bit string @xmath to be the original
substring padded with @xmath zeros.

Most logarithms in this thesis are with respect to base 2 and denoted by
@xmath . However, when needed, @xmath denotes the natural logarithm to
base @xmath .

We write @xmath for the ball of all @xmath -bit strings at Hamming
distance at most @xmath from @xmath . Note that the number of elements
in @xmath is the same for all @xmath , we denote it by @xmath . It is
well known that @xmath , where

  -- -------- --
     @xmath   
  -- -------- --

is the binary entropy function.

We denote by @xmath any function of @xmath smaller than the inverse of
any polynomial provided @xmath is sufficiently large.

If we want to choose two symbols @xmath or @xmath according to the bit
@xmath , we write @xmath . The Kronecker delta function is defined as

  -- -------- --
     @xmath   
  -- -------- --

The indicator random variable @xmath equals 1, if the event @xmath
occurs and @xmath else.

###### Definition 2.1 (convex/concave function)

A function @xmath is convex on the interval @xmath , if for any two
points @xmath and @xmath , it holds that

  -- -------- --
     @xmath   
  -- -------- --

Analogously, the function is concave on @xmath , if

  -- -------- --
     @xmath   
  -- -------- --

###### Lemma 2.2 (Jensen’s inequality)

Let @xmath be a convex function on @xmath and let @xmath . Let @xmath be
such that @xmath . Then,

  -- -------- --
     @xmath   
  -- -------- --

For @xmath , equality holds.

###### Lemma 2.3 (Cauchy-Schwarz inquality)

For real numbers @xmath and @xmath , the following holds

  -- -------- --
     @xmath   
  -- -------- --

{proof}

Note that @xmath is a quadratic polynomial @xmath without real roots
unless all @xmath are equal. Therefore, its discriminant @xmath is
non-positive:

  -- -------- --
     @xmath   
  -- -------- --

### 2.2 Probability Theory

For a discrete probability space @xmath , we write @xmath for the
probability of the event @xmath , and we write @xmath for the
distribution of the random variable @xmath taking values in the finite
set @xmath . As is common practice, we do not refer to the probability
space @xmath but leave it implicitly defined by the joint probabilities
of all considered events and random variables. For two random variables
@xmath and @xmath with joint distribution @xmath over @xmath , the
conditional probability distribution of @xmath given @xmath is defined
as @xmath for all @xmath and @xmath with @xmath . For a probability
distribution @xmath over @xmath , we abbreviate the (overall)
probability of a set @xmath with @xmath .

Let @xmath and @xmath be two probability distributions over the same
finite domain @xmath . The variational distance ¹ ¹ 1 also called
statistical or Kolmogorov distance @xmath between @xmath and @xmath is
defined as

  -- -------- --
     @xmath   
  -- -------- --

Note that this definition makes sense also for non-normalized
distributions, and indeed we define and use @xmath for arbitrary
positive-valued functions @xmath and @xmath with common domain. In case
@xmath is of the form @xmath , we can expand @xmath to @xmath . We write
@xmath to denote that @xmath and @xmath are @xmath -close, i.e., that
@xmath .

By we denote a uniformly distributed binary random variable independent
of anything else, such that @xmath for both @xmath , and @xmath stands
for @xmath independent copies of .

For a random variable @xmath over the reals @xmath , its expected value
is denoted by @xmath .

###### Lemma 2.4 (Markov’s inequality)

For a non-negative real random variable @xmath and @xmath , we have

  -- -------- --
     @xmath   
  -- -------- --

{proof}

For the indicator function @xmath which equals 1 if the event @xmath
occurs and 0 else, we observe that

  -- -------- --
     @xmath   
  -- -------- --

Taking the expected values on both sides, using linearity of the
expectation and rearranging the terms yields the claim.

###### Lemma 2.5 (Chernoff’s inequality)

Let @xmath be identically and independently distributed random variables
with Bernoulli distribution, i.e. @xmath with probability @xmath and
@xmath with probability @xmath . Then @xmath has binomial distribution
with parameters @xmath and it holds that

  -- -------- --
     @xmath   
  -- -------- --

See [ AS00 ] or [ MP95 ] for a proof.

### 2.3 Quantum Information Theory

In this section, we give a very brief introduction to the quantum
notions we use in this thesis, we refer to [ NC00 , Ren05 ] for further
explanations.

For any positive integer @xmath , @xmath stands for the complex Hilbert
space of dimension @xmath . Sometimes, we omit the dimension and simply
write @xmath . The state of a quantum-mechanical system in @xmath is
described by a density operator @xmath . A density operator @xmath is
normalized with respect to the trace norm ( @xmath ), Hermitian ( @xmath
) and has non-negative eigenvalues. @xmath denotes the set of all
density operators acting on @xmath . @xmath denotes the identity matrix
(describing the fully mixed state) renormalized by the appropriate
dimension.

A quantum state @xmath is called pure if it is of the form @xmath for a
(normalized) vector @xmath .

A positive operator-valued measurement (POVM) is a family @xmath of
non-negative operators such that @xmath equals the identity matrix. The
probability distribution @xmath obtained when applying the POVM @xmath
to the quantum state @xmath is defined as @xmath .

The general evolution (like unitary transforms, measurements, applying
noise etc.) of a quantum system in state @xmath can be described by a
quantum operation @xmath , which is a completely positive and
trace-preserving map, i.e. @xmath is linear and maps non-negative
normalized operators @xmath into non-negative normalized operators
@xmath .

The notion of (variational) distance of two random variables can be
naturally extended to the trace distance between two density operators
@xmath defined by @xmath , where we define @xmath to be the positive
square-root of @xmath . As in the classical case, we write @xmath to
denote that @xmath and @xmath are @xmath -close, i.e. @xmath . The trace
distance has an operational meaning in that the value @xmath is the
average success probability when distinguishing @xmath from @xmath via a
measurement. In fact, the relation to the classical variational distance
becomes evident in @xmath where the maximization is over all POVMs
@xmath and @xmath refers to the probability distribution obtained when
measuring @xmath using @xmath . Ruskai [ Rus94 ] showed that the trace
distance does not increase under (trace-preserving) quantum operations,
formally @xmath for any quantum operation @xmath .

The pair @xmath denotes the computational or rectilinear or “ @xmath ”
basis for the @xmath -dimensional Hilbert space @xmath . The diagonal or
“ @xmath ” basis is defined as @xmath where @xmath and @xmath . The
circular or “ @xmath ” basis consists of vectors @xmath and @xmath .
Measuring a qubit in the @xmath -basis (resp. @xmath -basis) means
applying the measurement described by projectors @xmath and @xmath
(resp. projectors @xmath and @xmath ). When the context requires it, we
write @xmath and @xmath instead of @xmath respectively @xmath . For a
@xmath -bit string @xmath , @xmath stands for the state @xmath and
analogous for @xmath .

As mentioned above, the behavior of a quantum state in a register @xmath
is fully described by its density matrix @xmath . We often consider
cases where a quantum state may depend on some classical random variable
@xmath , in that it is described by the density matrix @xmath if and
only if @xmath . For an observer who has only access to the register
@xmath but not to @xmath , the behavior of the state is determined by
the density matrix @xmath . The joint state, consisting of the c
lassical @xmath and the q uantum register @xmath and therefore called
cq-state , is described by the density matrix @xmath . In order to have
more compact expressions, we use the following notation. We write

  -- -------- --
     @xmath   
  -- -------- --

More general, for any event @xmath , we write

  -- -------- --
     @xmath   
  -- -------- --

We also write @xmath for the quantum representation of the classical
random variable @xmath (and similarly for @xmath ). This notation
extends naturally to quantum states that depend on several classical
random variables (i.e. to ccq-states, cccq-states etc.). Given a
cq-state @xmath as above, by saying that there exists a random variable
@xmath such that @xmath satisfies some condition, we mean that @xmath
can be understood as @xmath for a ccq-state @xmath that satisfies the
required condition.

Obviously, @xmath holds if and only if the quantum part is independent
of @xmath (in that @xmath for any @xmath ), where the latter in
particular implies that no information on @xmath can be learned by
observing only @xmath . Furthermore, if @xmath and @xmath are @xmath
-close in terms of their trace distance @xmath , then the real system
@xmath “behaves” as the ideal system @xmath except with probability
@xmath (as explained by Renner and König in [ RK05 ] ) in that for any
evolution of the system no observer can distinguish the real from the
ideal one with advantage greater than @xmath .

### 2.4 Entropies

#### 2.4.1 Classical Rényi Entropy

###### Definition 2.6

Let @xmath be a probability distribution over the finite set @xmath and
@xmath . The @xmath -order sum of the probability distribution @xmath is
defined as @xmath .

In the limits @xmath and @xmath , we set @xmath and @xmath .

###### Definition 2.7 (Rényi entropy [Rén61])

Let @xmath be a probability distribution over the finite set @xmath and
@xmath . The Rényi entropy of order @xmath is defined as

  -- -- --
        
  -- -- --

In the limit @xmath , we obtain the min-entropy @xmath and for @xmath ,
we obtain max-entropy @xmath . Another important special case is the
case @xmath , also known as collision probability @xmath and collision
entropy @xmath .

For the limit @xmath , we can use Jensen’s inequality (Lemma 2.2 ) with
@xmath to obtain

  -- -------- --
     @xmath   
  -- -------- --

In the limit @xmath , all @xmath go to 1 and therefore, equality holds
and we obtain the standard definition of Shannon entropy @xmath as in [
Sha48 ] .

For a random variable @xmath with probability distribution @xmath , we
will most often slightly abuse notation and use the common shortcut
@xmath instead of @xmath . For a fixed random variable @xmath over the
finite set @xmath , @xmath is a decreasing function on @xmath :

  -- -------- --
     @xmath   
  -- -------- --

with equality if and only if @xmath is uniform over a subset of @xmath .
Furthermore, we have that for @xmath , @xmath and therefore,

  -- -------- --
     @xmath   
  -- -------- --

which implies the following relation between Rényi entropies of order
@xmath :

  -- -------- -- -------
     @xmath      (2.1)
  -- -------- -- -------

##### Conditional Rényi entropy

The Rényi entropy @xmath of @xmath given the event @xmath is naturally
defined as @xmath . We can define the conditional @xmath -order sum of
@xmath given @xmath and conditional Rényi entropy by

  -- -------- -------- --
     @xmath   @xmath   
  -- -------- -------- --

In the limits we have, @xmath , @xmath . For the conditional min-,
collision- and max-entropy, we get

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

In the limit @xmath , we get @xmath and for @xmath , we get @xmath which
might be different. However, the standard definition of conditional
Shannon entropy is neither of those, but “in between”:

  -- -------- --
     @xmath   
  -- -------- --

We note that in the literature, @xmath is sometimes defined as average
over @xmath , @xmath , like for Shannon entropy. However, we define the
more natural following notion. For @xmath , we define the average
conditional Rényi entropy @xmath as

  -- -------- --
     @xmath   
  -- -------- --

and as @xmath for @xmath . This notion is useful in particular because
it has the property that if the average conditional Rényi entropy is
large, then the conditional Rényi entropy is large with high
probability:

###### Lemma 2.8

Let @xmath (allowing @xmath ) and @xmath . Then with probability at
least @xmath (over the choice of @xmath ) @xmath .

{proof}

By definition of average conditional Rényi entropy, we have

  -- -------- --
     @xmath   
  -- -------- --

By the Markov’s inequality (Lemma 2.4 ), we get that

  -- -------- --
     @xmath   
  -- -------- --

and therefore, the probability (over @xmath ) that @xmath is at most
@xmath .

As long as @xmath , the minimization (or average) over @xmath is the
same for all orders of Rényi entropy hence, Equation ( 2.1 ) translates
to (average) conditional Rényi entropy:

###### Lemma 2.9

For any @xmath , we have

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

##### Concavity

###### Lemma 2.10

For @xmath , Rényi Entropy is a concave entropic functional , i.e., for
@xmath and distributions @xmath , we have

  -- -------- --
     @xmath   
  -- -------- --

For the case of Shannon entropy, note that the function @xmath has
derivatives @xmath and @xmath and @xmath for @xmath . Therefore, @xmath
is concave and we have

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

Higher-order Rényi entropy is not necessarily concave as the following
example illustrates. Consider the distributions @xmath and @xmath over
@xmath with @xmath and @xmath . For the equal mixture of these
distributions holds @xmath for @xmath .

##### Fano’s Inequality

###### Lemma 2.11 (Fano’s Inequality)

Let @xmath be a Markov chain ² ² 2 Think of @xmath as guess of @xmath
based only on @xmath . . Then, for the error probability @xmath , it
holds

  -- -------- --
     @xmath   
  -- -------- --

{proof}

We denote by @xmath the indicator random variable of the event @xmath
that the guess was not successful. By the chain rule for Shannon
entropy, we can write

  -- -------- --
     @xmath   
  -- -------- --

We observe that @xmath , @xmath and

  -- -------- --
     @xmath   
  -- -------- --

and the claim follows by rearranging the terms.

#### 2.4.2 Smooth Rényi Entropy

Smooth min- and max-entropies were introduced by Renner and Wolf in [
Ren05 , RW05 ] ³ ³ 3 The notion of smoothing a probability distribution
was already used in [ ILL89 ] . Furthermore, a different kind of smooth
Rényi entropy (not equivalent to the ones used here) was introduced by
Cachin [ Cac97 ] . . They are families of entropy measures parametrized
by non-negative real numbers @xmath , called the smoothness . It is a
generalization of the notions of conditional min- and max-entropy
defined in the last section.

  -- -------- -------- --
     @xmath            
     @xmath   @xmath   
  -- -------- -------- --

where the maximum/minimum ranges over all events @xmath with probability
@xmath . @xmath is the probability that @xmath occurs and @xmath take
values @xmath . Hence, the “distribution” @xmath is not normalized.

For a given distribution @xmath , it is easy to compute its smooth
min-entropy (max-entropy), simply by cutting a maximum mass of @xmath
off the largest (smallest) probabilities.

Informally, the statement @xmath can be understood that the standard
min-entropy of @xmath is close to @xmath , except with probability
@xmath . As @xmath can be interpreted as an error probability, we
typically require @xmath to be negligible in the security parameter.

The reason why we only define the min- and max-versions of smooth Rényi
entropy is that it is shown in [ RW05 ] that for example smooth Rényi
entropy of order @xmath obeys

  -- -------- --
     @xmath   
  -- -------- --

and hence is equivalent to smooth min-entropy up to an additive term
which depends on @xmath and the smoothness @xmath . An analogue
statement holds for @xmath and smooth max-entropy. As pointed out in [
RW05 ] , for @xmath the relation above shows for example that @xmath
cannot be larger than @xmath whereas for the non-smooth versions, we
only know from Equation ( 2.1 ) that @xmath .

Most importantly, smooth min- and max-entropy have an operational
meaning as they provide the answer to two fundamental
information-theoretic problems:

-   @xmath is the maximum amount ⁴ ⁴ 4 up to some small additive error
    term which depends logarithmically on @xmath of randomness that can
    be extracted from @xmath and an independent random string @xmath ,
    such that except with probability @xmath , the extracted string
    looks completely uniform to an adversary who knows @xmath and learns
    @xmath . This falls into the setting of privacy amplification, see
    Section 2.5 below.

-   @xmath is the minimal length ⁴ ⁴ footnotemark: 4 of an encoding
    computed from @xmath and some additional independent randomness
    @xmath , such that except with probability @xmath , someone knowing
    @xmath and @xmath can reconstruct @xmath from the encoding. This is
    a data-compression problem which is often called information
    reconciliation or error correction in cryptographic settings.

In [ RW05 ] , it is shown that smooth min- and max-entropies enjoy
several Shannon-like properties such as the chain rule (see Lemma 2.12
below), sub-additivity @xmath and monotonicity @xmath .

###### Lemma 2.12 (Chain Rule [Rw05])

For all @xmath , we have

  -- -- --
        
  -- -- --

As a consequence of the asymptotic equipartition property (cf. [ CT91 ]
), smooth Rényi entropy is asymptotically equal to Shannon entropy in
the following sense.

###### Lemma 2.13 ([Rw05, Hr06])

Let @xmath be @xmath independent pairs of random variables distributed
according to @xmath . Then, for any @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

Note that such a lemma does not hold at all for non-smooth Rényi
entropies.

To provide some intuition about smooth min-entropy, the following lemma
shows how to translate smooth min-entropy back to regular conditional
min-entropy.

###### Lemma 2.14

If @xmath then there exists an event @xmath such that @xmath and @xmath
for every @xmath with @xmath .

{proof}

By definition of smooth min-entropy, there exists an event @xmath with
@xmath and such that @xmath for all @xmath , and thus @xmath @xmath for
all @xmath and @xmath . Define @xmath by setting for all @xmath and
@xmath

  -- -------- --
     @xmath   
  -- -------- --

Then obviously for any @xmath with @xmath and thus @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

Furthermore,

  -- -------- -------- -- -------
     @xmath   @xmath      
              @xmath      
              @xmath      (2.2)
              @xmath      
  -- -------- -------- -- -------

from which follows that @xmath . Thus we can conclude that

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

where the second-last inequality follows from ( 2.2 ), and noting (once
more) that @xmath .

#### 2.4.3 Min-Entropy-Splitting Lemma

For proving reductions between variants of oblivious transfer in Section
3.4 and the security of 1-2 OT in the bounded-quantum storage in Chapter
6 , we will make use of the following min-entropy splitting lemma. Note
that if the joint entropy of two random variables @xmath and @xmath is
large, then one is tempted to conclude that at least one of @xmath and
@xmath must still have large entropy, e.g. half of the original entropy.
Whereas this is indeed true for Shannon entropy, it is in general not
true for min-entropy. The following lemma, though, which first appeared
in a preliminary version of [ Wul07 ] , shows that it is true in a
randomized sense.

###### Lemma 2.15 (Min-Entropy-Splitting Lemma)

Let @xmath , and let @xmath be random variables with @xmath Then, there
exists a random variable @xmath such that @xmath .

{proof}

Below, we give the proof for @xmath , i.e., for ordinary (non-smooth)
min-entropy. The general claim for smooth min-entropy follows
immediately by observing that the same argument also works for
non-normalized distributions with a total probability smaller than 1.

We extend the probability distribution @xmath as follows to @xmath . Let
@xmath if @xmath and @xmath otherwise. We have that for all @xmath ,
@xmath either vanishes or is equal to @xmath . In any case, @xmath .

On the other hand, for all @xmath with @xmath , we have that @xmath and
therefore, for all @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

Summing over all @xmath with @xmath , and thus with @xmath , results in

  -- -------- --
     @xmath   
  -- -------- --

This shows that @xmath for all @xmath .

The corollary below follows rather straightforwardly by noting that (for
normalized as well as non-normalized distributions) @xmath holds exactly
if @xmath for all @xmath , applying the Min-Entropy Splitting Lemma, and
then using the chain rule, Lemma 2.12 .

###### Corollary 2.16

Let @xmath be given, and let @xmath be random variables with @xmath .
Then, there exists a binary random variable @xmath such that for @xmath
,

  -- -------- --
     @xmath   
  -- -------- --

#### 2.4.4 Entropy of Quantum States

As pointed out in [ RK05 ] , Rényi entropy @xmath can also be defined
for a quantum state @xmath . For @xmath and @xmath , we have

  -- -- --
        
  -- -- --

In the limit cases @xmath and @xmath , we obtain @xmath and @xmath ,
where @xmath denotes the maximum eigenvalue of @xmath . For @xmath , we
obtain the collision entropy @xmath , where @xmath are the eigenvalues
of @xmath .

For a classical random variable @xmath encoded in @xmath , it holds that
that @xmath .

For deriving our version of the privacy-amplification theorem in the
next section, we need the slightly more involved version of quantum
conditional min-entropy from [ Ren05 ] .

###### Definition 2.17 ([Ren05])

Let @xmath and @xmath . The min-entropy of @xmath relative to @xmath is

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the minimum real number such that @xmath is
non-negative.

The min-entropy of @xmath given @xmath is

  -- -------- --
     @xmath   
  -- -------- --

where the supremum ranges over all @xmath .

Similar to the classical case, the smooth version can be defined as
follows.

###### Definition 2.18 ([Ren05])

Let @xmath , @xmath , and @xmath . The @xmath -smooth min-entropy of
@xmath relative to @xmath is

  -- -------- --
     @xmath   
  -- -------- --

where the supremum ranges over the set @xmath containing all Hermitian,
non-negative operators @xmath acting on @xmath such that @xmath and
@xmath .

The @xmath -smooth min-entropy given @xmath is

  -- -------- --
     @xmath   
  -- -------- --

where the supremum ranges over all @xmath .

To compute @xmath where @xmath is a cq-state, the supremum can be
restricted to states @xmath which are classical on @xmath as well [
Ren05 , Remark 3.2.4] .

There is a chain rule for smooth min-entropy, proven in [ Ren05 , Lemma
3.2.9] .

###### Lemma 2.19 ([Ren05])

Let @xmath , @xmath , and let @xmath be the fully mixed state on the
image of @xmath , and let @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

The following two lemmas state that dropping a quantum register cannot
increase the (smooth) min-entropy.

###### Lemma 2.20

Let @xmath be a ccq-state. Then,

  -- -------- --
     @xmath   
  -- -------- --

{proof}

For @xmath , we have by Definition 2.17 that @xmath . Using that both
@xmath and @xmath are classical, we derive that for all @xmath , it
holds @xmath , where @xmath and @xmath are shortcuts for the
probabilities @xmath and @xmath . Let the normalized conditional
operator @xmath be the quantum state conditioned on the event that
@xmath and @xmath , i.e.

  -- -------- --
     @xmath   
  -- -------- --

Then,

  -- -------- --
     @xmath   
  -- -------- --

Because of @xmath , we get

  -- -------- --
     @xmath   
  -- -------- --

Therefore, @xmath holds, from which follows by definition that @xmath .

###### Lemma 2.21

Let @xmath be a ccq-state and let @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

{proof}

After the remark after Definition 2.18 above, there exists @xmath
classical on @xmath such that @xmath . Because both @xmath and @xmath
are classical, we can write @xmath and extend it to obtain @xmath .
Lemma 2.20 from above yields @xmath . We have by construction that
@xmath . Therefore, @xmath and @xmath

### 2.5 Two-Universal Hashing and Privacy Amplification against Quantum
Adversaries

#### 2.5.1 History and Setting of Privacy Amplification

Assume two parties Alice and Bob share some information @xmath which is
only partly secure in the sense that an adversary Eve has some partial
knowledge about it. Privacy Amplification , introduced by Bennett,
Brassard, and Robert [ BBR88 ] , is the art of transforming this
information @xmath into a highly secure key @xmath by public discussion.
The honest parties want to end up with an almost uniformly distributed
key @xmath about which Eve has only negligible information given the
communication.

A common way to achieve this is to have Alice pick a hash function
@xmath at random from a two-universal class of hashing functions (see
next section for the definition), apply it to @xmath and announce it to
Bob, who applies it to @xmath as well. Due to the randomizing properties
of a two-universal function, the output @xmath is close to uniformly
distributed from Eve’s point of view. As shown in [ BBR88 ] and by
Impagliazzo, Levin, Luby [ ILL89 ] and Bennett, Brassard, Crépeau, and
Maurer [ BBCM95 ] , the classical privacy amplification theorem or
left-over hash lemma (see Corollary 2.27 below) states that if Eve has
some classical knowledge @xmath about @xmath , a secure key of length
roughly the uncertainty of Eve about @xmath (measured in terms of
min-entropy) can be extracted by two-universal hashing. It is pointed
out in [ RW05 ] , that the maximum amount of extractable randomness is
essentially given by the conditional smooth min-entropy @xmath .

It is interesting to investigate the case when Eve holds quantum
information about @xmath . This scenario has been considered by König,
Maurer, and Renner [ KMR05 , RK05 , Ren05 ] and the results reproduced
below show that two-universal hashing works just as well against quantum
as against classical adversaries.

We note that unlike in the classical case, where many other forms of
randomness extractors are known, two-universal hashing is essentially
the only way to perform privacy amplification against quantum
adversaries. ⁵ ⁵ 5 In a recent paper, König and Terhal [ KT06 ] exhibit
some extractors which work against quantum adversaries, but the
parameters are far from the classical ones. This tool is one of the key
ingredients in all protocols presented in this thesis. It has been
widely used in other applications as well, for example in security
proofs of quantum-key-distribution schemes by Christandl, Renner, Ekert,
Kraus, and Gisin [ CRE04 , KGR05 , RGK05 , Ren05 ] .

#### 2.5.2 Two-Universal Hashing

An important tool we use is two-universal hashing.

###### Definition 2.22

A class @xmath of hashing functions from @xmath to @xmath is called
two-universal , if for any pair @xmath with @xmath , and @xmath
uniformly chosen from @xmath , it holds that

  -- -------- --
     @xmath   
  -- -------- --

We can also define a slightly stronger notion of two-universality as
follows:

###### Definition 2.23

A class @xmath of hashing functions from @xmath to @xmath is called
strongly two-universal , if for any pair @xmath with @xmath , and @xmath
uniformly chosen from @xmath , the random variables @xmath and @xmath
are independent and uniformly distributed over @xmath .

Several two-universal and strongly two-universal classes of hashing
functions are such that evaluating and picking a function uniformly and
at random in @xmath can be done efficiently, as pointed out by Wegman
and Carter [ CW77 , WC79 ] .

#### 2.5.3 Privacy Amplification against Quantum Adversaries

In the following, we consider the situation where a hash function is
picked randomly from @xmath and applied to a classical value @xmath
which is correlated with a quantum register @xmath . Formally, starting
with the cq-state @xmath , we obtain

  -- -------- -- -------
     @xmath      (2.3)
  -- -------- -- -------

The following privacy-amplification theorem in the presence of quantum
adversaries was first derived in [ RK05 ] . The version below is from [
Ren05 , Corollary 5.6.1] ⁶ ⁶ 6 Note that in [ Ren05 ] , the distance
from uniform is defined in terms of the trace-norm distance which is
twice the variational distance used in this thesis. .

###### Theorem 2.24 (Privacy Amplification [Ren05])

Let @xmath be a cq-state, where @xmath takes values in @xmath . Let
@xmath be a two-universal family of hash functions from @xmath to @xmath
, and let @xmath . Then, for the ccq-state @xmath defined by ( 2.3 ), it
holds

  -- -------- --
     @xmath   
  -- -------- --

For large parts of this thesis, slightly weaker forms of this theorem
are used. These are derived in the following.

###### Corollary 2.25

Let @xmath be a ccq-state, where @xmath takes values in @xmath , @xmath
in the finite domain @xmath and register @xmath contains q qubits. Let
@xmath be a two-universal family of hash functions from @xmath to @xmath
, and let @xmath . Then, for the cccq-state @xmath defined analogous to
( 2.3 ), it holds

  -- -------- -------- -- -------
     @xmath   @xmath      (2.4)
  -- -------- -------- -- -------

Recall that by the definition of the trace-distance, we have that if the
rightmost term of ( 2.4 ) is negligible, i.e. say smaller than @xmath ,
then this situation is @xmath -close to the ideal situation where @xmath
is perfectly uniform and independent of @xmath and @xmath . In
particular, replacing @xmath by an independent and uniformly distributed
bit results in a common state which essentially cannot be distinguished
from the original one.

{proof}

In our case, the quantum register @xmath from Theorem 2.24 consists of a
classical part @xmath and a quantum part @xmath . Denoting by @xmath the
fully mixed state on the image of @xmath , we only need to consider the
term in the exponent to derive Theorem 2.25 as follows

  -- -------- -------- -- -------
     @xmath   @xmath      
              @xmath      (2.5)
              @xmath      (2.6)
              @xmath      
  -- -------- -------- -- -------

The first inequality follows by Definition 2.18 of @xmath as supremum
over all @xmath . Inequality ( 2.5 ) is the chain rule for smooth
min-entropy (Lemma 2.19 ). Inequality ( 2.6 ) uses that the smooth
min-entropy cannot decrease when dropping the quantum register which is
proven in Lemma 2.21 from the last section. The last step follows by
assumption about the quantum register and observing that the state
@xmath is classical and the quantum Definition 2.18 therefore reduces to
classical smooth min-entropy.

The following corollary is a direct consequence of Corollary 2.25 . In
Chapter 7 , this lemma will be useful for proving the binding condition
of our commitment scheme. Recall that for @xmath , @xmath denotes the
set of all @xmath -bit strings at Hamming distance at most @xmath from
@xmath and @xmath is the number of such strings.

###### Corollary 2.26

Let @xmath be a ccq-state, where @xmath takes values in @xmath , @xmath
in the finite domain @xmath and register @xmath contains @xmath qubits.
Let @xmath be a guess for @xmath obtained by learning @xmath and
measuring @xmath , and let @xmath . Then, for all @xmath it holds that

  -- -------- --
     @xmath   
  -- -------- --

In other words, given some classical knowledge @xmath and a quantum
memory of @xmath qubits arbitrarily correlated with a classical random
variable @xmath , the probability to find @xmath at Hamming distance at
most @xmath from @xmath where @xmath is small. {proof} Here is a
strategy to try to bias @xmath when given @xmath and @xmath : Sample
@xmath and output @xmath . Note that, using @xmath as a short hand for
the probability @xmath to be bounded,

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

where the first equality follows from the fact that if @xmath then, as
@xmath is two-universal, @xmath . Note that, given @xmath and @xmath and
being allowed to measure @xmath , the probability of correctly guessing
a binary @xmath is upper bounded by @xmath [ FvdG99 ] . In combination
with Corollary 2.25 (with @xmath ) the above results in

  -- -------- --
     @xmath   
  -- -------- --

and the claim follows by rearranging the terms.

#### 2.5.4 Classical Privacy Amplification

The classical privacy-amplification theorem follows as special case from
the results above. When there is no quantum correlation, we (almost)
recover the well-known classical left-over hash lemma [ ILL89 , BBCM95 ,
HILL99 ] :

###### Corollary 2.27

Let @xmath be a random variable over @xmath , and let @xmath denote the
uniform choice of a hash function in a two-universal family of hash
functions @xmath mapping from @xmath to @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

This corollary (with collision- instead of min-entropy in the exponent
on the right-hand side) cannot immediately be derived from Theorem 2.24
above, but rather from its proof in [ Ren05 ] . The reason for this is
that the easiest way of proving both Theorem 2.24 and Corollary 2.27 is
by directly considering collision entropy instead of min-entropy. On the
other hand, relaxing the notion of collision entropy to smooth
min-entropy gives the natural operative meaning (see Section 2.4.2 ) and
interestingly, it only looks like we are losing something by doing that,
but in fact this achieves optimality [ RW05 ] .

## Chapter 3 Classical Oblivious Transfer

Most of the results presented in this chapter are published in [ DFSS06
] .

### 3.1 Introduction and Outline

As already mentioned in Section 1.1 , 1-out-of-2 Oblivious-Transfer, 1-2
OT for short, is a two-party primitive which allows a sender to send two
bits (or, more generally, strings) @xmath and @xmath to a receiver, who
is allowed to learn one of the two according his choice @xmath .
Informally, it is required that the receiver only learns @xmath but not
@xmath (what we call security for the honest sender, hence
sender-security ), while at the same time the sender does not learn
@xmath ( receiver-security ). Interestingly, 1-2 OT was introduced by
Wiesner around 1970 (but only published much later [ Wie83 ] ) under the
name of “multiplexing” in the context of quantum cryptography, and,
inspired by [ Rab81 ] where a different flavor was introduced, later
re-discovered by Even, Goldreich and Lempel [ EGL82 ] .

1-2 OT turned out to be very powerful as Kilian [ Kil88 ] showed it to
be sufficient for secure general two-party computation. For this reason,
much effort has been put into reducing 1-2 OT to seemingly weaker
flavors of OT , like RabinOT , 1-2 XOT , etc. [ Cré87 , BC97 , Cac98 ,
Wol00 , BCW03 , CS06 ] .

In this chapter, we focus on a slightly modified notion of 1-2 OT ,
which we call Randomized 1-2 OT , Rand1-2OT for short, where the bits
(or strings) @xmath and @xmath are not in put by the sender, but
generated uniformly at random during the Rand1-2OT and then out put to
the sender. It is still required that the receiver only learns the bit
(or string) of his choice, @xmath , whereas the sender does not learn
any information on @xmath . It is obvious that a Rand1-2OT can easily be
turned into an ordinary 1-2 OT simply by using the generated @xmath and
@xmath to mask the actual input bits (or strings). Furthermore, all
known constructions of unconditionally secure 1-2 OT protocols make
implicitly the detour via Rand1-2OT .

In a first step, we observe that the sender-security condition of a
Rand1-2OT of bits is equivalent to requiring the XOR @xmath to be close
to uniformly distributed from the receiver’s point of view. The proof is
very simple, and it is kind of surprising that—to the best of our
knowledge—this has not been realized before. We then ask and answer the
question whether there is a natural generalization of this result to
Rand1-2OT of strings . Note that requiring the bit wise XOR of the two
strings to be uniformly distributed is obviously not sufficient. We show
that the sender-security for Rand1-2OT of strings can be characterized
in terms of non-degenerate linear functions (bivariate binary linear
functions which non-trivially depend on both arguments, as defined in
Definition 3.3 ): sender-security holds if and only if the result of
applying any non-degenerate linear function to the two strings is (close
to) uniformly distributed from the receiver’s point of view.

We then show the usefulness of this new understanding of 1-2 OT . We
demonstrate this on the problem of reducing 1-2 OT to weaker primitives.
Concretely, we show that the reducibility of an ordinary 1-2 OT to
weaker flavors via a non-interactive reduction follows by a trivial
argument from our characterization of sender-security. This is in sharp
contrast to the current literature: The proofs given by Brassard,
Crépeau and Wolf [ BC97 , Wol00 , BCW03 ] for reducing 1-2 OT to 1-2 XOT
, 1-2 GOT and 1-2 UOT (we refer to Section 3.4 for a description of
these flavors of OT ) are rather complicated and tailored to a
particular class of privacy-amplifying hash functions; whether the
reductions also work for a less restricted class is left as an open
problem [ BCW03 , page 222] . And, the proof given by Cachin [ Cac98 ]
for reducing 1-2 OT to one execution of a general UOT is not only
complicated, but also incorrect, as we will point out. Thus, our
characterization of the condition for sender-security allows to simplify
existing reducibility proofs and, along the way, to solve the open
problem posed in [ BCW03 ] , as well as to improve the reduction
parameters in most cases, but it also allows for new, respectively until
now only incorrectly proven reductions. In recent work by Wullschleger [
Wul07 ] , the analysis of these reductions is further improved.

Furthermore, we extend our result and show how our characterization of
Rand1-2OT in terms of non-degenerate linear functions translates to 1-n
OT .

As historical side note, we note that the original motivation for
characterizing sender-security with the help of NDLFs was to prove
sender-security of the quantum protocol for 1-2 OT described in Chapter
6 . We point out by an example in Section 3.6 at the end of this chapter
why this approach does not work.

### 3.2 Defining 1-2Ot

#### 3.2.1 Randomized 1-2Ot of Bits

Formally capturing the intuitive understanding of the security of 1-2 OT
is a non-trivial and subtle task. For instance requiring the sender’s
view to be independent of the receiver’s choice bit @xmath is too strong
a requirement, since his input might already depend on @xmath . The best
one can hope for is that his view is independent of @xmath conditioned
on his input @xmath . Security against a dishonest receiver is even more
subtle. We refer to the security definition by Crépeau, Savvides,
Schaffner and Wullschleger of [ CSSW06 ] , where it is argued that this
definition is the ‘‘right” way to define unconditionally secure 1-2 OT .
In their model, a secure 1-2 OT protocol is as good as an ideal 1-2 OT
functionality.

In this thesis, we will mainly focus on a slight modification of 1-2 OT
, which we call Randomized 1-2 OT (although sender- randomized 1-2 OT
would be a more appropriate, but also rather lengthy name). A Randomized
1-2 OT , or Rand1-2OT for short, essentially coincides with an ordinary
1-2 OT , except that the two bits @xmath and @xmath are not input by the
sender but generated uniformly at random during the protocol and output
to the sender. This is formalized in Definition 3.1 below.

There are two main justifications for focusing on Rand1-2OT . First, an
ordinary 1-2 OT can easily be constructed from a Rand1-2OT : the sender
can use the randomly generated @xmath and @xmath to one-time-pad encrypt
his input bits for the 1-2 OT , and send the masked bits to the receiver
(as first realized by Beaver [ Bea95 ] ). For a formal proof of this we
refer to the full version of [ CSSW06 ] . And second, all
information-theoretically secure constructions of 1-2 OT protocols we
are aware of in fact do implicitly build a Rand1-2OT and use the above
reduction to achieve 1-2 OT .

We formalize Rand1-2OT in such a way that it minimizes and simplifies as
much as possible the security restraints, while at the same time
remaining sufficient for 1-2 OT .

###### Definition 3.1 (Rand1-2OT)

An @xmath -secure Rand1-2OT is a protocol between sender @xmath and
receiver @xmath , with @xmath having input @xmath (while @xmath has no
input), such that for any distribution of @xmath , the following
properties hold:

 @xmath  -Correctness:  

     For honest @xmath and @xmath , @xmath has output @xmath and @xmath
    has output @xmath , except with probability @xmath .

 @xmath  -Receiver-security:  

     For honest @xmath and any (dishonest) @xmath with output @xmath ,

      -- -------- --
         @xmath   
      -- -------- --

 @xmath  -Sender-security:  

     For honest @xmath and any (dishonest) @xmath with output @xmath ,
    there exists a binary random variable @xmath such that

      -- -------- --
         @xmath   
      -- -------- --

The condition for receiver-security simply says that @xmath learns no
information on @xmath , and sender-security requires that there exists a
choice bit @xmath , supposed to be @xmath , such that when given the
choice @xmath and the corresponding bit @xmath , then the other bit,
@xmath , is completely random from @xmath ’s point of view.

We would like to point out that the definition of Rand1-2OT given in [
CSSW06 ] look syntactically slightly different than our Definition 3.1 .
However, it is not hard to see that they are actually equivalent. The
main difference is that the definition in [ CSSW06 ] involves an
auxiliary input @xmath , which is given to the dishonest player, and
receiver- and sender-security as we define them are required to hold
conditioned on @xmath for any @xmath . Considering a constant @xmath
immediately proves one direction of the claimed equivalence, and the
other follows from the observation that if receiver- and sender-security
as we define them hold for any distribution @xmath (respectively @xmath
), then they also hold for the conditional distribution @xmath
(respectively @xmath ). The other difference is that in [ CSSW06 ] , in
the condition for sender-security of Rand1-2OT , @xmath is required to
be random and independent of @xmath , @xmath , @xmath and @xmath . This
of course implies our sender-security condition (which is without @xmath
), but it is also implied by our definition as @xmath may be part of the
output @xmath . We feel that simplifying the definitions as we do,
without changing their meaning, allows for an easier handling.

#### 3.2.2 Randomized 1-2Ot of Strings

In a 1-2 String OT the sender inputs two strings of the same length, and
the receiver is allowed to learn one and only one of the two. Formally,
for any positive integer @xmath , 1-2 OT @xmath and Rand1-2OT @xmath can
be defined along the same lines as 1-2 OT and Rand1-2OT of bits : the
binary random variables @xmath and @xmath as well as in Definition 3.1
are simply replaced by random variables @xmath and @xmath and @xmath
with range @xmath .

### 3.3 Characterizing Sender-Security

#### 3.3.1 The Case of Bit Ot

It is well known and it follows from sender-security that in a ( Rand )
1-2 OT the receiver @xmath should in particular learn essentially no
information on the XOR @xmath of the two bits. The following proposition
shows that this is not only necessary for sender-security but also
sufficient .

###### Theorem 3.2

The condition for @xmath -sender-security for a Rand1-2OT is satisfied
for a particular (possibly dishonest) receiver @xmath with output @xmath
if and only if

  -- -------- --
     @xmath   
  -- -------- --

Before going into the proof which is surprisingly simple, consider the
following example. Assume a candidate protocol for Rand1-2OT and a
dishonest receiver @xmath which is able to output @xmath if @xmath ,
@xmath if @xmath and @xmath or @xmath with probability @xmath each in
case @xmath . Then, it is easy to see that conditioned on, say, @xmath ,
@xmath is @xmath with probability @xmath , and @xmath and @xmath each
with probability @xmath , such that the condition on the XOR from
Theorem 3.2 is satisfied. On the other hand, neither @xmath nor @xmath
is uniformly distributed conditioned on @xmath , and it appears as if
the receiver has some joint information on @xmath and @xmath which is
forbidden by a ( Rand ) 1-2 OT . But that is not so. Indeed, the same
view can be obtained when attacking an ideal Rand1-2OT : submit a random
bit @xmath to obtain @xmath and output @xmath . In the light of
Definition 3.1 , if @xmath we can split the event @xmath into two
disjoint subsets (subevents) @xmath and @xmath such that each has
probability @xmath , and we define @xmath by setting @xmath if @xmath or
@xmath , and @xmath if @xmath or @xmath . Then, obviously, conditioned
on @xmath , the bit @xmath is uniformly distributed, even when given
@xmath . The corresponding holds if @xmath .

{proof}

The “only if” implication is well-known and straightforward. For the
“if” implication, we first argue the perfect case where @xmath . For any
value @xmath with @xmath , the non-normalized distribution @xmath can be
expressed as depicted in the left table of Figure 3.1 , where we write
@xmath for @xmath , @xmath for @xmath , @xmath for @xmath and @xmath for
@xmath . Note that @xmath and, by assumption, @xmath . Due to symmetry,
we may assume that @xmath . We can then define @xmath by extending
@xmath to @xmath as depicted in the right two tables in Figure 3.1 :
@xmath , @xmath etc. Important to realize is that @xmath is indeed a
valid extension since by assumption @xmath .

It is now obvious that @xmath as well as @xmath . This finishes the
perfect case.

Concerning the general case, the idea is the same as above, except that
one has to take some care in handling the error parameter @xmath . As
this does not give any new insight, and we anyway state and fully prove
a more general result in Theorem 3.6 , we skip this part of the proof. ¹
¹ 1 Although the special case @xmath in Theorem 3.6 is quantitatively
slightly weaker than Theorem 3.2 .

#### 3.3.2 The Case of String Ot

The obvious question after the previous section is whether there is a
natural generalization of Theorem 3.2 to 1-2 OT @xmath for @xmath . Note
that the straightforward generalization of the XOR-condition in Theorem
3.2 , requiring that any receiver has no information on the bit-wise XOR
of the two strings, is clearly too weak, and does not imply
sender-security for Rand1-2OT @xmath : for instance the receiver could
know the first half of the first string and the second half of the
second string.

##### The Characterization

Let @xmath be an arbitrary positive integer.

###### Definition 3.3

A function @xmath is called a non-degenerate linear function (NDLF) if
it is of the form

  -- -------- --
     @xmath   
  -- -------- --

for two non-zero @xmath , i.e., if it is linear and non-trivially
depends on both input strings.

Even though this is the main notion we are using, the following more
relaxed notion allows to make some of our claims slightly stronger.

###### Definition 3.4

A binary function @xmath is called 2-balanced if for any @xmath the
functions @xmath and @xmath are balanced in the usual sense, meaning
that @xmath and @xmath .

The following is easy to see and the proof is omitted.

###### Lemma 3.5

Every non-degenerate linear function is 2-balanced.

In case @xmath , the XOR is a NDLF and thus 2-balanced, and it is the
only NDLF and up to addition of a constant the only 2-balanced function.
Based on this notion of non-degenerate linear functions, sender-security
of Rand1-2StringOT can be characterized as follows.

###### Theorem 3.6

The condition of @xmath -sender-security for a Rand1-2OT @xmath is
satisfied for a particular (possibly dishonest) receiver @xmath with
output @xmath if

  -- -------- --
     @xmath   
  -- -------- --

for every NDLF @xmath , and, on the other hand, @xmath -sender-security
may be satisfied only if @xmath for every NDLF @xmath .

The number of NDLFs is exponential in @xmath , namely @xmath .
Nevertheless, we show in Section 3.4 that this characterization turns
out to be very useful. There, we will also argue that an exponential
overhead in @xmath in the sufficient condition is unavoidable. The proof
of Theorem 3.6 also shows that the set of NDLFs forms a minimal set of
functions among all sets that imply sender-security. In this sense, our
characterization is tight.

At first glance, Theorem 3.6 appears to be related to the so-called
(information-theoretic) XOR-Lemma, commonly attributed to Vazirani [
Vaz86 ] and nicely explained by Goldreich [ Gol95 ] , which states that
a string is close to uniform if the XOR of the bits of any non-empty
substring are. As far as we can see, neither follows Theorem 3.6 from
the XOR-Lemma in an obvious way nor can it be proven by modifying the
proof of the XOR-Lemma, as given in [ Gol95 ] .

Furthermore, we would like to point out that Theorem 4 in [ BCW03 ] also
provides a tool to analyze sender-security of 1-2 OT protocols in terms
of linear functions; however, the condition that needs to be satisfied
is much stronger than for our Theorem 3.6 : it additionally requires
that one of the two strings is a priori uniformly distributed from the
receiver’s point of view. ² ² 2 Concretely, it is additionally required
that every non-trivial parity of that string is uniform, but by the
XOR-Lemma this is equivalent to the whole string being uniform. This
difference is crucial, because showing that one of the two strings is
uniform (conditioned on the receiver’s view) is usually technically
involved and sometimes not even possible, as the example given after
Theorem 3.2 shows. This is also demonstrated by the fact that the
analysis in [ BCW03 ] of the considered 1-2 OT protocol is tailored to
one particular class of privacy-amplifying hash functions, and it is
stated as an open problem how to prove their construction secure when a
different class of hash functions is used. The condition for Theorem 3.6
, on the other hand, is naturally satisfied for typical constructions of
1-2 OT protocols, as we shall see in Section 3.4 . As a result, Theorem
3.6 allows for much simpler and more elegant security proofs for 1-2 OT
protocols, and, as a by-product, allows to solve the open problem from [
BCW03 ] . We explain this in detail in Section 3.4 , and the interested
reader may well jump ahead and save the proof of Theorem 3.6 for later.

##### Proof of Theorem 3.6 (“only if” part)

We start with the proof for the “only if” part of Theorem 3.6 . In fact,
a slightly stronger statement is shown, namely that @xmath
-sender-security implies @xmath for any 2-balanced function.

According to Definition 3.1 , @xmath -sender-security for Rand1-2OT is
satisfied for a receiver @xmath with output @xmath if there exists a
random variable @xmath with range @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

In order to upper bound

  -- -------- --
     @xmath   
  -- -------- --

we expand the terms on the right hand side as follows.

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

and

  -- -------- --
     @xmath   
  -- -------- --

where the last equality holds because there are @xmath values for @xmath
such that @xmath , as @xmath is a 2-balanced function. Using those two
expansions we conclude that

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

where the first inequality follows follows from the above expansions and
the triangle inequality and the last inequality is our initial
assumption. \qed

The “if” part, which is the interesting direction, is proven below.

##### The Case @xmath

We feel that in order to understand the proof of Theorem 3.6 , it is
useful to first consider the case @xmath . Let us focus on trying to
develop a condition that is sufficient for perfect sender-security. Fix
an arbitrary output @xmath , and consider an arbitrary non-normalized
probability distribution @xmath of @xmath and @xmath when @xmath . This
is depicted in the left table of Figure 3.2 , where we write @xmath for
@xmath , @xmath for @xmath , etc. We may assume that @xmath . We now
extend this distribution to @xmath similar as in the proof of Theorem
3.2 . This is depicted in the two right tables in Figure 3.2 . We verify
what conditions @xmath must satisfy such that @xmath is indeed a valid
extension, i.e., that @xmath .

For instance, looking at the second row and second column we get
equation @xmath . Altogether, we get the following system of equations.

  -- -------- -------- -------- -------- -------- -------- --
     @xmath   @xmath   @xmath   @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   @xmath   @xmath   @xmath   
  -- -------- -------- -------- -------- -------- -------- --

Note that if all these equations do hold for any @xmath , then @xmath is
well defined and satisfies @xmath and @xmath , in other words, perfect
sender-security holds.

The idea now is to show that the above equation system is equivalent to
another equation system, in which every equation expresses that a
certain NDLF applied to @xmath and @xmath is uniformly distributed when
@xmath , which holds by assumption.

For example, by adding all the equations in the original system while
taking every second equation with negative sign, one gets the equation

  -- -------- --
     @xmath   
  -- -------- --

Define the function @xmath as follows. Let @xmath be @xmath if the entry
which corresponds to @xmath in the left table in Figure 3.2 appears on
the left hand side of the above equation, and else we let @xmath be
@xmath . Then the above equation simply says that @xmath with the same
probability as @xmath (when @xmath ). Note that it is crucial that in
the above equation every variable @xmath up to @xmath occurs with
multiplicity exactly 1. By comparing the function tables, it is now easy
to verify that @xmath coincides with the function @xmath , where @xmath
denotes the second coordinate of @xmath , thus is a NDLF.

One can now show (and we are going to do this below for an arbitrary
@xmath ) that there are enough such equations, corresponding to NDLFs,
such that these equations imply the original ones. This implies that if
@xmath is distributed uniformly and independently of @xmath for every
NDLF @xmath , then the original equation system is satisfied (for any
@xmath ), and thus @xmath is well-defined.

##### Proof of Theorem 3.6 (“if” part).

First, we consider the perfect case: if @xmath equals @xmath for every
NDLF @xmath , then sender-security for Rand 1-2 OT @xmath holds
perfectly.

###### The Perfect Case:

Since the case @xmath is already settled, we assume that @xmath . We
generalize the idea from the case @xmath . The main issue will be to
transform the equations guaranteed by the assumption on the linear
functions into the ones required for @xmath .

Fix an arbitrary output @xmath of the receiver, and consider the
non-normalized probability distribution @xmath . We use the variable
@xmath to refer to @xmath , and we write for the all-zero string @xmath
. We assume that @xmath for any @xmath ; we show later that we may do
so. We extend this distribution to @xmath by setting

  -- -------- -- -------
     @xmath      (3.1)
  -- -------- -- -------

for any strings @xmath , and we collect the equations resulting from the
condition that @xmath needs to be satisfied: for any two @xmath

  -- -------- -- -------
     @xmath      (3.2)
  -- -------- -- -------

If all these equations do hold for any @xmath , then as in the case of
@xmath or @xmath , the random variable @xmath is well defined and @xmath
holds, since @xmath does not depend on @xmath and @xmath not on @xmath .

We proceed by showing that the equations provided by the assumed
uniformity of @xmath for any @xmath imply the equations given by ( 3.2
). Consider an arbitrary pair @xmath and let @xmath be the associated
NDLF, i.e., such that @xmath . By assumption, @xmath is uniformly
distributed, independent of @xmath . Thus, for any fixed @xmath , this
can be expressed as

  -- -------- -- -------
     @xmath      (3.3)
  -- -------- -- -------

where both summations are over all @xmath subject to the indicated
respective properties. Recall, that this equality holds for any pair
@xmath . Thus, for fixed @xmath , if we sum over all such pairs @xmath
subject to @xmath , we get the equation

  -- -------- --
     @xmath   
  -- -------- --

which, after re-arranging the terms of the summations, leads to

  -- -------- -- -------
     @xmath      (3.4)
  -- -------- -- -------

We will now argue that, up to a constant multiplicative factor, equation
( 3.4 ) coincides with equation ( 3.2 ).

First, it is straightforward to verify that the variables @xmath and
@xmath occur only on the left hand side, both with multiplicity @xmath
(the number of pairs @xmath such that @xmath ), whereas @xmath and
@xmath only occur on the right hand side, with the same multiplicity
@xmath .

Now, we argue that any other @xmath equally often appears on the right
and on the left hand side, and thus cancel out. Note that the set of
pairs @xmath , over which the summation runs on the left respectively
the right hand side, can be understood as the set of solutions to a
binary non-homogeneous linear equations system:

  -- -------- --
     @xmath   
  -- -------- --

Also note that the two linear equation systems consist of three
equations and involve at least 4 variables, because @xmath and @xmath .
Therefore, using basic linear algebra, one is tempted to conclude that
they both have solutions, and, because they have the same homogeneous
part, they have the same number of solutions, equal to the number of
homogeneous solutions. However, this is only guaranteed if the matrix
defining the homogeneous part has full rank. In our situation, this is
precisely the case if and only if @xmath , where those four exceptions
have already been treated above. It follows that the equations ( 3.3 ),
which are guaranteed by assumption, imply the equations ( 3.2 ).

It remains to justify the assumption that @xmath for any @xmath . In
general, we choose @xmath such that @xmath for any @xmath , and we set
@xmath and @xmath , resulting in the equation @xmath that needs to be
satisfied for @xmath and @xmath . This equality, though, can be argued
as for equation ( 3.2 ), which we did above, simply by replacing @xmath
on both sides of ( 3.3 ) by @xmath (where @xmath is the bit wise XOR).
We may safely do so: doing a suitable variable substitution and using
linearity of the inner product, it is easy to see that this modified
equation still expresses uniformity of @xmath . This concludes the proof
for the perfect case.

###### The General Case:

Now, we consider the general case where there exists some @xmath such
that @xmath for any NDLF @xmath . We use the observations from the
perfect case but additionally keep track of the ‘‘error term’’.

For any @xmath with @xmath and any NDLF @xmath , set

  -- -------- --
     @xmath   
  -- -------- --

Note that @xmath , independent of @xmath . Fix now an arbitrary @xmath
with @xmath . Then, ( 3.3 ) only holds up to an error of @xmath , where
@xmath is the NDLF associated to @xmath . As a consequence, Equation (
3.4 ) only holds up to an error of @xmath and thus ( 3.2 ) holds up to
an error of @xmath where the sum is over the @xmath functions associated
to the pairs @xmath with @xmath . Note that @xmath depends on @xmath ,
but the set of @xmath ’s, over which the summation runs, does not.
Adding up over all possible @xmath ’s gives

  -- -------- --
     @xmath   
  -- -------- --

Since ( 3.2 ) only holds approximately, @xmath as in ( 3.1 ) is not
necessarily a valid extension, but close. This can obviously be overcome
by instead setting

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

with suitably chosen @xmath with @xmath , and with suitably chosen signs
“ @xmath ” or “ @xmath ’’. ³ ³ 3 Most of the time, it probably suffices
to correct one of the two, say, choose @xmath and @xmath ; however, if
for instance @xmath and @xmath are both positive but @xmath , then one
has to correct both. Using that every @xmath differs from @xmath by at
most @xmath , it follows from a straightforward computation that @xmath
The corresponding holds for @xmath . It follows that

  -- -------- --
     @xmath   
  -- -------- --

which concludes the proof. \qed

### 3.4 Applications

In this section we will show the usefulness of Theorem 3.6 for the
construction of 1-2 OT @xmath , based on weaker primitives like a noisy
channel or other flavors of OT . In particular, we will show that the
reducibility of 1-2 OT to any weaker flavor of OT follows as a simple
argument using Theorem 3.6 .

#### 3.4.1 Reducing 1-2Ot @xmath to Independent Repetitions of Weak
1-2Ot s

##### Background

A great deal of effort has been put into constructing protocols for 1-2
OT @xmath based on physical assumptions like various models for noisy
channels [ CK88 , DKS99 , DFMS04 , CMW04 ] or a memory bounded adversary
[ CCM98 , Din01b , DHRS04 ] , as well as into reducing 1-2 OT @xmath to
(seemingly) weaker flavors of OT , like RabinOT , 1-2 XOT , 1-2 GOT and
1-2 UOT [ Cré87 , BC97 , Cac98 , Wol00 , BCW03 , CS06 , Wul07 ] . Note
that the latter three flavors of OT are weaker than 1-2 OT in that the
dishonest receiver has more freedom in choosing the sort of information
he wants to get about the sender’s input bits @xmath and @xmath : @xmath
, @xmath or @xmath in case of 1-2 XOR-OT (which is abbreviated by 1-2
XOT ), @xmath for an arbitrary one-bit-output function @xmath in case of
1-2 Generalized-OT (1-2GOT) , and an arbitrary probabilistic @xmath with
mutual information @xmath in case of 1-2 Universal-OT (1-2UOT) . ⁴ ⁴ 4
As a matter of fact, reducibility has been proven for any bound on
@xmath strictly smaller than @xmath . Note that there is some confusion
in the literature in what a Universal , is: In [ BC97 , Wol00 , BCW03 ]
, a takes as input two bits and the receiver is doomed to have at least
one bit or any other non-trivial amount of Shannon entropy on them; we
denote this by . Whereas in [ Cac98 ] , a takes as input two strings and
the receiver is doomed to have some Rényi entropy of order @xmath on
them. We address this latter notion in more detail in Section 3.4.2 .

All these reductions of 1-2 OT to weaker versions follow a specific
construction design, which is also at the core of the 1-2 OT protocols
based on noisy channels or a memory-bounded adversary. By repeated
independent executions of the underlying primitive, @xmath transfers a
randomly chosen bit string @xmath to @xmath such that:

1.  depending on his choice bit @xmath , the honest @xmath knows either
    @xmath or @xmath ,

2.  any @xmath has no information on which part of @xmath @xmath
    learned, and

3.  any @xmath has some uncertainty in @xmath .

Then, this is completed to a Rand1-2OT by means of privacy amplification
(cf. Section 2.5 ): @xmath samples two functions @xmath and @xmath from
a two-universal class @xmath of hash functions, sends them to @xmath ,
and outputs @xmath and @xmath , and @xmath outputs @xmath . Finally, the
Rand1-2OT is transformed into an ordinary 1-2 OT in the obvious way.

Correctness and receiver-security of this construction are clear, they
follow immediately from 1. and 2. How easy or hard it is to prove
sender-security depends heavily on the underlying primitive. In case of
RabinOT it is rather straightforward. In case of 1-2 XOT and the other
weaker versions, this is non-trivial. The problem is that since @xmath
might know @xmath , it is not possible to argue that there exists @xmath
such that @xmath ’s uncertainty on @xmath is large when given @xmath .
This, though, would be necessary in order to finish the proof by simply
applying the privacy amplification theorem (Corollary 2.27 ). This
difficulty is overcome in [ BC97 , BCW03 ] by tailoring the proof to a
particular two-universal class of hash functions, namely the class of
all linear hash functions. Whether the reduction also works for a less
restricted class of hash functions is left in [ BC97 , BCW03 ] as an
open problem, which we solve here as a side result. Using a smaller
class of hash functions would allow for instance to reduce the
communication complexity of the protocol.

In [ CS06 ] , the difficulty is overcome by giving up on the simplicity
of the reduction. The cost of two-way communication allowing for
interactive hashing is traded for better reduction parameters. We would
like to emphasize that these parameters are incomparable to ours,
because a different reduction is used, whereas our approach provides a
better analysis of the common non-interactive reductions.

##### The New Approach

We argue that, independent of the underlying primitive, sender-security
follows as a simple consequence of Theorem 3.6 , in combination with a
simple observation regarding the composition of non-degenerate linear
(respectively, more general, 2-balanced) functions with strongly
two-universal hash functions, stated in Proposition 3.7 below.

Recall Definition 2.23 of strong two-universality. A class @xmath of
hash functions from @xmath to @xmath is strongly two-universal , if for
any distinct @xmath the two random variables @xmath and @xmath are
independent and uniformly distributed over @xmath , where the random
variable @xmath represents the random choice of a function in @xmath .

###### Proposition 3.7

Let @xmath and @xmath be two classes of strongly two-universal hash
functions from @xmath respectively @xmath to @xmath , and let @xmath be
a 2-balanced function. Consider the class @xmath of all functions @xmath
with @xmath where @xmath and @xmath . Then, @xmath is strongly
two-universal. ⁵ ⁵ 5 It is easy to see that the claim does not hold in
general for ordinary (as opposed to strongly) two-universal classes: if
@xmath and @xmath and @xmath both only contain the identity function
@xmath and thus are two-universal, then @xmath consisting of the
function @xmath is not two-universal.

{proof}

Fix distinct @xmath and @xmath in @xmath . Assume without loss of
generality that @xmath . Fix @xmath , and set @xmath and @xmath . By
assumption on @xmath , the random variables @xmath and @xmath are
independent and uniformly distributed over @xmath , where @xmath
represents the random choice for @xmath . By the assumption on @xmath ,
this implies that @xmath and @xmath are independent and uniformly
distributed over @xmath . This holds no matter how @xmath is chosen, and
thus proves the claim.

Now, briefly, sender-security for a construction as sketched above can
be argued as follows: The only restriction is that @xmath needs to be
strongly two-universal. From the independent repetitions of the
underlying weak OT ( RabinOT , 1-2 XOT , 1-2 GOT or 1-2 UOT ) it follows
that @xmath has “high” collision entropy in @xmath . Hence, for any NDLF
@xmath , we can apply the privacy-amplification Theorem 2.27 with the
strongly two-universal hash function @xmath and argue that @xmath is
close to uniform for randomly chosen @xmath and @xmath . Sender-security
then follows immediately from Theorem 3.6 .

We save the quantitative analysis (Theorem 3.8 ) for next section, where
we consider a reduction of 1-2 OT to the weakest kind of OT : to one
execution of a UOT . Based on this, we compare in Section 3.4.3 the
quality of the analysis of the above reductions based on Theorem 3.6
with the results in [ BCW03 ] . It turns out that our analysis is
tighter for 1-2 GOT and 1-2 UOT , whereas the analysis in [ BCW03 ] is
tighter for 1-2 XOT ; but in all cases, our analysis is much simpler
and, we believe, more elegant.

#### 3.4.2 Reducing 1-2Ot @xmath to One Execution of Uot

In this section, we use the definition and some elementary properties of
Rényi entropy introduced in Section 2.4.1 .

##### Universal Oblivious Transfer

Probably the weakest flavor of OT is the Universal OT ( UOT ) as it was
introduced by Cachin in [ Cac98 ] , in that it gives the receiver the
most freedom in getting information on the string @xmath . Formally, for
a finite set @xmath and parameters @xmath (allowing @xmath ) and @xmath
, an @xmath -UOT @xmath works as follows: the sender inputs @xmath , and
the receiver may choose an arbitrary conditional probability
distribution @xmath with the only restriction that for a uniformly
distributed @xmath it must satisfy @xmath . The receiver then gets as
output @xmath , sampled according to the distribution @xmath , whereas
the sender gets no information on the receiver’s choice for @xmath .
Note that a 1-2 UOT is a limit case of this kind of UOT since ‘‘ 1-2 UOT
= @xmath -UOT @xmath ”.

The crucial property of such an UOT is that the input is not restricted
to two bits, but may be two bit- strings ; this potentially allows to
reduce 1-2 OT to one execution of a UOT , rather than to many
independent executions of the same primitive as for the 1-2 flavors of
OT mentioned above. Indeed, following the design principle discussed in
Section 3.4.1 , it is straightforward to come up with a candidate
protocol for 1-2 OT @xmath which uses one execution of a @xmath -UOT
@xmath with @xmath . The protocol is given in Figure 3.3 , where @xmath
is a strongly two-universal class of hash functions from @xmath to
@xmath .

In [ Cac98 ] it is claimed that, for appropriate parameters, protocol
OT2UOT is a secure Rand 1-2 OT @xmath , respectively, the resulting
protocol for 1-2 OT is secure. However, we argue below that the proof
given is not correct and it is not obvious how to fix it. In Theorem 3.8
we then show that its security follows easily from Theorem 3.6 .

##### A Flaw in the Security Proof

In [ Cac98 ] the security of protocol OT2UOT is argued as follows. Using
rather complicated spoiling-knowledge techniques , it is shown that,
conditioned on the receiver’s output (which we suppress to simplify the
notation) at least one out of @xmath and @xmath is “large” (for any
@xmath ), and, similarly, at least one out of @xmath and @xmath . Since
collision entropy is lower bounded by min-entropy, it then follows from
the privacy amplification theorem that at least one out of @xmath and
@xmath is close to @xmath , and similarly, one out of @xmath and @xmath
. It is then claimed that this proves OT2UOT secure.

We argue that this very last implication is not correct. Indeed, what is
proven about the entropy of @xmath and @xmath does not exclude the
possibility that both entropies @xmath and @xmath are maximal, but that
@xmath . This would allow the receiver to learn the bit wise XOR @xmath
, which is clearly forbidden by the condition of sender-security.

Also note that the proof does not use the fact that the two functions
@xmath and @xmath are chosen independently . However, if they are chosen
to be the same, then the protocol is clearly insecure: if the receiver
asks for @xmath , and if @xmath is a class of linear two-universal hash
functions, then @xmath obviously learns @xmath .

##### Reducing 1-2Ot @xmath to Uot

The following theorem guarantees the security of OT2UOT for an
appropriate choice of the parameters. The only restriction we have to
make is that @xmath needs to be a strongly two-universal class of hash
function.

###### Theorem 3.8

Let @xmath be a strongly two-universal class of hash functions from
@xmath to @xmath . Then OT2UOT reduces a @xmath -secure Rand1-2OT @xmath
to a perfect @xmath -UOT @xmath with @xmath .

Using the bounds from Lemma 2.9 on the different orders of Rényi
entropy, the reducibility of 1-2 OT @xmath to @xmath -UOT @xmath follows
immediately for any @xmath .

Informally, sender-security of the protocol OT2UOT is argued as for the
reduction of 1-2 OT to RabinOT , 1-2 XOT etc., discussed in Section
3.4.1 , simply by using Proposition 3.7 in combination with the privacy
amplification Theorem 2.27 , and applying Theorem 3.6 . The formal proof
given below additionally keeps track of the error term.

From this proof it also becomes clear that the exponential (in @xmath )
overhead in Theorem 3.6 is unavoidable. Indeed, a sub-exponential
overhead would allow @xmath in Theorem 3.8 to be super-linear in @xmath
, which of course is nonsense.

{proof}

By the definition of conditional collision entropy, we have that for all
@xmath , @xmath . Fix an arbitrary @xmath and consider any NDLF @xmath .
Let @xmath and @xmath be the random variables that represent the random
choices of @xmath and @xmath , and set @xmath . In combination with
Proposition 3.7 , privacy amplification (Corollary 2.27 ) guarantees
that

  -- -------- --
     @xmath   
  -- -------- --

It now follows that

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

Sender-security as claimed now follows from Theorem 3.6 .

The min-entropy splitting Lemma 2.15 and a larger (not necessarily
strongly) two-universal class of hash functions can alternatively be
used to show the security of the reduction protocol OT2UOT without the
use of NDLFs. We do this here for illustration purposes because the same
technique is used in the security proof of 1-2 OT in the
bounded-quantum-storage model in Chapter 6 . After the execution of a
perfect @xmath -UOT @xmath , we have @xmath and Lemma 2.15 yields the
existence of a random variable @xmath such that @xmath and therefore
also @xmath . By the chain rule (Lemma 2.12 ) and setting @xmath , we
get @xmath . Hence to get a @xmath -secure Rand1-2OT @xmath via the
privacy amplification theorem (Corollary 2.25 ), we need @xmath which
gives slightly worse parameters than in Theorem 3.8 , namely @xmath .

#### 3.4.3 Quantitative Comparisons To Related Work

Subsequent to [ DFSS06 ] , Wullschleger improved the min-entropy
splitting technique described in the last paragraph. In [ Wul07 ] , it
is shown that the protocol OT2UOT reduces a @xmath -secure Rand1-2OT
@xmath to a perfect @xmath -UOT @xmath if @xmath . So, Rand1-2OT @xmath
of strings of length @xmath roughly half of the receivers min-entropy
@xmath can be obtained, which is asymptotically optimal for this
reduction-protocol. Technically, the result is essentially obtained by
using the min-entropy splitting approach sketched at the end of last
section and a more careful case distinction. The random variable @xmath
pointing to the “known” string @xmath is basically defined as in Lemma
2.15 , but for the case when both @xmath have high min-entropy, a new
distributed left-over hash lemma is used to show that both @xmath and
@xmath are close to uniform and therefore close to independent (and
hence, the pointer @xmath can be chosen arbitrarily in this case).

In the following, we compare the simple reduction of 1-2 OT @xmath to
@xmath executions of 1-2 XOT , 1-2 GOT and 1-2 UOT , respectively, using
our analysis based on Theorem 3.6 together with the quantitative
statement given in Theorem 3.8 , with the results achieved in [ BCW03 ]
. ⁶ ⁶ 6 As mentioned earlier, these results are incomparable to the
parameters achieved in [ CS06 ] , where interactive reductions are used.
The quality of the analysis of a reduction is given by the reduction
parameters @xmath , @xmath and @xmath such that the 1-2 OT @xmath is
guaranteed to be @xmath -secure as long as @xmath . The smaller these
constants are, the better is the analysis of the reduction. The
comparison of these parameters is given in Figure 3.4 . We focus on
@xmath and @xmath since @xmath is not really relevant, unless very
large.

The parameters in the first line can easily be extracted from
Theorems 5, 7 and 9 of [ BCW03 ] , where in Theorem 9 @xmath . The
parameters in the second line corresponding to the reduction to 1-2 XOT
follow immediately from Theorem 3.8 , using the fact that in one
execution of a 1-2 XOT , the receiver’s conditional collision entropy on
the sender’s two input bits is at least @xmath .

Determining the parameters of the reductions to 1-2 GOT and 1-2 UOT
requires a little more work. We first determine the average conditional
min-entropy @xmath of one instance of 1-2 GOT and 1-2 UOT . In the case
of 1-2 GOT , @xmath can easily be seen to be at least 1 (for example by
inspection of Table 2 in [ BCW03 ] ). For one execution of 1-2 UOT , the
receiver’s average Shannon entropy is at least @xmath . Therefore, it
follows from Fano’s Inequality (Lemma 2.11 ) that his average guessing
probability is at most @xmath with @xmath as above, and thus his average
conditional min-entropy is at least @xmath .

We use Lemma 2.8 to lower bound the (regular) conditional min-entropy
@xmath except with probability @xmath and use Theorem 3.8 with security
parameter @xmath which together yields a @xmath secure Rand1-2OT @xmath
. To apply Theorem 3.8 , we require @xmath and to obtain this by Lemma
2.8 , we need @xmath .

This yields @xmath for 1-2 GOT and @xmath and @xmath for 1-2 UOT . The
derivation of the parameters for [ Wul07 ] is analogous.

### 3.5 Extension to 1-nOt @xmath

In this section we extend our characterization of sender-security of
Rand1-2OT to Rand1-nOT . We use the following notation. For a sequence
of random variables @xmath and indices @xmath , we denote by @xmath the
sequence of variables @xmath with all indices except @xmath and @xmath .
Similarly, @xmath denotes all variables but the @xmath th.

###### Definition 3.9 (Rand1-nOT @xmath)

An @xmath -secure Rand1-nOT is a protocol between @xmath and @xmath ,
with @xmath having input @xmath (while @xmath has no input), such that
for any distribution of @xmath , the following properties hold:

 @xmath  -Correctness:  

     For honest @xmath and @xmath , @xmath has output @xmath and @xmath
    outputs @xmath , except with probability @xmath .

 @xmath  -Receiver-security:  

     If @xmath is honest then for any (possibly dishonest) @xmath with
    output @xmath ,

      -- -------- --
         @xmath   
      -- -------- --

 @xmath  -Sender-security:  

     If @xmath is honest then for any (possibly dishonest) @xmath with
    output @xmath , there exists a random variable @xmath with range
    @xmath such that

      -- -------- --
         @xmath   
      -- -------- --

Analogous to the 1-2 OT -case we want for sender-security that there
exists a choice @xmath , such that when given the corresponding string
(or bit) @xmath all the other strings (or bits) look completely random
from @xmath ’s point of view.

Recall that for the characterization of sender-security in the case of
1-2 OT , it is sufficient that @xmath for every NDLF @xmath . In a first
attempt one might try to characterize the sender-security of 1-n OT
using linear functions @xmath that non-trivially depend on @xmath
arguments. In the case of 1-3 OT of bits, the only linear function of
this kind is the XOR of the three bits, but it can be easily verified
that the requirement that @xmath is uniform does not imply
sender-security in the sense defined above. Instead, as we will see
below, sufficient requirements are that the XOR of every pair of bits is
uniform when given the value of the third .

###### Theorem 3.10

The condition for @xmath -sender-security for a Rand1-nOT @xmath is
satisfied for a particular (possibly dishonest) receiver @xmath with
output @xmath , if for all @xmath

  -- -------- --
     @xmath   
  -- -------- --

for every NDLF @xmath , where @xmath .

{proof}

We first consider and prove the perfect case.

###### The Perfect Case:

Like in the proof of Theorem 3.6 , we fix an output @xmath of the
receiver and consider the non-normalized probability distribution @xmath
. We use the variable @xmath to refer to the value @xmath and for the
all-zero string @xmath . We use bold font to denote a collection of
strings @xmath , and we write @xmath for @xmath , the collection without
@xmath . Finally, for a collection @xmath of arbitrary size @xmath , we
define sets of indices with one (respectively two) non-zero substrings:

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

where the @xmath (and @xmath ) are at @xmath th (and @xmath th)
position. As in the proof of Theorem 3.6 , we assume for the clarity of
exposition that for all @xmath and @xmath , it holds that @xmath (where
@xmath is at position @xmath ). For symmetry reasons, the general case
can be handled along the same lines.

We extend the distribution @xmath similarly to ( 3.1 ): for every @xmath
, we set

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
              @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

In order to show that this is a valid extension, we have to show that
for every @xmath

  -- -------- -- -------
     @xmath      (3.5)
  -- -------- -- -------

If this holds, then the random variable @xmath is well defined, and the
@xmath are uniformly distributed given @xmath and @xmath .

We now show that ( 3.5 ) follows from the assumed uniformity property
that @xmath for every non-degenerate linear function @xmath and any
@xmath . This is done by induction on @xmath . The case @xmath is
covered by the proof of Theorem 3.6 , and by induction assumption we may
assume that it also holds for @xmath . Let us fix some @xmath and @xmath
. It is easy to see that the assumed uniformity property on @xmath
implies the corresponding uniformity property on @xmath when
conditioning on @xmath , and therefore, by induction assumption and
“multiplying out the conditioning”,

  -- -------- -- -------
     @xmath      (3.6)
  -- -------- -- -------

where the sum is over all @xmath with @xmath and @xmath . Summing all
the equations over @xmath yields

  -- -------- -- -------
     @xmath      (3.7)
  -- -------- -- -------

By a similar reasoning we can also derive from the case @xmath that
equations of type ( 3.2 ) hold conditioned on the event that all but two
of the @xmath ’s are zero. More formally, we have that for all @xmath ,

  -- -------- -- -------
     @xmath      (3.8)
  -- -------- -- -------

Summing these equations over all @xmath yields

  -- -------- -- -------
     @xmath      (3.9)
  -- -------- -- -------

We conclude by substituting ( 3.9 ) into ( 3.7 ) as follows

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

which is equation ( 3.5 ) after dividing by @xmath , and thus finishes
the induction step and the claim for @xmath .

###### The General Case:

For the non-zero error case, we follow the above argument, but keep
track of the error. For technical reasons, we assume that the @xmath ’s
are independent and uniformly distributed, and we assume that the
assumed uniformity property with respect to NDLFs holds conditioned on
@xmath for any @xmath , not just on average, i.e., @xmath for any @xmath
. We show at the end of the proof how to argue in general. Write

  -- -------- --
     @xmath   
  -- -------- --

such that ( 3.5 ) holds up to the error @xmath . Note that @xmath
depends on @xmath ; we also write @xmath to make this dependency
explicit. We will argue, following the induction proof, that

  -- -------- --
     @xmath   
  -- -------- --

The proof can then be completed analogue to the proof of Theorem 3.6 by
“correcting” the values for @xmath ’s appropriately.

By the proof of Theorem 3.6 , the claimed inequality holds in case
@xmath . For the induction step, note that by induction assumption, (
3.6 ) holds up to @xmath where

  -- -------- --
     @xmath   
  -- -------- --

Furthermore, from the case @xmath it follows that Equation ( 3.8 ) holds
up to @xmath , where

  -- -------- --
     @xmath   
  -- -------- --

and, by the additional assumption posed on the @xmath ’s, @xmath . It
follows that ( 3.5 ) holds up to

  -- -------- --
     @xmath   
  -- -------- --

such that

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
                       
              @xmath   
  -- -------- -------- --

It remains to argue the case where the @xmath ’s are not independent
uniformly distributed and/or the assumed uniformity property holds only
on average over the @xmath ’s. We first argue that we may indeed assume
without loss of generality that the @xmath ’s are random: We consider
@xmath defined as @xmath and @xmath for independent and uniformly
distributed @xmath ’s in @xmath . It is easy to see that the assumed
uniformity condition with respect to NDLFs on @xmath implies the
corresponding uniformity condition on @xmath with the same “error”
@xmath , and it is obvious that the @xmath ’s are independent and
uniformly distributed. Furthermore, it is easy to see that @xmath
-sender-security for @xmath implies @xmath -sender-security for @xmath
with the same @xmath . Thus it suffices to prove the claim for the case
of random @xmath ’s.

Finally, in order to reason that we may assume that the uniformity
property holds conditioned on every @xmath , where we now may already
assume that the @xmath ’s are random due to the above observation, we
again consider @xmath defined as above. It is not hard to verify that
due to this randomization and since the @xmath ’s are random, the
average near-uniformity of @xmath translates to a “worst-case”
near-uniformity of @xmath with the same @xmath .

### 3.6 1-2Ot in a Quantum Setting

As briefly mentioned in the introductory Section 3.1 , the results of
this chapter were originally motivated by the idea of using them to
prove sender-security in the bounded-quantum-storage model of the 1-2 OT
-protocol presented later in Chapter 6 . For this protocol, we can use a
quantum uncertainty relation to show a lower bound on the min-entropy of
the @xmath -bit string @xmath transmitted by the sender using a quantum
encoding.

If we had a quantum version of Theorem 3.6 at hand, we could use privacy
amplification against quantum adversaries (Theorem 2.25 ) to prove
sender-security against quantum-memory-bounded receivers. Unfortunately,
the example below shows that such a quantum version of Theorem 3.6
cannot exist.

In the case of a dishonest quantum receiver @xmath , the final state of
a quantum protocol for Rand1-2OT is given by the ccq-state @xmath . The
condition for @xmath -sender-security given in Definition 6.1 requires
the existence of a random variable @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

This coincides with the classical Definition 3.1 , except that the
dishonest receiver’s output is a quantum state, and closeness is
measured in terms of the trace-norm distance.

A quantum analogue of Theorem 3.6 would state that this condition is
fulfilled if for every NDLF @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is comparable to the classical parameter @xmath .

Consider now the following example for 1-2 OT of bits @xmath . We define
the ccq-state @xmath as follows: Let

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath are the projectors onto the states @xmath and
@xmath .

For this state, it is clear that the XOR @xmath is perfectly hidden from
the dishonest receiver holding @xmath , i.e.

  -- -------- --
     @xmath   
  -- -------- --

On the other hand, @xmath can determine the bit of his choice by
measuring in the Breitbart basis @xmath if he is interested in the first
bit, or by measuring in the Breitbart basis rotated by 45 degrees if he
wants to obtain the second bit. It is easy to see that such a
measurement succeeds in yielding the correct bit with probability @xmath
. This precludes the existence of a pointer variable @xmath such that
perfect sender-security in the sense of Definition 6.1 holds.

It is unclear how that difficulty can be overcome, but it is clear from
the simple example above, that a statement like in Theorem 3.6 with
comparable parameters cannot hold. Therefore, the alternative approach
via the entropy-splitting Lemma 2.15 (outlined at the end of Section
3.4.2 ) will be taken in Chapter 6 to show sender-security.

## Chapter 4 Quantum Uncertainty Relations

Quantum uncertainty relations are the fundamental tool for the security
analysis of protocols in the bonded-quantum-storage model presented
later in this thesis. We start off with some preliminary tools in
Section 4.1 and proceed to the history of uncertainty relations in
Section 4.2 . Then, we derive new high-order entropic uncertainty
relations for two (Section 4.3 ) and more (Section 4.4 ) mutually
unbiased bases. In the last Section 4.5 , we investigate the situation
where for each qubit, a basis is picked independently at random from a
set of bases.

The results in this chapter are based on joint work with Damgård, Fehr,
Salvail and Renner which appeared in [ DFSS08 , DFR @xmath 07 ] .

### 4.1 Preliminaries

#### 4.1.1 Operators and Norms

For a linear operator @xmath on the complex Hilbert space @xmath , we
define the operator norm

  -- -- --
        
  -- -- --

for the Euclidian norm @xmath of the vector @xmath . When @xmath is
Hermitian, i.e. the complex conjugate transpose @xmath and @xmath
coincide, we have

  -- -------- --
     @xmath   
  -- -------- --

From an equivalent definition of the norm @xmath , it is easy to see
that @xmath . For two Hermitian matrices @xmath and @xmath , we have
that @xmath . The operator norm is unitarily invariant , i.e. for all
unitary @xmath , @xmath holds. It is easy to show that

  -- -------- --
     @xmath   
  -- -------- --

###### Lemma 4.1

Let @xmath , @xmath be any two @xmath matrices such that the products
@xmath and @xmath are Hermitian. Then, we have

  -- -------- --
     @xmath   
  -- -------- --

{proof}

For any two @xmath matrices @xmath and @xmath , @xmath and @xmath have
the same eigenvalues, see e.g. [ Bha97 , Exercise I.3.7] . Therefore,
@xmath .

A linear operator @xmath such that @xmath and @xmath is called an
orthogonal projector .

###### Proposition 4.2

Let @xmath and @xmath be two orthogonal projectors. Then it holds that
@xmath .

{proof}

We adapt a technique by Kittaneh [ Kit97 ] to our case. Define two
@xmath -block matrices @xmath and @xmath as follows

  -- -------- --
     @xmath   
  -- -------- --

Using @xmath and @xmath , we compute

  -- -- --
        
  -- -- --

As @xmath and @xmath are Hermitian, so are @xmath , @xmath , @xmath ,
@xmath and @xmath as well. We use Lemma 4.1 and the triangle inequality
to obtain

  -- -------- --
     @xmath   
  -- -------- --

Using the unitary invariance of the operator norm to permute the columns
in the rightmost matrix and the facts that @xmath as well as @xmath , we
conclude that

  -- -------- --
     @xmath   
  -- -------- --

A nice feature of this block-matrix technique is that it generalizes
easily to more projectors.

###### Proposition 4.3

For orthogonal projectors @xmath , it holds that

  -- -------- -- -------
     @xmath      (4.1)
  -- -------- -- -------

{proof}

Defining

  -- -------- --
     @xmath   
  -- -------- --

yields

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

The matrix @xmath can be additively decomposed into @xmath matrices
according to the following pattern

  -- -------- --
     @xmath   
  -- -------- --

where the asterisk stand for entries of @xmath and for @xmath the @xmath
th asterisk-pattern after the diagonal pattern is obtained by @xmath
cyclic shifts of the columns of the diagonal pattern. Entries without
asterisk are zero.

As in the proof of Proposition 4.2 , @xmath and @xmath are Hermitian and
we use Lemma 4.1 , the triangle inequality, the unitary invariance of
the operator norm and the facts that for all @xmath , @xmath to obtain
the desired statement ( 4.1 ).

#### 4.1.2 Azuma’s Inequality

As we will exclusively use the concentration result at the end of this
section, we only give an informal definition of martingales. We refer to
[ AS00 ] or [ MP95 ] for a more detailed treatment.

###### Definition 4.4

A sequence of real random variables @xmath is a martingale sequence, if
for all @xmath , it holds @xmath .

###### Theorem 4.5 (Azuma’s inequality [Azu67])

Let @xmath be a martingale sequence such that for each @xmath , @xmath ,
where @xmath may depend on @xmath . Then, for all @xmath and any @xmath
,

  -- -------- --
     @xmath   
  -- -------- --

The theorem is often stated as two-sided bound with absolute values:

  -- -------- --
     @xmath   
  -- -------- --

but the one-sided version fits our purposes better.

###### Definition 4.6

A sequence of real-valued random variables @xmath is called a martingale
difference sequence if for every @xmath and every @xmath : @xmath .

Note that for an arbitrary sequence of real random variables @xmath ,
defining @xmath (with @xmath ) yields a martingale difference sequence
@xmath .

The following lemma follows directly from Azuma’s Theorem 4.5 .

###### Corollary 4.7

Let @xmath be a martingale difference sequence such that @xmath for
every @xmath . Then, for any @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

{proof}

Set @xmath , @xmath , and for @xmath , @xmath in Theorem 4.5 .

#### 4.1.3 Mathematical Tools

The following two purely analytical lemmas will be used to bound some
error terms.

###### Lemma 4.8

For any @xmath such that @xmath , it holds that @xmath .

{proof}

Define the function @xmath . It holds that @xmath , which shows that
@xmath is bijective in the interval @xmath , and thus the inverse
function @xmath is well defined for @xmath , which contains the interval
@xmath . We are going to show that @xmath for all @xmath , where @xmath
. Since both @xmath and @xmath converge to 0 for @xmath , it suffices to
show that @xmath ; respectively, we will compare their reciprocals. For
any @xmath such that @xmath

  -- -------- --
     @xmath   
  -- -------- --

and

  -- -------- --
     @xmath   
  -- -------- --

such that

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

where for the inequality we are using that @xmath so that @xmath .
Defining the function

  -- -------- --
     @xmath   
  -- -------- --

and showing that @xmath for all @xmath finishes the proof, as then

  -- -------- --
     @xmath   
  -- -------- --

which was to be shown. For this last claim, note that @xmath for @xmath
and for @xmath , and thus the global minimum is at @xmath with @xmath .
@xmath and thus @xmath , and hence the minimum of @xmath equals @xmath ,
which turns out to be positive.

###### Lemma 4.9

For any @xmath , it holds that @xmath .

{proof}

Note that @xmath . Therefore, it suffices to show that @xmath or
equivalently that the function @xmath is smaller than 1 for @xmath . It
holds that @xmath and @xmath and it is easy to see that @xmath is a
continuous increasing function, e.g. by verifying that for the first
derivative

  -- -------- --
     @xmath   
  -- -------- --

holds for @xmath .

### 4.2 History and Previous Work

#### 4.2.1 Mutually Unbiased Bases

###### Definition 4.10 (Mutually Unbiased Bases (MUBs))

Two orthonormal bases @xmath and @xmath of the complex Hilbert space
@xmath of dimension @xmath are called mutually unbiased if

  -- -- --
        
  -- -- --

More @xmath bases of this space @xmath are called mutually unbiased , if
every pair of them is mutually unbiased.

Wiesner showed in 1970 in one of the first articles about quantum
cryptography [ Wie83 ] that there are at least @xmath mutually unbiased
bases in a Hilbert space of dimension @xmath . Later, optimal
constructions of @xmath mutually unbiased bases in a Hilbert space of
dimension @xmath were shown by Ivanović when @xmath is prime [ Ivo81 ]
and by Wootters and Fields for @xmath a prime power [ WF89 ] (in
particular, for @xmath in the case of @xmath qubits). A nice
construction based on the stabilizer formalism can be found in the
article by Lawrence, Brukner, and Zeilinger [ LBZ02 ] . It turned out to
be an intriguing question to determine the maximal number of mutually
unbiased bases in other dimensions, already the case @xmath is still
open [ Eng03 ] .

For a density matrix @xmath describing the state of @xmath qubits, let
@xmath be the probability distributions over @xmath -bit strings when
measuring @xmath in bases @xmath , respectively. For instance, for basis
@xmath and basis @xmath , we have @xmath and @xmath . We leave out the
state @xmath in the subscript when it is clear from the context.

#### 4.2.2 Uncertainty Relations Using Shannon Entropy

The history of uncertainty relations starts with Heisenberg who showed
that the outcomes of two non-commuting observables applied to a quantum
state are not easy to predict simultaneously [ Hei27 ] . However,
Heisenberg only speaks about the variance of the measurement results,
and his result was shown to have several shortcomings by Deutsch [ Deu83
] and Hilgevood and Uffink [ HU88 ] . More general forms of uncertainty
relations were proposed by Bialynicki-Birula and Mycielski in [ BBM75 ]
and by Deutsch [ Deu83 ] to resolve these problems. The new relations
were called entropic uncertainty relations , because they are expressed
using Shannon entropy instead of the statistical variance.

For mutually unbiased bases, Deutsch’s relation reads

  -- -------- --
     @xmath   
  -- -------- --

A much stronger bound was first conjectured by Kraus [ Kra87 ] and later
proved by Maassen and Uffink [ MU88 ]

  -- -------- -- -------
     @xmath      (4.2)
  -- -------- -- -------

Intuitively, these bounds assure that if you know the outcome of
measuring @xmath in basis @xmath pretty well, you have large uncertainty
when measuring in the other basis @xmath .

Note that for entropic bounds using Shannon entropy , it is sufficient
to state them for pure states. They then automatically hold for mixed
state by concavity.

###### Lemma 4.11

If @xmath holds for all pure states @xmath , then @xmath holds for all
(possibly mixed) states @xmath .

{proof}

Let @xmath the spectral composition of a mixed state. We then have for
@xmath that @xmath and therefore by concavity of the Shannon entropy
(Lemma 2.10 )

  -- -------- --
     @xmath   
  -- -------- --

Although a bound on Shannon entropy can be helpful in some cases, it is
usually not good enough in cryptographic applications. The main tool to
reduce the adversary’s information---privacy amplification by
two-universal hashing---requires a bound on the adversary’s min-entropy
(in fact collision entropy), see Section 2.5 . As @xmath for @xmath ,
higher-order entropic bounds are generally weaker, but imply bounds for
Shannon entropy as well.

#### 4.2.3 Higher-Order Entropic Uncertainty Relations

Different results are known for complete sets of @xmath mutually
unbiased bases of @xmath . All of them are based on the following
surprising geometrical result by Larsen.

###### Theorem 4.12 ([Lar90])

Let @xmath be the @xmath distributions obtained by measuring state
@xmath in mutually unbiased bases @xmath of the Hilbert space @xmath .
Then,

  -- -------- -- -------
     @xmath      (4.3)
  -- -------- -- -------

where @xmath denotes the collision probability of a distribution @xmath
(cf. Definition 2.6 ).

For a pure state @xmath , @xmath holds and the right hand side of ( 4.3
) equals 2. In this case, using that @xmath is a convex function,
Sánchez-Ruiz [ Sán95 ] applies Jensen’s inequality (Lemma 2.2 ) to
derive the following lower-bound on the sum of the collision entropies

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

Because of the lack of convexity of higher-order Rényi entropy, we
cannot immediately extend an uncertainty relation for pure states to
mixed states. On the other hand, the following lemma shows that
uncertainty relations based on upper bounds of high-order probability
sums for pure states also hold for mixed states and therefore translate
to entropy lower bounds for mixed states.

###### Lemma 4.13

Let @xmath . If @xmath for all pure states @xmath , then for all mixed
states @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

Equality holds for a state @xmath for which @xmath for all @xmath .

{proof}

As @xmath is convex for @xmath , @xmath is a convex functional.
Therefore, for a mixed state @xmath , we have @xmath and

  -- -------- --
     @xmath   
  -- -------- --

Just as above follows by Jensen’s inequality (Lemma 2.2 ) that

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

Jensen’s inequality is tight if the values @xmath are all equal.

For incomplete sets of bases @xmath with @xmath , the current
state-of-the-art bound was independently obtained by Damgård, Salvail
and Pedersen [ DPS04 ] and Azarchs [ Aza04 ] by subtracting the minimal
amount of collision probability ( @xmath ) in the bases not included in
the sum:

  -- -------- -- -------
     @xmath      (4.4)
  -- -------- -- -------

By Lemma 4.13 , this yields

  -- -------- -- -------
     @xmath      (4.5)
  -- -------- -- -------

As mentioned above, all lower bounds on the collision entropy from this
section imply bounds on the Shannon entropy because @xmath , but do not
tell us anything about the min-entropy @xmath . In the rest of this
chapter, we derive entropic uncertainty relations involving min-entropy
.

Uncertainty relations in terms of Rényi entropy have also been studied
in a different context by Bialynicki-Birula [ BB06 ] .

### 4.3 Two Mutually Unbiased Bases

In this section, we consider the situation where a @xmath -qubit state
is measured in one out of two mutually unbiased bases of @xmath .
Without loss of generality, we assume these two bases to be the @xmath
-fold tensor product of the computational basis @xmath and of the
diagonal basis @xmath , in this section simply called @xmath - and
@xmath -basis.

We show that two distributions obtained by measuring in two mutually
unbiased bases cannot both be “very far from uniform”. One way to
characterize non-uniformity of a distribution is to identify a subset of
outcomes that has much higher probability than for a uniform choice.
Intuitively, the theorem below says that such sets cannot be found
simultaneously for both measurements.

###### Theorem 4.14

Let @xmath be an arbitrary state of @xmath qubits, and let @xmath and
@xmath be the respective distributions of the outcome when @xmath is
measured in the @xmath -basis respectively the @xmath -basis. Then, for
any two sets @xmath and @xmath it holds that

  -- -------- --
     @xmath   
  -- -------- --

{proof}

We define the two orthogonal projectors

  -- -------- --
     @xmath   
  -- -------- --

Using the spectral decomposition of @xmath , we have

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

where the last line is Proposition 4.2 . To conclude, we show that
@xmath . Note that an arbitrary state @xmath can be expressed with
coordinates @xmath in the diagonal basis. Then, with the sums over
@xmath and @xmath understood as over @xmath and @xmath , respectively,

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

The second equality holds since @xmath are mutually unbiased, the first
inequality follows from Pythagoras and the triangle inequality, and the
last inequality follows from Cauchy-Schwarz (Lemma 2.3 ). This implies
@xmath and finishes the proof.

This theorem yields a meaningful bound as long as @xmath , for instance
if @xmath and @xmath both contain less than @xmath elements. The
relation is tight in the sense that for the Hadamard-invariant state

  -- -------- --
     @xmath   
  -- -------- --

and @xmath , it is straightforward to verify that @xmath and therefore
@xmath . Another state that achieves equality (for @xmath even) is
@xmath with @xmath and @xmath . We get that @xmath and thus @xmath .

If for @xmath , @xmath contains only the @xmath -bit string with the
maximal probability of @xmath , we obtain a known tight relation (see
(9) in [ MU88 ] ).

###### Corollary 4.15

Let @xmath and @xmath be the maximal probabilities of the distributions
@xmath and @xmath from above. It then holds that @xmath and therefore
also @xmath where @xmath .

Equality is achieved for the same state @xmath as above.

Using Lemma 4.13 , the following corollary is obtained.

###### Corollary 4.16

For all quantum states @xmath of @xmath qubits, it holds that

  -- -------- --
     @xmath   
  -- -------- --

There exists a quantum state achieving equality.

The following corollary plays the crucial role in the security proofs of
protocols in the bounded-quantum-storage model presented in the
following chapters of this thesis.

###### Corollary 4.17

Let @xmath be a random variable over @xmath , and let @xmath be the
outcome when @xmath is measured in basis @xmath , such that @xmath .
Then, for any @xmath there exists @xmath and an event @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

and thus @xmath in case @xmath is uniform, and such that

  -- -------- --
     @xmath   
  -- -------- --

for @xmath with @xmath .

{proof}

Choose @xmath such that @xmath , and define

  -- -------- -------- --
              @xmath   
     @xmath   @xmath   
  -- -------- -------- --

to be the sets of strings with small probabilities and denote by @xmath
and @xmath their complements ¹ ¹ 1 Here’s the mnemonic: @xmath for the
strings with S mall probabilities, @xmath for L arge. . Note that for
all @xmath , we have that @xmath and therefore @xmath . Analogously, we
have @xmath . For ease of notation, we abbreviate the probabilities that
strings with small probabilities occur with @xmath and @xmath . It
follows immediately from the choice of @xmath and Theorem 4.14 that

  -- -------- --
     @xmath   
  -- -------- --

We define @xmath to be the event @xmath . Then @xmath and similarly
@xmath , and thus the first claim follows immediately. Furthermore, if
@xmath is uniformly distributed, then

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

Regarding the second claim, in case @xmath , we have

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
  -- -------- -------- --

Thus, if @xmath then indeed @xmath . The corresponding holds for the
case @xmath .

Finally, if @xmath (or similarly @xmath ) then instead of the above, we
define @xmath as the empty event if @xmath and as the event @xmath if
@xmath . It follows that @xmath and @xmath , as well as @xmath (for
@xmath large enough), both by the bound on @xmath and on @xmath ,
whereas @xmath .

### 4.4 More Mutually Unbiased Bases

In this section, we generalize the uncertainty relation derived in
Section 4.3 to more than two mutually unbiased bases. Such uncertainty
relations over more than two, but not all mutually unbiased bases in
terms of min-entropy may be of independent interest, see the discussion
at the end of Section 4.2 .

###### Theorem 4.18

Let the density matrix @xmath describe the state of @xmath qubits and
let @xmath be mutually unbiased bases of @xmath . Let @xmath be the
distributions of the outcome when @xmath is measured in bases @xmath ,
respectively. Then, for any sets @xmath , it holds that

  -- -------- -------- --
     @xmath   @xmath   
  -- -------- -------- --

{proof}

Except of using Proposition 4.3 instead of Proposition 4.2 , the proof
is analogous to the one of Theorem 4.14 .

As in Corollary 4.16 , we derive an uncertainty relation about the sum
of the min-entropies of up to @xmath distributions.

###### Corollary 4.19

For an @xmath , let @xmath . For @xmath , let @xmath be the
min-entropies of the distributions @xmath from the theorem above. Then,

  -- -------- --
     @xmath   
  -- -------- --

{proof}

For @xmath , we denote by @xmath the maximal probability of @xmath and
let @xmath be the set containing only the @xmath -bit string @xmath with
this maximal probability @xmath . Theorem 4.18 together with the
assumption about @xmath assures @xmath . By Lemma 4.13 follows

  -- -------- -------- --
     @xmath   @xmath   
  -- -------- -------- --

### 4.5 Independent Bases for Each Subsystem

So far, we have focused on the case of an @xmath -qubit state @xmath
measured in two or more mutually unbiased bases of @xmath . In this
section, we investigate the case when each of the @xmath qubits is
measured in an individual basis, picked independently and uniformly from
@xmath , i.e. @xmath is measured in basis @xmath .

More generally, our result holds for a state @xmath of @xmath quantum
systems—each @xmath -dimensional—which are measured in an individual
basis, picked independently and uniformly from a set @xmath of basis of
@xmath , see Theorem 4.22 .

#### 4.5.1 A Classical Tool

We start our derivation with a classical information-theoretic tool
which itself might be of independent interest.

###### Theorem 4.20

Let @xmath be @xmath random variables (not necessarily independent) over
alphabet @xmath . If there exists a real number @xmath such that for all
@xmath and @xmath :

  -- -------- --
     @xmath   
  -- -------- --

then for any @xmath

  -- -------- --
     @xmath   
  -- -------- --

where @xmath .

If the @xmath ’s are independent and have Shannon entropy at least
@xmath , it is known (see Lemma 2.13 ) that the smooth min-entropy of
@xmath is at least @xmath for large enough @xmath . Informally, Theorem
4.20 guarantees that when the independence-condition is relaxed to a
lower bound on the Shannon entropy of @xmath given any previous history
, then we still have (almost) @xmath bits of min-entropy except with
negligible probability @xmath .

The proof idea is to use Azuma’s inequality in the form of Corollary 4.7
for cleverly chosen @xmath ’s. The main trick is that for a random
variable @xmath over @xmath , we can define another random variable
@xmath over @xmath with expected value @xmath equal to the Shannon
entropy of @xmath , which allows us to make the connection with the
assumption about the Shannon entropy.

{proof}

Recall that the superscript means @xmath for any @xmath , and similarly
for other sequences. We want to show that

  -- -------- --
     @xmath   
  -- -------- --

for @xmath as claimed in Theorem 4.20 . This means that @xmath is
smaller than @xmath except with probability at most @xmath (over the
choice of @xmath ), and therefore implies the claim @xmath by the
definition of smooth min-entropy from Section 2.4.2 . Note that @xmath
is equivalent to

  -- -- -- -------
           (4.6)
  -- -- -- -------

which is of suitable form to apply Azuma’s inequality (Corollary 4.7 ).

Consider first an arbitrary sequence @xmath of real-valued random
variables. We assume the @xmath ’s to be either all positive or all
negative. Define a new sequence @xmath of random variables by putting
@xmath . It is straightforward to verify that @xmath , i.e., @xmath
forms a martingale difference sequence. Thus if for any @xmath , @xmath
for some @xmath , and thus @xmath , Azuma’s inequality guarantees that

  -- -- -- -------
           (4.7)
  -- -- -- -------

We now put @xmath for @xmath . Note that @xmath . It is easy to see that
the bound on the conditional entropy of @xmath from Theorem 4.20 implies
that @xmath . Indeed, for any @xmath , we have @xmath , and thus for any
subset @xmath of @xmath , and in particular for the set of @xmath ’s
which map to a given @xmath , it holds that

  -- -------- -------- -- -------
     @xmath   @xmath      
              @xmath      (4.8)
  -- -------- -------- -- -------

As a consequence, the bound on the probability of ( 4.7 ) in particular
bounds the probability of the event ( 4.6 ), even with @xmath instead of
@xmath . A problem though is that we have no upper bound @xmath on the
@xmath ’s. Because of that, we now consider a modified sequence @xmath
defined by @xmath if @xmath and @xmath otherwise, where @xmath will be
determined later. This gives us a bound like ( 4.7 ) but with an
explicit @xmath , namely @xmath . Below, we will argue that @xmath by
the right choice of @xmath ; the claim then follows from observing that

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

where the last inequality follows from ( 4.8 ). Regarding the claim
@xmath , using a similar argument as for ( 4.8 ), it suffices to show
that @xmath for any @xmath :

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

where the summation is over all @xmath with @xmath , and where the
inequality holds as long as @xmath , as can easily be verified. Thus, we
let @xmath be such that @xmath . Using the mathematical Lemma 4.8 , we
have that @xmath and derive that @xmath , which gives us the claimed
bound @xmath on the probability.

#### 4.5.2 Quantum Uncertainty Relations

We now state and prove the new entropic uncertainty relation in its most
general form. A special case will then be introduced (Corollary 4.23 )
and used in the security analysis of the 1-2 OT -protocols we consider
in Chapter 6 .

###### Definition 4.21

Let @xmath be a finite set of orthonormal bases in the @xmath
-dimensional Hilbert space @xmath . We call @xmath an average entropic
uncertainty bound for @xmath if every state in @xmath satisfies @xmath ,
where @xmath is the distribution obtained by measuring the state in
basis @xmath .

Note that by the convexity of the Shannon entropy @xmath , a lower bound
for all pure states in @xmath suffices to imply the bound for all
(possibly mixed) states.

###### Theorem 4.22

Let @xmath be a set of orthonormal bases in @xmath with an average
entropic uncertainty bound @xmath , and let @xmath be an arbitrary
quantum state. Let @xmath be uniformly distributed over @xmath and let
@xmath be the outcome when measuring @xmath in basis @xmath ,
distributed over @xmath . Then for any @xmath

  -- -------- --
     @xmath   
  -- -------- --

with @xmath .

{proof}

Define @xmath and @xmath . Let @xmath be arbitrary. Then

  -- -------- -------- --
     @xmath   @xmath   
  -- -------- -------- --

where the inequality follows from the fact that @xmath is chosen
uniformly at random and from the definition of @xmath . Note that @xmath
lower bounds the average entropy for any system in @xmath , and thus in
particular for the @xmath th subsystem of @xmath , with all previous
@xmath -dimensional subsystems measured. Theorem 4.20 thus implies that
@xmath for any @xmath and for @xmath as claimed. We conclude that

  -- -------- -------- --
     @xmath   @xmath   
  -- -------- -------- --

where the first inequality follows from the equality

  -- -------- --
     @xmath   
  -- -------- --

for all @xmath and @xmath and any event @xmath , and from the definition
of (conditional) smooth entropy.

For the special case where @xmath is the set of BB84 bases, we can use
the uncertainty relation of Maassen and Uffink [ MU88 ] (see Equation (
4.2 )) which, using our terminology, states that @xmath has average
entropic uncertainty bound @xmath . Theorem 4.22 together with Lemma 4.9
then immediately gives the following corollary.

###### Corollary 4.23

Let @xmath be an arbitrary @xmath -qubit quantum state. Let @xmath be
uniformly distributed over @xmath and @xmath be the outcome when
measuring @xmath in basis @xmath . Then for any @xmath

  -- -------- --
     @xmath   
  -- -------- --

where @xmath .

Maassen and Uffink’s relation being optimal means there exists a quantum
state @xmath —namely the product state of eigenstates of the subsystems,
e.g. @xmath —for which @xmath . On the other hand, we have shown that
@xmath for @xmath arbitrarily close to @xmath . For the product state
@xmath , the @xmath are independent and we know from Lemma 2.13 that
@xmath approaches @xmath . It follows that the relation cannot be
significantly improved even when considering Rényi entropy of order
@xmath .

Another tight corollary is obtained if we consider the set of
measurements @xmath (see Section 2.3 for the definition of the circular
basis @xmath ). In [ Sán93 ] , Sánchez-Ruiz shows that for this @xmath ,
the average entropic uncertainty bound

  -- -------- -- -------
     @xmath      (4.9)
  -- -------- -- -------

is optimal. It implies that @xmath for negligible @xmath .

#### 4.5.3 The Overall Average Entropic Uncertainty Bound

In the this section, we compute the average uncertainty bound for the
set of all bases of a @xmath -dimensional Hilbert space. Let @xmath be
the set of unitaries on @xmath . Moreover, let @xmath be the normalized
Haar measure on @xmath , i.e.,

  -- -------- --
     @xmath   
  -- -------- --

for any @xmath and any integrable function @xmath , and @xmath . (Note
that the normalized Haar measure @xmath exists and is unique.)

Let @xmath be a fixed orthonormal basis of @xmath , and let @xmath be
the family of bases @xmath with @xmath . The set @xmath consist of all
orthonormal basis of @xmath . We generalize Definition 4.21 , the
average entropic uncertainty bound for a finite set of bases, to the
infinite set @xmath .

###### Definition 4.24

We call @xmath an overall average entropic uncertainty bound in @xmath
if every state in @xmath satisfies

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the distribution obtained by measuring the state in
basis @xmath .

###### Proposition 4.25

For any positive integer @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

is the overall average entropic uncertainty bound in @xmath . It is
attained for any pure state in @xmath .

The proposition follows immediately from Formula (14) in [ JRW94 ] for a
pure state, i.e. @xmath . The result was originally shown by Sýkora [
Sýk74 ] and by Jones [ Jon91 ] , another proof can be found in the
appendix of an article by Jozsa, Robb, and Wootters [ JRW94 ] . An
elementary proof suggested by Harremoës based on recent results by
Harremoës and Vignat [ HV06 ] is given below. {proof} Let @xmath be a
pure state in @xmath . For the probability distribution @xmath holds
@xmath . We want to compute the integral

  -- -------- --
     @xmath   
  -- -------- --

Note that by the invariance of the Haar measure, all summands on the
right-hand side are equal and it suffices to compute

  -- -- -- --------
           (4.10)
  -- -- -- --------

where @xmath is the first vector in the computational basis, i.e. @xmath
is the length of the projection onto the first coordinate of @xmath .

The Haar measure over @xmath is the uniform distribution over the @xmath
-dimensional complex sphere which can be seen as the uniform
distribution over the @xmath -dimensional real sphere @xmath where the
complex coordinates are given by @xmath . Setting @xmath and @xmath and
using a result from [ HV06 ] about the projection of the uniform
distribution over @xmath to the first coordinate, we obtain that the
density of @xmath is @xmath for @xmath . Therefore, ( 4.10 ) equals

  -- -------- --
     @xmath   
  -- -------- --

where the evaluation of this integral follows from standard calculus. By
convexity of the Shannon entropy, the bound also holds for mixed states
and the claim follows.

The following table gives some numerical values of @xmath for small
values of @xmath .

  @xmath   @xmath   @xmath   @xmath   @xmath
  -------- -------- -------- -------- --------
  @xmath   @xmath   @xmath   @xmath   @xmath
  @xmath   @xmath   @xmath   @xmath   @xmath

It is well-known that the harmonic series in Proposition 4.25 diverges
in the same way as @xmath and therefore, @xmath goes to 1 for large
dimensions @xmath .

## Chapter 5 RabinOT in the Bounded-Quantum-Storage Model

In this chapter, we present an efficient protocol for Rabin Oblivious
Transfer which is secure in the bounded-quantum-storage model. It first
appeared in [ DFSS05 ] , a journal version of this paper is in
preparation [ DFSS08 ] .

### 5.1 The Definition

A protocol for Rabin Oblivious Transfer ( RabinOT ) between sender Alice
and receiver Bob allows for Alice to send a bit @xmath through an
erasure channel to Bob. Each transmission delivers @xmath or an erasure
with probability @xmath . Intuitively, a protocol for RabinOT is secure
if

-   the sender Alice gets no information on whether @xmath was received
    or not, no matter what she does, and

-   the receiver Bob gets no information about @xmath with probability
    at least @xmath , no matter what he does.

In this chapter, we are considering quantum protocols for RabinOT . This
means that while the inputs and outputs of the honest senders are
classical, described by random variables, the protocol may contain
quantum computation and quantum communication, and the view of a
dishonest player is quantum, and is thus described by a quantum state.

Any such (two-party) protocol is specified by a family @xmath of pairs
of interactive quantum circuits (i.e. interacting through a quantum
channel). Each pair is indexed by a security parameter @xmath , where
@xmath and @xmath denote the circuits for sender Alice and receiver Bob,
respectively. In order to simplify the notation, we often omit the index
@xmath , leaving the dependency on it implicit.

For the formal definition of the security requirements of a RabinOT
protocol, let us fix the following notation. Let @xmath denote the
binary random variable describing @xmath ’s input bit @xmath , and let
@xmath and @xmath denote the binary random variables describing @xmath
’s two output bits, where the meaning is that @xmath indicates whether
the bit was received or not. Furthermore, for a dishonest sender @xmath
, the final state of a fixed candidate protocol for Rand1-2OT can be
described by the ccq-state @xmath where (by slight abuse of notation) we
also denote by @xmath the quantum register that the sender outputs. Its
state may depend on @xmath and @xmath . Similarly, for a dishonest
receiver @xmath , we have the cq-state @xmath .

###### Definition 5.1

A two-party (quantum) protocol @xmath is a @xmath -secure RabinOT if the
following holds:

 @xmath  -Correctness:  

     For honest @xmath and @xmath ,

      -- -------- --
         @xmath   
      -- -------- --

 @xmath  -Receiver-security:  

     For honest @xmath and any dishonest @xmath there exists ¹ ¹ 1
    Recall from Section 2.3 : Given a cq-state @xmath , by saying that
    there exists a random variable @xmath such that @xmath satisfies
    some condition, we mean that @xmath can be understood as @xmath for
    a ccq-state @xmath that satisfies the required condition. a binary
    random variable @xmath such that

      -- -------- --
         @xmath   
      -- -------- --

 @xmath  -Sender-security:  

     For any @xmath there exists an event @xmath with @xmath such that

      -- -------- --
         @xmath   
      -- -------- --

If any of the above holds for @xmath , then the corresponding property
is said to hold perfectly . If one of the properties only holds with
respect to a restricted class @xmath of @xmath ’s respectively @xmath of
@xmath ’s, then this property is said to hold (and the protocol is said
to be secure) against @xmath respectively @xmath .

Receiver-security requires that the joint quantum state is essentially
the same as when the dishonest sender chooses a bit @xmath according to
some distribution and a (possibly dependent) quantum state, and gives
@xmath to an ideal functionality which passes it on to the receiver with
probability @xmath . Sender-security requires that the joint quantum
state is essentially the same as when the dishonest receiver gets the
sender’s bit @xmath with probability @xmath and prepares some state that
may depend on @xmath in case he receives it, and prepares some state
that does not depend on @xmath otherwise. In other words, security
requires that the dishonest party cannot do more than when attacking an
ideal functionality. From such a strong security guarantee we expect
nice composition behavior, for instance like in [ CSSW06 ] .

Note that the original definition given in [ DFSS05 ] does not guarantee
that the distribution of the input bit is determined at the end the
execution of RabinOT . This is a strictly weaker definition and does not
fully capture what is expected from a RabinOT : it is easy to see that
if the dishonest sender can still influence his input bit after the
execution of the protocol, then known schemes based on RabinOT , like
bit commitments, are not secure anymore. The security definition given
here is in the spirit of the security definition from [ DFR @xmath 07 ]
for 1-2 OT, described in the next Chapter 6 .

### 5.2 The Protocol

We present a quantum protocol for RabinOT that will be shown perfectly
correct and perfectly receiver-secure (against any sender) and
statistically sender-secure against any quantum-memory-bounded receiver.
Our protocol exhibits some similarity with quantum conjugate coding
introduced by Wiesner [ Wie83 ] .

The protocol given in Figure 5.1 is very simple: @xmath picks @xmath and
sends to @xmath @xmath qubits in state either @xmath or @xmath each
chosen with probability @xmath . @xmath then measures all received
qubits either in the rectilinear or in the diagonal basis. With
probability @xmath , @xmath picked the right basis and gets @xmath ,
while any @xmath that is forced to measure part of the state (due to a
memory bound) can only have full information on @xmath in case the
@xmath -basis was used or in case the @xmath -basis was used (but not in
both cases). Privacy amplification based on any two-universal class of
hashing functions @xmath is then used to eliminate partial information
(as explained in Section 2.5 ). For simplicity, we focus on the case
where the output size of the family @xmath is just one bit, i.e. @xmath
, but all results of this chapter can easily be extended to RabinOT
@xmath of @xmath -bit strings, by using an output size @xmath and
adjusting the memory bounds accordingly, see Section 5.7 .

In order to avoid aborting, we specify that if a dishonest @xmath
refuses to participate, or sends data in incorrect format, then @xmath
samples its output bits @xmath and @xmath both at random in @xmath .

We first consider receiver-security.

###### Proposition 5.2

qot is perfectly receiver-secure.

It is obvious that no information about whether @xmath has received the
bit is leaked to any sender @xmath , since @xmath does not send
anything. However, one needs to show the existence of a random variable
@xmath as required by receiver-security. {proof} Recall, the quantum
state @xmath is defined by the experiment where the dishonest sender
@xmath interacts with the honest memory-bounded @xmath . Consider a
modification of the experiment where we allow @xmath to be unbounded in
memory and where @xmath waits to receive @xmath and then measures all
qubits in basis @xmath . Let @xmath be the resulting string.
Nevertheless, @xmath picks @xmath at random and outputs @xmath if @xmath
and @xmath if @xmath . Since the only difference between the two
experiments is when @xmath measures the qubits and in what basis @xmath
measures them when @xmath , in which case his final output is
independent of the measurement outcome, the two experiments result in
the same @xmath . However, in the modified experiment we can choose
@xmath to be @xmath , such that by construction @xmath if @xmath and
@xmath is uniformly distributed, independent of anything, and thus
@xmath .

As we shall see in Section 5.4 , the security of the qot protocol
against receivers with bounded-size quantum memory holds as long as the
bound applies before Step 3 is reached. An equivalent protocol is
obtained by purifying the sender’s actions. Although qot is easy to
implement, the purified or EPR-based version depicted in Figure 5.2 is
easier to prove secure. This technique was pioneered by Ekert [ Eke91 ]
in the scenario of quantum key distribution. A similar approach was
taken in the Shor-Preskill proof of security for the BB84
quantum-key-distribution scheme [ SP00 ] .

Notice that while qot requires no quantum memory for honest players,
quantum memory for @xmath seems to be required in epr - qot . The
following Lemma shows the strict security equivalence between qot and
epr - qot .

###### Lemma 5.3

qot is @xmath -sender-secure if and only if epr - qot is.

{proof}

The proof follows easily after observing that @xmath ’s choices of
@xmath and @xmath , together with the measurements all commute with
@xmath ’s actions. Therefore, they can be performed right after Step 1
with no change for @xmath ’s view. Modifying epr - qot that way results
in qot .

Note that for a dishonest receiver it is not only irrelevant whether he
tries to attack qot or epr - qot , but in fact there is no difference in
the two protocols from his point of view.

### 5.3 Modeling Dishonest Receivers

We model dishonest receivers in qot , respectively epr - qot , under the
assumption that the maximum size of their quantum storage is bounded.
These adversaries are only required to have bounded quantum storage when
they reach Step 3 in ( epr -) qot . Before (and after) that, the
adversary can store and carry out quantum computations involving any
number of qubits. Apart from the restriction on the size of the quantum
memory available to the adversary, no other assumption is made. In
particular, the adversary is not assumed to be computationally bounded
and the size of its classical memory is not restricted.

###### Definition 5.4

The set @xmath denotes all possible quantum dishonest receivers @xmath
in qot or epr - qot where for each @xmath , @xmath has quantum memory of
size at most @xmath when Step 3 is reached.

In general, the adversary @xmath is allowed to perform any quantum
computation compressing the @xmath qubits received from @xmath into a
quantum register @xmath of size at most @xmath when Step 3 is reached.
More precisely, the compression function is implemented by some unitary
transform @xmath acting upon the quantum state received and an ancilla
register of arbitrary size (initially in the state @xmath ). The
compression is performed by a measurement that we assume in the
computational basis without loss of generality. Before starting Step 3 ,
the adversary first applies a unitary transform @xmath :

  -- -------- --
     @xmath   
  -- -------- --

where for all @xmath , @xmath . Then, a measurement in the computational
basis is applied to register @xmath providing classical outcome @xmath .
The result is a quantum state in register @xmath of size @xmath qubits.
Ignoring the value of @xmath to ease the notation, the re-normalized
state of the system in its most general form when Step 3 in epr - qot is
reached is thus of the form

  -- -------- --
     @xmath   
  -- -------- --

where @xmath . We will prove security for any such state @xmath and thus
conditioned on any value @xmath that may be observed. It is therefore
safe to leave the dependency on @xmath implicit.

### 5.4 Security Against Dishonest Receivers

In this section, we use the uncertainty relation derived in Section 4.3
to show that epr - qot is secure against any dishonest receiver having
access to a quantum storage device of size strictly smaller than half
the number of qubits received at Step 1 .

###### Theorem 5.5

For all @xmath , qot is @xmath -secure for a negligible (in @xmath )
@xmath against @xmath .

{proof}

After Lemmas 5.3 and 5.2 , it remains to show that epr - qot is @xmath
-sender-secure against @xmath . Since @xmath , we can find @xmath with
@xmath . Consider a dishonest receiver @xmath in epr - qot with quantum
memory of size @xmath . Let @xmath and @xmath denote the random
variables describing the basis @xmath and the outcome @xmath of @xmath
’s measurement (in basis @xmath ) in Step 3 of epr - qot , respectively.
We implicitly understand the distribution of @xmath given @xmath to be
conditioned on the classical outcome @xmath of the measurement @xmath
performed when the memory bound applies, as described in Section 5.3 ;
the following analysis works no matter what @xmath is. Corollary 4.17
with @xmath implies the existence of @xmath negligible in @xmath and an
event @xmath such that @xmath and such that @xmath for any relevant
@xmath . Note that by construction, the random variables @xmath and
@xmath , and thus also the event @xmath , are independent of the
sender’s input bit @xmath , and hence @xmath . It remains to show that
@xmath . As the bit @xmath is masked by the output of the two-universal
hash function @xmath in Step 4 of epr - qot (where the random variable
@xmath represents the random choice for @xmath ), it suffices to show
that @xmath is close to uniform and essentially independent from @xmath
’s view, conditioned on @xmath . But this is guaranteed by the above
bound on @xmath and by the privacy-amplification theorem (Corollary 2.25
with @xmath and @xmath constant).

### 5.5 On the Necessity of Privacy Amplification

In this section, we show that randomized privacy amplification is needed
for protocol qot to be secure. For instance, it is tempting to believe
that the sender could use the XOR @xmath in order to mask the bit @xmath
, rather than @xmath for a randomly sampled @xmath . This would reduce
the communication complexity as well as the number of random coins
needed. However, we argue in this section that this is not secure
(against an adversary as we model it). Indeed, somewhat surprisingly,
this variant can be broken by a dishonest receiver that has no quantum
memory at all (but that can do coherent measurements on pairs of qubits)
in the case @xmath is even. For odd @xmath , the dishonest receiver
needs to store a single qubit .

Clearly, a dishonest receiver can break the modified scheme qot and
learn the bit @xmath with probability @xmath if he can compute @xmath
with probability @xmath . Note that, using the equivalence between qot
and epr - qot , @xmath can be understood as the outcome of the
measurement in either the @xmath - or the @xmath -basis, performed by
the sender on one part of an EPR pair while the other is handed over to
the receiver. The following proposition shows that indeed the receiver
can learn @xmath by a suitable measurement of his parts of the EPR
pairs. Concretely, he measures the qubits he receives pair-wise by a
suitable measurement which allows him to learn the XOR of the two
corresponding @xmath ’s, no matter what the basis is (and he needs to
store one single qubit in case @xmath is odd). This obviously allows him
to learn the XOR of all @xmath ’s in all cases.

###### Proposition 5.6

Consider two EPR pairs, i.e., @xmath where @xmath ranges over @xmath .
Let @xmath , and let @xmath and @xmath be the result when measuring the
two qubits in register @xmath in basis @xmath . There exists a fixed
measurement for register @xmath so that the outcome together with @xmath
uniquely determines @xmath .

{proof}

The measurement that does the job is the Bell measurement , i.e., the
measurement in the Bell basis @xmath . Recall,

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

Due to the special form of the Bell basis, when register @xmath is
measured and, as a consequence, one of the four Bell states is observed,
the state in register @xmath collapses to that same Bell state. Indeed,
when doing the basis transformation, all cross-products cancel each
other out. It now follows by inspection that knowledge of the Bell state
and the basis @xmath allows to predict the XOR of the two bits observed
when measuring the Bell state in basis @xmath . For instance, for the
Bell state @xmath , the XOR is @xmath if @xmath and it is @xmath if
@xmath .

Note that from the proof above, one can see that the receiver’s attack,
respectively his measurement on each pair of qubits, can be understood
as teleporting one of the two entangled qubits from the receiver to the
sender using the other as EPR pair. However, the receiver does not send
the outcome of his measurement to the sender, but keeps it in order to
predict the XOR.

Clearly, the same strategy also works against any fixed linear function.
Therefore, the only hope for doing deterministic privacy amplification
is by using a non-linear function. However, it has been shown recently
by Ballester, Wehner, and Winter [ BWW06 ] , that also this approach is
doomed to fail in our scenario, because the outcome of any fixed Boolean
function can be perfectly predicted by a dishonest receiver who can
store a single qubit and later learns the correct basis @xmath .

### 5.6 Weakening the Assumptions

Observe that qot requires error-free quantum communication, in that a
transmitted bit @xmath , that is encoded by the sender and measured by
the receiver using the same basis, is always received as @xmath . In
addition, it also requires a perfect quantum source which on request
produces one and only one qubit in the right state, e.g. one photon with
the right polarization. Indeed, in case of noisy quantum communication,
an honest receiver in qot is likely to receive an incorrect bit, and the
sender-security of qot is vulnerable to imperfect sources that once in a
while transmit more than one qubit in the same state: a malicious
receiver @xmath can easily determine the basis @xmath and measure all
the following qubits in the right basis. However, current technology
only allows to approximate the behavior of single-photon sources and of
noise-free quantum communication. It would be preferable to find a
variant of qot that allows to weaken the technological requirements put
upon the honest parties.

In this section, we present such a protocol based on BB84 states [ BB84
] , bb84-qot (see Figure 5.3 ). The security proof follows essentially
by adapting the security analysis of qot in a rather straightforward
way, as will be discussed later.

#### 5.6.1 Weak Quantum Model

Let us consider a quantum channel with an error probability @xmath ,
i.e., @xmath denotes the probability that a transmitted bit @xmath ,
that is encoded by the sender and measured by the receiver using the
same basis, is received as @xmath . In order not to have the security
rely on any level of noise, we assume the error probability to be zero
when considering a dishonest receiver. Also, let us consider a quantum
source which produces two or more qubits (in the same state), rather
than just one, with probability @xmath . We call this the @xmath -weak
quantum model . By adjusting the parameters, this model can also cope
with dark counts and empty pulses, see Section 9.1.1 .

In order to deal with noisy quantum communication, we need to do
error-correction without giving the adversary too much information.
Techniques to solve this problem are known as information reconciliation
(as introduced for instance by Brassard and Salvail [ BS93 ] ) or as
secure sketches introduced by Dodis, Reyzin, Smith [ DRS04 ] . Let
@xmath be an arbitrary string, and let @xmath be the result of flipping
every bit in @xmath (independently) with probability @xmath . It is well
known that learning the syndrome @xmath of @xmath , with respect to a
suitable efficiently-decodable linear error-correcting code @xmath of
length @xmath , allows to recover @xmath from @xmath , except with
negligible probability in @xmath (see,e.g., [ Mau91 , Cré97 , DRS04 ] ).
Furthermore, it is known from coding theory that, for large enough
@xmath , such a code can be chosen with rate @xmath arbitrarily close to
but smaller than @xmath , i.e., such that the syndrome length @xmath is
bounded by @xmath where @xmath (see e.g. [ Cré97 ] or the full version
of [ DRS04 ] and the references therein).

Regarding the loss of information, we can use the privacy-amplification
statement in form of Corollary 2.25 with @xmath and constant @xmath in a
similar way as before, just by appending the classical syndrome @xmath
(of length @xmath ) to the quantum register @xmath , which results in

  -- -------- -------- -- -------
     @xmath   @xmath      (5.1)
  -- -------- -------- -- -------

Consider the protocol bb84-qot shown in Figure 5.3 in the @xmath -weak
quantum model. The protocol uses an efficiently decodable linear code
@xmath , parametrized in @xmath , with codeword length @xmath , rate
@xmath for some small @xmath , and being able to correct errors
occurring with probability @xmath (except with negligible probability).
Let @xmath be the corresponding syndrome function. Like before, the
memory bound in bb84-qot applies before Step 3 .

By the above mentioned properties of the code @xmath , it is obvious
that @xmath receives the correct bit @xmath if @xmath , except with
negligible probability. (The error probability is negligible in @xmath ,
but by Chernoff’s inequality (Lemma 2.5 ), @xmath is linear in @xmath
except with negligible probability.) Also, since there is no
communication from @xmath to @xmath , a dishonest sender @xmath cannot
learn whether @xmath received the bit. In fact, bb84-qot can be shown
perfectly receiver-secure in the same way as in Proposition 5.2 .
Similar as for protocol qot , in order to argue about sender-security we
compare bb84-qot with a purified version shown in Figure 5.4 .
bb84-epr-qot runs in the @xmath -weak quantum model, and the
imperfectness of the quantum source assumed in bb84-qot is simulated by
@xmath in bb84-epr-qot so that there is no difference from @xmath ’s
point of view.

The security equivalence between bb84-qot (in the @xmath -weak quantum
model) and bb84-epr-qot (in the @xmath -weak quantum model) follows
along the same lines as in Section 5.2 .

###### Theorem 5.7

In the @xmath -weak quantum model, bb84-qot is @xmath -secure with
@xmath negligible in @xmath against @xmath for any @xmath and @xmath
large enough.

{sketch}

It remains to show that bb84-epr-qot is sender-secure against @xmath (in
the @xmath -weak quantum model). The reasoning goes analogous to the
proof of Theorem 5.5 , except that we restrict our attention to those
@xmath ’s which are in @xmath . By Chernoff’s inequality (Lemma 2.5 ),
@xmath lies within @xmath and @xmath within @xmath except with
negligible probability. In order to make the proof easier to read, we
assume that @xmath and @xmath , and we also treat the @xmath occurring
in the rate of the code @xmath as zero. For the full proof, we simply
need to carry the @xmath ’s along, and then choose them small enough at
the end of the proof.

Write @xmath , and let @xmath be such that @xmath , i.e., @xmath .
Assume @xmath such that @xmath , where we make sure later that such
@xmath exists. It then follows from Corollary 4.17 that there exists an
event @xmath such that @xmath and

  -- -------- --
     @xmath   
  -- -------- --

By Inequality ( 5.1 ), it remains to argue that this is larger than
@xmath , i.e.,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath has to satisfy

  -- -------- --
     @xmath   
  -- -------- --

This can obviously be achieved (by choosing @xmath appropriately) if and
only if the claimed bound on @xmath holds.

### 5.7 RabinOT of Strings

In this chapter, we only considered RabinOT of one bit per invocation.
Our technique can easily be extended to deal with RabinOT @xmath of
@xmath -bit strings, essentially by using a class of two-universal
functions with range @xmath rather than @xmath , for some @xmath with
@xmath (respectively @xmath for bb84-qot ).

## Chapter 6 1-2Ot in the Bounded-Quantum-Storage Model

In the last chapter, we have shown how to construct RabinOT securely in
the bounded-quantum-storage model. Although other flavors of OT can be
constructed from RabinOT using standard reductions, a more direct
approach gives a better ratio between storage-bound and
communication-complexity.

In this chapter, we present an efficient protocol for 1-2 Oblivious
Transfer secure in the bounded-quantum-storage model. The protocol is
very close to Wiesner original ”conjugate-coding” protocol [ Wie83 ]
from the early 70’s. The uncertainty relation from Section 4.5 will be
extensively used for proving the security.

The results of this section appeared in [ DFR @xmath 07 ] .

### 6.1 The Definition

In 1-2 OT @xmath , the sender Alice sends two @xmath -bit strings @xmath
to the receiver Bob in such a way that Bob can choose which string he
wants to receive, but does not learn anything about the other. Alice
does not get to know which string Bob has chosen. As explained in
Chapter 3 , the common way to build 1-2 OT @xmath is by constructing a
protocol for (Sender-)Randomized 1-2 OT @xmath , which then can easily
be converted into an ordinary 1-2 OT @xmath . Rand1-2OT @xmath
essentially coincides with ordinary 1-2 OT @xmath , except that the two
strings @xmath and @xmath are not input by the sender but generated
uniformly at random during the protocol and output to the sender.

For the formal definition of the security requirements for a quantum
protocol for Rand1-2OT @xmath , we translate the classical Definition
3.1 to the quantum setting using a similar notation as for the
definition of RabinOT in Section 5.1 : Let @xmath denote the binary
random variable describing receiver @xmath ’s choice bit, let @xmath
denote the @xmath -bit long random variables describing sender @xmath ’s
output strings, and let @xmath denote the @xmath -bit long random
variable describing @xmath ’s output string (supposed to be @xmath ).
Furthermore, for a fixed candidate protocol for Rand1-2OT @xmath , and
for a fixed input distribution for @xmath , the overall quantum state in
case of a dishonest sender @xmath is given by the ccq-state @xmath .
Analogously, in the case of a dishonest receiver @xmath , we have the
ccq-state @xmath .

###### Definition 6.1 (Rand1-2OT @xmath)

An @xmath -secure Rand1-2OT @xmath is a quantum protocol between @xmath
and @xmath , with @xmath having input @xmath while @xmath has no input,
such that for any distribution of @xmath , the following holds:

 @xmath  -Correctness:  

     If @xmath and @xmath follow the protocol, then @xmath gets output
    strings @xmath and @xmath gets @xmath except with probability @xmath
    .

 @xmath  -Receiver-security:  

     If @xmath is honest, then for any @xmath , there exist ¹ ¹ 1 Recall
    from Section 2.3 : Given a cq-state @xmath , by saying that there
    exists a random variable @xmath such that @xmath satisfies some
    condition, we mean that @xmath can be understood as @xmath for a
    ccq-state @xmath that satisfies the required condition. random
    variables @xmath and @xmath such that @xmath and

      -- -------- --
         @xmath   
      -- -------- --

 @xmath  -Sender-security:  

     If @xmath is honest, then for any @xmath , there exists a random
    variable @xmath such that

      -- -------- --
         @xmath   
      -- -------- --

If any of the above holds for @xmath , then the corresponding property
is said to hold perfectly . If one of the properties only holds with
respect to a restricted class @xmath of @xmath ’s respectively @xmath of
@xmath ’s, then this property is said to hold and the protocol is said
to be secure against @xmath respectively @xmath .

Receiver-security, as defined here, implies that whatever a dishonest
sender does is as good as the following: generate the ccq-state @xmath
independently of @xmath , let @xmath know @xmath , and output @xmath .
On the other hand, sender-security implies that whatever a dishonest
receiver does is as good as the following: generate the ccq-state @xmath
arbitrarily, let @xmath know @xmath and an independent uniformly
distributed @xmath , and output @xmath . In other words, a protocol
satisfying Definition 6.1 is a secure implementation of the natural
Rand1-2OT @xmath ideal functionality, except that it allows a dishonest
sender to influence the distribution of @xmath and @xmath , and the
dishonest receiver to influence the distribution of the string of his
choice. This is in particular good enough for constructing a standard
1-2 OT @xmath in the straightforward way.

We would like to point out the importance of requiring the existence of
@xmath and @xmath in the formulation of receiver-security in a quantum
setting: requiring only that the sender learns no information on @xmath
, as is sufficient in the classical setting (see e.g. [ CSSW06 ] ), does
not prevent a dishonest sender from obtaining @xmath by a suitable
measurement after the execution of the protocol in such a way that he
can choose @xmath at will, and @xmath is the string the receiver has
obtained in the protocol. This would for instance make the
straightforward construction of a bit commitment ² ² 2 The committer
sends two random bits of parity equal to the bit he wants to commit to,
the verifier chooses to receive at random one of those bits. based on
1-2 OT insecure.

### 6.2 The Protocol

We present a quantum protocol for Rand1-2OT @xmath that will be shown
perfectly receiver-secure against any sender and statistically
sender-secure against any quantum-memory-bounded receiver. The first two
steps of the protocol are identical to Wiesner’s ‘‘conjugate coding’’
protocol [ Wie83 ] from circa 1970 for “transmitting two messages either
but not both of which may be received” .

The simple protocol is described in Figure 6.1 . The sender @xmath sends
random BB84 states to the receiver @xmath , who measures all received
qubits according to his choice bit @xmath . @xmath then picks randomly
two functions from a fixed two-universal class of hash functions @xmath
from @xmath to @xmath , where @xmath is to be determined later, and
applies them to the bits encoded in the @xmath -basis respectively the
bits encoded in @xmath -basis to obtain the output strings @xmath and
@xmath . Note that we may apply a function @xmath to a @xmath -bit
string with @xmath by padding it with zeros ³ ³ 3 Recall the notation
for padding @xmath introduced in Section 2.1 . (which does not decrease
its entropy). @xmath announces the encoding bases and the hash functions
to the receiver who then can compute @xmath . Intuitively, a dishonest
receiver who cannot store all the qubits until the right bases are
announced will measure some qubits in the wrong basis and thus cannot
learn both strings simultaneously.

We would like to stress that although protocol description and analysis
are designed for an ideal setting with perfect noiseless quantum
communication and with perfect sources and detectors, all our results
can easily be extended to a more realistic noisy setting along the same
lines as in the previous Chapter 5 .

It is clear by the non-interactivity of Rand 1-2 QOT @xmath that a
dishonest sender cannot learn anything about the receiver’s choice bit.
Below, we show Rand 1-2 QOT @xmath perfectly receiver-secure according
to Definition 6.1 .

###### Proposition 6.2

Rand 1-2 QOT @xmath is perfectly receiver-secure.

{proof}

Recall that the ccq-state @xmath is defined by the experiment where
@xmath interacts with the honest memory-bounded @xmath . We now define
(in a new Hilbert space) the ccccq-state @xmath by a slightly different
experiment: We let @xmath interact with a receiver with unbounded
quantum memory, which waits to receive @xmath and then measures the
@xmath -th qubit in basis @xmath for @xmath . Let @xmath be the
resulting string, and define @xmath and @xmath . Finally, sample @xmath
according to @xmath and set @xmath . It follows by construction that
@xmath and @xmath is independent of @xmath . It remains to argue that
@xmath , so that corresponding @xmath and @xmath also exist in the
original experiment. But this is obviously satisfied since the only
difference between the two experiments is when and in what basis the
qubits at position @xmath are measured, which, once @xmath is fixed,
cannot influence @xmath respectively @xmath .

### 6.3 Security Against Dishonest Receivers

As in Section 5.3 , we model dishonest receivers in Rand 1-2 QOT @xmath
under the assumption that the maximum size of their quantum storage is
bounded. Such adversaries are only required to have bounded quantum
storage when Step 3 in Rand 1-2 QOT @xmath is reached. Before and after
that, the adversary can store and carry out arbitrary quantum
computations involving any number of qubits. Apart from the restriction
on the size of the quantum memory available to the adversary, no other
assumption is made. In particular, the adversary is not assumed to be
computationally bounded and the size of its classical memory is not
restricted.

###### Definition 6.3

The set @xmath denotes all possible quantum dishonest receivers @xmath
in Rand 1-2 QOT @xmath which have quantum memory of size at most @xmath
when Step 3 is reached.

First, we consider a purified version of Rand 1-2 QOT @xmath , EPR Rand
1-2 QOT @xmath in Figure 6.2 , where @xmath prepares an EPR pair @xmath
instead of @xmath and sends one part to the receiver while keeping the
other. Only when Step 3 is reached and @xmath ’s quantum memory is bound
to @xmath qubits, @xmath measures her qubits in basis @xmath . It is
easy to see that for any @xmath , EPR Rand 1-2 QOT @xmath is equivalent
to the original Rand 1-2 QOT @xmath , and it suffices to prove
sender-security for the former. Indeed, @xmath ’s choices of @xmath and
@xmath , together with the measurements all commute with @xmath ’s
actions. Therefore, they can be performed right after Step 1 with no
change for @xmath ’s view. Modifying EPR Rand 1-2 QOT @xmath that way
results in Rand 1-2 QOT @xmath .

###### Theorem 6.4

Rand 1-2 QOT @xmath is @xmath -secure against @xmath for a negligible
(in @xmath ) @xmath if there exists @xmath such that @xmath .

The proof has the same structure as the security-proof for the reduction
OT2UOT described at the end of Section 3.4.2 . The uncertainty relation
from Section 4.5 lower bounds the dishonest receiver’s (smooth)
min-entropy about the sender’s @xmath . Hence, we have an (imperfect)
@xmath -UOT @xmath from which we get an ordinary Rand1-2OT @xmath via
the min-entropy splitting lemma and privacy amplification against
quantum adversaries. {proof} Consider the ccq-state @xmath in EPR Rand
1-2 QOT @xmath after @xmath has measured all but @xmath of his qubits,
where @xmath describes the outcome of the sender measuring her part of
the state in random basis @xmath . Also, let @xmath and @xmath be the
random variables that describe the random and independent choices of
@xmath . Finally, let @xmath be @xmath (padded with zeros so it makes
sense to apply @xmath ).

Choose @xmath all positive, but small enough such that (for large enough
@xmath )

  -- -------- --
     @xmath   
  -- -------- --

From the uncertainty relation (Corollary 4.23 ), we know that @xmath for
@xmath exponentially small in @xmath . Therefore, by the Min-Entropy
Splitting Lemma 2.15 , there exists a binary random variable @xmath such
that

  -- -------- --
     @xmath   
  -- -------- --

We denote by the random variables @xmath Alice’s choices of hash
functions. It is clear that we can condition (for free) on the
independent @xmath . We write @xmath , set @xmath , and use the chain
rule (Lemma 2.12 ) to condition on @xmath as well.

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

by the choice of @xmath .

We can now apply privacy amplification in form of Corollary 2.25 to
obtain

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

which is negligible. This shows @xmath -sender-security according to
Definition 6.1 .

### 6.4 Extensions

#### 6.4.1 1-2Ot @xmath with Longer Strings

It is possible to extend recent techniques by Wullschleger [ Wul07 ]
described in Section 3.4.3 to the quantum case and hence, the security
of Rand 1-2 QOT @xmath can be proven against @xmath if there exists
@xmath such that @xmath .

#### 6.4.2 Weakening the Assumptions

As described in Section 5.6 for RabinOT , we can extend protocol Rand
1-2 QOT to work in the @xmath -weak quantum model. To enable the
receiver to recover from errors in the transmission, the sender @xmath
additionally sends error-correcting information in Step 3 . The players
agree beforehand on an efficiently decodable error-correcting code of
length @xmath with syndrome length @xmath roughly @xmath as in Section
5.6 . Then, @xmath sends along the two syndromes of @xmath and @xmath
(where the @xmath are padded with 0s or truncated to length @xmath ). It
can be argued as for RabinOT that this will reduce the min-entropy by
the length @xmath of the syndrome and hence, we can show sender-security
of this protocol against the class of receivers @xmath with @xmath such
that there exists @xmath with

  -- -------- --
     @xmath   
  -- -------- --

#### 6.4.3 Reversing the Quantum Communication

In order to illustrate the versatility of our security analysis, we show
that the proofs carry easily over to a protocol where the direction of
the quantum communication is reversed. In the protocol described in
Figure 6.3 , the receiver @xmath of the Rand1-2OT sends @xmath qubits,
encoded in the basis determined by his choice bit. The sender of the
Rand1-2OT @xmath measures them in a random basis. The players then
proceed as in Rand 1-2 QOT .

It is clear by construction that the protocol is perfectly correct.
@xmath -Sender-security against dishonest receivers in @xmath can be
argued as in Theorem 6.4 above by observing that the uncertainty
relation applies to any @xmath -qubit state of the honest sender which
is measured in a random basis and about which the dishonest receiver
holds at most @xmath qubits of information.

For the security of an honest receiver against a dishonest sender, we
can show the existence of the two input strings as in Proposition 6.2
above by letting the sender interact with an unbounded receiver. In an
error-free model, it further holds that the sender cannot infer the
basis in which the qubits are encoded and therefore does not learn any
information about the receiver’s choice bit. However, in a more
realistic setting with multi-pulse emissions, this coding scheme with
reversed communication is highly insecure, as a malicious sender can
determine the encoding basis from a multi-pulse qubit. The same problem
occurred for the RabinOT -protocol qot from the last chapter.

## Chapter 7 Quantum Bit Commitment

This chapter is about quantum Bit Commitment ( BC ) schemes. In BC , a
committer @xmath commits himself to a choice of a bit @xmath by
exchanging information with a verifier @xmath . We want that @xmath does
not learn @xmath (we say the commitment is hiding ), yet @xmath can
later choose to reveal @xmath in a convincing way, i.e., only the value
fixed at commitment time will be accepted by @xmath (we say the
commitment is binding ).

In the next section, we present a BC scheme from a committer @xmath with
bounded quantum memory to an unbounded receiver @xmath . The scheme is
peculiar since in order to commit to a bit, the committer does not send
anything. During the committing stage, information only goes from @xmath
to @xmath . Therefore, there is no way for the verifier to get
information about the committed bit, i.e. the scheme is perfectly
hiding.

In Section 7.3 , we define two notions of the binding property and show
our scheme secure against quantum-memory-bounded committer in both of
these senses. Similar techniques as in the two previous chapters for the
analysis of the oblivious-transfer protocols are used.

The results in this chapter appeared in [ DFSS05 , DFR @xmath 07 ] .

### 7.1 The Protocol

The protocol is given in Figure 7.1 . Intuitively, a commitment to a bit
@xmath is made by measuring random BB84-states in basis @xmath .

As for the oblivious-transfer protocols in the two previous chapters, we
present an equivalent EPR-version of the protocol that is easier to
analyze (see Figure 7.2 ).

###### Lemma 7.1

comm is secure against dishonest committers @xmath if and only if
epr-comm is.

{proof}

The proof uses similar reasoning as the one for Lemma 5.3 . First, it
clearly makes no difference, if we change Step 4 to the following:

-   @xmath chooses the subset @xmath , measures all qubits with index in
    @xmath in basis @xmath and all qubits not in @xmath in basis @xmath
    . @xmath verifies that @xmath for all @xmath and accepts if and only
    if this is the case.

Finally, we can observe that the view of @xmath does not change if
@xmath would have done his choice of @xmath and his measurement already
in Step 1. Doing the measurements at this point means that the qubits to
be sent to @xmath collapse to a state that is distributed identically to
the state prepared in the original scheme. The EPR-version is therefore
equivalent to the original commitment scheme from @xmath ’s point of
view.

It is clear that epr-comm is hiding, i.e., that the commit phase reveals
no information on the committed bit, since no information is transmitted
to @xmath at all. Hence we have

###### Lemma 7.2

epr-comm is perfectly hiding.

### 7.2 Modeling Dishonest Committers

A dishonest committer @xmath with bounded memory of at most @xmath
qubits in epr-comm can be modeled very similarly to the dishonest
oblivious-transfer receivers @xmath from Section 5.3 and 6.3 : @xmath
consists first of a circuit acting on all @xmath qubits received, then
of a measurement of all but at most @xmath qubits, and finally of a
circuit that takes the following input: a bit @xmath that @xmath will
attempt to open, the @xmath qubits in memory, and some ancilla in a
fixed state. The output is a string @xmath to be sent to @xmath at the
opening stage.

###### Definition 7.3

We define @xmath to be the class of all committers @xmath in comm or
epr-comm that, at the start of the opening phase (i.e. at Step 3 ), have
a quantum memory of size at most @xmath qubits.

### 7.3 Defining the Binding Property

#### 7.3.1 The “Standard” Binding Condition

In the context of unconditionally secure quantum bit commitment, it is
widely accepted that “the right way” of defining the binding property is
to require that the probability of opening a commitment successfully to
0 plus the probability of opening it successfully to 1 is essentially
upper bounded by one, put forward by Dumais, Mayers, and Salvail [ DMS00
] . We call this notion weakly binding , as opposed to the new notion of
strongly binding defined in the next section below.

###### Definition 7.4

A (quantum) bit-commitment scheme is weakly binding against @xmath if
for all @xmath , the probability @xmath that @xmath opens @xmath with
success satisfies

  -- -------- --
     @xmath   
  -- -------- --

In the next Section 7.4 , we show that epr-comm is weakly binding
against @xmath for any @xmath .

Note that the binding condition given here in Definition 7.4 is weaker
than the classical one, where one would require that a bit @xmath exists
such that @xmath is negligible. For a general quantum adversary though
who can always commit to 0 and 1 in superposition, this is a too strong
requirement; thus, it is typically argued that Definition 7.4 is the
best one can hope for.

However, we argue now that this weaker notion is not really
satisfactory, and we show that there exists a stronger notion, which
still allows the committer to commit to a superposition and thus is not
necessarily impossible to achieve in a quantum setting, but which is
closer to the classical standard way of defining the binding property.

#### 7.3.2 A Stronger Binding Condition

A shortcoming of Definition 7.4 is that committing bit by bit is not
guaranteed to yield a secure string commitment—the argument that one is
tempted to use requires independence of the @xmath ’s between the
different executions, which in general does not hold.

We now argue that this notion is unnecessarily weak, at least in some
cases, and in particular in the case of commitments in the
bounded-quantum-storage model where the dishonest committer is forced to
do some partial measurement and where we assume honest parties to
produce only classical output (by measuring their entire quantum state).
Technically, this means that for any dishonest committer @xmath , the
joint state of the honest verifier and of @xmath after the commit phase
is a ccq-state @xmath , where the first register contains the verifier’s
(classical) output and the remaining two registers contain @xmath ’s
(partially classical) output. We propose the following definition.

###### Definition 7.5

A commitment scheme in the bounded-quantum-storage model is called
@xmath -binding , if for every (dishonest) committer @xmath , inducing a
joint state @xmath after the commit phase, there exists a classical
binary random variable @xmath , given by its conditional distribution
@xmath , such that for @xmath and @xmath the state @xmath satisfies the
following condition. When executing the opening phase on the state
@xmath , for any strategy of @xmath , the honest verifier accepts an
opening to @xmath with probability at most @xmath .

It is easy to see that the binding property as defined here implies the
above discussed weak version, namely @xmath and thus @xmath .
Furthermore, it is straightforward to see that this stronger notion
allows for a formal proof of the obvious reduction of a string to a bit
commitment by committing bit-wise: the @xmath -th execution of the bit
commitment scheme guarantees a random variable @xmath , defined by
@xmath , such that the committer cannot open the @xmath -th bit
commitment to @xmath , and thus there exists a random variable @xmath ,
namely @xmath defined by @xmath , such that for any opening strategy,
the committer cannot open the list of commitments to any other string
than @xmath .

In Section 7.5 , we show that the bit commitment comm from Figure 7.1 as
a matter of fact satisfies this stronger and more useful notion of
security. This turns out to be a rather straightforward consequence of
the security of the 1-2 OT scheme from Chapter 6 .

### 7.4 Weak Binding of the Commitment Scheme

In this section, we use the techniques from the analysis of the RabinOT
protocol from Chapter 5 to prove our commitment scheme comm (or rather
its purified version epr-comm ) weakly binding against
quantum-memory-bounded adversarial committers.

Note that the first two steps of epr - qot (from Figure 5.2 ) and
epr-comm (i.e. before the memory bound applies) are exactly the same!
This allows us to reuse Corollary 4.17 and the analysis of Section 5.4
to prove the weakly binding property of epr-comm .

###### Theorem 7.6

For any @xmath , comm is perfectly hiding and weakly binding against
@xmath .

The proof is given below. It boils down to showing that essentially
@xmath and @xmath . The weak binding property then follows immediately
from Corollary 4.17 . The intuition behind @xmath is that a committer
has only a fair chance in opening to @xmath if @xmath measured in the
@xmath -basis has large probability, i.e., @xmath . The following proof
makes this intuition precise by choosing the @xmath and @xmath ’s
correctly. {proof} It remains to show that epr-comm is binding against
@xmath . Let @xmath be such that @xmath , where @xmath is the binary
entropy function. Recall that the number @xmath of @xmath -bit strings
of Hamming-distance at most @xmath from a fixed string is at most @xmath
. Let @xmath be the basis, determined by the bit that @xmath claims in
Step 3 , and in which @xmath measures the quantum state in Step 4 , and
let @xmath be the outcome. Corollary 4.17 implies the existence of an
event @xmath such that @xmath and @xmath . Applying Corollary 2.26 (with
constant @xmath and @xmath ), it follows that any guess @xmath for
@xmath satisfies

  -- -------- -------- --
     @xmath   @xmath   
  -- -------- -------- --

However, if @xmath then sampling a random subset of the positions will
detect an error except with probability at most @xmath . Hence, writing
@xmath and @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

and analogously @xmath . We conclude that

  -- -------- --
     @xmath   
  -- -------- --

### 7.5 Strong Binding of the Commitment Scheme

In this section, we reuse the analysis of the 1-2 OT -protocol from
Chapter 6 to prove the strong binding condition.

###### Theorem 7.7

The quantum bit-commitment scheme comm is @xmath -binding according to
Definition 7.5 against @xmath for a negligible (in @xmath ) @xmath if
@xmath .

Intuitively, one can argue that @xmath has (smooth) min-entropy about
@xmath given @xmath . The Min-Entropy Splitting Lemma implies that there
exists @xmath such that @xmath has smooth min-entropy about @xmath given
@xmath and @xmath . Privacy amplification implies that @xmath is close
to random given @xmath and @xmath ’s quantum register of size @xmath ,
where @xmath is a two-universal one-bit-output hash function, which in
particular implies that @xmath cannot guess @xmath . The formal proof is
given below. {proof} It remains to show that epr-comm is strongly
binding against @xmath . Let @xmath be the random basis that would
correspond to the choice of basis in the first step of comm , i.e.
@xmath for @xmath and @xmath for @xmath . Let @xmath be the measurement
outcome when @xmath measures his halves of the EPR-pairs in basis @xmath
.

Recall that @xmath denotes the binary Shannon entropy. Choose @xmath and
@xmath all positive, but small enough such that @xmath , @xmath , and
@xmath . Before Step 3 , the overall state is given by the ccq-state
@xmath after @xmath has measured all but @xmath of his qubits, where
@xmath describes the outcome of the verifier @xmath measuring his part
of the state in random basis @xmath . From the uncertainty relation
(Corollary 4.23 ), we know that @xmath for @xmath exponentially small in
@xmath . Therefore, by Corollary 2.16 , there exists a binary random
variable @xmath such that for @xmath , it holds that

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

Recall that @xmath . Applying Corollary 2.26 , it follows that any guess
@xmath for @xmath satisfies

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

which is negligible by the choice of the parameters.

### 7.6 Weakening the Assumptions

As argued earlier, assuming that a party can produce single qubits (with
probability 1) is not reasonable given current technology. Also the
assumption that there is no noise on the quantum channel is impractical.
It can be shown that a straightforward modification of comm remains
secure in the @xmath -weak quantum model as introduced in Section 5.6
(see also Section 9.1.1 ), with @xmath and @xmath .

The protocol comm ’ in Figure 7.3 is the same as comm from Figure 7.1
except that in the last Step 4 , @xmath accepts if and only if @xmath
for all but about a @xmath -fraction of the @xmath where @xmath . More
precisely, for all but a @xmath -fraction, where @xmath is sufficiently
small.

###### Theorem 7.8

In the @xmath -weak quantum model, comm ’ is perfectly hiding and it is
weakly binding against @xmath for any @xmath satisfying @xmath .

{sketch}

Using Chernoff’s inequality (Lemma 2.5 ), one can argue that for honest
@xmath and @xmath , the opening of a commitment is accepted except with
negligible probability. The hiding property holds using the same
reasoning as in Lemma 7.2 . And the binding property can be argued
essentially along the lines of Theorem 7.6 , with the following
modifications. Let @xmath denote the set of indices @xmath where @xmath
succeeds in sending a single qubit. We restrict the analysis to those
@xmath ’s which are in @xmath . By Chernoff’s inequality (Lemma 2.5 ),
the cardinality of @xmath is about @xmath (meaning within @xmath ),
except with negligible probability. Thus, restricting to these @xmath ’s
has the same effect as replacing @xmath by @xmath (neglecting the @xmath
to simplify notation). Assuming that @xmath knows every @xmath for
@xmath , for all @xmath ’s with @xmath , he has to be able to guess all
but about a @xmath -fraction correctly, in order to be successful in the
opening. Using Corollary 2.26 , we can show that for a correctly chosen
@xmath , the probability of guessing @xmath within Hamming distance
@xmath to the real @xmath is negligible. Therefore, @xmath succeeds with
only negligible probability if the fraction of allowed errors @xmath is
smaller than @xmath , i.e.

  -- -------- --
     @xmath   
  -- -------- --

Additionally, in order for the machinery from Theorem 7.6 to work,
@xmath must be such that

  -- -------- --
     @xmath   
  -- -------- --

@xmath can be chosen that way if

  -- -------- --
     @xmath   
  -- -------- --

Using the fact that @xmath for any @xmath and @xmath such that @xmath ,
this is clearly satisfied if @xmath .

###### Theorem 7.9

In the @xmath -weak quantum model, comm ’ is perfectly hiding and it is
strongly binding against @xmath for any @xmath satisfying @xmath .

{sketch}

The proof goes like the proof of Theorem 7.8 , but uses the techniques
from Section 7.5 . In order for those to work, we need to choose @xmath
, and @xmath all positive and such that

  -- -------- -- -- -------
     @xmath         (7.1)
  -- -------- -- -- -------

We verify that the assumption @xmath on @xmath allows for that.
Rearranging the terms and using that @xmath for @xmath yields

  -- -------- --
     @xmath   
  -- -------- --

Using as in the previous proof the fact that @xmath for any @xmath and
@xmath such that @xmath , we get that

  -- -------- --
     @xmath   
  -- -------- --

That allows to choose @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

and therefore, also @xmath and @xmath can be chosen such that the
conditions ( 7.1 ) are fulfilled.

## Chapter 8 Qkd Secure Against Quantum-Memory-Bounded Eavesdroppers

In this chapter, we present another application for the uncertainty
relation derived in Section 4.5 . This illustrates that these relations
are useful in scenarios beyond the simple two-party setting.

In Quantum Key Distribution ( QKD ), two honest players Alice and Bob
want to agree on a secure key, using only completely insecure quantum
and authentic classical communication. The computationally unbounded
eavesdropper Eve should not get any information about the key. A major
difficulty when implementing QKD schemes is that they require a
low-noise quantum channel. The tolerated noise level depends on the
actual protocol and on the desired security of the key. Because the
quality of the channel typically decreases with its length, the maximum
tolerated noise level is an important parameter limiting the maximum
distance between Alice and Bob.

We consider a model in which the adversary has a limited amount of
quantum memory to store the information she intercepts during the
protocol execution. In this model, we show that the maximum tolerated
noise level is larger than in the standard scenario where the adversary
has unlimited resources.

For simplicity, we restrict ourselves to one-way QKD protocols which are
protocols where error-correction is performed non-interactively, i.e., a
single classical message is sent from one party to the other.

The results in this chapter appeared in [ DFR @xmath 07 ] .

### 8.1 Derivation of the Maximum Tolerated Noise Level

Let @xmath be a set of orthonormal bases of a @xmath -dimensional
Hilbert space @xmath . For each basis @xmath , we assume that the @xmath
basis vectors are parametrized by the elements of the fixed set @xmath
of size @xmath . We then consider QKD protocols consisting of the steps
described in Figure 8.1 .

Note that the quantum channel is only used in the preparation step.
Afterwards, the communication between Alice and Bob is only classical
(over an authentic channel).

As shown in [ Ren05 , Lemma 6.4.1] , the length @xmath of the secret key
that can be generated by the protocol described above is given by ¹ ¹ 1
The approximation in this and the following equations holds up to some
small additive value which depends logarithmically on the desired
security @xmath of the final key.

  -- -------- --
     @xmath   
  -- -------- --

where the cq-state @xmath is the state of the quantum system with the
property that @xmath contains all the information Eve has gained during
the preparation step of the protocol and where @xmath is the number of
error correction bits sent from Alice to Bob. Note that this formula can
be seen as a generalization of the well-known expression by Csiszár and
Körner for classical key agreement [ CK78 ] .

Let us now assume that Eve’s system @xmath can be decomposed into a
classical part @xmath and a purely quantum part @xmath . Then, by the
same derivation as in the proof of Corollary 2.25 , we find

  -- -------- --
     @xmath   
  -- -------- --

As, during the preparation step, Eve does not know the encoding bases
which are chosen at random from the set @xmath , we can apply our
uncertainty relation (Theorem 4.22 ) to get a lower bound for the
min-entropy of @xmath conditioned on Eve’s classical information @xmath
, i.e.,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath denotes the length of the sifted raw key @xmath and @xmath
is the average entropic uncertainty bound for @xmath . [write much
more!] Let @xmath be the bound on the size of Eve’s quantum memory
@xmath . Moreover, let @xmath be the average amount of error correction
information that Alice has to send to Bob per symbol of the sifted raw
key @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

Hence, if the memory bound only grows sublinearly in the length @xmath
of the sifted raw key, then the key rate , i.e., the number of key bits
generated per bit of the sifted raw key, is lower bounded by

  -- -------- --
     @xmath   
  -- -------- --

### 8.2 The Binary-Channel Setting

For a binary channel (with a two-dimensional Hilbert space @xmath ), the
average amount of error correction information @xmath is given by the
binary Shannon entropy ² ² 2 This value of @xmath is only achieved if an
optimal error-correction scheme is used. In practical implementations,
the value of @xmath might be slightly larger. @xmath , where @xmath is
the bit-flip probability (for classical bits encoded according to some
orthonormal basis as described above). The achievable key rate of a QKD
protocol using a binary quantum channel is thus given by

  -- -------- --
     @xmath   
  -- -------- --

Summing up, we have derived the following theorem.

###### Theorem 8.1

Let @xmath be a set of orthonormal bases of @xmath with average entropic
uncertainty bound @xmath . Then, a one-way QKD protocol as in Figure 8.1
produces a secure key against eavesdroppers whose quantum-memory size is
sublinear in the length of the raw key (i.e., sublinear in the number of
qubits sent from Alice to Bob) at a positive rate as long as the
bit-flip probability @xmath fulfills

  -- -------- -- -------
     @xmath      (8.1)
  -- -------- -- -------

For the BB84 protocol [ BB84 ] , we have @xmath (cf. Inequality ( 4.2
)). Inequality ( 8.1 ) is thus satisfied as long as @xmath . This bound
coincides with the known bound for one-way QKD in the standard model
(with an unbounded eavesdropper). So, using our analysis here, the
memory-bound does not give an advantage.

The situation is different for the six-state protocol where @xmath .
According to ( 8.1 ), security against memory-bounded adversaries is
guaranteed (i.e. @xmath ) as long as @xmath . If one requires security
against an unbounded adversary, the threshold for the same protocol lies
below @xmath as shown by Lo [ Lo01 ] , and even the best known QKD
protocol on binary channels with one-way classical post-processing can
only tolerate noise up to roughly @xmath [ RGK05 ] . It has also been
shown that, in the unbounded model, no such protocol can tolerate an
error rate of more than @xmath .

The performance of QKD protocols against quantum-memory bounded
eavesdroppers can be improved further by making the choice of the
encoding bases more random. For example, they might be chosen from the
set of all possible orthonormal bases on a two-dimensional Hilbert
space. As shown in Section 4.5.3 , the overall average entropic
uncertainty bound is then given by @xmath and ( 8.1 ) is satisfied if
@xmath . For an unbounded adversary, the thresholds are the same as for
the six-state protocol (i.e., @xmath for the best known one-way
protocol).

### 8.3 Possible Extensions

It is an interesting open problem to consider protocols using
higher-dimensional quantum systems. The results described in Section
4.5.3 show that for high-dimensional systems, the average entropic
uncertainty bound converges to its theoretical maximum. The maximal
tolerated channel noise might thus be higher for such protocols
(depending on the noise model for higher-dimensional quantum channels).

Another interesting problem is to derive completely one-way
quantum-key-distribution schemes, i.e. to eliminate the interactive
sifting phase from the protocol in Figure 8.1 . The idea is to let the
honest parties use a pre-shared secret key to determine the bases of the
encoding. If a key of size linear in the number of qubits is used, the
scheme has to guarantee that a big portion of the key can be reused
several times in order to yield a reasonable amount of fresh key.
Quantifying the amount of information an eavesdropper can learn about
the pre-shared key by interfering in the preparation step and
eavesdropping on the following classical communication is an open
problem.

Another approach consists of expanding a pre-shared key of size only
logarithmic in the number of qubits into a pseudo-random linear-size key
to determine the bases of the encoding. It is an open question how to
extend our uncertainty relation from Section 4.5 to the case of only
pseudo-random bases.

## Chapter 9 Conclusion

### 9.1 Towards Practice

In the following two sections, we elaborate on the question how close to
practice our systems are. First, we argue that imperfections occurring
in practice like dark counts and empty pulses are covered by our @xmath
-weak quantum model used in Sections 5.6 , 6.4.2 , and 7.6 . Second, we
sketch how our techniques can be extended to the more realistic setting
of noisy quantum memory .

#### 9.1.1 More Imperfections

A natural approach for implementing two-party protocols like bb84-qot ,
Rand 1-2 QOT @xmath , and comm is to use the polarization of photons
governed by the laws of quantum optics. Such systems are nowadays at the
stage where they can be built in a optical physics lab. Besides the
already modeled bit errors and multi-pulse emissions, more imperfections
of the physical apparatus such as empty pulses and dark counts need to
be taken into account.

The players have synchronized clocks and in every predefined time slot,
the sender is supposed to send out a single qubit. In practice, weak
coherent pulses are used to approximate single-photon sources by
producing in average only a small fraction of one qubit per pulse. This
means that most of the pulses are empty , but on the other hand, there
is also a small probability for a multi-qubit pulse. The receiver
reports to the sender in which time slots he received pulses.

Empty pulses also occur when the quantum channel lets a transmitted
qubit escape or when it is absorbed. It is realistic that a good
estimate on the rate at which empty pulses are produced (when no
adversary is present) is known, e.g., from the hardware specifications
and by measuring and calibrating the experimental setup. In this case,
the adversary can only take advantage of empty pulses caused by
absorption in the fiber. The best the adversary can do is to substitute
the fiber for one that preserves all qubits sent and to report empty
pulses when a single pulse has been received. The effect is to increase
the rate at which multi-qubit pulses occur. This attack is known as
Photon-Number-Splitting attack as first noted by Huttner, Imoto, Gisin,
and Mor [ HIGM95 ] and for instance explained in [ BLMS00a , BLMS00b ]
in the setting of quantum key distribution. It follows that empty pulses
can also be included in the @xmath -weak quantum model by an appropriate
adjustment of parameter @xmath .

Furthermore, thermal fluctuation in the detector hardware might result
in detection even though no qubit was received. This is called a dark
count . In this time slot, the receiver will report the reception of a
qubit and as the outcome is random, it agrees with the actual bit sent
with probability @xmath .

Formally, assume that a practical implementation of bb84-qot , Rand 1-2
QOT @xmath , or comm takes place in a setting where @xmath is the
probability for a bit error caused by the channel, @xmath is the
probability for a dark count in a specific time slot, @xmath is the
probability for a multi-qubit transmission in a non-empty pulse, and
@xmath is the probability for an empty pulse caused by absorption of a
non-empty pulse. In these terms, dark counts contribute @xmath to the
bit-error rate @xmath . If the adversary is able to get perfect
transmission, she can suppress single-qubit pulses up to a rate of
@xmath , thereby increasing the rate @xmath of multi-photon pulses by
@xmath . It follows that if bb84-qot , comm , and Rand 1-2 QOT @xmath
are secure in the @xmath -weak quantum model, then their implementation
is also secure, provided it is accurately modeled by these four
parameters.

Likewise, a variety of imperfections specific to particular
implementations may be adapted to the weak quantum model.

#### 9.1.2 Generalizing the Memory Model

The bounded-quantum-storage model limits the number of physical qubits
the adversary’s memory can contain. A more realistic model would rather
address the noise process the adversary’s memory undergoes. For
instance, it is not hard to build a very large, but unreliable memory
device containing a large number of qubits. It is reasonable to expect
that our protocols remain secure also in a scenario where the
adversary’s memory is of arbitrary size, but where some quantum
operation (modeling noise) applies to it. If we do not substitute @xmath
with the number of qubits @xmath in Term ( 2.6 ) in the
privacy-amplification Section 2.5 , then our constructions can cope with
slightly more general memory models. In particular, all our protocols
that are secure against adversaries with memory of no more than @xmath
qubits are also secure against any noise model that reduces the rank
@xmath of the mixed state @xmath held by the adversary to at most @xmath
.

An example of a noise process resulting in a reduction of @xmath is an
erasure channel. Assuming the @xmath initial qubits are each erased with
probability larger than @xmath when the memory bound applies, it holds
except with negligible probability in @xmath that @xmath . The same
applies if the noise process is modeled by a depolarizing channel with
error probability @xmath . Such a depolarizing channel replaces each
qubit by a random one with probability @xmath and does nothing with
probability @xmath .

The technique we have developed does not allow to deal with depolarizing
channels with @xmath although one would expect that some @xmath should
be sufficient to ensure security against such adversaries. The reason
being that not knowing the positions where the errors occurred should
make it more difficult for the adversary than when the noise process is
modeled by an erasure channel. However, it seems that our uncertainty
relations are not strong enough to address this case. Generalizing the
bounded-quantum-storage model to more realistic noisy-memory models is
an interesting open question.

### 9.2 Conclusion

The bounded-quantum-storage model presented in this thesis is an
attractive model, in both the theoretical and practical sense. On the
theoretical side, it allows for very simple protocols implementing basic
two-party primitives such as oblivious transfer and bit commitment. New
high-order entropic uncertainty relations have been established in order
to show the security with the help of techniques such as purification
and privacy amplification by two-universal hashing. These uncertainty
relations can also be applied in different settings like quantum key
distribution.

On the practical side, the protocols do not require any quantum memory
for honest players and remain secure provided the adversary has a
quantum memory of size bounded by a constant fraction of all transmitted
qubits. Such a gap between the amount of storage required for honest
players and adversaries is not achievable by classical means. The
protocols can be adapted to tolerate various kinds of errors and in
fact, they can be implemented with today’s technology. A collaboration
of people from the computer science and physics departments of the
University of Aarhus is currently working on the implementation of these
protocols ¹ ¹ 1 See http://www.brics.dk/~salvail/qusep.html for further
information on the QUSEP project. .

In summary, one can say that the bounded-quantum-storage model has
passed its first tests by proving its power (the possibility of
oblivious transfer) and by inspiring beautiful theoretical results
(quantum uncertainty relations). It is a good sign that the protocols
for the basic primitives are simple in structure. In principle, enough
instances of these protocols could be used to implement more involved
cryptographic tasks like secure identification, which reduces
essentially to securely checking whether two inputs are equal (without
revealing more than this mere bit of information). However, it is a
natural next step to find more efficient, direct protocols for those
tasks, secure in the bounded-quantum-storage model. Such a direct
approach gives a better ratio between storage-bound and
communication-complexity and is the topic of a recent paper [ DFSS07 ] .

A major open problem is the optimality of the bounds on the adversary’s
quantum memory. The bit-commitment protocol comm for instance appears to
be secure against any adversary with memory less than @xmath qubits, but
our analysis requires the memory to be smaller than @xmath (or @xmath
for strong binding). Also, finding protocols secure against adversaries
in more general noisy-memory models, as discussed in the last Section
9.1.2 , would certainly be a natural and interesting extension of this
work to more practical settings [ DSTW07 ] . Furthermore, there is still
a lack of simple and intuitive security definitions for primitives like
1-2 OT etc. with rigorous composability results (like universal
composability) in the quantum setting. Very recent results in this
direction have been established in [ WW07 ] .

## Notation

  General                        
  ------------------------------ ------------------------------------------------------------------------------------
  @xmath                         binary logarithm
  @xmath                         natural logarithm
  @xmath                         natural numbers: @xmath
  @xmath                         real numbers
  @xmath                         set of real numbers @xmath such that @xmath
  @xmath                         set of real numbers @xmath such that @xmath
  @xmath                         substring of @xmath consisting of bit positions in index set @xmath
  @xmath                         as above, padded with @xmath s
  @xmath                         set of @xmath -bit strings with Hamming distance at most @xmath from @xmath @xmath
  @xmath                         any function in @xmath smaller than the inverse of any polynomial
                                 for large enough @xmath
  @xmath                         @xmath for @xmath and @xmath for @xmath
  @xmath                         Kronecker delta
  Classical Information Theory   
  @xmath                         conditional probability distribution of @xmath given @xmath
  @xmath                         expected value of the real random variable @xmath
  @xmath                         variational distance between distributions @xmath and @xmath
  @xmath                         @xmath and @xmath are at variational distance at most @xmath
                                 independent and uniformly distributed binary random variable
  @xmath                         @xmath copies of it
  @xmath                         event
  @xmath                         indicator random variable of event @xmath
  @xmath                         Markov chain
  Quantum Information Theory     
  @xmath                         Hilbert space of dimension @xmath
  @xmath                         set of density operators on @xmath
  @xmath                         density operator: normalized, Hermitian, non-negative
  @xmath                         trace of @xmath
  @xmath                         fully mixed state
  @xmath                         trace distance between @xmath and @xmath
  @xmath                         classical bit @xmath encoded in basis @xmath
  @xmath                         cq-state

  Entropies   
  ----------- -------------------------------------------------------------------------
  @xmath      binary Shannon entropy function
  @xmath      @xmath -order sum of @xmath given @xmath with joint distribution @xmath
  @xmath      Rényi entropy of order @xmath of @xmath given @xmath
  @xmath      min-entropy of @xmath given @xmath
  @xmath      collision entropy of @xmath given @xmath
  @xmath      Shannon entropy of @xmath given @xmath
  @xmath      max-entropy of @xmath given @xmath
  @xmath      average conditional Rényi entropy of order @xmath
  @xmath      @xmath -smooth Rényi entropy of order @xmath of @xmath given @xmath
  @xmath      @xmath -smooth min-entropy of @xmath given @xmath
  @xmath      @xmath -smooth max-entropy of @xmath given @xmath
  @xmath      Rényi entropy of order @xmath of the state @xmath
  @xmath      min-entropy of @xmath relative to @xmath
  @xmath      min-entropy of @xmath given @xmath
  @xmath      @xmath -smooth min-entropy of @xmath relative to @xmath
  @xmath      @xmath -smooth min-entropy of @xmath given @xmath