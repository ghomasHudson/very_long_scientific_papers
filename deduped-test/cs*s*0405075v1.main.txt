##### Contents

-    1 Introduction
-    2 The @xmath -Calculus and Explicit Substitutions
    -    2.1 An Overview of the @xmath -Calculus
        -    2.1.1 Terms in the @xmath -Calculus
        -    2.1.2 Substitutions
        -    2.1.3 Rules of @xmath -Conversions
    -    2.2 The De Bruijn Notation
        -    2.2.1 Terms in the De Bruijn Notation
        -    2.2.2 Substitutions in the De Bruijn Notation
        -    2.2.3 Rule of @xmath -Contraction in the De Bruijn Notation
    -    2.3 Explicit Substitution Calculi
        -    2.3.1 The Suspension Notation
        -    2.3.2 Some Formal Properties
        -    2.3.3 Other Explicit Substitution Calculi
-    3 Environment Based Reduction
    -    3.1 An Environment Based Head Normalization Procedure
    -    3.2 Discussion on Heap Usage
-    4 Explicit Use of Suspensions
    -    4.1 A Head Normalization Procedure with Explicit Suspensions
    -    4.2 Discussion on Heap Usage
-    5 Combining Implicit and Explicit Uses of Suspensions
-    6 Comparisons of Different Head Reduction Strategies
    -    6.1 Experiment Examples
    -    6.2 Experiment Results
-    7 Conclusions

###### List of Figures

-    2.1 Rewrite rules for the suspension notation
-    2.2 The enhanced version of rule (r5)
-    3.1 Type declarations for an environment based head normalization
    procedure
-    3.2 Head normalization with implicit use of suspensions
-    3.3 Calculating out suspensions
-    3.4 Construction functions
-    4.1 Type declarations for suspension terms
-    4.2 Auxiliary procedure for exposing term structures under
    suspensions
-    4.3 Head normalization using suspensions and immediate rewriting
-    5.1 Construction functions
-    5.2 Head normalization using suspensions implicitly and explicitly
-    6.1 Heap usage for different reduction approaches
-    6.2 The effect of the term size

\textpages \singlespace

## Chapter 1 Introduction

This thesis is concerned with the treatment of @xmath -terms in a
situation where they are used as a means for representing syntactic
objects whose structures involve binding. Such a use occurs in a variety
of metaprogramming and symbolic computation tasks, such as proof
assistants [ 5 , 6 , 8 , 22 ] , logical frameworks [ 7 , 11 ] and
metalanguages [ 18 , 23 ] . The usefulness of @xmath -terms in
representing higher-order syntactic objects, objects involving binding,
lies in the following two aspects. First, the binding notions can be
encoded by @xmath -abstractions explicitly. For example, in a theorem
proving context, the first-order logic formula @xmath , where @xmath
represents an arbitrary formula in which @xmath perhaps appears free,
can be encoded by the @xmath -term @xmath , where @xmath denotes,
recursively, the representation of @xmath , and the constructor @xmath
encodes the universal quantifier. The binding scope of the universal
quantifier over @xmath in the above formula is explicitly represented by
the @xmath -abstraction. Second, the important substitution computation
on such objects is captured by the attendant @xmath -reduction operation
on @xmath -terms. For example, in the formula above, the instantiation
of the quantifier over @xmath with a term denoted by @xmath can be
simply represented as @xmath . The displayed @xmath -term can be
rewritten to a form in which the occurrences of @xmath in @xmath have
been replaced by @xmath using the @xmath -reduction operation, and
therefore represents the result of substituting @xmath properly for
@xmath when we assume a notion of equality on @xmath -terms based on
this operation.

Since @xmath -terms are used as data structures to represent syntactic
objects, these terms may often have to be compared in the course of
symbolic computation over such objects. To perform comparisons properly,
the equality relation between @xmath -terms must incorporate variable
renaming, @xmath -conversion. For example, the two @xmath -terms @xmath
and @xmath which represent formulae @xmath and @xmath respectively,
should be recognized as being equal. Further, as we have noted already,
in determining equality, it is necessary to take into account the notion
of @xmath -conversion. For instance, in a theorem proving context, we
may want to check whether the formula generated from instantiating the
quantifier over @xmath in the formula @xmath is a universally quantified
formula with a conjunction as its top-level connective inside the
quantifier. This computation requires matching the @xmath -term @xmath
with a term of the form @xmath , where @xmath and @xmath are schema
variables that may be instantiated in the course of the matching; we
note that we are using the constructor @xmath here to encode the logical
connective @xmath . An important point to note here is that in order for
the matching to be performed, the @xmath -redex in the first term has to
be contracted and the top-level structure of the resulting formula has
to be exposed. The latter actually means that it is necessary to
propagate a substitution into a context embedded within an abstraction.
This is an aspect that is novel to the use of @xmath -terms as
representational devices. In the context of functional programming, for
instance, it is never necessary to look inside abstraction contexts.

Considering the frequency with which it is used, the efficiency of the
implementation of the @xmath -reduction operation has a significant
impact on the performance of the system that supports the use of @xmath
-terms as its data structures. Focusing on this issue in the realization
of such systems is therefore important. A significant part of the @xmath
-reduction operation is substitution. Traditional presentations of
@xmath -contraction, the single step rewriting process from which the
@xmath -reduction operation is constructed, take a rather simplistic
view of substitution. The operation is usually presented via a rule such
as @xmath , where @xmath denotes the term obtained by replacing the free
occurrences of @xmath in @xmath by @xmath , carrying out the necessary
renaming in the process to ensure that binding scopes are properly
respected. Unfortunately, from an implementation perspective, the
substitution operation is too complex to be performed as an atomic step.
In particular, this substitution operation requires going through the
structure of @xmath , taking care to rename the bound variables where
necessary to avoid illegal capture, and eventually replacing free
occurrences of @xmath with @xmath . For this reason, in real
implementations, the substitution operation is often broken into smaller
steps. Each step focuses on one specific substructure of the term. For
example, consider the term @xmath . When it is observed that this term
can be rewritten using the @xmath -contraction rule, the reduction
process registers the substitution of @xmath for @xmath in an
environment. Calling this environment @xmath , the task now becomes that
of propagating it over @xmath and @xmath . In processing the term with
the abstraction, it may become necessary to rename the bound variable
and this can be built into the rule for this case, possibly resulting in
the addition of the substitution of, say, @xmath for @xmath to the
environment @xmath . Finally, in traversing @xmath and @xmath , a
variable may be encountered and the result in this case would be to
possibly substitute a term based on the environment.

The use of an environment actually leads to some possible improvements
in the implementation of reduction. First, the delaying of substitutions
gives us the ability to combine substitutions generated by different
@xmath -contractions into the same environment so that they can all be
performed in one traversal over the involved term. For example, consider
the term @xmath . There are two redices that have to be contracted in
normalizing this term. If the naive approach to @xmath -contraction is
used, it would be necessary to walk through the structure of @xmath
twice in effecting the necessary substitutions. With the delaying of
substitutions, the two substitutions @xmath and @xmath can be combined
into one environment and performed in the same traversal over @xmath .
The delaying of substitutions also gives us more opportunities to avoid
unnecessary term traversals. For example, in the term considered above,
the variable @xmath that is to be substituted for by @xmath can only
occur inside @xmath . Under the naive approach to @xmath -contraction,
we would first substitute @xmath for all the free occurrences of @xmath
in @xmath . Then the traversal to substitute @xmath for @xmath would
also examine these (new) occurrences of @xmath to see if there are any
free occurrences of @xmath in them to replace. However, there are no
such @xmath ’s in @xmath . With the delayed performance of substitution,
such substitution traversals can be recognized and avoided. This kind of
approach to substitution and reduction has, in fact been central to the
implementation of functional programming languages. In recent years, it
has also been given a formal basis by the work on explicit substitution
notations (e.g. see [ 1 , 14 , 21 ] ) that incorporate the possibility
of encoding suspended substitutions in terms. These notations also make
it possible to extend this approach to reduction even to situations
where we need to look inside abstractions.

The above discussion leads naturally to an implementation of @xmath
-reduction that is environment based. In the simplest form, such a
procedure would be guided by an explicit substitution notation but would
use suspended substitutions only implicitly, it would not explicitly
create terms with suspended substitutions as their (sub)structures, but,
instead, it would record those suspended substitutions via local
variables and parameters of the reduction procedure. Thus the terms
eventually produced by such a procedure would not contain subparts
encoding suspended substitutions. More specifically, when the
non-reducible head of a term is found, the procedure would need to
actually carry out the suspended substitutions on the remaining part of
the term structure. The consequence of this is that the ability to delay
and combine substitutions is limited to the extent of a single
invocation of the reduction procedure, which means the opportunities for
sharing the substitution walks that are caused by contracting redices
generated dynamically by other kinds of computation steps are missed.
For example, consider a formula in the first-order logic that is
represented by @xmath , where @xmath is an arbitrary @xmath -term.
Suppose that we now carry out a computation over this formula that
involves recognizing and instantiating all its universal quantifiers.
This computation would first recognize the outermost quantifier and
instantiate it by generating the term @xmath . Now the outer redex would
be contracted, generating a substitution computation involving the
variable @xmath . At a later stage, the inner quantifier will be
noticed, generating another substitution computation, this time
involving the variable @xmath . Thus, it is necessary in principle to
substitute for two different variables in the structure represented by
@xmath . If we do not have the ability to delay substitutions beyond the
extent of one invocation of the reduction procedure, each of these
substitutions requires a separate walk over the structure of @xmath .
This leads to overhead in both processing time and in the creation of
term structures.

To overcome this kind of overhead, it becomes meaningful to consider a
reduction procedure that uses the ability to suspend substitutions
explicitly by sometimes returning terms that have (sub)structures
encoding other terms with substitutions yet to be performed on them.
Now, explicit substitution notations are usually presented via rules
that generate and propagate substitutions. For example, the @xmath
-contraction operation may be expressed via a rule of the form @xmath ,
where an expression of the form @xmath represents the term @xmath with
substitutions contained in the environment @xmath to be performed on it,
and environments are represented as lists of bindings. Similarly, we may
have a rule of the form @xmath that realizes the propagation of
substitutions over applications. Assuming such a presentation, the
simplest way of realizing the kind of reduction procedure we desire
would be to use these kinds of rules directly, explicitly creating
structures corresponding to the righthand sides when matching those
corresponding to the lefthand sides. In the end, when the top-level
structure of the term has been exposed to the extent desired, the
non-reducible head of the term is found, the rewriting process is
stopped. Notice that in this process some subterms may be left in the
form of @xmath to be further evaluated as desired at some later stage of
computation.

The second strategy that we have described clearly solves the problems
noted for the first strategy but it also has problems of its own. In
particular, it has the potential drawback for creating too many new
structures. This would happen if, for instance, the righthand sides of
rules that we create become the lefthand sides of other rules and have
to be rewritten immediately. Now, new terms that are created have
obviously to be allocated in dynamic space, in the heap. If a lot of
space is unnecessarily allocated in the heap, it will become necessary
in an industrial-strength system to reclaim such space using a garbage
collector. The running time of the garbage collector becomes a factor in
the overall performance of the computational system, and therefore we
would like to reduce it as much as possible.

The organization of the first reduction procedure based on environment
suggests a way to avoid such a potentially profligate use of heap space.
Rather than creating new terms with embedded substitutions immediately,
the suspended substitutions may be represented implicitly by the
parameters and local variables of the reduction procedure. However when
the non-reducible head of a term is found, rather than performing the
substitutions on the remaining term structures right away, new
structures that maintain such substitutions in suspended forms can be
created explicitly. This approach combines the implicit and explicit
treatments of substitutions and can accrue the benefits of both.

In earlier paragraphs, we have outlined three different approaches to
realizing reduction and have discussed their potential drawbacks and
advantages. In this thesis we lend concreteness to these informal
discussions. Our particular contributions are twofold:

1.  Using a specific explicit substitution notation [ 17 ] , we develop
    the three strategies into reduction procedures that can be embedded
    in actual systems. The development of the third strategy is new to
    our work and that of the first extends usual environment based
    procedures to a situation where it is important to look within
    abstractions. We also include correctness proofs with our
    procedures.

2.  We quantify the differences between the different strategies through
    experiments on “real-life” computations. To conduct this study, we
    have realized our reduction procedures in the C language and have
    embedded them within the Teyjus implementation [ 19 ] of @xmath
    Prolog [ 18 ] —a language that provides @xmath -terms as data
    structures—and have collected data from a suite of user programs
    using the resulting versions of the system. We believe this kind of
    a study to be unique to our work and its encompassing project [ 20 ,
    15 ] .

The rest of this thesis is organized as follows. In the next chapter we
introduce the @xmath -calculus and describe an explicit substitution
calculus called the suspension notation [ 21 ] ; this notation has
already been used in two practical systems [ 19 , 24 ] and is therefore
an appealing basis for our study. Chapters 3 , 4 and 5 then present
reduction procedures realizing the three different approaches of
interest. These procedures are presented using the SML language both for
simplicity of exposition and for concreteness, although the same ideas
can be deployed in realizations in any other language as well. Chapter 6
contains a quantitative comparison of these approaches using, in fact, a
C based realization of each. Chapter 7 concludes the thesis.

## Chapter 2 The @xmath-Calculus and Explicit Substitutions

This chapter provides technical background needed for our later
discussions. In Section 2.1 , we give an overview of the @xmath
-calculus. Section 2.2 introduces the de Bruijn notation. In Section 2.3
, we introduce the idea of explicit substitution calculi and describe
the suspension notation as a representative.

### 2.1 An Overview of the @xmath-Calculus

Invented by Alonzo Church in 1930’s, the @xmath -calculus is designed to
capture the most basic aspects of functionality, what it is means to be
a function and what it means to apply a function to arguments under this
interpretation. Using @xmath -terms to represent syntactic objects
naturally requires the ability to perform comparisons between @xmath
-terms. The usual method is to transform the terms to their @xmath
-normal forms first and then to check the equality between those normal
forms, which we will discuss in detail in Section 2.1.3 . Thus the
normal forms of the terms under comparison should be guaranteed to
exist. In the context of using @xmath -terms to represent syntactic
objects, we are mainly interested in the use of typed @xmath -calculi.
In these situations, the set of terms is restricted to only those that
satisfy certain typeable constraints, and this restriction usually
ensures the existence of @xmath -normal forms. However, since we are not
interested in any property associated with the types of @xmath -terms
other than the guarantee of the existence of @xmath -normal forms, our
discussion in this thesis is still based on the untyped @xmath -calculus
for generality and simplicity. Section 2.1.1 introduces the terms of the
untyped @xmath -calculus. Section 2.1.2 presents the substitution
operation. Section 2.1.3 describes the important @xmath -conversion and
@xmath -conversion operations and the equality notion of @xmath -terms
based upon them.

#### 2.1.1 Terms in the @xmath-Calculus

We begin with the definition of @xmath -terms.

###### Definition 2.1.1.1.

We assume in the beginning that we are given a set of constants, a set
of abstractable variables and a set of instantiatable variables. The set
of @xmath -terms is then the smallest set obtained from the combination
of these sets using the following operations:

1.   abstraction, that produces the term @xmath given an abstractable
    variable @xmath and a @xmath -term @xmath , and

2.   application, that produces the term @xmath given two @xmath -terms
    @xmath and @xmath .

In an abstraction of the form @xmath , we say that the scope of this
abstraction is @xmath and we also refer to @xmath as the body of this
abstraction. In an application of the form @xmath , we refer to @xmath
as the function and @xmath as the argument of this application.

The instantiatable variables in this definition are also referred to as
logic variables. They differ from the abstractable variables in the
sense that they cannot be substituted by @xmath -reductions, which we
will discuss later, but possibly be replaced by other operations trying
to make two @xmath -terms equal, , unifications.

For the sake of readability, we often omit parentheses surrounding
abstractions and applications when we write terms, assuming that these
can be inserted using the following conventions: applications associate
to the left and have a higher priority than abstractions.

Intuitively, the abstraction term @xmath is intended to represent the
function that when given @xmath returns @xmath . In this sense, @xmath
is the formal argument and @xmath is the body of this function. For
example, using @xmath as an infix operator, the abstraction @xmath
represents a function that when given a value for @xmath returns @xmath
.

Now consider two @xmath -terms @xmath and @xmath . It can be seen that
these two terms both represent the same function: when given the same
actual argument, they return the same value, that is, the actual
argument plus one. For this reason, we want to recognize these two terms
as being equal. The equality relation that we describe for @xmath -terms
in Section 2.1.3 actually encompasses this idea.

The intuitive meaning of an application term is the application of a
function to actual arguments. For example, the term @xmath represents
the application of the function @xmath to @xmath . Naturally, this
application term is equal to @xmath . For this reason, we expect to
generally recognize the term representing the application of a function
to a value, and the term representing the result of evaluating this
application, to be equal. The notion of equality we formalize in Section
2.1.3 also encompasses this idea.

###### Definition 2.1.1.2.

Term @xmath is said to be an immediate subterm of @xmath when @xmath is
in the form of @xmath , @xmath or @xmath . A term @xmath is a subterm of
@xmath if it is @xmath or, recursively, a subterm of an immediate
subterm of @xmath .

###### Definition 2.1.1.3.

Let @xmath be a @xmath -term that has a subterm @xmath . All the
occurrences of @xmath in @xmath are said to be bound in @xmath , and
@xmath is called a bound variable of the subterm @xmath . Any non-bound
occurrence of @xmath is said to be free in @xmath . If @xmath has at
least one free occurrence in @xmath , then it is called a free variable
of @xmath ; the set of all the free variables of @xmath is represented
by @xmath . If @xmath , we refer to @xmath as a closed term.

According to this definition, @xmath is a bound variable of the closed
term @xmath . For another example, consider the term @xmath . The
variable @xmath is free in its subterm @xmath , even though it is bound
in the top-level term.

#### 2.1.2 Substitutions

To compare two @xmath -terms @xmath and @xmath , it is required to
rename their formal arguments to be the same. In particular, we need to
rename the variable @xmath in @xmath by @xmath first, then further check
whether the resulting function body is the same as the one represented
by @xmath . The evaluation of function application @xmath also requires
replacing the occurrences of its formal argument @xmath by @xmath inside
@xmath . In this sense, these two kinds of operations both have
substitution as a main component. However, the substitution operation is
not always so straightforward and extra attention should be paid to
perform it correctly. For example, consider the evaluation of the @xmath
-term @xmath , which requires substituting the variable @xmath for the
variable @xmath in its subterm @xmath . Note that the occurrence of the
variable @xmath is bound by the top level abstraction but is free in the
abstraction it will be substituted in. If we directly replace @xmath
with @xmath , the evaluation result would be @xmath , in which @xmath is
incorrectly bound by the inner abstraction instead of the top level one.
To preserve the correct binding relation, we need to first rename @xmath
in @xmath to a new abstractable variable @xmath , and then replace
@xmath with @xmath to obtain the term @xmath . To present such term
replacement operations systematically, we define the substitution of
@xmath -terms as the following:

###### Definition 2.1.2.1.

For any @xmath -terms @xmath , @xmath and abstractable variable @xmath ,
@xmath represents the result of substituting @xmath for every free
occurrence of @xmath in @xmath simultaneously and is defined recursively
on the structure of @xmath as the following.

1.   If @xmath is an abstractable variable, @xmath

2.   If @xmath is an instantiatable variable, @xmath ;

3.   If @xmath is a constant, @xmath ;

4.   If @xmath is an application @xmath , @xmath ;

5.   If @xmath is an abstraction @xmath ,
    @xmath

Among these substitution rules the last case of rule (5) takes care of
renaming bound variables to avoid illegal capture, name clashes.

#### 2.1.3 Rules of @xmath-Conversions

One component of the equality relation that we want to define on @xmath
-terms is that of recognizing the irrelevance of bound variable names.
This is formalized through the notion of @xmath -conversion defined
below.

###### Definition 2.1.3.1.

Let @xmath be a @xmath -term that has a subterm @xmath , and let @xmath
be an abstractable variable such that @xmath . The action of replacing
this subterm @xmath with @xmath is called an @xmath -conversion. We say
@xmath @xmath -converts to @xmath if and only if @xmath has been
obtained from @xmath by a finite (perhaps empty) series of @xmath
-conversions.

Note that @xmath -conversion is also used implicitly in the substitution
operation.

The evaluation process of a function application represented by term
@xmath is the operation of replacing the free occurrences of @xmath
inside @xmath with @xmath , which can be denoted as @xmath . This
process is captured by the @xmath -contraction operation.

###### Definition 2.1.3.2.

Let @xmath be a @xmath -term that has a subterm in the form of @xmath
which is called a @xmath -redex. The action of replacing this subterm
with @xmath is called a @xmath -contraction. We say that @xmath if and
only if @xmath has been obtained from @xmath by a @xmath -contraction. A
finite (perhaps empty) series of @xmath -contractions is called a @xmath
-reduction.

Clearly, the following property is preserved by @xmath -contraction.

###### Lemma 2.1.3.3.

Let @xmath and @xmath be @xmath -terms. If @xmath , then @xmath .

If there are any @xmath -redices left in terms after the @xmath
-reduction, then these terms can intuitively still be evaluated. When we
have finished all such evaluations, we may think of having reached a
final value, a @xmath -normal form .

###### Definition 2.1.3.4.

A @xmath -term @xmath which contains no @xmath -redices is called a
@xmath -normal form.

We can define the notion of equality that we desire by using the notions
of @xmath -contraction and @xmath -conversion as follows.

###### Definition 2.1.3.5.

We say a term @xmath is @xmath -convertible to a term @xmath if and only
if @xmath is obtained from @xmath by a finite (perhaps empty) series of
@xmath -contractions, reversed @xmath -contractions and @xmath
-conversions.

To qualify as a satisfactory notion of equality, the @xmath
-convertibility relation between @xmath -terms must possess the
properties of being symmetric, reflexive and transitive. Thus, it must
be an equivalence relation, which is assured by the following theorem.

###### Theorem 2.1.3.6.

The relations @xmath -conversion and @xmath -conversion are equivalence
relations.

The proof of this theorem can be found in [ 12 ] .

Now we need a method to determine equality between @xmath -terms based
on @xmath -conversions. We could first try to reduce these terms to
their @xmath -normal forms, and then check if these normal forms are
identical, allowing for renaming of bound variables. If the @xmath
-normal forms of the terms we are trying to compare exist, this
comparison approach is justified by the Church-Rosser Theorem for @xmath
-conversion and its corollary.

###### Theorem 2.1.3.7 (Church-Rosser Theorem for @xmath-conversion).

If a term @xmath is @xmath -convertible to a term @xmath , then there
exists a term @xmath such that @xmath and @xmath both @xmath -reduce to
@xmath .

This theorem follows from the Church-Rosser Theorem for @xmath
-reduction [ 12 ] and its proof can be found in [ 12 ] .

From the Church-Rosser Theorem for @xmath -conversion , we can obtain
the following corollary.

###### Corollary 2.1.3.8.

If normal forms exist for the terms @xmath and @xmath , then @xmath and
@xmath are @xmath -convertible if and only if their normal forms are
identical up to @xmath -conversions.

###### Proof.

By the definition of @xmath -conversion, a term and its normal form are
@xmath -convertible to each other. The necessity of this claim is
obvious because two identical (up to @xmath -conversion) terms are
@xmath -convertible to each other and @xmath -conversion is transitive.
The sufficiency of this claim is proved as the following: suppose @xmath
and @xmath are the normal forms of @xmath and @xmath respectively. By
the transitivity of @xmath -conversion, @xmath is @xmath -convertible to
@xmath . Theorem 2.1.3.7 gives a term @xmath that @xmath and @xmath both
reduce to. Since @xmath and @xmath contain no redices, they must both be
@xmath -convertible to @xmath . ∎

Consider the comparison of two @xmath -terms @xmath and @xmath , where
@xmath and @xmath are distinct constants. The reductions of the
top-level redices generate two terms in the form of @xmath and @xmath .
Since the difference between constants @xmath and @xmath already implies
that the normal forms of the two terms we are trying to compare can not
be identical modulo @xmath -conversion, we are not interested in the
reduction results of @xmath and @xmath any more and, therefore, the
reduction on @xmath and @xmath can be ignored. To describe such an
improvement of our comparison approach, the idea of a head normal form
is useful.

###### Definition 2.1.3.9.

We say a @xmath -term is in head normal form if it has the structure
@xmath where @xmath is a constant, any one of @xmath or an
instantiatable variable. By a harmless abuse of the notation, we permit
@xmath and @xmath to be @xmath in this presentation. Given such a form,
@xmath are called its arguments, @xmath is called its head, @xmath are
called its binders and @xmath is its binder length.

We can observe that a term has a normal form only if it has a head
normal form.

There are certain kinds of reduction sequences that are guaranteed to
produce a head normal form of a given term whenever one exists. The
following definition identifies a sequence of this kind.

###### Definition 2.1.3.10.

The head redex of a @xmath -term @xmath that is not a head normal form
is identified as follows. If @xmath is a redex, then it is its own head
redex. Otherwise @xmath must be of the form @xmath or @xmath . In either
case, the head redex of @xmath is identical to that of @xmath .

The head reduction sequence of a term @xmath is the sequence @xmath ,
where, for @xmath , there is a term succeeding @xmath if @xmath is not a
head normal form and, in this case, @xmath is obtained from @xmath by
rewriting the head redex using the @xmath -contraction rule. Such a
sequence is obviously unique and terminates just in case there is an
@xmath such that @xmath is a head normal form.

The following theorem justifies that if a term has a head normal form,
then its head reduction sequence will terminate with such a form.

###### Theorem 2.1.3.11.

A @xmath -term @xmath has a head normal form if and only if the head
reduction sequence of @xmath terminates.

The proof of this theorem can be found in [ 2 ] .

Thus to compare two @xmath -terms, we can first try to reduce them into
their head normal forms following their head reduction sequences, and
then check the identity of the binder lengths and the number of
arguments and the identity (up to @xmath -conversion) of the heads of
these head normal forms. After that, we can proceed to compare their
arguments, if this is still relevant.

As we discussed previously, this comparison method is meaningful only if
the (head) normal forms of the terms we are trying to compare exist.
There is no promise of such an existence in the untyped @xmath
-calculus. However, in the context of representing syntactic objects, we
are interested eventually in typed @xmath -calculi in which the set of
terms is restricted to contain only the typeable ones of the untyped
@xmath -calculus. In most useful cases of typed @xmath -calculi, head
normal forms are known to exist for every term.

### 2.2 The De Bruijn Notation

In the comparison approach we illustrated previously, after the @xmath
-terms are reduced to their head normal forms, we need to check the
identity of their heads based on @xmath -conversions, renaming the
relevant bound variables. From the perspective of real implementations,
the ease of @xmath -conversions in the identity checking is of special
significance. The notation proposed by de Bruijn [ 4 ] provides an
elegant way of handling this problem by ignoring the bound variable
names and thus the need of renaming bound variables during identity
checking. In this section, we give an overview of the de Bruijn
notation.

#### 2.2.1 Terms in the De Bruijn Notation

The de Bruijn terms are defined as follows.

###### Definition 2.2.1.1.

The set of de Bruijn terms are given by the following syntactic rules.
@xmath ::= @xmath In these rules, @xmath represents constants, @xmath
represents instantiatable variables and @xmath represents the category
of positive numbers.

In the de Bruijn notation, a bound variable occurrence is denoted by an
index which counts the number of abstractions between the occurrence of
this variable and the abstraction binding it. Since we are in fact
interested in only top-level closed terms, all the abstractable
variables can be transformed to their indices in this way. This
correspondence is exposed by the transformation function @xmath defined
as the following, where we correspondingly assume that the term to be
transformed is closed at the top-level.

###### Definition 2.2.1.2.

The mapping @xmath from the closed name-carrying terms to the de Bruijn
terms is given as @xmath where @xmath is a mapping from the class of
name-carrying terms and the class of bound variable name lists to the
class of de Bruijn terms and is defined as follows. (For simplicity, we
assume that the bound variable names of the term to be transformed are
distinct from each other without loss of generality.)

1.   If @xmath is a constant, @xmath ;

2.   If @xmath is an instantiatable variable, @xmath ;

3.   If @xmath is an abstractable variable, @xmath , where @xmath ;

4.   If @xmath is an application @xmath , @xmath ;

5.   If @xmath is an abstraction @xmath , @xmath .

For example, consider two @xmath -convertible terms @xmath and @xmath in
the name-carrying scheme. Their de Bruijn representations obtained from
the application of the transformation function @xmath both have the same
form as @xmath . In general, it can be seen that the need for bound
variable renaming is eliminated in determining the identity of the de
Bruijn terms.

#### 2.2.2 Substitutions in the De Bruijn Notation

Since an index is used to count the number of abstractions between the
occurrence of a bound variable and the abstraction binding it, extra
attention should be paid when a term is substituted into the bodies of
some abstractions. Consider the term @xmath . The @xmath -contraction of
the redex inside this term requires substituting @xmath for the first
free variable of @xmath which is denoted by the index @xmath . The first
thing we need to note is that the variable occurrence represented by
index @xmath in @xmath is in fact bound by the top level abstraction of
the entire term. Thus after the substitution, this index should be
increased by one to preserve the correct binding relation, because there
appears an extra abstraction between this variable occurrence and the
abstraction binding it. Second, the variable occurrence represented by
the index @xmath in the subterm @xmath is also bound by the top-level
abstraction of the entire term. After the contraction, its index should
be decreased by one to reflect that an abstraction between this variable
occurrence and the abstraction binding it disappears. In fact, all the
free variable occurrences of this subterm should be affected in this
way. For this reason, we are more interested in a generalized notation
of substitutions, that of substituting terms for all the free variables
simultaneously, the precise definition of which is given as the
following.

###### Definition 2.2.2.1.

Let @xmath be a de Bruijn term and let @xmath , @xmath , @xmath ,… be an
infinite sequence of de Bruijn terms. The result of simultaneously
substituting @xmath for the @xmath th free variable of @xmath is denoted
by @xmath and is defined recursively as the following:

1.   if @xmath is a constant, @xmath ;

2.   if @xmath is an instantiatable variable, @xmath ;

3.   if @xmath is a variable reference @xmath , @xmath ;

4.   if @xmath is an application @xmath ,
    @xmath ;

5.   if @xmath is an abstraction @xmath ,
    @xmath ,
    where, for @xmath , @xmath .

The last substitution rule is used to deal with some of the issues we
illustrated by the previous example. First, we note that within an
abstraction @xmath , the first free variable has an index @xmath , the
second has an index @xmath and so on. Since @xmath is intended to be
substituted for the @xmath th free variable of @xmath , the variable
occurrences with indices less than @xmath , which are bound in @xmath ,
should not be changed by this substitution. Thus, in rule (5), we add
@xmath in the front of the infinite substitution sequence to achieve
such a protection. Furthermore, since an extra abstraction appears in
front of @xmath after the substitution is pushed into the abstraction,
the indices of the free variables of @xmath should be increased by one
to preserve the correct binding relation. Substitution @xmath is used
for this renumbering operation. Note that although the implicit use of
@xmath -conversions is eliminated from the substitution operation, extra
effort should be made to renumber the indices of the free variables to
preserve the correct binding relation.

#### 2.2.3 Rule of @xmath-Contraction in the De Bruijn Notation

With the presentation of substitutions in the de Bruijn notation, we can
now formally describe the @xmath -contraction schema within this
context.

###### Definition 2.2.3.1.

The @xmath -contraction rule in the de Bruijn notation is the following.
@xmath , where @xmath and @xmath are de Bruijn terms.

Let @xmath be a de Bruijn term that has a subterm in the form of @xmath
. If the de Bruijn term @xmath is obtained from @xmath by replacing its
subterm @xmath with @xmath , then we say @xmath .

The intuitive meaning of this rule is: after the contraction, the
occurrences of the first free variable of @xmath should be replaced with
the term @xmath . At the same time, the indices of all the other free
variables of @xmath should be decreased by one to reflect the
disappearance of the abstraction in the front.

Now we want to utilize the de Bruijn notation in our comparison approach
to eliminate the renaming operation during the identity checking. In
particular, we can first translate the name-carrying terms into their de
Bruijn representations, and then follow the method we discussed in
Section 2.1.3 to compare these de Bruijn terms. This approach is
meaningful only if the properties of the name-carrying @xmath -calculus
we discussed in the Section 2.1.3 still hold in the de Bruijn notation.
We first adapt Definition 2.1.3.9 and 2.1.3.10 to the de Bruijn notation
in the obvious way, and then use Theorem 2.2.3.4 and 2.2.3.5 to exhibit
a close correspondence between the contractions in the name-carrying
@xmath -calculus and those in the de Bruijn notation, and hence assure
that the properties we are interested in still follow in the context of
the de Bruijn notation.

The following two lemmas are used in the proofs of Theorems 2.2.3.4 and
2.2.3.5 .

Consider the situation of substituting a name-carrying term @xmath into
a context embedded under @xmath abstractions. Lemma 2.2.3.2 assures that
the result of the transformation of @xmath is the same no matter whether
we transform @xmath to its de Bruijn representation first, and then
increase the indices of its free variables by @xmath , or we preform the
substitution in the name-carrying scheme first, and then transform the
entire term.

###### Lemma 2.2.3.2.

Let @xmath be a name-carrying term with all the names of its free
variables contained in the list @xmath . @xmath @xmath , where each
@xmath , for @xmath , does not occur amongst @xmath ,…, @xmath , or in
@xmath .

This lemma can be proved by straightforward induction on the structure
of @xmath .

Consider the situation of substituting a name-carrying term @xmath for
the free variable @xmath in a name-carrying term @xmath . Lemma 2.2.3.3
assures that the result of transformation is the same no matter whether
we perform the substitution @xmath first, and then translate the entire
term to its de Bruijn representation, or we transform @xmath and @xmath
first, and then perform the substitution in the context of de Bruijn
notation.

###### Lemma 2.2.3.3.

Let @xmath be a name-carrying term with all the names of its free
variables contained in the list @xmath . @xmath @xmath , where @xmath .

With the aid of Lemma 2.2.3.2 , this lemma can be easily proved by
induction on the structure of @xmath .

###### Theorem 2.2.3.4.

Let @xmath be a name-carrying @xmath -term such that all the names of
its free variables are contained in the list @xmath . If @xmath , then
@xmath . Further, if the contracted redex is a head redex in the
name-carrying scheme, then the translation to the de Bruijn term is
realized by contracting a head redex in the de Bruijn notation.

###### Proof.

The first part of this theorem is proved by induction on the structure
of @xmath , and the second part can be easily observed during this
process.

Now we consider the cases of the structure of @xmath . Since @xmath
contains a redex, it can only be an abstraction or an application.

Suppose @xmath is an application @xmath . There are two subcases: first,
@xmath itself is the redex contracted; second, the redex contracted is a
subterm of one of @xmath or @xmath . In the first case, as a redex being
contracted, @xmath is in the form of @xmath , and correspondingly,
@xmath is in the form of @xmath . According to the definition of
function @xmath , @xmath and @xmath . Following the @xmath -contraction
rule in the de Bruijn notation, @xmath . As an instance of Lemma 2.2.3.3
, @xmath . In the second case, without loss of generality, we assume
that the redex contracted is a subterm of @xmath . Thus @xmath must have
the form of @xmath , where @xmath . By Lemma 2.1.3.3 , we know that
@xmath contains all the free variable names of @xmath . By the induction
hypothesis, @xmath . Clearly, @xmath . According to the definition of
function @xmath , @xmath and @xmath . Thus we have proven that @xmath in
the case that @xmath is an application.

Suppose @xmath is an abstraction @xmath . Since @xmath , @xmath must be
in the form of @xmath where @xmath . By Lemma 2.1.3.3 , @xmath and
therefore, all the free variable names of @xmath and @xmath are
contained in the list @xmath . Hence, by the induction hypothesis,
@xmath . Hence @xmath . According to the definition of function @xmath ,
@xmath and @xmath . Thus we have proven that @xmath in this case. ∎

###### Theorem 2.2.3.5.

Let @xmath be a name-carrying @xmath -term such that all the names of
its free variables are contained in the list @xmath . If @xmath , then
@xmath . Further, if the contracted redex is a head redex in the de
Bruijn notation, then the corresponding redex before the transformation
is a head redex in the name-carrying scheme.

###### Proof.

The first part of this theorem is proved by induction on the structure
of @xmath , and the second part can be easily observed during this
process.

Now we consider the cases of the structures of @xmath . Since @xmath
contains a redex, @xmath can only be an application or an abstraction
and therefore so can @xmath .

Suppose @xmath is an application @xmath . Then @xmath . If the redex
contracted is @xmath itself, then @xmath must have the form @xmath , and
@xmath must be in the form @xmath . According to the definition of
function @xmath , @xmath . Thus @xmath has the form @xmath . Following
the @xmath -contraction rule in the name-carrying scheme, this redex
should be rewritten to @xmath . As an instance of Lemma 2.2.3.3 , @xmath
. Now we consider the case that the redex contracted is not @xmath
itself but is a subterm of one of @xmath or @xmath . Without loss of
generality, we assume the redex contracted is inside @xmath , and @xmath
. Thus @xmath must be in the form @xmath , and therefore @xmath . By the
induction hypothesis, @xmath in the name carrying scheme. Clearly,
@xmath . Thus we have proven that @xmath in the case that @xmath is an
application.

Suppose @xmath is an abstraction @xmath . Then @xmath . Since @xmath ,
@xmath must have the form @xmath , where @xmath . Thus, @xmath has the
form of @xmath . By the induction hypothesis, @xmath in the
name-carrying scheme. Clearly, @xmath . Thus we have proven that @xmath
in this case. ∎

Suppose two terms @xmath and @xmath are @xmath -convertible to each
other in the name-carrying scheme. Then @xmath and @xmath are also
@xmath -convertible in the context of the de Bruijn notation. By
Corollary 2.1.3.8 , we know that @xmath and @xmath have a common normal
form @xmath (up to @xmath -conversion), if their normal forms exist.
According to Theorem 2.2.3.4 and Theorem 2.2.3.5 , the contractions
performed on @xmath and @xmath will be mapped exactly to those performed
on @xmath and @xmath . Thus @xmath and @xmath have a common (head)
normal form @xmath , if the normal forms of @xmath and @xmath exist.
Further, Theorem 2.2.3.4 and Theorem 2.2.3.5 also assure that the
contraction steps performed on a name-carrying term @xmath when
following its head reduction sequence will be mapped exactly to those
performed on @xmath when following its head reduction sequence in the
context of the de Bruijn notation. Therefore Theorem 2.1.3.11 holds in
this context, too. Finally, we are only interested in the terms for
which normal forms exist. Thus we can refine our comparison approach to
the following: we first transform the name-carrying terms under
comparison into their de Bruijn representations, and then try to reduce
these de Bruijn terms into their head normal forms. After that, we
simply match the binder lengths and the heads of those head normal
forms, and proceed to compare their arguments if this is still relevant.
It is clear that the main issue of the comparison approach is the head
reduction process of the de Bruijn terms under comparison.

### 2.3 Explicit Substitution Calculi

Hitherto the substitution in the course of @xmath -reduction has still
been viewed as a rather atomic operation in the sense that once
generated, it will be performed on the corresponding term structures
immediately. However, the performance of substitutions consists of the
traversals of the term structures which are not yet, but will be,
reduced. Thus, if we can temporarily suspend the substitutions once they
are generated and delay their performance so that they can be carried
out alone with the reduction steps, the substitution process can gain
the ability to interact more with the reduction process. For instance,
we can hopefully combine the substitutions generated at different
reduction stages and which are to be performed on the same term
structures, and carry them out in one term traversal. Thus we can also
avoid some redundant effort incurred by the performance of those
substitutions which turns out to be unnecessary due to later reduction
results.

Explicit substitution calculi extend the de Bruijn notation to record
suspended substitutions directly into term structures, thereby offering
our desired flexibility in ordering computations. We study the benefits
of this flexibility in this thesis based on a particular calculus known
as the suspension notation [ 21 ] . We outline this notation in this
section to facilitate this discussion. Although our empirical study must
utilize a particular system, the suspension notation is general enough
for our observations to eventually be calculus independent. We make this
point below by contrasting this system with the other explicit
substitution calculi in existence.

#### 2.3.1 The Suspension Notation

To explicitly record substitutions, the explicit substitution notations
involve at least two syntactic categories: those correspond to terms,
and to the environment in which the suspended substitutions are
recorded. As we noticed in Section 2.2.2 , when substitutions are pushed
into an abstraction, the free variable indices of terms to be
substituted in should be increased by one to reflect the change in their
embedding levels. Thus in a notation such as the @xmath -calculus [ 1 ]
that uses exactly two categories of expressions, such an adjustment
should be performed on the entire environment each time that the
environment is propagated into an abstraction. The suspension notation
instead uses a global mechanism for recording the adjustment to be made
on the free variable indices of the terms to be substituted in, so that
the adjustment can be made only once at the time that the substitutions
are actually performed, rather than in an iterated manner. To support
this possibility, the suspension notation includes a third category of
expressions called environment terms that encode terms to be substituted
in, together with their embedding context.

###### Definition 2.3.1.1.

The syntactical definition of suspension terms is given by the following
rules. @xmath ::= @xmath @xmath @xmath ::= @xmath @xmath ::= @xmath In
these rules, @xmath represents constants, @xmath represents
instantiatable variables, @xmath is the category of positive numbers and
@xmath is the category of nonnegative numbers.

Besides the de Bruijn terms, there is a new type of terms called , of
the form @xmath , corresponding to the temporarily suspended
substitutions with the term they should be performed on. The intuitive
meaning of a suspension in this form is that the first @xmath variables
of term @xmath should be substituted for in a way determined by @xmath
and the other variables of @xmath should be renumbered to reflect the
fact that the embedding level of @xmath was originally @xmath but now is
@xmath . Note that a suspension has the ability to record multiple
substitutions generated from the contractions of different redices. This
ability is necessary for the realization of substitution combinations.

An environment, corresponding to the category @xmath , is a finite list
in which the term to be substituted for the @xmath th free variable,
together with its embedding context, is maintained in the @xmath th
position. Hence in a well-formed suspension term, the length of this
environment list must be the same as @xmath .

Represented by the category @xmath , two kinds of environment terms can
appear within the environment. They correspond to variables bound by two
different types of abstractions in the original term: @xmath denotes a
term replacement to be made on the variables bound by abstractions which
disappear after reductions, while @xmath represents the adjustment to be
made on the variables bound by abstractions which persist. The natural
number @xmath inside these two kinds of terms encodes the new embedding
level at the relevant abstraction, for the variables bound by
abstractions that persist after the reduction, we intend this to be the
new embedding level just within the scope of the abstraction.
Consequently, there are also constraints on @xmath and @xmath in a
well-formed suspension term: the @xmath in @xmath should be less than or
equal to @xmath , and the @xmath in @xmath should be less than @xmath .

Along with term representations, there is a collection of rewrite rules
to simulate @xmath -reduction. These rules are presented in Figure 2.1 .
We use @xmath to refer to the @xmath th item in the environment list.

Among these rules, @xmath and @xmath generate the suspended
substitutions corresponding to @xmath -contraction; rules (r1)-(r9),
referred to as reading rules , are used to actually carry out those
substitutions.

Now we use a concrete example to illustrate the roles played by the
rewrite rules to simulate @xmath -reduction and the way in which the
substitutions are combined. Consider the de Bruijn term @xmath , where
@xmath and @xmath are arbitrary de Bruijn terms. Using rule ( @xmath )
to contract the outermost redex, the term is rewritten to @xmath . Using
rule (r6) to propagate the substitution into the top-level application
inside the suspension, the term is rewritten to @xmath . Using rule (r7)
to propagate the substitution into the top-level abstraction inside the
former suspension, the whole term is rewritten to @xmath . Now using
rule ( @xmath ) to contract the redex and combine the substitution
generated by this contraction with the one already existing in the
environment, the term is rewritten to @xmath . Using rule (r7) and (r6)
several times to propagate the substitution into applications and
abstractions, the term is transformed to @xmath @xmath @xmath @xmath
@xmath . At this time, reaching the abstractable variables,
substitutions can actually be performed. Using rule (r4) to rewrite the
first suspension, the term is rewritten to: @xmath @xmath @xmath . Using
rule (r5) to rewrite the current first suspension, the term is
transformed to @xmath @xmath @xmath . Using rule (r8) to combine
renumbering with the existing substitution, the term is rewritten to
@xmath @xmath @xmath .

Similarly, by the application of rule (r5), the term is transformed to

  ----------
  @xmath .
  ----------

Depending on the particular structures of @xmath and @xmath , the
rewrite rules can be applied to finally produce a de Bruijn term which
is @xmath -reduced from the original term.

If our sole purpose is to simulate @xmath -reduction, the rule ( @xmath
) is redundant: whenever ( @xmath ) is applied, rule ( @xmath ) is
applicable too. However, as illustrated in the previous example, (
@xmath ) is the rule in our rewriting system that serves to combine the
substitutions newly generated by a contraction, with those already
recorded in the environment. This rule requires the redex to be
contracted to have the form of @xmath , which means that the suspension
as the abstraction body is obtained from pushing the suspension @xmath
into the top-level abstraction inside it. If the reduction process
strictly follows the outermost and leftmost order, which fits the
reduction order required by head reduction sequences, all substitutions
generated during the reduction process can be combined in this way.
Similarly, rule (r8) is redundant, but serves to combine the renumbering
needed after a term has been substituted into a new embedding context
with the already existing substitutions to be performed on the same term
in the environment. It requires the nested suspension to have the form
of @xmath which means that this suspension is generated from the
application of the rule (r5). In fact, the main uses of (r9) also arise
after a use of (r5). Thus we can further eliminate rules (r8) and (r9)
in favor of the enhanced versions of (r5) shown in Figure 2.2 .

This course is followed in our reduction procedures.

#### 2.3.2 Some Formal Properties

To justify that the comparison approach we discussed before still works
in the context of the suspension notation, we need to first show that
the suspension notation is capable of simulating reductions in the de
Bruijn notation.

Theorem 2.3.2.1 assures that for every well-formed suspension term,
there is a unique de Bruijn term underlying it.

###### Theorem 2.3.2.1.

Let @xmath be a well-formed term in the suspension notation. If terms
@xmath and @xmath are different suspension terms obtained from @xmath by
a series (maybe empty) of applications of the reading rules, then there
exists a de Bruijn term @xmath , which can be obtained from @xmath by a
series (maybe empty) of applications of the reading rules, such that
@xmath and @xmath can be transformed to @xmath by a series (maybe empty)
of applications of reading rules.

Theorem 2.3.2.2 assures that every rewrite sequence from a well-formed
suspension term to the de Bruijn term underlying it terminates.

###### Theorem 2.3.2.2.

Every well-formed term @xmath in the suspension notation can be
transformed to a de Bruijn term by a finite series (maybe empty)
applications of the reading rules, regardless of the specific choice of
a reading rule when there are multiple rules applicable.

The proofs of the above two theorems can be found in [ 21 ] .

The following theorem, which is proved in [ 21 ] , establishes the
correspondence between the reductions in the de Bruijn notation and the
term transformations in the suspension notation which are intended to
simulate those reductions.

###### Theorem 2.3.2.3.

Let @xmath be a de Bruijn term. Then @xmath @xmath -reduces to the de
Bruijn term @xmath if and only if @xmath can be transformed to @xmath by
a series (maybe empty) of applications of rules in Figure 2.1 and 2.2 .

Head normal forms are extended to the suspension notation by permitting
their arguments to be arbitrary suspension terms. For the convenience of
our later discussion, we refer to a term in the suspension notation as
being a weak head normal formal form if it is a head normal form or it
is of the form of @xmath , where @xmath is a suspension term. Following
the theorems above, Theorem 2.3.2.4 , which is proved in [ 21 ] ,
assures that if a de Bruijn term @xmath has a (weak) head normal form
@xmath in the context of the de Bruijn notation, then @xmath has one or
more (weak) head normal forms in the suspension notation from which
@xmath can be calculated out by a finite series (maybe empty) of
applications of the reading rules.

###### Theorem 2.3.2.4.

Let @xmath be a de Bruijn term and suppose that the rules in Figure 2.1
allow @xmath to be rewritten to a (weak) head normal form in the
suspension notation that has @xmath as its head, @xmath as its binder
length and @xmath as its arguments. Let @xmath be the de Bruijn term
obtained from @xmath by a series (maybe empty) of applications of
reading rules. Then @xmath has the term

  -- -------- --
     @xmath   
  -- -------- --

with a binder length of @xmath as a (weak) head normal form in the de
Bruijn notation.

Comparing with the de Bruijn notation, there is one more possibility for
terms and there is also a larger set of rewriting rules in the
suspension notation. Taking these aspects into account, we generalize
the notions of head redex and head reduction sequence to the suspension
notation and also define the notions of weak head redex and weak head
reduction sequence as the following.

###### Definition 2.3.2.5.

Let @xmath be a suspension term that is not in (weak) head normal form.

1.   Suppose that @xmath has the form @xmath . If @xmath is an
    abstraction, then @xmath is its sole (weak) head redex. Otherwise
    the (weak) head redices of @xmath are the weak head redices of
    @xmath ; notice that @xmath cannot be a weak head normal form here.

2.   If @xmath is of the form @xmath , its head redices are identical to
    those of @xmath . (This case does not arise if @xmath is not a weak
    head normal form.)

3.   If @xmath is of the form @xmath , then its (weak) head redices are
    itself and all the (weak) head redices of @xmath .

Let two subterms of a term be considered non-overlapping just in case
neither is contained in the other. Then a (weak) head reduction sequence
of a suspension term @xmath is a sequence @xmath in which, for @xmath ,
there is a term succeeding @xmath if @xmath is not in (weak) head normal
form and, in this case, @xmath is obtained from @xmath by simultaneously
rewriting a finite set of non-overlapping subterms that includes a
(weak) head redex using the rule schemata in Figure 2.1 or 2.2 .
Obviously, such a sequence terminates if for some @xmath it is the case
that @xmath is in (weak) head normal form.

The following theorem, which is proved in [ 21 ] , assures that if a
term in the de Bruijn notation has a (weak) head normal form then its
(weak) head reduction sequences terminate.

###### Theorem 2.3.2.6.

A term @xmath in the suspension notation has a (weak) head normal form
if and only if every (weak) head reduction sequence of @xmath
terminates.

Thus we show that the comparison approach we illustrated before still
works in the context of the suspension notation. Further, the extension
of head normal forms to the suspension notation permits the performance
of those substitutions over the arguments to be delayed until we
actually need to compare the arguments.

#### 2.3.3 Other Explicit Substitution Calculi

According to their combination ability, explicit substitution calculi
can be classified into two categories. The calculi in the first category
do not have the ability to combine substitutions at all. Their purposes
are only to delay substitutions in the course of simulating the @xmath
-reduction. The @xmath -calculus [ 3 ] and the @xmath -calculus [ 14 ]
are two representative calculi in this category. On the other hand, the
calculi in the second category have the ability to combine substitutions
during the reduction process. The suspension notation we presented
previously and the @xmath -calculus [ 1 ] both belong to this category.

Without the ability to combine substitutions, the terms used to record
explicit substitutions in the first kind of calculi have the
characteristic that they can each record the substitutions generated by
only one contraction. Certainly, this kind of information can be covered
by a subset of the suspension terms with a certain pattern. For example,
the two kinds of terms used to record substitutions in the @xmath
-calculus can be represented by suspension terms of the form @xmath ,
for renumbering after a term is substituted into a new embedding
context, and of the form @xmath , for the term replacement and
renumbering caused by one contraction. Correspondingly, the effects of
the rewrite rules in such calculi can also be achieved by a subset of
the rewrite rules of the suspension notation. In particular, since the
rewrite rules in those calculi are used to purely simulate the @xmath
-contractions, the same effect can be achieved by the rewrite rules in
the suspension notation without ( @xmath ) and (r8).

The other explicit substitution calculus @xmath also has the ability to
combine substitutions to be performed on the same term structures. While
the @xmath -calculus has the ability to combine arbitrarily nested
suspended substitutions, in the suspension notation we presented
previously, the substitution combination rules ( @xmath ) and (r8) have
certain requirements on the substitutions to be combined. Although we
know that if strictly following the leftmost and outermost reduction
order, all the substitutions can be combined by these two rules, the
permission to share the reduction results and the binding of
instantiatable variables caused by unification could sometimes violate
this reduction order and may cause the failure of the combination of the
suspended substitutions. For example, the binding of the instantiatable
variable @xmath to a suspension @xmath in the term @xmath generates the
term @xmath . To contract this redex, the only applicable rule is (
@xmath ). This contraction results in a suspension term in the form of
@xmath . In this nested suspension, the combination of the common
substitution walks over @xmath is lost. In fact, the suspension notation
we represented in this thesis is a restricted version of the calculus
presented in [ 19 ] . In particular, the full calculus allows for the
transformation from an arbitrarily nested suspension in the form of
@xmath to a single suspension @xmath . The main task in this
transformation is the computation of the effect of the substitutions
embodied in the environment @xmath on each of the terms in @xmath . The
richer calculus includes expression forms and rules that allow for this
computation to be carried out through genuinely atomic steps. However,
from the perspective of implementations, it is desired that substitution
combination be realized in a simple step, as opposed to a series of
operations. Secondly, in reality, following head reduction sequences, a
situation where the application of ( @xmath ) fails when substitution
combination is needed, occurs relatively rarely. Thus we sacrifice some
of the ability to combine substitutions in order to simplify the
combination process by using ( @xmath ) and (r8) to “over-look” some
steps of combinations and directly generate the combination result. As
the full calculus of the suspension notation does, the @xmath -calculus
uses a set of merging rules to combine arbitrarily nested substitutions.
Thus the problem with the sophisticated suspension notation we discussed
above also exists in this context: the complex set of merging rules is
not suitable for real implementations. Requiring the reduction process
to follow head reduction sequences, the merging rules in @xmath
-calculus can also be simplified to a rule which can recognize redices
in the form of @xmath , where @xmath is an explicit substitution term
with a certain pattern, and directly rewrite it into the combination of
the substitutions generated from these two contractions by losing some
of the ability to combine substitutions.

The main difference between the @xmath -calculus and the suspension
notation is the way they record the adjustment to be made on indices
corresponding to term replacement or renumbering. In the suspension
notation, this adjustment is not explicitly maintained, but is computed
from @xmath and the natural number @xmath associated with the
environment terms. For example, consider a suspension term @xmath . When
the substitution is to be carried out, the indices of the free variables
of @xmath should be increased by @xmath . In @xmath -calculus, this
increment information is maintained explicitly within the environment
term as @xmath . Thus when a substitution is pushed into an abstraction,
this number also needs to be increased by one, which means all the items
in the environment list should be adjusted. For example, to push a
delayed substitution into an abstraction, @xmath , in the suspension
notation the only work on the environment list is to add a dummy
environment term: @xmath . On the other hand, in the @xmath -calculus,
the already existing environment terms also need to be walked through to
perform the increment: @xmath .

In summary, we believe that the suspension notation provides a concrete
yet sufficiently general basis for examining the use of explicit
substitution systems and the effect of the various choices afforded by
them on actual implementations.

## Chapter 3 Environment Based Reduction

As we discussed previously, the head normalization process which reduces
the de Bruijn terms under comparison to their head normal forms when
following head reduction sequences is the main issue of the comparison
approach we want to realize for the systems using @xmath -terms to
represent syntactic objects. Guided by the suspension notation, there is
still flexibility to choose a specific strategy to realize the head
normalization procedure, and these choices have different impacts on the
heap usage of the computation systems. Now we discuss these possible
reduction strategies and their impact on heap usage by using SML
procedures for simplicity of exposition and for concreteness, although
the same ideas can be deployed in realizations in any other language as
well. Here we assume a basic familiarity with SML which one can obtain
from [ 10 ] . All the procedures we present are graph-based, @xmath
-terms are encoded as directed graphs and destructive changes are used
to register, and thus to share the reduction steps.

### 3.1 An Environment Based Head Normalization Procedure

According to the suspension notation, it is natural to consider a
reduction procedure based on an environment to achieve the delaying and
combination of substitutions. The most straightforward way to realize
the environment is to use the local variables and parameters of this
reduction procedure. This idea is encompassed by the first head
normalization procedure we present. In particular, suspensions are
realized mainly through the structure of recursive calls to the
normalization routine; they are not explicitly embedded into terms built
on the heap, and thus the input and output terms of this procedure are
pure de Bruijn terms. In this sense, the suspension notation is used
only implicitly in this reduction strategy.

Figure 3.1 provides the datatype declarations in SML that serve to
represent the structures needed in this reduction procedure.

SML expressions of types rawterm and term can be viewed as directed
graphs, which are used to support a graph-based approach to reduction.
We refer to such expressions as being acyclic if the graphs they
correspond to in this sense are acyclic. An important assumption for our
later discussion is that all the SML expressions we deal with are
acyclic. In particular, we expect the input terms of our reduction
procedures to hold this property, and we will show that our reduction
procedures preserve this property.

Among these declarations, the de Bruijn terms are realized as references
to appropriate SML expressions of the type rawterm . Correspondingly,
the declaration of the type rawterm reflects, for the most part, the
possible structures of de Bruijn terms. The constructor ptr in the
declaration of rawterm serves to aid the sharing of reduction results
which means that at certain points in our reduction process, we want to
identify (the representations of) terms in a way that makes the
subsequent rewriting of one of them correspond to the rewriting of the
others. Such an identification is usually realized by representing both
expressions as pointers to a common location whose contents can be