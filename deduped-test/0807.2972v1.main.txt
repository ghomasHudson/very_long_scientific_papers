##### Acknowledgements. This thesis is the culmination of my graduate
studies at the University of Toronto. It goes without saying that no
scientific work can be carried out in isolation, and this one is no
exception. I would like to thank here all the people who helped me along
the way. First and foremost, I wish to express my utmost gratitude to
Alberto Mendelzon and Renée Miller, both of whom have been a source of
inspiration for many years. They were also the Alpha and the Omega of my
graduate studies: Alberto was my advisor during my master’s and the
early years of my PhD, and also the first one to suggest the idea of a
framework upon which this thesis is based; Renee supervised the final
stages of the work and made sure that all the pieces fitted together.
Both provided me with support and guidance well beyond the call of duty.
They really made this work possible. Special thanks go to José María
Turull Torres and Alejandro Vaisman, great friends and mentors. José
María introduced me to the fascinating world of scientific research and
encouraged me to pursue graduate studies. I could never thank him enough
for his guidance in the first steps of my research career. Alejandro’s
encouragement and insight were always invaluable, especially during the
most difficult times of my PhD (he was my thesis advisor in disguise for
many years). I consider them my academic role models for their integrity
and professionalism. I would like to thank the members of my PhD
committee, Kelly Lyons, Thodoros Topaloglou, and John Mylopoulos, for
their insightful comments, and Frank Tompa for his thorough external
appraisal. I also wish to acknowledge the contribution of Mariano
Consens, who helped in the development of some core ideas of this
thesis. I am deeply indebted to the administrative staff of the
Department of Computer Science for assisting me in so many different
ways. Joan Allen and Linda Chow deserve a special mention. I am also
grateful to the Department of Computer Science, the Natural Sciences and
Engineering Research Council of Canada, and the IBM Center for Advanced
Studies for their generous financial support at different times over my
years of graduate studies. I want to express my heartfelt appreciation
to my many friends in Toronto and abroad, especially to my best
officemate, Attila, and to my musical buddies, Diego, Danny, Fabricio,
Gustavo and Santi; and in general to all those that had to put up with
me for years: Adriana, Adrian, Alberto, Alejandra, Christian, Ceci,
Carlos, Clau, Fernanda, Fernando, Frank, Jime, Lily, Lore, Mara, Pachi,
Patricia, Rosana, Sebastian and Vivi. Each in their one way made my life
more meaningful and enjoyable. I am also in debt with my parents, Ofelia
and Juan Carlos, for helping me to become who I am. I owe them much, and
regret that I missed my best opportunities to repay. I dedicate this
thesis to them. Above all, I have to thank a thousand times to my wife,
Mariana, the person without whom this thesis could have never been
written. Her support and unconditional love are beyond words. It is hard
to know who I would be without her; I hope never to have the occasion to
find out.

###### Contents

-    1 Introduction
    -    1.1 Major contributions
        -    1.1.1 AxPRE summaries
        -    1.1.2 Refinement lattice
        -    1.1.3 System implementation
        -    1.1.4 Answering queries using extents
    -    1.2 Motivating example: exploring RSS feeds with summaries and
        XPath queries
    -    1.3 Organization
-    2 Related work
    -    2.1 Structural summaries
    -    2.2 Path summaries for OO data
    -    2.3 Hierarchical encodings
    -    2.4 Answering XML queries using views
    -    2.5 Validating summaries
-    3 AxPRE summaries
    -    3.1 A regular expression language on axes
    -    3.2 Neighbourhoods and bisimulation
    -    3.3 Describing summaries with AxPREs
-    4 Capturing earlier literature proposals with DescribeX
    -    4.1 Bisimilarity-based proposals
    -    4.2 Ad-hoc construction proposals
-    5 Describing extents and neighbourhoods
    -    5.1 Concise descriptions
    -    5.2 Refinement and stabilization
-    6 Changing descriptions with XPath
    -    6.1 XPath syntax and data model
    -    6.2 Refinement with XPath
    -    6.3 Stabilization with XPath
    -    6.4 Adapting SDs to XPath queries
        -    6.4.1 Deriving AxPREs from queries
        -    6.4.2 Finding candidates
-    7 DescribeX engine
    -    7.1 Initial SD construction
    -    7.2 Computing refinements
-    8 Experimental results
    -    8.1 Initial SD construction
    -    8.2 Refinements
    -    8.3 Edge stabilization
    -    8.4 XPath query evaluation using SDs
        -    8.4.1 Comparison with summary proposals
        -    8.4.2 Comparison with XPath evaluators
-    9 Conclusion
-    A XPath 1.0 formal semantics
-    B Declarative debugging of XPath queries with DescribeX

###### List of Tables

-    8.1 Test collections
-    8.2 Selected @xmath SD nodes and EEs from RSS2
-    8.3 Selected @xmath SD nodes and EEs from PSIMI2
-    8.4 Selected @xmath SD nodes and EEs from Wiki5 and Wiki45
-    8.5 RSS2 @xmath refinements
-    8.6 PSIMI2 @xmath refinements
-    8.7 Wiki5 @xmath refinements
-    8.8 Wiki45 @xmath refinements
-    8.9 RSS2 AxPRE refinements
-    8.10 PSIMI2 AxPRE refinements
-    8.11 Wiki5 AxPRE refinements
-    8.12 Wiki45 AxPRE refinements
-    8.13 RSS2 edge stabilization
-    8.14 PSIMI2 edge stabilization
-    8.15 Wiki5 edge stabilization
-    8.16 Wiki45 edge stabilization
-    8.17 RSS collection queries
-    8.18 PSIMI collection queries
-    8.19 Wikipedia collections queries
-    8.20 RSS2 query results and times
-    8.21 PSIMI2 query results and times
-    8.22 Wiki5 query results and times
-    8.23 Wiki45 query results and times
-    8.24 System comparison: SD graph construction times (s)
-    8.25 RSS2 query evaluation comparative times (s)
-    8.26 Wiki5 query evaluation comparative times (s)

###### List of Figures

-    1.1 Wikipedia document graph (a) and its incoming path summary (b)
-    1.2 Axis graphs of RSS feed samples
-    1.3 Label SD (a), and heterogeneous SD (b) of the RSS feed samples
-    2.1 Label SD fragment with XML graph schema model annotations
-    3.1 The axis graph of two PSI-MI interactions
-    3.2 Axis graph fragment from node 8 (a) and its automaton @xmath
    (b)
-    3.3 Rules of the modified Thompson’s construction
-    3.4 AxPRE automaton @xmath
-    3.5 Intersection automaton @xmath (a) and resulting AxPRE
    neighbourhood @xmath (b)
-    3.6 All @xmath neighbourhoods
-    3.7 All @xmath neighbourhoods
-    3.8 Label SD for the PSI-MI samples
-    3.9 A refined SD for the PSI-MI samples
-    3.10 @xmath neighbourhoods of Figure 3.8  (a) and Figure 3.9  (b)
    SDs
-    4.1 AxPRE summary lattice capturing earlier homogeneous proposals
-    5.1 The two @xmath neighbourhoods (a) and their representative
    neighbourhood (b) from our running example
-    5.2 Two @xmath neighbourhoods from our running example
-    5.3 Two @xmath neighbourhoods (a) and their representative
    neighbourhood (b) from our running example
-    5.4 The @xmath neighbourhood of node @xmath of Figure 3.8
-    5.5 The @xmath neighbourhood of @xmath from Figure 3.8 : (a) before
    stabilizing @xmath edge to @xmath , (b) after stabilization
-    5.6 The neighbourhood from Figure 5.5  (b) after stabilizing @xmath
    loop on @xmath
-    6.1 Partition of the nodes in the XML tree by axis relations
-    6.2 The @xmath neighbourhood from Figure 3.9
-    6.3 The @xmath neighbourhood of @xmath from Figure 3.8 : (a) before
    a @xmath refinement, (b) after the refinement
-    6.4 AxPRE derivation functions @xmath and @xmath
-    A.1 Semantic definitions of XPath expressions
-    A.2 Semantic definitions of XPath location paths
-    A.3 Semantic definitions of XPath basic operators
-    A.4 Semantic definitions of XPath additional operators
-    B.1 DescribeX-Eclipse user interface

## Chapter 1 Introduction

XML is widely used as a common format for web accessible data (e.g.,
hypertext collections like Wikipedia) as well as for data exchanged
among web applications (e.g., blogs, news feeds, podcasts, web services
messaging). This data is often referred to as semistructured for the
lack of a clear separation between data and metadata it represents: tags
(metadata) and content (data) are mixed together in the same XML file.

The vast majority of software tools used for managing XML rely on XPath
[ W3C07 ] as the core dialect for XML querying. Hence, web developers
use XPath queries for many of the tasks involved in the processing of
XML collections. Such collections are normally handled one document at a
time, whether the document is an individual RSS ¹ ¹ 1
http://www.rss-specifications.com/ file (used by content distributors to
deliver to subscribers frequently updated content over the Web), a
single SOAP ² ² 2 http://www.w3.org/TR/soap/ message, or a Wikipedia
article in XHTML.

Even when XML collections have a schema (which can be either a DTD ³ ³ 3
http://www.w3.org/TR/REC-xml or an XML Schema ⁴ ⁴ 4
http://www.w3.org/TR/xmlschema-1/ ), the actual structure present in
each document may exhibit significant variations for several reasons.
First, schemas can be very lax. One reason for this is the extensive use
of the           <xsd:choice>          construct in XML schemas, which
allows optional elements to occur any number of times, including zero.
Such a construct is very common in RSS for instance. Second, a schema
can be very large and only subsets are actually used in a given
instance. This is the situation with several industry specific standards
that contain hundreds of elements, such as UBL ⁵ ⁵ 5
http://oasis-open.org/committees/ubl/ or HR-XML ⁶ ⁶ 6 http://hr-xml.org
. UBL and HR-XML are standard libraries of XML schemas that support a
variety of business processes. UBL is designed to handle supply chain
transactions such as purchase orders, shipping notices, and invoices,
whereas HR-XML contains schemas for human resource management such as
resumes, payroll information, and benefits enrollment. Finally, a schema
can be extended by using the           <xsd:any>          XML Schema
construct, which allows arbitrary content from other schemas to appear
under a given element. Such a construct enables different user
communities to pick and choose how to combine schemas. Consequently, it
provides great flexibility, but makes it harder to determine the
structure of the documents that actually appear in a given collection.
Examples of the           <xsd:any>          extensions can be found in
a wide variety of industry standards, including RSS, UBL and HR-XML. For
instance, the UBL standard permits a contractor to represent invoice
documents that include HR-XML TimeCard elements for the contractor
employee’s time and expenses. The actual structure of invoice
collections will vary significantly across contractors and customers. If
an enclosing messaging schema is used, even the UBL and HR-XML fragments
in the document can be replaced by other invoicing and time billing
schemas. In these scenarios, schemas alone are insufficient for
understanding the structure (metadata) of the documents in the
collection for either writing or optimizing XPath evaluation.

A developer working with this type of collection faces several
challenges. She must learn enough about the structure present in the XML
collection to be able to write meaningful XPath queries. She must also
develop an understanding of how the XPath expressions behave across
different documents in the collection. Even when a task deals with a
single document at a time, the developer needs to extrapolate the
behaviour of queries over a single document across the entire collection
over which the task may be repeatedly applied. In this context,
understanding the actual metadata of a web collection can be a
significant barrier, even for collections validated against a schema.

XML structural summaries are graphs representing relationships between
sets of XML elements (i.e., extents). Unlike schemas, which prescribe
what may and may not occur in an instance, summaries provide a
description of the metadata that is actually present in a given
collection. Figure 1.1 (a) shows the instance graph of a Wikipedia
sample document in which nodes correspond to XML elements in the
document. Nodes have an id and are labeled with their element names. The
structure in Figure 1.1 (b) is a typical summary that groups together
instance nodes with the same incoming label paths. In such a summary,
two nodes that have the same incoming label path from the root belong to
the same extent (sets located below each summary node in the figure).
For instance, wikilink elements appear at the end of three different
label paths – article.section.wikilink (in blue),
article.section.section.wikilink (in red), and article.par.wikilink (in
green). Consequently, there are three different wikilink nodes in the
summary, one with extent @xmath , another with extent @xmath , and a
last one with extent @xmath . Extents can also be viewed as mappings
between instance (document) nodes and summary nodes – represented in the
figure by dashed arrows linking wikilink nodes in the document graph
(left) and wikilink extents in the incoming path summary (right). An
edge @xmath in the summary means that at least one node in the extent of
@xmath is the parent of at least one node in the extent of @xmath . For
instance, an edge from node @xmath to @xmath means that some figure
elements within par have caption elements, but not necessarily all of
them have (for this document only node 12 has a caption element).

Describing metadata in semistructured collections was a major motivation
in one of the earliest summary proposals in the literature [ NUWC97 ,
GW97 ] . Since then, research on summaries has focused on query
processing, making summaries one of the most studied techniques for
query evaluation and indexing in XML (and other semistructured) data
models [ MS99 , KBNK02 , KSBG02 , QLO03 , BCF @xmath 05 ] , as well as
for providing statistics useful in XML query estimation and optimization
[ PG06b ] .

Most of the existing summary proposals define all extents using the same
criteria, hence creating homogeneous summaries. These summaries are
based on common element paths (in some cases limited to length @xmath ),
including incoming paths (e.g., representative objects [ NUWC97 ] ,
dataguides [ GW97 ] , 1-index [ MS99 ] , ToXin [ RM01 ] , A(k)-index [
KSBG02 ] ), both incoming and outgoing paths (e.g., F&B-Index [ KBNK02 ]
), or sequences of outgoing paths (e.g., Skeleton [ BCF @xmath 05 ] ).
The few examples of heterogeneous summaries that can adapt/change their
structure based on a dynamic query workload (e.g., APEX [ CMS02 ] ,
D(k)-index [ QLO03 ] , XSKETCH [ PG06b ] ) compute the extents from
statistics and workload information.

However, none of these proposals can help us to find elements based on
order and cardinality criteria. Consider again the instance in Figure
1.1 . What are the par elements that contain two figures ? How many
section elements contain a figure with caption next to a table ? How
many of those contain more than one figure ? These are questions that
cannot be answered with any of the summaries mentioned above.

Moreover, since these proposals are algorithmically defined, it is hard
to determine how they can be used together for processing today’s
increasingly heterogeneous and large web collections effectively.
Specifically, the summary information is not defined declaratively,
limiting the ease with which these summaries can be used within standard
data management tasks.

In this thesis, we propose a novel approach for flexibly summarizing the
structure of metadata actually present in an XML collection. We
introduce DescribeX, a framework that supports constructing heterogenous
summaries, where each set in the partition can be defined by means of
path regular expressions on axes, or axis path regular expression (
AxPRE , for short). AxPREs provide the flexibility necessary for
declaratively defining complex mappings between instance nodes and
summary nodes capable of expressing order and cardinality, among other
properties. Each AxPRE can be specified by the user or obtained from any
expression in the complete XPath language (all the axes, document order,
use of parenthesis, etc.). Given an arbitrary XPath expression posed by
the user, DescribeX can create a partition defined by an AxPRE that
captures exactly the structural commonality expressed by a query. AxPRE
summaries have a unique capability that makes them suitable for
describing the structure of XML collections: they are the first
summaries capable of declaratively defining and refining the summary
extents using a powerful language. In addition, DescribeX summaries
express relationships between instance nodes that go beyond the
traditional parent-child (e.g., next sibling, following, preceding,
etc.). Last but not least, DescribeX captures most summary proposals in
the literature by providing a declarative definition for them for the
first time.

This thesis argues that DescribeX can significantly help not only in the
understanding of the structure of large collections of XML documents,
but also in the evaluation of XPath queries posed on them. In fact,
DescribeX summaries can also be used to significantly speed up (and
scale up) XPath evaluation over existing file-at-a-time tools, enabling
fast exploration of the results of XPath workloads on large collections.
The experimental results demonstrate that using a summary created from a
given workload can produce query evaluation times that are two orders of
magnitude better than using existing summaries (in particular, summaries
on incoming paths like 1-index [ MS99 ] , APEX [ CMS02 ] , A(k)-index [
KSBG02 ] , and D(k)-index [ QLO03 ] ). The experiments also validate
that DescribeX summaries allow file-at-a-time XPath processors to be a
competitive light-weight alternative (in terms of performance) to
conventional DB-like XML query engines supporting additional
functionality such as security, transaction processing, and native
storage.

DescribeX also has applications to helping a user write and understand
XPath queries on large XML collections. Several software tools have been
developed to help XPath users debug query expressions (e.g., Oxygen XML
Editor ⁷ ⁷ 7 http://www.oxygenxml.com/ , Altova XMLSpy ⁸ ⁸ 8
http://www.altova.com/ , etc.) A recent research project includes a
tool, XPlainer-Eclipse [ CLR07 ] , that provides visual explanations of
XPath expressions. An explanation returns precisely the nodes in a
document that contribute to the answer, a useful debugging technique.
However, the main limitation of traditional XPath debugging tools in the
context of large XML collections is that they provide debugging
mechanisms only for a single document. Understanding queries over
collections containing thousands of documents (or even 650,000
documents, like in the Wikipedia XML Corpus [ DG06 ] ) using these tools
can be an impractical and very time-consuming task. DescribeX provides
an important foundation on which such a large-scale XML collection
understanding tool could be built, as evidenced by the
DescribeX-Eclipse tool presented in Appendix B .

### 1.1 Major contributions

This thesis identifies the growing need for describing the structure of
web collections (encoded in XML) using mechanisms that go beyond
providing one or more schemas. We propose the use of highly customizable
summaries that represent the actual structure of metadata labels as used
in a given collection. The following are the major contributions of this
thesis.

#### 1.1.1 AxPRE summaries

AxPRE summaries rely on the novel concept of a summary descriptor ( SD
). Traditional summaries consist of a labeled graph that describes the
label paths in the instance (which we call an SD graph) together with an
extent relation between summary nodes and sets of instance nodes. An SD
incorporates three key original features:

##### A description of the neighborhood of a node expressed by path
regular expressions on axes (i.e., binary relations between nodes),
AxPREs for short (Chapter 3).

AxPREs are evaluated on an axis graph , which is an abstract
representation of the XPath data model [ W3C07 ] extended with edges
that represent XPath axis binary relations. Edges are labeled by axis
names and nodes are labeled by element or attribute names (including
namespaces), or by new labels defined using XPath.

Given an axis graph @xmath , an AxPRE @xmath applied to a node @xmath in
@xmath returns an AxPRE neighbourhood of @xmath which provides a
description of the subgraph local to @xmath that satisfies @xmath . The
AxPRE neighbourhood of @xmath by @xmath is computed by intersecting the
automaton constructed from the axis graph and the automaton accepting
the language generated by the AxPRE and all its prefixes.

The AxPRE neighbourhood of a node @xmath is used to determine to which
equivalence class @xmath belongs. That is, if two nodes in @xmath have
similar AxPRE neighbourhoods (i.e. they cannot be distinguished by
@xmath ), they belong to the same equivalence class. This way, an AxPRE
can be used to define a partition of nodes in @xmath in which each set
is the extent of a node @xmath in the SD. The notion of similarity we
use is the familiar notion of bisimulation [ PT87 ] .

The use of AxPREs neighbourhoods supports the definition of summaries
that go beyond the traditional parent and child hierarchical
relationships covered by the abundant literature on summaries [ GW97 ,
MS99 , KBNK02 , KSBG02 , PG02 , QLO03 , BCF @xmath 05 , PG06b ] . In
particular, AxPREs can describe heterogeneous SDs, i.e., SDs described
by multiple AxPREs.

##### An extent expression (Ee) capable of computing precisely the set
of elements in the extent of a given SD node (Chapter 5.1).

Since an AxPRE @xmath is used to compute by bisimulation an entire
partition, we can say that all sets in the partition share the same
AxPRE @xmath . Thus, AxPREs cannot be used to uniquely identify each
equivalence class (extent) in such partition (unless the partition
contains only one set).

For a large class of neighbourhoods, it is possible to precisely
characterize the extent of an SD node @xmath with a new type of
expression we call extent expression (EE, for short). The EE @xmath of
@xmath with AxPRE @xmath is generated from the bisimilarity contraction
of the @xmath neighbourhoods of the elements in the extent of @xmath .
(Recall that all nodes in the extent of @xmath have bisimilar AxPRE
neighborhoods.) Thus, we pick any element in the extent of @xmath ,
compute its @xmath neighbourhood, and then compute its bisimilarity
contraction. The representative neighbourhood thus obtained is
guaranteed to be bisimilar to all neigbourhoods in the extent of @xmath
. A representative neighbourhood provides the sequence of axis
compositions and labels that will appear in the EE that computes the
extent of @xmath . EEs can be expressed in XPath and function like
virtual views (see Chapter 6 ).

##### The notion of AxPRE refinements of SD nodes (Chapter 5.2).

Exploring collections of XML documents typically requires knowledge of
the metadata present in the collection. SDs provide a descriptive tool
for representing metadata as SD graphs. The description provided by a
node in the SD can be changed by an operation that modifies its AxPRE
and thus its AxPRE neighbourhood. This operation is called an AxPRE
refinement of an SD node. Refinement refers to applying summarization to
selectively produce more or less detailed SDs.

The notion of refinement is well-known in the XML literature [ PT87 ] .
Intuitively, two nodes in the same equivalence class may be refined into
different classes, and two nodes from different classes will always be
refined into separate classes. An SD node can be refined by changing its
AxPRE definition. This produces SDs that are tailored to the exploration
needs of the user. Using successive node refinements, SD nodes can be
refined to produce SDs that provide a more detailed description of the
data.

Previous proposals perform global refinements on the entire SD graph [
KBNK02 , KSBG02 ] or local refinements based on statistics or workload [
QLO03 , HY04 , PG06b ] , without the ability to define the refinement
declaratively. In contrast, we can precisely characterize the
neighbourhood considered for the refinement with an AxPRE [ CRV08 ] .

The notion of refinement is tightly related to that of stabilization .
An edge stabilization determines the partition of an extent into two
sets based on the participation of the extent nodes in the axis relation
the edge represents.

#### 1.1.2 Refinement lattice

We show the existence of a hierarchical relationship between summaries
and provide a concise description of the hierarchy within the
DescribeX framework based on a refinement lattice . A refinement lattice
describes a refinement relationship between entire summaries.

The DescribeX refinement lattice provides a mechanism for capturing
earlier summary proposals, and understanding how those proposals relate
to each other and to richer SDs that were never previously considered in
the literature (see Chapter 4 ). Each node in the lattice corresponds to
a homogeneous SD defined by an AxPRE. The top (coarsest) summary of the
lattice corresponds to the label SD where each node is partitioned by
label, and the bottom (finest) summaries of the lattice each corresponds
to a distinct combination of axes.

#### 1.1.3 System implementation

In Chapter 7 , we present the implementation of the
DescribeX summarization engine for interactively creating and refining
AxPRE summaries given large collections of XML documents. Chapter 8
provides experimental results that validate the performance of the
techniques employed by DescribeX.

The engine uses Berkeley DB Java Edition ⁹ ⁹ 9
http://www.oracle.com/technology/products/berkeley-db/je/index.html to
store and manage indexed collections, and supports an arbitrary XPath
processor for the evaluation of XPath expressions. A visual interactive
tool based on the DescribeX framework, DescribeX-Eclipse (see Appendix B
), was developed as an Eclipse ¹⁰ ¹⁰ 10 http://www.eclipse.org/ plug-in.
In addition to the DescribeX summarization engine presented in this
thesis, DescribeX-Eclipse provides retrieval and visualization tools
implemented by other colleagues [ ACKR08 ] .

Our experiments (employing gigabyte XML collections) provide strong
evidence of the advantages of using DescribeX to build and exploit
summaries for exploration and XPath query evaluation. These results
demonstrate that the simple mechanism of accessing a summary extent
employed by the DescribeX implementation yields speedup factors of over
two orders of magnitude over commercial and open source implementations.

#### 1.1.4 Answering queries using extents

For evaluating a query using an SD, we need to find the SD nodes that
participate in the answer. Since our framework relies on XPath EEs for
defining the extents, the problem of answering queries using extents is
related to that of XPath containment [ Sch04 ] .

DescribeX can derive AxPREs from queries and use them to change the
description provided by the SD. Since AxPREs describe only structural
constraints and XPath queries may contain predicates on values, extents
resulting from AxPRE manipulation rarely provide the exact answer
without further filtering. The main reason for this is that the addition
of an XPath value predicate either reduces the size of the answer or
leaves the answer unchanged. Thus, DescribeX finds first the SD nodes
that participate in the answer (i.e., those whose extents contain at
least part of the answer), then evaluate the entire expression on them
and take the union of the results to get the exact answer (see Chapter
6.4 ). The experimental results provided in Chapter 8.4 considerably
expand the preliminary results presented in [ CR07 ] .

### 1.2 Motivating example: exploring RSS feeds with summaries and XPath
queries

This section walks through a concrete example to illustrate how
DescribeX summaries can help developers perform collection-wide
exploration and XPath query evaluation.

Consider a developer, Sue, who has to implement a web application that
retrieves RSS feeds from several content providers to produce an
aggregated meta-feed. The feed may span several days or weeks, and there
might be more than one item in the feed per day. Figure 1.2 shows the
instances of two sample RSS feeds represented as axis graphs .

An axis graph can display selected binary relations between elements in
an XML document tree, like @xmath @xmath @xmath and @xmath shown in the
figure (shorthands for XPath axes document , child , following-sibling ,
and for the derived axis firstchild , respectively). The semantics of
these axes is straightforward: the edge from element @xmath to @xmath
labeled @xmath means that @xmath is the first child of @xmath in
document order, and the edge from element @xmath to @xmath labeled
@xmath means that @xmath is a following sibling of @xmath in document
order. For simplicity, even though every first child is also a child, we
do not draw the @xmath edge between two nodes when an @xmath edge exits
between them. Being binary relations, axes have inverses, e.g., the
inverse of @xmath is @xmath (shorthand for parent ) and the inverse of
@xmath is @xmath (shorthand for preceding-sibling ). These inverses are
not shown in the figure.

Using DescribeX, Sue can create a summary descriptor (SD for short) like
the one shown on Figure 1.3 (a). This label SD , created from the two
feeds in Figure 1.2 , partitions the elements in the feeds by element
name. For example, SD node @xmath represents all the @xmath elements in
the two documents, @xmath (this set is called the extent of @xmath ).

An SD edge is labeled by the axis relation it represents. For instance,
edge @xmath is labeled by @xmath , which means that there is a @xmath
axis relation between elements in the extent of @xmath and @xmath .
Figure 1.3 (a) shows three kinds of edges, depending on properties of
the sets that participate in the axis relation: dashed, regular, and
bold. Dashed edges, like @xmath labeled @xmath , mean that some element
in the extent of @xmath has a child in the extent of @xmath . Regular
edges, like ( @xmath ) labeled @xmath , mean that every element in the
extent of @xmath has a first child in the extent of @xmath . Finally,
bold edges, like @xmath labeled @xmath , mean that every element in the
extent of @xmath is a child of some element in the extent of @xmath and
that every element in the extent of @xmath has some child in the extent
of @xmath .

From the label SD Sue learns that channel elements in the collection
always contain title , link , description , and item subelements.
However, the structure of item elements may vary. An item in the two
sample feeds always includes title and enclosure elements, but may
contain any combination of description and pubDate elements. Note that
the label SD does not provide information on exactly which combinations
actually appear. At this point Sue has two options:

1.  She can interactively refine the SD node @xmath in the label SD in
    order to learn how many different types of channels exist in the
    collection (i.e., how many subsets of title , enclosure ,
    description and pubDate are present within item elements).

2.  Since she already knows that some item elements have a pubDate from
    the label SD and she is interested in channels that contain such
    items, she can write query Q1 to retrieve them.

    Q1 = /rss/channel[item[pubDate]]

Sue can now decide either to run Q1 using the current SD or to make
DescribeX adapt the current SD to Q1. If she picks the former option,
DescribeX finds the only SD node that contains a superset of the answer
( @xmath ) and runs Q1 on its entire extent. If Sue chooses the latter
option, DescribeX changes the SD by partitioning the single channel node
@xmath in Figure 1.3 (a), which represents all channels in the
collection, into two channel nodes: one with a pubDate within their item
elements and another without a pubDate ( @xmath and @xmath in Figure 1.3
(b), respectively). Both SDs can be used to evaluate query Q1, but
notice this latter refinement (the SD of Figure 1.3 (b)) will yield a
more efficient evaluation.

Summaries in DescribeX are defined and manipulated via AxPREs. AxPREs
describe the neighbourhood of the elements in a given extent. A
neighbourhood of an element @xmath for an AxPRE @xmath is the subgraph
local to @xmath that matches @xmath . For instance, the @xmath AxPRE
describes the neighbourhood of @xmath containing all label paths from
@xmath to the root, @xmath all label paths from @xmath to the leaves,
and @xmath the sequence of @xmath ’s child labels. AxPREs can also be
derived from a query in order to adapt an SD to it. For example, the
@xmath AxPRE of node @xmath in Figure 1.3 (b) was derived from Q1 and
describes the neighbourhood of channel elements with common outgoing
label paths of length @xmath (more on this in Chapter 3 ). Sue could
have written the @xmath herself had she wanted to refine the channel
node @xmath according to the substructure of the channel elements in the
extent of @xmath (since she knows from the label SD that the variability
within channel elements may only come from description and pubDate
within item subelements, the @xmath AxPRE representing outgoing label
paths of length @xmath suffices).

Suppose further that Sue is also interested in item elements containing
both title and enclosure subelements, but she does not know whether such
items exist in the collection and, if they do, how common they are. In
addition, she wants those items to be part of a series (i.e., to belong
to channel elements that contain more than one item element, as done in
feeds for podcasts published daily). Therefore, she writes another
query:

Q2 = /rss/channel[item/following-sibling::item]

[not(pubDate=../item[1]/pubDate)] /item[title][enclosure]

Q2 contains structural (in black) and non-structural (in grey) XPath
constructs. The expression that results from removing all non-structural
constraints is called the structural subquery of Q2. A structural
subquery provides insight into the behaviour of the entire query and can
be used by DescribeX to refine an SD.

As with Q1, Sue can decide to either evaluate Q2 on the current SD (the
label SD with the refined channel node) or to add Q2 to the workload and
make DescribeX adapt the current SD. Assuming she chooses the second
option, the system partitions the item node @xmath from Figure 1.3 (a)
into the nodes @xmath and @xmath in Figure 1.3 (b) that describe the
structure of the collection with respect to the workload including Q2
and Q1. Note that the extent of node @xmath is exactly the answer to the
structural subquery of Q2, and thus a superset of the answer of Q2. The
elements in this extent are called candidate elements . Hence, by
adapting the SD to the structural subquery, DescribeX has considerably
reduced the search space for computing the entire query.

In a document-at-a-time approach to query evaluation, adapting an SD to
a workload can reduce the number of documents on which queries in the
workload need to be evaluated, potentially yielding a significant
speedup (see Chapter 8 ). That is, after adapting the SD to a given
query @xmath , DescribeX can evaluate @xmath only on those documents
(called candidate documents ) that are guaranteed to provide a non-empty
answer for the structural subquery of @xmath . Those candidate documents
that do contain an answer for the entire query are called answer
documents .

It is important to note that DescribeX can recognize two kinds of
channels with different structure beyond the elements directly contained
by them, a capability not available using DTD’s (unless channel elements
are renamed, which is not a possibility when the original DTD or the
instances cannot be modified). In particular, proposals to infer a DTD
from an instance (such as [ BNST06 , GGR @xmath 03 ] ) by suggesting
(general, but succinct) regular expression from the strings of child
elements, do not help to identify the two kinds of channels as done
above. For instance, the DTD expression <!ELEMENT channel (title, link,
description, item)> can be inferred for the channel elements occurring
in the instances shown in Figure 1.2 . However, a DTD can only give a
rule for the children of channel , there is no mechanism for giving
rules relating channel elements to their grandchildren (or any other
elements farther away). In contrast, the AxPRE summary in Figure 1.3 (b)
can distinguish between a channel containing an item with a pubDate
element from those that contain a description , and also between item
elements that belong to a multi-item channel from single-item ones.

As we will show in this thesis, DescribeX is not only more expressive
than DTD’s and XML Schemas, but also more expressive than other summary
proposals making it a robust foundation for managing large document
collections.

### 1.3 Organization

This thesis is structured as follows. Chapter 2 gives an overview of the
large body of related work in the literature. Chapter 3 introduces the
DescribeX framework, including the AxPRE language and some basic notions
such as neighbourhood, bisimilarity, and summary descriptor (SD).
Chapter 4 revisits some of the related work discussed in Chapter 2 and
explains how they can be captured by the DescribeX framework and how
DescribeX offers significant new functionality. Chapter 5 presents two
new operations, AxPRE refinement and stabilization, for declaratively
changing the description provided by an SD using AxPREs. Refinement and
stabilization are central to the use of summaries for both structure
understanding and query processing. Chapter 6 introduces a novel
mechanism to characterize an SD node with an XPath expression whose
evaluation returns exactly the elements in the extent. It also discusses
how to compute AxPRE refinements and stabilizations with XPath
expressions and how to evaluate XPath queries using DescribeX summaries.
Chapter 7 describes the implementation of the DescribeX summarization
engine for creating and manipulating SDs of XML collections. Chapter 8
provides experimental results, using gigabyte size XML collections, that
validate the performance of the techniques employed by our framework. We
conclude in Chapter 9 by presenting some future research issues. In
addition, Appendix A provides a concise definition of the formal
semantics of XPath 1.0, and Appendix B presents a visual interactive
tool built on top of the DescribeX summarization engine.

## Chapter 2 Related work

In this chapter, we discuss contributions from the literature on
structural summaries and other areas related to our work, such as path
summaries for object-oriented data, hierarchical encodings, answering
XML queries using views, and validating summaries.

### 2.1 Structural summaries

The large number of summaries that have been proposed in recent years
clearly establishes the value and usefulness of these structures for
describing semistructured data, assisting with query evaluation, helping
to index XML data, and providing statistics useful in XML query
optimization.

Most of the summary proposals in the literature define synopses of
predefined subsets of paths in the data. They construct a labeled graph
that represents relationships between sets of XML elements. Examples of
such summaries are region inclusion graphs (RIGs) [ CM94 ] ,
representative objects (ROs) [ NUWC97 ] , dataguides [ GW97 ] , reversed
dataguides [ LS00 ] , 1-index, 2-index and T-index [ MS99 ] , and more
recently, ToXin [ RM01 ] , A(k)-index [ KSBG02 ] , F-Index, B-index, and
F&B-Index [ KBNK02 ] . Dataguides and ROs group nodes into sets
according to the label paths incoming to them (each node may appear more
than once in the dataguide if the document instance is not just a tree).
RIGs, 1-index, T-index, ToXin, F&B-Index, and F+B-Index, on the other
hand, partition the data nodes into equivalence classes (called extents
in the literature) so that each node appears only once in the summary.
The partition is computed in different ways: according to the node
labels (RIGs), the label paths incoming to the nodes (1-index, ToXin,
A(k)-index), the label paths going out from the nodes (reversed
dataguides), or label paths both incoming and outgoing (F&B-Index and
F+B-Index). The length of the paths in the summary also varies: ToXin,
1-index and F&B-Index/F+B-Index summarize paths of any length, whereas
A(k)-index is a synopsis of paths of a fixed length. Updates to
structural summaries have been studied in [ KBNS02 ] and [ YHSY04 ] .

RIGs were one of the first summaries proposed in the literature,
introduced in the context of region algebras [ CM94 , YLT03 ] .
Dataguides [ GW97 ] group nodes in a rooted data graph into sets called
target sets according to the label paths from the root they belong to.
Since the label paths form a language, its deterministic finite
automaton (DFA) is used as a more concise representation of the label
paths. The construction of a dataguide from a data graph is equivalent
to the conversion of a NFA (the XML tree) into a deterministic finite
automaton (the dataguide) [ NUWC97 ] .

An index family was presented in [ MS99 ] (1-index, 2-index, and
T-index). Like dataguides, the 1-index summarizes root-to-leaf paths. In
the 1-index, the nodes of a XML tree are partitioned into equivalence
classes according to the label paths they belong to. Since the 1-index
extents constitute a partition of the XML nodes, the number of 1-index
nodes can never be bigger than the XML tree. The extreme case is the one
in which every XML node belongs to a separate equivalence class (which
is in fact the data instance). The 1-index partition is computed by
using bisimulation [ PT87 ] .

Based also on bisimulation, the A(k)-index was introduced in [ KSBG02 ]
. The construction of the summary is based on @xmath -bisimilarity
(bisimilarity computed for paths of length k). Thus, the A(0)-index
creates the partition based on the labels of the nodes (0-bisimilarity),
and the A(h)-index uses @xmath -bisimilarity which creates the partition
based on incoming label paths of length @xmath .

Another index family was introduced in [ KBNK02 ] . The F&B-Index
construction uses bisimulation like the 1-index, but applied to the
edges and their inverses in a recursive procedure until a fix-point.
With this construction, the F&B-Index’s equivalence classes are computed
according to the incoming and outgoing label paths of the nodes. The
same work introduces the F+B-index, which applies the recursive
procedure only twice, once for the edges and another reversing the
edges. Both F&B-Index and F+B-index are special cases of the BPCI(k,j,m)
index, where @xmath and @xmath controls the lengths of the paths and
@xmath the iterations of the bisimulation on the edges and their
inverses.

ToXin consists of three index structures: the ToXin schema, the path
index, and the value index. The ToXin schema is equivalent to a strong
dataguide. The path index contains additional structures that keep track
of the parent-child relationship between individual nodes in different
extents. A recent proposal, TempIndex [ MRV04 ] extends ToXin with the
temporal dimension in order to speed-up path queries on a temporal XML
data model. TempIndex summarizes incoming paths that are valid
continuously during a certain time interval and is part of the TSummary
framework [ RV08 ] .

Based on the A(k)-index, a recent proposal [ FGW @xmath 07 ] defines
partitions of paths, rather than nodes, called P(k)-partitions – where
@xmath is the maximum length of the paths summarized. This work also
introduces an algebraization of the navigational core of XPath in order
to define XPath fragments that can be coupled to P(k)-partitions for
fast evaluation of queries in the fragments. Since this proposal is
based on navigational XPath, it supports only expressions containing
composition of @xmath , @xmath , @xmath , and @xmath axes. In contrast,
DescribeX can be used to evaluate expressions in the complete XPath
language (with all the axes, functions, use of parenthesis, etc.).

Other summaries are augmented with statistical information of the
instance for selectivity estimation, including path/branching
distribution (XSKETCH [ PG02 , DPGM04 ] ), value distributions (XCLUSTER
[ PG06a ] ), and additional statistical information for approximate
query processing (TREESKETCH [ PGI04 ] ).

A few adaptive summaries like APEX [ CMS02 ] , D(k)-index [ QLO03 ] ,
and M(k)-index [ HY04 ] use dynamic query workloads to determine the
subset of incoming paths to be summarized. APEX is a summary of
frequently used paths that summarizes incoming paths to the nodes and
adapts to changes in the workload by changing the set of path considered
in the synopsis. That is, instead of keeping all paths starting from the
root, it maintains paths that have some “support” (i.e., paths that
appear a number of times over a certain threshold in the workload). The
workload APEX considers are expressions containing a number of @xmath
axis composition that may be preceded by a @xmath axis, without any
predicate. APEX summarizes incoming paths to the nodes and adapts to
changes in the workload by changing the set of paths summarized.
D(k)-index and M(k)-index, in contrast, summarize variable-length paths
based on both the workload and local similarity (the length of each path
depends on its location in the XML instance).

There has been almost no work on summaries that capture the node
ordering in the XML tree: the only proposals we are aware of are the
early region order graphs (ROGs) [ CM94 ] and the Skeleton summary [ BCF
@xmath 05 ] that clusters together nodes with the same subtree
structure. Skeleton has additional structures that store relationships
between individual nodes that belong to different equivalence classes.

In contrast to these proposals, DescribeX is capable of declaratively
defining complex mappings between instance nodes and summary nodes for
expressing order, cardinality, and relationships that go beyond the
traditional parent-child (e.g., next sibling, following, preceding,
etc.) In addition, DescribeX provides a declarative definition for the
first time for most of the proposals discussed above (for more details
on how DescribeX captures other structural summaries see Chapter 4 ).

### 2.2 Path summaries for OO data

We can trace the origin of structural summaries for XML to the OODB
community. This community has been quite active in the past in the area
of path summaries for object-oriented data. Examples are path indexes [
Ber94 ] , access support relations [ KM90 ] , and join index hierarchies
[ XH94 ] . All three proposals materialize frequently traversed paths in
the database. Access support relations are designed to support joins
along arbitrary reference chains leading from one object instance to
another. They also support collection-valued attributes by materializing
frequently traversed reference chains of arbitrary length. Access
support relations are a generalization of the binary join indices
originally proposed for the relational model [ Val87 ] . One fundamental
difference with respect to join indices, however, is that rather than
relating only two relations (or object types), access support relations
materialize access paths of arbitrary length.

A path index can materialize the same class of paths as an access
support relation. It stores the sequence of nodes (objects) that define
a given path. In contrast, a join index hierarchy constructs hierarchies
of join indices to optimize navigation via a sequence of objects and
classes. A join index stores the pairs of identifiers of objects of two
classes that are connected via logical relationships. Since all these
OODB approaches are based on the paths found in the OO schema, they can
only be adapted to XML documents for which either a DTD or an XML Schema
is present. In contrast, DescribeX permits summarization of collections
without any schema.

### 2.3 Hierarchical encodings

We should mention that, in addition to the use of summaries, query
evaluation can be facilitated by encoding the hierarchical structure of
an XML instance. Node encoding evaluations use some sort of interval
encodings [ SK85 ] to label each node with its positional information
within the XML instance. This positional information is used by join
algorithms to efficiently reconstruct paths and label paths. Recent
proposals for node encoding evaluations are region algebras [ CM94 ,
YLT03 ] , path joins (XISS) [ LM01 ] , relative region coordinates [
KYU01 ] , structural joins [ AKJP @xmath 02 , CVZ @xmath 02 ] , holistic
twig joins [ BKS02 , JWLY03 ] , partition-based path joins [ LM03 ] ,
XR-Tree [ JLWO03 ] , PBiTree [ WJLY03 , VMT04 ] , extended Dewey
encoding for holistic twig joins [ LLCC05 ] , and FIX [ ZÖIA06 ] , a
feature-based indexing technique.

Structural encoding proposals are based on mapping the XML tree
structure into strings and use efficient string algorithms for query
processing. Since the size of each string grows with the length of the
encoded path, many approaches use some sort of compression to offset
this overhead. Examples of those are Index Fabric [ CSF @xmath 01 ] ,
tree signatures [ ADR @xmath 04 ] , materialized schema paths [ BW03 ] ,
PathGuides [ CYWY03 ] , and tree sequencing (ViST [ WPFY03 ] , PRIX [
RM04 ] , and NoK [ ZKÖ04 ] ). These encodings can be used in conjunction
with structural summaries to improve query evaluation performance. In
fact, the availability of summaries can be of great assistance to an XML
optimizer [ BCM05 ] .

DescribeX uses an interval encoding derived from [ SK85 ] in which each
element in the collections is represented by its start and end positions
(the character offset from the beginning of the document they belong
to).

### 2.4 Answering XML queries using views

Another area closely related to summarization is answering queries using
views. As in traditional database systems, the performance of XML
queries can be improved by rewriting them using caching and materialized
views containing information relevant to the computation of the query. A
recent contribution in this area includes a framework for XPath view
materialization and query containment [ BOB @xmath 04 ] that uses value
and structure indexes on views. Another framework was proposed in [ MS05
] for maintaining a semantic cache of XPath query results as
materialized views used to speed-up query processing. Other work has
considered the problem of deciding the existence of a query rewriting
and finding a minimal rewriting using XPath views [ XÖ05 ] , and
computing maximal contained rewriting for tree pattern queries (a core
subset of XPath) [ LWZ06 ] .

For XQuery, query rewriting poses additional challenges. One of them is
that queries may be nested. Another challenge comes from the mix of
list, bag and set semantics supported by XQuery, which makes testing
equivalence more difficult. In this context, there has been some work on
query rewriting for nested XQuery queries using nested XQuery views [
ODPC06 ] . A recent contribution for extended tree patterns views (a
subset of XQuery) proposes containment and equivalent rewriting
strategies based on a dataguide enhanced with integrity constraints [
ABMP07 ] . This proposal considers only queries described by tree
patterns.

We must point out here that most of the work in this area could be
applied to our framework to expand the query evaluation techniques we
present in Chapter 6 .

### 2.5 Validating summaries

DTDs ¹ ¹ 1 http://www.w3.org/TR/REC-xml and XML Schemas ² ² 2
http://www.w3.org/TR/xmlschema-1/ are proposals used for validation and
verification of XML documents. A DTD is a context-free grammar and an
XML Schema is a typed definition language. Both are schemas in the
database sense, and thus describe classes of documents and constrain
their structure. However, they provide only a limited description of the
instances that satisfy them and no mechanism to locate specific instance
fragments. In contrast, summaries are constructed for a particular
instance and consequently provide a tighter description of the data.
They also contain the necessary information for locating the instance
fragments they describe. DTDs and XML Schemas can be used to constrain
the construction of summaries but they are no substitute for them.
Moreover, summaries can be constructed even when DTDs and XML Schemas
are not present.

In addition to describing an instance, DescribeX summaries could
potentially be used for prescribing or constraining the data by adding
schema constructs. Figure 2.1 shows a fragment of the label SD from
Figure 1.3 (a) annotated with XML graph schema constructs [ MS07 ] in
blue. These constructs, which contain choice and sequence nodes (and
others not shown in the figure), are able to express XML schema
languages like DTDs, XML Schemas, and Relax NG ³ ³ 3
http://www.oasis-open.org/committees/relax-ng/spec-20011203.html/ . (For
a survey on XML schema languages see [ MLMK05 ] .) The SD of Figure 2.1
represents channels that contain exactly one title, one description and
one or more items that contain themselves one title and a sequence of
zero or more description elements. In the figure, choice and sequence
nodes are used to represent the number of occurrences of an element,
which can be zero, one, or unbounded. The DTD corresponding to the
elements that appear in Figure 2.1 is the following:

<!ELEMENT channel (title, item+, description)>

<!ELEMENT item (title, description?)>

<!ELEMENT title (#PCDATA)>

<!ELEMENT pubDate (#PCDATA)>

In an SD, schema annotations have to be consistent with instance
descriptions. For example, the existential edge @xmath is compatible
with an schema permitting any number of occurrences of @xmath (even
zero). In contrast, the same edge is incompatible with an schema
requiring at least one @xmath element because the dashed edge allows
some items to have no descriptions.

This is just an example of how schema constructs can be integrated with
DescribeX summaries. There are many other ways of approaching the
subject, but we do not consider it further in this thesis.

This chapter provided a discussion of related work on structural
summaries and four other areas close to our work: path summaries for OO
data, hierarchical encodings, answering XML queries using views and
validating summaries. In the next chapter, we begin introducing one of
the major contributions of this thesis, the DescribeX framework. We will
show how DescribeX generalizes and extends both structural and path
summaries, and how DescribeX summaries can be used in query processing.

## Chapter 3 AxPRE summaries

This chapter provides an overview of the DescribeX framework. The
framework includes a powerful language based on axis path regular
expressions (AxPREs) for describing each set in a partition of instance
nodes (extents). AxPREs provide the flexibility necessary for
declaratively specifying the mapping between instance nodes and summary
nodes for a given collection. These AxPRE mappings are capable of
expressing order and cardinality, among other properties. AxPREs are
evaluated on a graph (called axis graph ) in which nodes are XML
elements and edges are binary relations between them. Hence, AxPREs can
be viewed as path regular expressions on binary relations. These
relations include all XPath axes and additional ones that can be
expressed in XPath.

Extents are defined using a novel approach: selective bisimilarity
applied to subgraphs described by AxPREs (i.e., AxPRE neighbourhoods ).
This particular use of bisimulation supports the definition of summaries
that go beyond the traditional parent and child hierarchical
relationships covered by the abundant literature on summaries.
Intuitively, nodes that have bisimilar subgraphs “around” them (i.e.,
neighbourhoods) belong to the same extent. For instance, DescribeX can
define extents containing only nodes with the same set of outgoing label
paths matching a given sequence of axes. Neighbourhoods are a key
mechanism in the declarative definition of DescribeX summaries.

### 3.1 A regular expression language on axes

In this section, we introduce the AxPRE language for describing
neighbourhoods in an SD. For representing an XML instance,
DescribeX uses a labeled graph model called an axis graph .

###### Definition 3.1 (Axis Graph)

An axis graph @xmath @xmath @xmath @xmath is a structure where @xmath is
a set of nodes, @xmath is a set of binary relations @xmath in @xmath and
their inverses, @xmath is a finite set of node names, and @xmath is a
function that assigns labels in @xmath to nodes in @xmath . Edges are
labeled by axis names. @xmath

An axis graph is an abstract representation of the XPath data model [
W3C07 ] extended with edges that represent XPath binary relations
between elements. It can also include additional axes, such as @xmath
(where @xmath ), @xmath (where @xmath ), id-idrefs or any binary
relation that can be expressed in XPath. When representing an XML
instance, axis graph nodes are labeled by element or attribute names
(including namespaces).

###### Example 3.1 (PSI-MI Axis Graph)

Figure 3.1 shows an axis graph for our running example, which is a
sample of a protein-protein interaction (PPI) dataset in PSI-MI ¹ ¹ 1
http://psidev.sourceforge.net/mi/xml/doc/user/ format. PSI-MI stands for
Proteomics Standards Initiative Molecular-Interaction and is the
de-facto model for PPI used by many molecular interaction databases such
as BioGRID ² ² 2 http://www.thebiogrid.org/ , Human Protein Reference
Database (HPRD) ³ ³ 3 http://www.hprd.org/ , and IntAct ⁴ ⁴ 4
http://www.ebi.ac.uk/intact/ . The PSI-MI XML schema has a large number
of optional elements to allow flexibility, with the result that PSI-MI
data can be very heterogeneous. Since different databases use different
fragments of the schema, finding common instance patterns and
understanding schema usage can be challenging [ SCKT07 ] .

Each interaction consists of an experimentList element with all the
experiments in which the interaction has been determined, a
participantList element with the molecules that participate in the
interaction and some optional elements like the name of the interaction
and a reference (xref) to an interaction database. Each participantList
contains two or more participants, which are the molecules participating
in the interaction. A participant element contains a description of the
molecule, either by reference to an element of the interactorList, or
directly in an interactor element. In addition, each participant
contains a list of all the roles it plays in the experiments (e.g.,
bait, prey, neutral, etc.)

Note that, for the sake of clarity, we have omitted many edges depicting
relations that actually exist. For example, the @xmath ( @xmath )
relation is included in the @xmath ( @xmath ) relation, so any @xmath
edge is also a @xmath edge. The inverses of each relation are not shown
in the figure, e.g., for each @xmath relation, a @xmath ( @xmath )
relation exists (since @xmath ). @xmath

An AxPRE gives a declarative description of a partition of elements in
an SD, something not provided by any other proposal in the literature.

In an axis graph we define paths and label paths as usual. We call a
path defined on edges an axis path , and the string resulting from the
concatenation of its labels is an axis label path .

###### Definition 3.2 (Axis Path and Axis Label Path)

Let @xmath be a connected subgraph of an axis graph @xmath , and @xmath
be two nodes in @xmath such that there is a path @xmath , @xmath ,
@xmath from @xmath to @xmath . The axis path of @xmath is the string
@xmath . @xmath . @xmath . The axis label path of @xmath is the string
@xmath @xmath @xmath . @xmath

###### Example 3.2

Consider the axis graph of Figure 3.1 . Two of the paths from node
@xmath to @xmath are @xmath and @xmath . Their axis paths are @xmath and
@xmath , respectively. Finally, the axis label paths of @xmath and
@xmath are @xmath @xmath @xmath @xmath and @xmath @xmath @xmath ,
respectively. @xmath

###### Definition 3.3 (Axis Path Regular Expressions)

An axis path regular expression (AxPRE) is an expression generated by
the grammar

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath is the symbol representing the empty expression.
@xmath

Definition 3.3 describes the syntax of path regular expressions on the
binary relations (labeled edges) of the axis graph including node label
tests. The function @xmath is a boolean function on a label @xmath that
supports elaborate tests beyond just matching labels.

An AxPRE defines a pattern we want to find in an instance. We need a way
of computing all occurrences of such pattern in an axis graph – each
occurrence will be called a neighbourhood. We do this by computing an
automaton for the AxPRE, another for the axis graph, and then taking the
intersection. Finally, a summary will group nodes with similar patterns
together into an extent (DescribeX uses bisimulation as the notion of
similarity).

The AxPRE semantics (Definition 3.8 ) is given by the notion of AxPRE
neighbourhood of a node (Definition 3.7 ). In order to compute an AxPRE
neighbourhood we need first to define an automaton from the axis graph.
Such an automaton will have two states for each node in the axis graph,
one named @xmath and the other @xmath . In addition, edges in the graph
will be represented as transitions between @xmath and @xmath states, and
node labels as transitions between @xmath and @xmath states.

###### Definition 3.4 (Axis Graph Automaton)

Let @xmath @xmath @xmath @xmath be an axis graph and @xmath a node in
@xmath . The axis graph automaton of @xmath from @xmath , @xmath , is an
automaton [ HU79 ] defined as follows:

-    For each node @xmath there is a state @xmath , a state @xmath and a
    transition @xmath ;

-    For each edge @xmath labeled @xmath in @xmath there is a transition
    @xmath ;

-    All @xmath states in @xmath , @xmath , are final states in @xmath ,
    and @xmath is the initial state @xmath .

@xmath

###### Example 3.3

Consider node @xmath of our running example. Figure 3.2 shows on the
left hand side a fragment of the axis graph that contains node 8. The
axis graph automaton from node @xmath (on the right hand side of the
figure) has @xmath as initial state and all @xmath states as final. Each
node in the axis graph fragment is unfolded into a head and a tail
states in the automaton and its label is represented by a transition
between them. Consider node @xmath with label @xmath that has @xmath and
@xmath incoming edges and a @xmath outgoing edge in the axis graph. In
the automaton, @xmath is represented by a @xmath state that has @xmath
and @xmath incoming transitions and an outgoing transition @xmath to
@xmath . The outgoing @xmath edge is translated into a @xmath transition
from @xmath to the head state of the corresponding node, which is @xmath
. @xmath

An automaton can be obtained from an AxPRE following the usual
Thompson’s construction for regular expressions with a minor change to
the basis steps to account for AxPRE semantics (which require accepting
all prefixes of the language). The language accepted by the so called
AxPRE automaton thus constructed will always be prefix-closed. (A
language @xmath is said to be prefix-closed if, given any word @xmath ,
all prefixes of @xmath are also in @xmath [ HU79 ] .)

###### Definition 3.5 (AxPRE Automaton)

Let @xmath be an AxPRE. The AxPRE automaton of @xmath is an automaton
@xmath obtained from @xmath with a modified Thompson’s construction [
HU79 ] for accepting all prefixes (Figure 3.3 ), in which only the final
states of the basis rules are kept as final in the resulting automaton
(the inductive rules for concatenation, disjunction and Kleene closure
do not mark any additional state as final). The transition function
@xmath returns the states that can be reached by an @xmath transition
after following an arbitrary number (possibly zero) of @xmath
transitions. @xmath

###### Example 3.4

Consider the AxPRE @xmath and its automaton in Figure 3.4 . The
application of rule @xmath of the modified Thompson’s construction
creates states @xmath , @xmath and the @xmath transition between them.
The application of rule @xmath creates @xmath , @xmath , @xmath , @xmath
, and the @xmath transitions from @xmath to @xmath and from @xmath to
@xmath (there is one transition @xmath for each string in @xmath ). The
final automaton is obtained by applying the concatenation and Kleene
closure rules. @xmath

An automaton for the intersection of two languages can be constructed by
taking the product of the automata for the two languages [ MW95 , Yan90
] .

###### Definition 3.6 (Intersection Automaton)

Let @xmath be the automaton of an axis graph @xmath from a node @xmath ,
and @xmath be the automaton of an AxPRE @xmath . The intersection
automaton @xmath is an automaton in which states are pairs @xmath @xmath
consisting of a state @xmath and a state @xmath , and there is a
transition @xmath @xmath @xmath if there are transitions @xmath in
@xmath and @xmath in @xmath , where @xmath is either an axis or a label.
A state @xmath is final (initial) if both @xmath and @xmath are final
(initial). @xmath

The machinery introduced in Definitions 3.4 through 3.6 is required for
computing AxPRE neighbourhoods of nodes in the axis graph. The
neighbourhood of a node @xmath by @xmath can be obtained by taking the
intersection between the axis graph automaton from @xmath and the AxPRE
automaton of @xmath , and then converting the resulting automaton to an
axis graph fragment as described in Definition 3.7 .

###### Definition 3.7 (AxPRE Neighbourhood of a Node)

Let @xmath @xmath @xmath @xmath be an axis graph, @xmath a node in
@xmath , @xmath an AxPRE, and @xmath the intersection automaton of
@xmath and @xmath . The AxPRE neighbourhood of @xmath by @xmath denoted
@xmath is the subgraph of @xmath defined as follows:

-    For each transition @xmath , where @xmath is a final state, there
    is a node @xmath with label @xmath in @xmath ;

-    For each transition @xmath , where @xmath is a final state, there
    is an edge @xmath labeled @xmath in @xmath .

@xmath

###### Example 3.5 (AxPRE Neighbourhood of a Node)

Consider node 8 of our running example. The intersection automaton
@xmath @xmath @xmath is depicted in Figure 3.5 (a). States are labeled
by pairs @xmath , where @xmath is a state in automaton @xmath and @xmath
is a state in automaton @xmath . The intersection has been computed
following Definition 3.6 . The figure shows only the states that have
some incoming or outgoing transition. Note that transition @xmath
between @xmath and @xmath is not part of the intersection because @xmath
is the only outgoing transition from @xmath in @xmath .

Figure 3.5 (b) shows the AxPRE neighbourhood of node 6, @xmath ,
obtained by converting the intersection automaton to an axis graph
fragment as described in Definition 3.7 . Note that transitions from
@xmath to @xmath in the intersection are node labels in the AxPRE
neighbourhood and that transitions from @xmath to @xmath are edge labels
(axes) in the neighbourhood.

Consider now the five @xmath neighbourhoods depicted in Figure 3.6 .
Neighbourhood (a) matches a prefix of the AxPRE ( @xmath ) whereas (b)
through (e) match the entire AxPRE but with a different number of
iterations in the Kleene closure for @xmath : 1 for (b) and (e), and 0
for (c) and (d). @xmath

We formalize next the notion of AxPRE semantics based on AxPRE
neighbourhoods.

###### Definition 3.8 (AxPRE Semantics)

Let @xmath @xmath @xmath @xmath be an axis graph and @xmath a node in
@xmath . The evaluation of an AxPRE @xmath on @xmath returns the AxPRE
neighbourhood of @xmath by @xmath . @xmath

### 3.2 Neighbourhoods and bisimulation

AxPRE neighbourhoods allow us to define a notion of similarity between
nodes in an axis graph. The idea underlying DescribeX is that nodes with
similar AxPRE neighbourhoods will be grouped together. In particular,
DescribeX uses the familiar concept of labeled bisimulation applied to
AxPRE neighbourhoods, formalized by Definition 3.9 .

###### Definition 3.9 (Labeled Bisimulation and Bisimilarity)

Let @xmath and @xmath be two AxPRE neighbourhoods of an axis graph
@xmath @xmath @xmath @xmath , such that @xmath and @xmath . A labeled
bisimulation between @xmath and @xmath is a symmetric relation @xmath
such that for all @xmath , @xmath , @xmath , and @xmath : if @xmath then
@xmath ; if @xmath and @xmath , then @xmath and @xmath . Two nodes
@xmath , @xmath are bisimilar , in notation @xmath , iff there exist a
labeled bisimulation @xmath between @xmath and @xmath such that @xmath .
Similarly, two neighbourhoods @xmath and @xmath are bisimilar , in
notation @xmath , iff @xmath . @xmath

Definition 3.9 captures outgoing label paths from the nodes.
Bisimulation provides a way of computing a double homomorphism between
graphs. The widespread use of bisimulation in summaries is motivated by
its relatively low computational complexity properties. The bisimulation
contraction of a labelled graph can be done in time @xmath (where @xmath
is the number of edges and @xmath is the number of nodes in a labelled
graph) as shown in [ PT87 ] , or even linearly for acyclic graphs, as
shown in [ DPP04 ] . Using bisimulation also allows us to capture all
the existing bisimulation-based proposals in the literature (Chapter 4
).

###### Example 3.6

Let us consider the nodes @xmath and @xmath in the axis graph of Figure
3.1 . Their @xmath neighbourhoods are depicted in Figure 3.6 (b) and
(c), respectively. Based on Definition 3.9 , we can define a labeled
bisimulation @xmath between nodes @xmath and @xmath because they have
the same labels and they do not have outgoing edges. For the same
reasons we have @xmath . However, it is not possible to define a labeled
bisimulation between @xmath and @xmath because, even though they have
the same labels, @xmath has one outgoing edge whereas @xmath does not.
Thus, @xmath . This prevents us from defining a label bisimulation
between @xmath and @xmath because they each have only one outgoing
@xmath edge, but to nodes @xmath and @xmath , which are not bisimilar.
Therefore, @xmath . Similarly, @xmath because they have edges with the
same labels ( @xmath ) to nodes that are not bisimilar ( @xmath and
@xmath ). Consequently, neighbourhoods (b) and (c) of Figure 3.6 are not
bisimilar.

In contrast, let us compare now nodes @xmath and @xmath but with respect
to their @xmath neighbourhoods, which are depicted in Figure 3.7 (b) and
(c), respectively. In this case we can have @xmath and @xmath because
all of them are leaves and have the same label. Therefore, @xmath
because the outgoing edges from @xmath go to nodes @xmath and @xmath ,
which are bisimilar to the target node ( @xmath ) of the only outgoing
edge from @xmath . Thus, @xmath because they have edges with the same
labels ( @xmath ) to nodes that in this case are bisimilar ( @xmath and
@xmath ). Consequently, neighbourhoods (b) and (c) of Figure 3.7 are in
fact bisimilar. @xmath

###### Definition 3.10 (AxPRE Bisimilarity)

Let @xmath @xmath @xmath @xmath . When two nodes @xmath and @xmath in
@xmath have bisimilar neighbourhoods by the same AxPRE @xmath , that is
@xmath , we say that @xmath and @xmath are AxPRE bisimilar by @xmath or
@xmath -bisimilar , in notation @xmath . @xmath

###### Example 3.7

Consider again the neighbourhoods in Figure 3.6 . Nodes @xmath and
@xmath have non-bisimilar @xmath neighbourhoods and thus @xmath , where
AxPRE @xmath . However, if we consider now their @xmath neighbourhoods,
which are bisimilar, then @xmath for AxPRE @xmath . @xmath

AxPRE bisimilarity is used for defining partitions of an axis graph.
Intuitively, a so called AxPRE partition assigns two nodes @xmath and
@xmath in an axis graph to the same class if their AxPRE neighbourhoods
by a given @xmath are bisimilar. This is formalized by Definition 3.11 .

###### Definition 3.11 (AxPRE Partition)

Let @xmath @xmath @xmath @xmath be an axis graph and @xmath an AxPRE. An
AxPRE partition of @xmath by @xmath , denoted @xmath , is a set of
pairwise disjoint subsets of @xmath whose union is @xmath defined as
follows: two nodes @xmath belong to the same set @xmath iff @xmath .

###### Definition 3.12 (Positive Classes)

Let @xmath @xmath @xmath @xmath be an axis graph, @xmath an AxPRE and
@xmath the set of the empty neighbourhoods in the AxPRE partition of
@xmath by @xmath . Then, @xmath is the set of positive classes of @xmath
. @xmath

Since all nodes that have an empty AxPRE neighbourhood belong to the
same equivalence class, @xmath and @xmath differ in at most one set.

###### Example 3.8

Consider the AxPRE partitions by @xmath , where @xmath are the different
node labels that appear in the axis graph, have one positive class each
because each neighbourhood represents a different node label. (Note that
the @xmath different positive classes do not overlap.) Moreover, the
union of those @xmath sets (each coming from a different partition) also
constitute a partition of @xmath . In contrast, if we take only a proper
subset of @xmath node labels, @xmath , the @xmath positive classes of
the resulting AxPRE partitions do not constitute a partition because
their union does not have all nodes in @xmath . @xmath

Given an AxPRE, the positive classes plus one additional class for the
empty neighbourhood forms a partition. If we have another AxPRE whose
positive classes fall exclusively within this empty neighbourhood class,
then these two AxPREs may be used together to summarize an axis graph.
We are interested in sets of AxPREs whose positive classes define a
partition of @xmath , which is formalized next.

###### Definition 3.13 (Positive Partition)

Let @xmath @xmath @xmath @xmath be an axis graph. A set @xmath of AxPREs
defines a positive partition of @xmath , denoted @xmath , iff @xmath is
a partition of @xmath . @xmath

The intuition behind the notion of positive partition from a set of
AxPREs @xmath can be explained as follows. We know, by Definition 3.13 ,
that each @xmath in @xmath defines an AxPRE partition which has positive
classes and a unique empty neighbourhood class. In order for the set
@xmath to define a positive partition, the empty neighbourhood class of
@xmath has to be further partitioned by some @xmath in @xmath . In other
words, when the entire set @xmath is considered, every node that belongs
to the empty neighbourhood of some @xmath also belongs to some positive
class of some @xmath .

###### Example 3.9 (Positive Partition)

Positive partitions play a key role in our framework. This requires a
thorough understanding of the semantics of the AxPREs, and the
partitions they define. We discuss now some particular cases of our
running example of Figure 3.1 .

Let us consider first the AxPRE @xmath , which evaluated on each axis
graph node will produce as many different neighborhoods as there are
different labels in the axis graph (each neighbourhood containing a
single node). Since all nodes with bisimilar neighbourhoods will belong
to the same class, if there are @xmath different labels in the axis
graph the @xmath positive partition will contain @xmath classes (Figure
3.8 shows below each SD node the sets of the partition for our running
example). The same positive partition can be obtained with the set of
expressions @xmath , where @xmath are all the different node labels that
appear in the axis graph. In our running example, the set of expressions
equivalent to @xmath would contain @xmath , @xmath , etc.

Let us consider now the AxPRE @xmath The partition by @xmath is obtained
as follows: for each node in the axis graph, we compute the AxPRE
neighbourhood corresponding to @xmath , and all nodes with bisimilar
neighbourhoods (i.e., all nodes that are @xmath -bisimilar) will belong
to the same class. Thus, the partition will consist of two classes: one
containing all the nodes @xmath such that @xmath which is the set @xmath
(the positive class), and the other one with the remaining nodes (the
empty neighbourhood class). On the other hand, the @xmath partition will
create as many classes as nodes @xmath with labels @xmath exist in
@xmath . In our running example, the @xmath partition will have nine
positive classes (one per label different from “participant”) whereas
all nodes with “participant” label will belong to the empty
neighbourhood class. The two AxPREs @xmath and @xmath , when put
together, define a positive partition with ten classes (one for each
label). @xmath

### 3.3 Describing summaries with AxPREs

In the previous sections, we have introduced the basic machinery we need
to define summary descriptor (SD, for short). An SD is defined from an
axis graph and a set of AxPREs. Intuitively, an SD consists of an axis
graph in which each node has associated an AxPRE and a set in its AxPRE
partition, and whose edges represent axis relationships between those
sets.

###### Definition 3.14 (Summary Descriptor)

Let @xmath @xmath @xmath @xmath be an axis graph of an instance. A
summary descriptor (SD for short) of @xmath is a structure @xmath that
consists of:

-    a set @xmath of AxPREs such that @xmath is a positive partition of
    @xmath by @xmath ;

-    an axis graph @xmath , called SD graph , representing axis
    relationships between nodes in the sets (extents) of the positive
    partition @xmath where:

    -   @xmath is a set of nodes;

    -   @xmath is a set of binary relations @xmath in @xmath such that
        there is a tuple @xmath in @xmath iff @xmath (edges are labeled
        by axis names);

    -   @xmath is the set of node labels from @xmath ;

    -   @xmath is a function that assigns labels in @xmath to nodes in
        @xmath .

-    a bijective function @xmath that assigns AxPREs from @xmath to
    nodes in @xmath ;

-    a bijective function @xmath that assigns a set from the positive
    partition @xmath to each node in @xmath (the set assigned is called
    the extent of the node).

@xmath

An SD has some particular characteristics. The set @xmath uniquely
defines the extents of the SD, and therefore its nodes, for any
particular axis graph instance. In other words, given an axis graph
@xmath and the set @xmath we can create the SD of @xmath by @xmath . On
the other hand, not any set of AxPREs define a positive partition and
thus an SD. The first SDs we can distinguish are those that are defined
by a unique AxPRE from those that have a multi-AxPRE definition. We
denote the former ones as homogeneous SDs because all their nodes are
defined uniformly. Homogeneous SDs are the most common in the summary
literature (e.g., dataguides [ GW97 ] , 1-index [ MS99 ] , ToXin [ RM01
] , A(k)-index [ KSBG02 ] , F&B-Index [ KBNK02 ] , Skeleton [ BCF @xmath
05 ] ). SDs defined by multiple AxPREs are called heterogeneous .

###### Definition 3.15 (Homogeneous and Heterogeneous SDs)

When the extents of all nodes in a SD @xmath are defined with the same
AxPRE @xmath (i.e., @xmath ), we say that the corresponding SD is
homogeneous . In this case we say that @xmath is an @xmath SD. In
contrast, if at least two different nodes are defined with different
AxPREs (i.e., @xmath ) we have a heterogeneous SD. @xmath

###### Proposition 3.1

Given an axis graph @xmath , and a set @xmath of AxPREs. If each @xmath
contains only AxPREs of the form @xmath different from each other, such
that there is an AxPRE for each label in @xmath then @xmath defines an
heterogeneous SD. Such an SD is denoted label SD . @xmath

###### Proof 3.1

It is easy to see that if @xmath contains all the labels in @xmath ,
each AxPRE @xmath will create a positive class labeled @xmath associated
to a different SD node @xmath such that all nodes in @xmath with label
@xmath will belong to the extent of @xmath Since @xmath contains all the
labels in the document, the set @xmath will be a partition of @xmath .
@xmath

Note that we need to know the instance in advance in order to define the
set @xmath accordingly. However, the label SD can also be defined by the
AxPRE @xmath , which makes the label SD homogeneous and its definition
independent of the axis graph. The @xmath SD will produce exactly the
same equivalence classes that the set @xmath of Proposition 3.1 .

###### Example 3.10 (Summary Descriptor)

Figure 3.8 shows a label SD for our running example. Since there are ten
different labels in the axis graph of the instance, there are ten
summary nodes in the label SD. Nodes in the figure are labeled by their
AxPREs, so we are considering a heterogeneous label SD in which @xmath
contains an AxPRE per label. The extent of each node is depicted below
it. Edges represent summary axis relations. For instance, there is an
edge from @xmath to @xmath labeled @xmath because there is a @xmath edge
in the axis graph from node 14 (in the extent of @xmath ) to node 16 (in
the extent of @xmath ).

There are three kinds of edges in the figure, depending on properties of
the sets that participate in the axis relation: dashed, regular, and
bold. Dashed edges, like @xmath with label @xmath , mean that some
element in the extent of @xmath has a child in the extent of @xmath .
Regular edges, like ( @xmath ) with label @xmath , mean that every
element in the extent of @xmath has a first child in the extent of
@xmath . (Since @xmath includes @xmath , we do not draw a @xmath edge
when an @xmath edge exists.) Finally, bold edges, like @xmath with label
@xmath , mean that every element in the extent of @xmath is a first
child of some element in the extent of @xmath and that every element in
the extent of @xmath has a first child in the extent of @xmath The nodes
and edges in the figure constitute the SD graph of the label SD.

Figure 3.9 shows another heterogeneous SD with a different set @xmath
where @xmath , @xmath and @xmath from Figure 3.8 have been replaced by
@xmath , @xmath and @xmath , respectively. @xmath

###### Definition 3.16 (Summary Axis Stability)

Let @xmath be an SD graph edge with label @xmath . We say that @xmath is
an existential edge if @xmath , and a forward-stable edge if @xmath .
@xmath

Definition 3.16 captures the relationship between edges in the SD graph
and the axis graph, and generalizes to several axes the edge stability
representation in XSketch [ PG06b ] . Note that all forward-stable edges
are also existential. In Figures 3.8 and 3.9 , existential edges are
represented by dashed lines and forward-stable edges by solid lines. A
dashed line does not necessarily mean that an edge is not
forward-stable, it might be that stability has not been checked on that
edge (existential edges in Figures 3.8 and 3.9 have been checked and are
not forward-stable). When an edge @xmath and its inverse are both
forward-stable, @xmath is shown in bold lines.

Algorithm 3.1 computes an SD @xmath from an axis graph @xmath and a set
@xmath of AxPREs that define a positive partition of @xmath .
Essentially, the algorithm creates the positive partition in one pass
over @xmath (outer loop spanning steps 2-18). Loop 3-18 computes the
AxPRE neighbourhood of @xmath for each @xmath in @xmath (step 5) in
order to find the @xmath for which the AxPRE neighbourhood of @xmath is
non-empty. Since @xmath defines a positive partition as a precondition,
then for every @xmath there is one and only one @xmath in @xmath such
that @xmath . This guarantees that condition in step 6 is true exactly
once for every @xmath in @xmath .

The next task in the algorithm is to find the extent where @xmath
belongs. Loop 7-11 compares by bisimulation @xmath with every node in
@xmath that has the same AxPRE @xmath . If there is a node @xmath in
@xmath with @xmath but the @xmath neighbourhoods of @xmath and @xmath
are not bisimilar (step 10), then a new node @xmath is created and
@xmath is added to its extent (steps 12-16). The same happens if there
is no @xmath in @xmath with @xmath at all. Since each @xmath in @xmath
may be in an @xmath relationship with nodes in any extent, the final
loop 17-18 checks edge existence (for the input set of axes @xmath )
between the node @xmath such that @xmath and every other node in @xmath
. The result of the algorithm is an SD @xmath where each @xmath in
@xmath has associated a set in the positive partition of @xmath by
@xmath and the axes in @xmath satisfy the conditions in Definition 3.16
.

As shown, loop 2-18 performs @xmath iterations. At any given moment,
there is at most the same number of nodes in @xmath as in @xmath (each
extent having only one node) and all have the same AxPRE. Therefore,
loop 7-11 performs @xmath iterations in the worst case. Each iteration
computes an AxPRE bisimulation (step 10) with time complexity @xmath ,
where @xmath is the total number of tuples (edges) in all axes in @xmath
. The worst case for loop 17-18 is the same as that of loop 7-11, so it
also performs @xmath iterations. Thus, the total time complexity of
Algorithm 3.1 is @xmath .

The notion of an AxPRE neighbourhood can also be defined for an SD
graph, and it is called summary AxPRE neighbourhood of a node. Since an
SD Graph is in fact an axis graph @xmath , for any given SD node @xmath
and AxPRE @xmath we can define its SD graph automaton @xmath (Definition
3.4 ) and intersect it with the AxPRE automaton @xmath (Definition 3.5 )
in order to obtain an AxPRE neighbourhood (Definition 3.7 ) of @xmath .

###### Definition 3.17 (Summary Neighbourhood)

Let @xmath @xmath @xmath @xmath be an SD, axis graph @xmath @xmath
@xmath @xmath its SD graph, @xmath a node in @xmath , @xmath an AxPRE,
and @xmath the intersection automaton of @xmath and @xmath . The summary
neighbourhood of @xmath by @xmath , denoted @xmath is the subgraph of
@xmath as in Definition 3.7 . @xmath

###### Definition 3.18 (Partition Refinement)

Let @xmath @xmath @xmath @xmath be an axis graph. If @xmath and @xmath
are positive partitions of @xmath , @xmath is a partition refinement of
@xmath if every set of @xmath is contained in a set of @xmath . @xmath

###### Definition 3.19 (SD Refinement)

Let @xmath @xmath @xmath @xmath be an axis graph and @xmath and @xmath
be two SDs of @xmath . @xmath is an SD refinement of @xmath if @xmath is
a partition refinement of @xmath . @xmath

###### Proposition 3.2

Let @xmath @xmath @xmath @xmath be an axis graph, @xmath and @xmath be
AxPREs, and @xmath and @xmath be AxPRE partitions of @xmath . If @xmath
is contained in @xmath then @xmath is a refinement of @xmath . @xmath

###### Proof 3.2

(sketch) The proof follows from the notion of AxPRE neighbourhoods. If
@xmath is contained in @xmath then for any given node @xmath , its
@xmath neighbourhood is contained in its @xmath neighbourhood.
Consequently, two nodes that are not distinguished by @xmath (i.e., they
are @xmath -bisimilar) may be distinguished by @xmath , but not the
other way around. This guarantees that @xmath creates either the same
partition as @xmath or a refinement. @xmath

###### Corollary 3.1

Let @xmath @xmath @xmath @xmath be an axis graph and @xmath and @xmath
be two SDs of @xmath . If every @xmath is contained in some @xmath then
@xmath is an SD refinement of @xmath . @xmath

###### Example 3.11 (SD Refinement)

Let us consider the label SD of Figure 3.9 . Recall that in the label
SD, @xmath where @xmath @xmath and @xmath Suppose we want to refine node
@xmath For this node, the partition represented in the figure was
produced by the AxPRE @xmath If we replace this AxPRE by @xmath in
@xmath and apply this set of AxPREs to @xmath , two nodes will be
produced, let us call these nodes @xmath and @xmath with extents @xmath
and @xmath , respectively ( @xmath will not appear because the AxPRE
which produced it was replaced by the new one). This occurs because node
4 in the axis graph has one child (namely interactorRef) while the other
four nodes have two children each (interactorRef and expRoleList). Thus,
applying @xmath we obtain two different AxPRE neighbourhoods, plus the
empty neighbourhood, which is itself partitioned by the remaining
AxPREs.

Analogously, if we want to refine the extent of @xmath further using the
AxPRE @xmath we will replace the AxPRE @xmath by @xmath This will
produce three sets, with extents: @xmath @xmath @xmath

Finally, suppose now that the label SD is defined using @xmath and we
want to refine node @xmath with @xmath In this case, just adding the new
AxPRE does not suffice, because we would not obtain an SD: the union of
positive partitions will not be a partition of @xmath because @xmath
will still produce its own partitions. We solve this adding the AxPRE
@xmath which will produce the remainder of the label SD and will send
all nodes labeled @xmath to the empty neighbourhood class. @xmath

The notions of partition and SD refinement, besides describing the axis
structure of an axis graph, allows us to define a hierarchy of SDs. This
provides the basis for recognizing a lattice among different SDs, where
each node corresponds to a different AxPRE definition. We will show that
this lattice covers all the summaries addressed in the literature, plus
more complex new ones. At the top of this hierarchy (i.e., the coarsest
partition), the empty AxPRE defines a SD where each node is partitioned
by label (as shown in Figure 4.1 ), a typical summary found in the
literature [ CM94 , NUWC97 ] . The bottom of the lattice may vary,
although the finest partition granularity can be represented by the
expression @xmath that produces a partition in which each node in the
axis graph will belong to a different equivalence class.

###### Definition 3.20 (DescribeX Lattice)

A DescribeX lattice with respect to a set of axes @xmath is defined as
follows: each node corresponds to an AxPRE generated by the grammar of
Definition 3.3 when the terminal axis is one of @xmath Also, there is an
edge @xmath in the lattice if and only if the AxPRE of @xmath is
contained in the AxPRE of @xmath @xmath

From Definition 3.20 it follows that the coarsest partition that the
lattice may define is the label SD. The finest partition depends on the
chosen set of axes.

This chapter provided an overview of the DescribeX framework, including
the AxPRE language and some fundamental notions like neighbourhood,
bisimilarity, and summary descriptor (SD). In the next chapter we will
discuss how the DescribeX lattice captures and generalizes many
proposals in the literature.

## Chapter 4 Capturing earlier literature proposals with DescribeX

DescribeX summaries can be classified in a lattice that describes a
refinement relationship between entire summaries (Definition 3.20 ). In
this chapter we revisit some of the related work discussed in Chapter 2
that can be captured in such a lattice by the DescribeX framework.

Figure 4.1 shows a fragment of a DescribeX summary lattice that captures
earlier proposals based on the notion of bisimilarity (in green) and
ad-hoc constructions (in red). Each node in the figure corresponds to a
homogeneous SD defined by an AxPRE. DescribeX not only captures most
summary proposals but also provides a declarative way of defining
entirely new ones: nodes and edges in blue are a sample of the richer
SDs that were never considered in the literature, like the one that
appears in Figure 3.9 ( @xmath ) and in Chapter 8 ( @xmath ).

### 4.1 Bisimilarity-based proposals

The earliest bisimilarity-based summary proposal is the family presented
in [ MS99 ] , which contains a @xmath summary: the 1-index. The 1-index
partition is computed by using bisimulation as the equivalence relation.
The F&B-Index [ KBNK02 ] , is an example of a @xmath SD. The F&B-Index
construction uses bisimulation like the 1-index, but applied to the
edges and their inverses in a recursive procedure until a fix-point.
With this construction, the F&B-Index’s equivalence classes are computed
according to the incoming and outgoing label paths of the nodes. The
same work introduces the F+B-index (a @xmath AxPRE summary constructed
by applying bisimulation to the edges and their inverses only once) and
the BPCI(k,j,m) index (a @xmath AxPRE summary, where @xmath , and @xmath
controls the lengths of the paths and @xmath the iterations of the
bisimulation on the edges and their inverses). The F+B-index and the
F&B-index are BPCI( @xmath ) and BPCI( @xmath ) respectively. The
A(k)-index [ KSBG02 ] is a @xmath AxPRE summary based on @xmath
-bisimilarity (bisimilarity computed for paths of length @xmath ). Thus,
the A(0)-index is a label SD, the A(1)-index is a @xmath SD, the
A(2)-index is a @xmath SD, and the A(h)-index is the @xmath SD. We
discuss some of these proposals in more detail.

Unlike standard definitions in the bisimulation literature [ PT87 ,
DPP04 ] , 1-index, A(k)-index, F&B-index, and BPCI(k,j,m) use a
bisimulation defined backwards in order to capture incoming paths to the
nodes. We provide next a definition of backwards bisimulation and
bisimilarity for completeness. In the literature, the only axes
considered are @xmath and @xmath .

###### Definition 4.1 (Backwards Bisimulation and Bisimilarity)

Let @xmath and @xmath be two rooted subgraphs of an axis graph @xmath
@xmath @xmath @xmath , such that @xmath and @xmath , and let @xmath be
the roots of @xmath and @xmath respectively. A backwards bisimulation
between @xmath and @xmath is a symmetric relation @xmath such that for
all @xmath , @xmath , @xmath , and @xmath : if @xmath then @xmath ; if
@xmath and @xmath , then @xmath and @xmath . Two nodes @xmath , @xmath
are backward bisimilar , in notation @xmath , iff there exist a
backwards bisimulation @xmath between @xmath and @xmath such that @xmath
. @xmath

It is easy to see that the backwards bisimulation is an equivalence
relation. The F&B-Index construction uses backwards bisimulation like
the 1-index, but applied to @xmath and @xmath edges and their inverses.
Algorithm 4.2 computes the equivalence classes for the F&B-Index
according to both incoming and outgoing label paths of the nodes.

###### Proposition 4.1

Let @xmath be an axis graph with @xmath (or @xmath ). The F&B-index of
@xmath is a @xmath SD (or a @xmath SD). @xmath

###### Proof 4.1

The input data graph used in the F&B-index construction (Algorithm 4.2 )
can be viewed as an axis graph with the @xmath axis, in which the
reversed edges of lines @xmath and @xmath correspond to the @xmath axis
(equivalent to a @xmath axis). Therefore, for simplicity, instead of
reversing edges we use an axis graph @xmath with @xmath and take its
inverse when necessary. If id-idrefs are considered, then @xmath .

Let us consider first the case of @xmath . We start with the label SD in
Line @xmath , which is an @xmath SD. Lines @xmath and @xmath are
equivalent to refining all nodes in the initial @xmath SD by the @xmath
AxPRE. This produces a @xmath SD. Then, lines @xmath and @xmath produce
a refinement of all @xmath nodes by the @xmath AxPRE, thus obtaining a
@xmath SD. The iterative process until the fix point can be represented
in our framework as a Kleene closure of the @xmath AxPRE, which yields a
@xmath SD. It is easy to see that AxPRE @xmath produces the same SD as
@xmath (by identity of regular expressions). The remainder of the
algorithm (lines @xmath - @xmath ) creates existential edges like in
Definition 3.16 .

When @xmath , the argument is similar but with AxPREs @xmath and @xmath
instead of @xmath and @xmath , respectively. In this case, the final
AxPRE for the SD is @xmath . @xmath

The notion of k-bisimilarity used in the A(k)-index was defined to
capture incoming paths on @xmath and @xmath edges of length up to @xmath
. We provide next a more general definition for axis graphs that
supports paths on all types of axes.

###### Definition 4.2 (Backwards k-Bisimulation and k-Bisimilarity)

Let @xmath and @xmath be two rooted subgraphs of an axis graph @xmath
@xmath @xmath @xmath , such that @xmath and @xmath , and let @xmath be
the roots of @xmath and @xmath respectively. A backwards k-bisimulation
between @xmath and @xmath is a symmetric relation @xmath such that for
all @xmath , @xmath , @xmath , and @xmath : if @xmath then @xmath ; if
@xmath and @xmath , then @xmath and @xmath . Two nodes @xmath , @xmath
are backward k-bisimilar , in notation @xmath , iff there exist a
backwards k-bisimulation @xmath between @xmath and @xmath such that
@xmath . @xmath

Note that backwards k-bisimilarity defines an equivalence relation on
the nodes in the axis graph. The partition created by the backwards
k-bisimilarity corresponds to the A(k)-index, where @xmath is a
parameter that represents the length of the incoming paths summarized by
the index.

###### Proposition 4.2

Let @xmath be an axis graph with @xmath (or @xmath ). The A(k)-index of
@xmath is a @xmath SD (or a @xmath SD). @xmath

###### Proof 4.2

Consider an axis graph @xmath with @xmath . Two nodes @xmath belong to
the same extent in the @xmath SD iff they are @xmath -bisimilar. In
addition, we know that @xmath iff there exists neighbourhoods @xmath and
@xmath such that @xmath . This means we can define a backwards
k-bisimulation @xmath between @xmath and @xmath such that @xmath and
thus @xmath . @xmath

The BPCI( @xmath )-index is another proposal based on the notion of
backwards k-bisimulation. Algorithm 4.3 constructs a BPCI( @xmath
)-index. Algorithm 4.3 is similar to Algorithm 4.2 but uses @xmath
-bisimilarity for the reversed edges (line 5), @xmath -bisimilarity for
the original edges (line7), and a @xmath number of iterations instead of
a fix point (lines 3 to 7).

###### Proposition 4.3

Let @xmath be an axis graph with @xmath (or @xmath ). The BPCI( @xmath
)-index of @xmath is a @xmath SD (or a @xmath SD). @xmath

###### Proof 4.3

Like for F&B-index construction (Algorithm 4.2 ) the input data graph
@xmath can be viewed as an axis graph with the @xmath axis, in which the
reversed edges correspond to the @xmath (or @xmath ) axis. If id-idrefs
are considered, then @xmath .

Let us consider first the case of @xmath . Lines @xmath and @xmath are
equivalent to refining all nodes in the initial @xmath SD (line 2) by
the @xmath AxPRE. This produces a @xmath SD. Then, lines @xmath and
@xmath produce a refinement of all @xmath nodes by the @xmath AxPRE,
thus obtaining a @xmath SD. The iterative process is repeated @xmath
times, which is equivalent to a @xmath SD. Again, by identity of regular
expressions @xmath is equivalent to as @xmath . The remaining of the
algorithm (lines @xmath - @xmath ) creates existential edges like in
Definition 3.16 . When @xmath , the final AxPRE for the SD is @xmath .
@xmath

The Skeleton summary [ BCF @xmath 05 ] clusters together nodes with the
same subtree structure, thus capturing node ordering in subtrees.
Skeleton uses an entirely different construction approach, but its
essence can be captured by the @xmath AxPRE.

The D(k)-index [ QLO03 ] , and M(k)-index [ HY04 ] are heterogeneous SD
proposals. All nodes @xmath are described by @xmath AxPREs with a
different @xmath per @xmath . They use different construction strategies
based on dynamic query workloads and local similarity (i.e., the length
of each path depends on its location in the XML instance) to determine
the subset of incoming paths to be summarized.

XSketch [ PG06b ] manages summaries capturing many (but not all)
heterogeneous SD’s along the @xmath and @xmath axis, ranging from the
label summary to the F&B-Index. However there is no control over the
refinements chosen, nor a description of the intermediate summaries
obtained. This makes sense given that XSketch objective is to provide
selectivity estimates. As such, its construction algorithm is guided by
heuristics to optimize the space/accuracy trade-off.

### 4.2 Ad-hoc construction proposals

Region inclusion graphs (RIGs) [ CM94 ] and representative objects of
length 1 (1-RO) [ NUWC97 ] are label SDs, that is @xmath SDs (because
all their nodes @xmath are described by the @xmath AxPRE). In general,
representative objects are @xmath SDs for XML tree instances. Therefore,
the 1-RO is a label SD, the 2-RO is a @xmath SD, the 3-RO is a @xmath
SD, and the FRO (full representative object) is the @xmath SD.

Dataguides [ GW97 ] group instance nodes into sets called target sets
according to the label paths from the root they belong to. The dataguide
construction is basically a nondeterministic-to-deterministic automaton
translation. When the data instance is a tree, the dataguide’s target
sets are equivalent to the extents in our framework: a dataguide of an
XML tree is a @xmath SD.

ToXin [ RM01 ] also has a component that can be viewed as an @xmath SD.
ToXin consists of three index structures: the ToXin schema, the path
index, and the value index. The ToXin schema is defined only for tree
instances, and it is equivalent to a @xmath SD graph.

In this chapter, we discussed how DescribeX uses AxPREs to capture many
summary proposals in the literature by providing a declarative
definition for them for the first time. In the next chapter, we will
show how SDs can be declaratively updated by means of two basic
operations, refinement and stabilization applied to neighbourhoods.

## Chapter 5 Describing extents and neighbourhoods

We have seen that several SD nodes can share the same AxPRE @xmath . The
reason for this is that each SD node with the same @xmath corresponds to
a different extent in the @xmath partition. In the first section of this
chapter, we provide mechanisms for describing each extent in the
partition based on neighbourhoods, sets of axis label paths, and AxPREs.

The description provided by a node in the SD can be changed by an
operation that modifies its AxPRE and thus the AxPRE neighbourhood of
the nodes in its extent. When the new AxPRE partition thus obtained
constitutes a refinement of the old one, the operation is called an
AxPRE refinement . The notion of refinement is tightly related to that
of stabilization . An edge stabilization determines the partition of an
extent into two sets based on the participation (total or partial) of
the extent nodes in the axis relation the edge represents. In the second
section of this chapter, we discuss in detail our approaches to
refinement and stabilization based on AxPREs.

### 5.1 Concise descriptions

Since several SD nodes can share the same AxPRE, we need a mechanism for
uniquely describe each SD node and its extent. The most straightforward
way to do that would be just to list all nodes that belong to the extent
(extensional definition). A more concise description is provided by the
@xmath neighbourhood of any node in the extent. Since all nodes in an
extent are bisimilar, any @xmath neighbourhood can be used to find all
the other nodes in the extent by bisimulation.

In order to get the most concise description, we need to find the
smallest (in terms of number of nodes) neighbourhood in the extent of
@xmath that is bisimilar to all the others. We can do this by computing
a bisimulation contraction over all neighbourhoods in the extent of
@xmath . The bisimulation contraction of a given graph is the smallest
graph that is bisimilar to it, which can be computed in time @xmath
(where @xmath is the number of edges and @xmath is the number of nodes)
[ PT87 ] , or even linearly for acyclic graphs [ DPP04 ] . Based on
bisimulation contraction we define the notion of representative
neighbourhood .

###### Definition 5.1 (Representative Neighbourhood)

Let @xmath be an SD and @xmath a node in @xmath such that @xmath . The
representative neighbourhood of @xmath for @xmath denoted @xmath is an
axis graph that is the bisimulation contraction of all neighbourhoods
@xmath , where @xmath . @xmath has a single root node @xmath that is
bisimilar to all @xmath @xmath

Note that the bisimulation contraction is not necessarily one of the
neighbourhoods in the extent – it could be smaller than any of them.
Rather, a representative neighbourhood is an entirely new axis graph
that happens to be the smallest that is bisimilar to all neighbourhoods
in an extent.

###### Example 5.1 (Representative Neighbourhood)

Consider the AxPRE partition of our running example described by AxPRE
@xmath . It has only one set containing nodes @xmath and @xmath , whose
neighbourhoods are shown in Figure 5.1 (a). Its representative
neighbourhood @xmath is the graph shown in Figure 5.1 (b). Note that
such a neighbourhood does not belong to the extent of @xmath (there is
no participantList in the axis graph with only one participant node).
@xmath

For some neighbourhoods, deciding bisimilarity is equivalent to
comparing the sets of simple label paths from their roots to their
leaves. (A path is simple when it has no repeated edges.) In those
cases, neighbourhoods can be described by an extent expression (EE for
short), which is capable of computing precisely the set of elements in
the extent of a given SD node and functions like a virtual view. In
Chapter 6 we provide a mechanism for expressing EEs in XPath.

###### Definition 5.2 (Path and LPath Sets)

Let @xmath be a neighbourhood in an axis graph @xmath , and @xmath a
node in @xmath . We denote by @xmath and @xmath the set of simple axis
paths and simple axis label paths from @xmath , respectively. @xmath

###### Example 5.2

Consider the neighbourhoods of Figure 5.1 (a). The @xmath and @xmath
sets are defined as follows: @xmath , and @xmath @xmath . Note that both
sets include all the prefixes. @xmath

If deciding bisimilarity between a given set of neighbourhoods is
equivalent to comparing their @xmath sets, we say that such
neighbourhoods are LPath distinguishable .

###### Definition 5.3 (LPath Distinguishable)

Let @xmath be neighbourhoods in an axis graph @xmath . We say that
@xmath are LPath distinguishable when, for all @xmath @xmath iff @xmath
. @xmath

Although the axis graph neighbourhoods we have considered so far are all
LPath distinguishable, some combination of axes may produce
neighbourhoods that are not, as illustrated by the next example.

###### Example 5.3 (LPath Distinguishable)

Consider the two acyclic neighbourhoods of Figure 5.2 , which correspond
to nodes 25 and 30 in Figure 3.1 , respectively. Both neighbourhoods
have the same LPath set @xmath . However, it is easy to see they are not
bisimilar: node 33 in neighbourhood (b) has @xmath and @xmath incoming
edges, whereas all @xmath nodes in neighbourhood (a) have either a
@xmath or an @xmath edge, but not both. Thus, they are not LPath
distinguishable.

In contrast, the three cyclic neighbourhoods of Figure 5.1 are all
bisimilar and have the same LPath set @xmath @xmath . Therefore, they
are all LPath distinguishable. @xmath

We are interested in LPath distinguishable neighbourhoods because they
can be described by EEs. In general, determining whether a given set of
neighbourhoods is LPath distinguishable entails computing the
bisimulation between them and then comparing the result to their LPath
sets.

There is a class of neighbourhoods, however, that are guaranteed to be
always LPath distinguishable. For neighbourhoods in that class, we can
bypass the bisimulation computation and obtain the EEs directly from the
LPaths sets. Such is the class of the tree neighbourhoods . How to
characterize other classes of LPath distinguishable neighbourhoods
without resorting to bisimulation remains an open problem.

We will show below that tree neighbourhoods are in fact LPath
distinguishable (Proposition 5.1 ). In order to do that, we need first
some auxiliary results.

###### Lemma 5.1

If two neighbourhoods @xmath and @xmath are bisimilar then there exists
a labeled bisimulation @xmath such that every node in both graphs is in
@xmath . @xmath

###### Proof 5.1

By definition, in order for @xmath and @xmath to be bisimilar @xmath and
@xmath have to be bisimilar, where @xmath and @xmath are the roots of
@xmath and @xmath respectively. Thus, there has to be a labeled
bisimulation @xmath such that @xmath . In addition, all nodes in @xmath
connected to @xmath by an edge with label @xmath have to be in the
labeled bisimulation with all nodes in @xmath connected to @xmath by an
edge with label @xmath (also by definition). This means that every node
connected to either @xmath or @xmath by an edge have to belong to @xmath
. Since every node in @xmath and @xmath is reachable from @xmath and
@xmath respectively, we can prove inductively that every node in both
@xmath and @xmath belong to @xmath . @xmath

###### Corollary 5.1

For all leaves @xmath and @xmath : @xmath iff @xmath . @xmath

###### Proof 5.2

By Definition 3.9 if @xmath then there exist a labeled bisimulation
@xmath between @xmath and @xmath such that @xmath , which means that
@xmath . We need to prove now that leaves having the same label are
bisimilar. It is easy to see from Definition 3.9 that there always
exists a labeled bisimulation between leaves in @xmath and @xmath when
they have the same labels. Consequently, if @xmath then @xmath . @xmath

###### Proposition 5.1

Let @xmath and @xmath be tree neighbourhoods in an axis graph @xmath .
Then, @xmath iff @xmath . @xmath

###### Proof 5.3

We proceed by induction on the length of an arbitrary outgoing path. For
the base case, we have that @xmath and @xmath are leaves of @xmath and
@xmath respectively. By Corollary 5.1 , @xmath iff @xmath . Since they
are leaves, @xmath , so @xmath iff @xmath and @xmath .

For the induction step, consider nodes @xmath and @xmath and all edges
from them with label “ @xmath ”: @xmath , @xmath and @xmath , @xmath .
We know that, if there is a @xmath that is not bisimilar to any @xmath ,
i.e., @xmath , @xmath , @xmath , then by Definition 3.9 @xmath . We need
to prove that the latter statement is equivalent to the following: if
there is a @xmath whose label (or @xmath set) is different from the
label (or @xmath set) of every @xmath , then @xmath .

By inductive hypothesis, @xmath iff @xmath or @xmath . Note that, edges
@xmath and @xmath add prefixes “ @xmath ” and “ @xmath ” to each string
in @xmath and @xmath respectively. For a given node @xmath , let us call
@xmath the set of strings in @xmath prefixed with “ @xmath ”. It is easy
to see that, given any two nodes @xmath and @xmath , if the original set
of string are different @xmath , then the strings with the prefixes are
going to be different @xmath , no matter what the prefixes are. In
addition, if @xmath , we have that @xmath even when @xmath (because the
label of the nodes are included in the prefixes).

Since @xmath contains all label paths from @xmath , in particular it
contains all those that begin with “ @xmath ” ( @xmath ). Similarly,
@xmath . However, if there is a @xmath such that either its label or its
@xmath set is different from those of every @xmath , then @xmath . Since
all label paths in @xmath that are not in @xmath begin with a prefix
different from “ @xmath ”, we conclude @xmath . @xmath

##### Notation.

Let @xmath be a node in an SD @xmath whose extent contains only LPath
distinguishable neighbourhoods. We denote by @xmath and @xmath the set
of all different axis paths and axis label path, respectively, from the
nodes in the extent of @xmath . That is, @xmath , @xmath .

When dealing with @xmath distinguishable neighbourhoods, the @xmath set
can be an alternative way of representing an extent: just compute the
representative neighbourhood @xmath of a given SD node @xmath and then
take @xmath . However, checking containment and equivalence from the
@xmath sets is cumbersome, so we would like to have a way of obtaining
an AxPRE from an @xmath set that provides a concise description of the
representative neighbourhood and thus of all nodes in a given extent. We
will denote this new expression extent AxPRE .

###### Definition 5.4 (Extent AxPRE)

Let @xmath be an SD, @xmath a node in @xmath and @xmath its AxPRE. An
extent AxPRE @xmath of @xmath is an AxPRE such that all nodes in the
extent of @xmath have @xmath neighbourhoods and @xmath is different from
all other extent AxPREs in @xmath . @xmath

It is important to note that extent AxPREs can only be defined when
representative neighbourhoods are not pairwise in an inclusion
relationship. Because of the prefix semantics we use, if for any two
representative neighbourhoods @xmath and @xmath we have that @xmath then
any possible AxPRE for @xmath will also return @xmath , and consequently
it will not be an “extent” AxPRE.

The extent AxPRE of an SD node @xmath can be constructed from the
representative neighbourhood @xmath by taking the label of the root
@xmath of @xmath and concatenating it with the disjunction of the axis
label paths of @xmath . That is, the extent AxPRE @xmath of @xmath is
one of the followings:

-   @xmath if @xmath

-   @xmath if @xmath

-   @xmath if @xmath

It easy to see from the construction that all nodes in the extent of
@xmath will have @xmath neighbourhoods.

###### Example 5.4 (Extent AxPRE)

Consider the two neighbourhoods of Figure 5.3 (a) from our running
example. They are tree @xmath neighbourhoods of elements @xmath and
@xmath , respectively. In this case, the bisimulation contraction of
both neighbourhoods is an axis graph isomorphic to them and appears in
Figure 5.3 (b). Since the label of both nodes @xmath and @xmath is
@xmath , the extent AxPRE begins with the prefix @xmath . In addition,
@xmath @xmath , which means that the AxPRE contains a conjunction of
four subAxPREs, resulting in @xmath @xmath @xmath

According to Definition 3.16 (summary axis stability), forward-stable
edges provide stronger information on the axis relationship that nodes
in their extents satisfy: from a forward-stable edge @xmath labeled
@xmath , we know that all nodes in the extent of @xmath are related by
@xmath to some nodes in the extent of @xmath . Thus, we are particulary
interested in neighbourhoods in which all edges are forward-stable for
their descriptive capabilities.

###### Definition 5.5 (Forward-stable Neighbourhood)

A forward-stable neighbourhood of an SD node @xmath is a neighbourhood
of @xmath with all its edges forward-stable. @xmath

An AxPRE always describes some neighbourhood in an axis graph, either of
an instance or an SD. When an AxPRE describes a forward-stable
neighbourhood in the SD graph, it is called a neighbourhood AxPRE . If
all edges in the @xmath neighbourhood of SD node @xmath are
forward-stable, the extent AxPRE of @xmath can be computed from them
rather than from the axis graph of the instance.

###### Example 5.5 (Neighbourhood AxPRE)

Consider node @xmath in Figure 5.4 . Its current AxPRE is @xmath , which
means that its extent contains only interaction elements. We can infer
from the SD graph an neighbourhood AxPRE as follows. Since edges @xmath
, @xmath , and @xmath are forward-stable, we could write an AxPRE that
expresses those relations, which is @xmath Such an AxPRE tells us that
not only the extent of @xmath contains interaction elements, but more
precisely they also have nested elements such as a participantList with
a nested participant, and an experimentList. @xmath

### 5.2 Refinement and stabilization

The description provided by a node in the SD can be changed by an
operation that modifies its AxPRE and thus its AxPRE neighbourhood. This
operation is called a refinement of an SD node. The refinement of an SD
node can be computed directly by changing the AxPRE of the node
(Algorithm 5.4 ) or by stabilizing a summary neighbourhood for a given
AxPRE (Algorithm 5.8 ). Note that Algorithm 5.4 in fact changes one of
the AxPREs in the definition of the SD, so all nodes that share the
modified AxPRE will be affected.

Previous proposals perform global refinements on the entire SD graph [
KBNK02 , KSBG02 ] or local refinements based on statistics or workload [
QLO03 , HY04 , PG06b ] , without the ability to refine a declaratively
defined neighbourhood. In contrast, using DescribeX we can precisely
characterize the neighbourhood considered for the refinement with an
AxPRE.

DescribeX refinements can also be based on the notion of summary axis
stability (Definition 3.16 ). The goal of this particular refinement
operation is to make all edges of a neighbourhood, given by an AxPRE in
the SD graph, forward-stable. Edges can be stabilized one at a time or
by groups with the same axis. For the former approach,
DescribeX implements two different strategies. If the edge links two
different nodes, then Algorithm 5.5 is invoked. In contrast, if the edge
forms a loop, then Algorithm 5.7 is used. For stabilizing a group of
edges with the same axis from a given node, DescribeX invokes Algorithm
5.6 . All algorithms mentioned above reduce edge stabilization to
refinement: step 1 in each algorithm composes a new AxPRE and step 3
refines the affected nodes by calling Algorithm 5.4 .

The next two examples illustrate how a non forward-stable edge is
stabilized by Algorithms 5.5 and 5.7 , respectively.

###### Example 5.6 (Edge Stabilization)

Consider edge @xmath from Figure 5.5 (a). This edge is not
forward-stable because elements 4 is not related to any node in @xmath
via the @xmath axis (i.e. there is no @xmath edge from 4 to a
expRoleList element in Figure 3.1 ). Edge stabilization (Algorithm 5.5 )
creates two nodes, @xmath and @xmath , such that @xmath and @xmath .
Since @xmath and @xmath (the original AxPREs), then line 1 of Algorithm
5.5 creates the new AxPRE @xmath , which will be used to refine all
nodes with @xmath AxPRE (lines 2 and 3). The new edge @xmath is
forward-stable. The result of stabilizing edge @xmath is shown in Figure
5.5 (b). @xmath

###### Example 5.7 (Edge Unfolding)

Consider the @xmath loop on node @xmath from Figure 5.5 (b). The edge is
not forward-stable because some element in @xmath is not in a @xmath
relation with elements in the same extent (for instance, there is no
element that is the next sibling of 28 in Figure 3.1 ). Since @xmath
(the result of the stabilization performed in Example 5.6 ), then line 1
of Algorithm 5.7 creates the new AxPRE @xmath , which will be used to
refine all nodes with @xmath @xmath AxPRE (lines 2 and 3). The new edges
are forward-stable. The result of unfolding @xmath loop on @xmath is
shown in Figure 5.6 . @xmath

We have now all the building blocks for introducing the neighbourhood
stabilization algorithm, Algorithm 5.8 , which computes a refinement of
the extent of an SD node @xmath for an AxPRE @xmath that results in a
stable @xmath neighbourhood of @xmath . Given an SD node @xmath and an
AxPRE @xmath , Algorithm 5.8 computes an AxPRE partition of the extent
of @xmath for @xmath that is a refinement of the extent of @xmath . This
is achieved by stabilizing the @xmath neighbourhood of @xmath . In order
to stabilize a single edge, Algorithm 5.8 invokes Algorithm 5.5 , for
different nodes, and Algorithm 5.7 , for the same node (loop). Algorithm
5.6 is a variation of Algorithm 5.5 in which all edges labeled with the
same axis are stabilized.

Most of the execution of the neighbourhood stabilization algorithm is
covered by Examples 5.6 and 5.7 . For instance, if we want to stabilize
the @xmath neighbourhood of node @xmath in Figure 5.5 (a), then
Algorithm 5.8 stabilizes edge @xmath , as described in Example 5.6 , and
unfolds edge @xmath labeled @xmath , as described in Example 5.7 . The
resulting stable @xmath neighbourhood is shown in Figure 5.6 .

In this chapter, we discussed how an SD description can be changed by
operations that modify its AxPREs and thus the AxPRE neighbourhoods of
the nodes in their extents. We introduced the two basic
DescribeX operations, AxPRE refinement and stabilization, and provided
algorithms for them. We also gave, for LPath distinguishable
neighbourhoods, a characterization of the extent of an SD node with an
EE. In the next chapter, we discuss the XPath syntax and data model,
together with a novel mechanism for expressing EEs in XPath.

## Chapter 6 Changing descriptions with XPath

We have discussed how to characterize SD nodes and their extents using
different approaches based on neighbourhoods, sets of axis label paths,
and AxPREs. In this chapter, we propose a novel mechanism to
characterize an SD node with an XPath expression [ W3C07 ] whose
evaluation returns exactly the elements in the extent. This expression,
which effectively represents the extent of a given SD node @xmath , is
called extent expression (EE) and is denoted @xmath .

In DescribeX, the extents of any SD node can be precomputed and stored
in a data structure. This approach, which we call materialized extents ,
uses a pointer to every XML element in the collection and therefore it
can be very space consuming. Since the evaluation of an @xmath of a node
@xmath returns the actual extents of @xmath , a more space-efficient
approach is to keep only the EEs. These virtual extents are a compact
representation of the extents, similar to the concept of virtual views.

Since EEs are expressed in XPath, we give first an introduction to the
XPath syntax and data model. The formal semantics definition of the full
language is provided for completeness in Appendix A .

### 6.1 XPath syntax and data model

XPath is a compositional language for selecting element nodes in XML
documents. It is also the dialect that most XML manipulation languages
(e.g., XSLT ¹ ¹ 1 http://www.w3.org/TR/xslt , XPointer ² ² 2
http://www.w3.org/TR/xptr/ , XQuery ³ ³ 3 http://www.w3.org/TR/xquery/ ,
etc.) have in common. In this section we introduce the language
expression grammar and its data model based on axes.

###### Definition 6.1 (XPath Expression Grammar)

Let @xmath be expressions, @xmath , @xmath , @xmath , @xmath be location
paths, @xmath be a node name from the label alphabet @xmath of the axis
graph, @xmath be a relation in @xmath , and @xmath be a place holder for
any of the XPath functions and operators such as @xmath and @xmath , as
well as for context accessing functions @xmath and @xmath . The
following is the grammar for XPath 1.0 expressions:

  -- -------- --
     @xmath   
  -- -------- --

  -- -------- --
     @xmath   
  -- -------- --

  -- -------- --
     @xmath   
  -- -------- --

  -- -------- --
     @xmath   
  -- -------- --

  -- -------- --
     @xmath   
  -- -------- --

  -- -------- --
     @xmath   
  -- -------- --

  -- -------- --
     @xmath   
  -- -------- --

@xmath

The XPath data model includes atomic values, sequences, and a predefined
set of axes for navigating the instance. Like in an axis graph, which is
an abstract representation of the XPath data model, axes define
relationships between nodes in the instance. We provide next a
definition of the XPath axes in terms of @xmath , @xmath , their
inverses and @xmath .

###### Definition 6.2 (XPath Axes)

Given an axis graph @xmath @xmath @xmath @xmath , the XPath axes in
@xmath are defined as follows:

-   @xmath

-   @xmath

-   @xmath

-   @xmath

-   @xmath

-   @xmath - @xmath - @xmath

-   @xmath - @xmath - @xmath

-   @xmath - @xmath - @xmath - @xmath - @xmath

-   @xmath - @xmath - @xmath - @xmath - @xmath

-   @xmath - @xmath

-   @xmath - @xmath @xmath

Whenever it is clear from the context, we use @xmath , @xmath , @xmath ,
@xmath , @xmath , @xmath , @xmath , @xmath , @xmath , @xmath and @xmath
as abbreviations of @xmath , @xmath , @xmath , @xmath , @xmath , @xmath
- @xmath - @xmath , @xmath - @xmath - @xmath , @xmath , @xmath , @xmath
- @xmath and @xmath - @xmath , respectively. @xmath

Note that the @xmath , @xmath , @xmath , @xmath , and @xmath axes from a
given node @xmath partition the nodes in the XML tree. This is
represented graphically by the schema in Figure 6.1 .

Since XML documents are ordered, we need to define a document order
relation on the nodes of an axis graph @xmath .

###### Definition 6.3 (Document Order)

The document order relation @xmath on an axis graph @xmath @xmath @xmath
@xmath is the total order relation given by @xmath , where @xmath and
@xmath are the XPath axes in @xmath from Definition 6.2 . @xmath

Based on the document order relation and its inverse we define next axis
order and axis position .

###### Definition 6.4 (Axis Order)

Let axis graph @xmath @xmath @xmath @xmath be an axis graph. We define
the binary axis order relation @xmath in @xmath as @xmath if @xmath ,
@xmath , @xmath , @xmath , @xmath , @xmath and as @xmath otherwise.
@xmath

Having introduced the XPath syntax and data model, we discuss next how
descriptions are changed in DescribeX using XPath.

### 6.2 Refinement with XPath

Whenever the representative neighbourhood of an SD node @xmath is LPath
distinguishable, it is possible to precisely characterize the extent of
@xmath in terms of the axis label paths in its @xmath set (see Chapter
5.1 ). For this class of neighbourhood, nodes with the same LPath set
are bisimilar (Proposition 5.1 ). Therefore, we propose a mechanism
capable of computing the extent of @xmath based on its @xmath set.

First, we need a few auxiliary results that show how an axis label path
in a given LPath set can be captured by a single XPath expression. We
will show later how to derive EEs from these axis label path
expressions. In order to prove our results, we use the XPath formal
semantics given in Appendix A .

###### Lemma 6.1

Let @xmath be an XPath expression of the form @xmath . If @xmath then
there exists an axis label path @xmath from @xmath . @xmath

###### Proof 6.1

If @xmath , then by semantic rule ( A.1 ) in Figure A.1 there must exist
@xmath such that @xmath @xmath @xmath and @xmath , @xmath . This means
that there is a path from @xmath to @xmath going through edges @xmath
and nodes @xmath such that @xmath is its axis label path. @xmath

###### Lemma 6.2

Let @xmath be an XPath expression of the form @xmath . If @xmath then
there is no axis label path @xmath from @xmath . @xmath

###### Proof 6.2

If @xmath , then by semantic rule ( A.1 ) in Figure A.1 there are no
@xmath such that @xmath and @xmath , @xmath . This means that there is
no path from @xmath to @xmath going through edges @xmath and nodes
@xmath , and thus there is no axis label path @xmath from @xmath .
@xmath

Consider SD node @xmath with AxPRE @xmath . In order to compute the
extent of @xmath we need to get all nodes that have the same @xmath set
and label as @xmath . Therefore, we need to write an XPath expression
@xmath as defined in Lemma 6.1 for each different axis label path @xmath
in @xmath . Then, all @xmath expressions have to be combined in one EE
as follows: @xmath . However, such an expression does not guarantee that
the returned nodes have the exact @xmath LPath set: it only guarantees
containment. That is, @xmath will return all nodes @xmath such that
@xmath . The reason for that is that @xmath says that all @xmath have to
be satisfied, but it does not say they have to be the only ones, which
would be required for equality. The way of circumventing this problem is
by explicitly adding a @xmath predicate for each @xmath that is not in
@xmath .

The problem with this approach is that it would require the explicit
negation of a large number of axis label paths. However, we can
drastically reduce that number by considering only SD nodes that have an
AxPRE @xmath such that @xmath . The intuition is that, if two AxPREs of
SD nodes @xmath and @xmath are not in a containment relationship, then
nodes in their extents cannot have @xmath sets in a containment
relationship either and we do not need to have a @xmath predicate for
them. The following example illustrates how an EE is composed from axis
label paths expressions and @xmath predicates.

###### Example 6.1 (Extent Expressions)

Consider SD nodes @xmath , @xmath , and @xmath from Figure 6.2 . For the
EE of @xmath , we need all axis label paths that are in @xmath but not
in @xmath . The required LPath sets are the following: @xmath , @xmath ,
and @xmath . The final EE will have a positive predicate for each string
in @xmath and a negative one for each string in @xmath . The resulting
expression is @xmath , where @xmath and @xmath are the XPath expressions
of @xmath and @xmath , respectively. @xmath

Note that the EEs resulting from this approach might have redundant
predicates that can be simplified. Consider Example 6.1 for instance: if
a node does not exists, neither does a following sibling for that node,
then the last predicate for @xmath can be removed safely. There are many
other useful simplifications that can be applied to EEs, but a broad
theory of equivalence is beyond the scope of this thesis.

The next proposition shows that the EEs thus constructed return all
nodes that do have the axis label paths specified in the positive
predicates and do not have those in the negative predicates.

###### Proposition 6.1

Let @xmath be an axis graph and @xmath an XPath expression where @xmath
, @xmath . Then, @xmath returns all nodes @xmath such that there exists
@xmath axis label paths from @xmath and there are no @xmath axis label
paths from @xmath , where @xmath @xmath

###### Proof 6.3

  -------- --- -------- --------------------------------------------------------------------------
               @xmath   
           =            by semantic rules ( A.5 ) and ( A.9 ) in Figure A.2
               @xmath   
                        @xmath
           =            since all nodes @xmath are reachable from @xmath , @xmath is always true
               @xmath   
                        @xmath
           =            by semantic rule ( A.4 ) in Figure A.1 with @xmath from Figure A.3
               @xmath   
                        @xmath
           =            by semantic rule ( A.1 ) in Figure A.1
               @xmath   
           =            by Lemmas 6.1 and 6.2
               @xmath   
  @xmath                
  -------- --- -------- --------------------------------------------------------------------------

In some special cases, a more compact XPath expression can be obtained.
For instance, for an expression containing the closure of an axis, like
@xmath , we can enforce that the @xmath ’s expressed by the EE are the
only ones by using the @xmath XPath function. Since the XPath expression
of each @xmath for @xmath contains only compositions of the @xmath axis,
the set of nodes reached by all @xmath ’s and all their substrings are
exactly all the descendants.

###### Example 6.2

Consider the @xmath neighbourhood of nodes @xmath and @xmath in Figure
6.3 . The extents of @xmath and @xmath are @xmath and @xmath ,
respectively. The LPath sets of the nodes are @xmath and @xmath @xmath ,
whereas the EEs are @xmath @xmath and @xmath @xmath @xmath

The next proposition shows, for the special case of @xmath , that the
EEs thus constructed return a set of nodes that do have the axis label
paths specified in the predicates.

###### Proposition 6.2

Let @xmath be an axis graph and @xmath an XPath expression where @xmath
, @xmath . Then, @xmath returns all nodes @xmath such that there exists
only @xmath axis label paths from @xmath of the form @xmath @xmath

For proving Proposition 6.2 we need the following Lemmas.

###### Lemma 6.3

Let @xmath be an XPath expression. For every node @xmath @xmath

###### Lemma 6.4

Let @xmath and @xmath be sets such that @xmath and @xmath for @xmath .
Then @xmath @xmath

Using Lemmas 6.3 and 6.4 we can prove Proposition 6.2 as follows.

###### Proof 6.4

  -------- --- ------------------------------- ----------------------------------------------------------------------------------------------------
               @xmath                          
           =                                   by semantic rules ( A.5 ) and ( A.9 ) in Figure A.2
               @xmath                          
                                               @xmath
           =                                   since all nodes @xmath are reachable from @xmath , @xmath is always true
               @xmath                          
                                               @xmath
           =                                   by semantic rule ( A.4 ) in Figure A.1 with @xmath ’s @xmath , @xmath , and @xmath from Figure A.3
               @xmath                          
           =                                   by semantic rule ( A.1 ) in Figure A.1
               @xmath                          
           =                                   by Lemmas 6.3 and 6.4
               @xmath                          
           =                                   by semantic rule ( A.9 ) in Figure A.1
               @xmath                          
           =                                   since the @xmath ’s are of the form @xmath
               @xmath is an axis path @xmath   
  @xmath                                       
  -------- --- ------------------------------- ----------------------------------------------------------------------------------------------------

### 6.3 Stabilization with XPath

As we have seen in Chapter 5.2 , edge stabilization can be reduced to
node refinement. However, when the EEs of the nodes in an edge are
available, we can use the description provided by the EEs and compute
the stabilization directly from them. The idea is to express the
condition for forward-stability (i.e., @xmath ) of an edge @xmath in
XPath using @xmath and @xmath .

Algorithm 6.9 computes the stabilization of a single edge by updating
the EEs of the nodes in the edge and their extents. The algorithm
replaces node @xmath by two new nodes: @xmath and @xmath . The extent of
@xmath contains all nodes in the extent of the original @xmath that are
in an @xmath relation with nodes in the extent of @xmath (line 2). The
extent of @xmath contains the complement of @xmath with respect to
@xmath , i.e., it contains all nodes that do not have such an @xmath
relation with nodes in the extent of @xmath (line 3). Consequently,
after the new edge is created (line 6), @xmath has a forward-stable
@xmath edge to @xmath whereas @xmath does not have any @xmath edge to
@xmath . The EEs obtained in lines 4 and 5 are the EEs for the new
nodes.

Note that we do not need additional @xmath nor @xmath predicates in the
new expressions because all the required ones are already in @xmath and
@xmath .

###### Example 6.3

Consider edge @xmath from Figure 5.5 (a), which is not forward-stable.
Edge stabilization will create two nodes, @xmath and @xmath as shown in
Figure 5.5 (b). Given that @xmath , @xmath , and the stabilized edge
corresponds to a @xmath axis, the resulting expressions are the
following: @xmath @xmath and @xmath . @xmath

### 6.4 Adapting SDs to XPath queries

Previously in this chapter, we used XPath to express EEs and to
manipulate them for refinement and edge stabilization operations. In
this section we show how XPath queries are used to guide a refinement
operation in the process of adapting an SD to a query.

In order to evaluate a query using an SD, we need to find the SD nodes
that participate in the answer. DescribeX’s approach is to find the SD
nodes that contain a superset of the answer and then evaluate the entire
expression on them to get the exact answer.

One of the central problems for finding a superset of the answer is how
to decide what SD nodes can be used to answer an XPath query. This
requires some sort of XPath matching algorithm and the ability to decide
whether there exists an exact rewriting of a query using an SD. The
matching algorithm will transform the structural subquery of the XPath
expression (the expression that results from removing all non-structural
predicates such as those containing functions) to be evaluated into an
equivalent AxPRE @xmath . Then, we need to find the SD node (or nodes)
whose AxPRE is contained in @xmath . The union of the extents of such
nodes are a superset of the answer. If the query is purely structural
(i.e. the query is equal to its structural subquery) and @xmath is
equivalent to some SD node AxPRE, then the answer to the query is
exactly the union of the extents. Otherwise, we need to run the entire
query on the union of the extents to find the exact answer.

We begin by discussing in the next section how to derive an AxPRE from
an XPath expression.

#### 6.4.1 Deriving AxPREs from queries

DescribeX can adapt an SD node to an XPath query @xmath , as we have
illustrated in our RRS feeds motivating example in Chapter 1.2 . This
section formalizes how an AxPRE is obtained from @xmath by using the two
derivation functions @xmath and @xmath we provide in Figure 6.4 . We
begin by illustrating the XPath-to-AxPRE derivation with a concrete
example.

###### Example 6.4

Consider the following query

Q3 = /ds::participant[c::expRoleList/fc::expRole/ns::expRole]
[not(ds::expRole/names=‘‘prey’’)]

Q3 returns all participants that have expRoleLists whose first two
children are expRole elements and that are not playing the “prey” role
in the experiments. Note that the structural subquery appears in black
(the last predicate in grey is not part of the structural subquery).

The first rule of Figure 6.4 that applies is ( 6.5 ) with the following
variables: @xmath , @xmath , @xmath , @xmath , and @xmath , resulting in

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is a function that translates the XPath axis into its AxPRE
axis counterpart. In particular, @xmath returns the actual AxPRE inverse
(e.g., @xmath is converted into @xmath ) and recursive axes are
translated to an equivalent Kleene closure of non-recursive axes (e.g.,
@xmath translates into @xmath ).

The expansion of @xmath is very simple. The predicate is basically a
function, so it matches rule ( 6.1 ) and the result of @xmath is @xmath
(Remember that this predicate is not part of the structural subquery).
This results in the following intermediate expression

  -- -------- --
     @xmath   
  -- -------- --

For expanding @xmath , the first rule invoked is ( 6.2 ) with @xmath ,
@xmath , @xmath and empty predicates. The intermediate expression is now

  -- -------- --
     @xmath   
  -- -------- --

For expanding @xmath , the rule that applies is ( 6.6 ) with @xmath ,
@xmath , @xmath and no predicates, which results in

  -- -------- --
     @xmath   
  -- -------- --

Similarly, we can expand @xmath and obtain

  -- -------- --
     @xmath   
  -- -------- --

Finally, the node test of the step corresponding to the answer ( @xmath
in this case) is prefixed as a label predicate to the AxPRE. Therefore,
the resulting AxPRE of query @xmath is

  -- -------- --
     @xmath   
  -- -------- --

Once the query AxPRE @xmath of a given XPath query @xmath is computed,
the next step in adapting the SD to @xmath is finding the SD node (or
nodes) whose AxPRE @xmath is contained in @xmath . Since the problem of
AxPRE containment is related to that of regular expression containment,
any regular expression containment algorithm can be used here. After
finding the node, DescribeX proceeds to change @xmath to @xmath , which
in fact modifies the description of the node and thus the neighbourhood
it summarizes. This entails performing a refinement of the extent of the
node.

#### 6.4.2 Finding candidates

If an extent contains a superset of the answer of a query, then we say
that the elements in such an extent are candidate elements . Note that,
by adapting the SD to the structural subquery, DescribeX has found a
restricted superset of the answer and hence has considerably reduced the
search space for computing the entire query.

The DescribeX architecture is tailored to process XML collections one
file-at-a-time, the prevalent data processing model for the Web. Each
file is parsed and processed independently of the other files in the
collection. In this context, after adapting the SD to a given query
@xmath , DescribeX can restrict the evaluation of @xmath to those
documents (called candidate documents ) that are guaranteed to provide a
non-empty answer for the structural subquery of @xmath . Those candidate
documents that do contain an answer for the entire query are called
answer documents .

Once DescribeX has computed the query AxPRE @xmath of a given XPath
query @xmath as described above, it needs to find the SD node whose
AxPRE contains @xmath in order to get the candidate documents for
evaluating @xmath . If there is an SD node @xmath with AxPRE @xmath ,
then all documents in the extent of @xmath are in fact candidate
documents. In contrast, if @xmath has an AxPRE @xmath containing @xmath
, DescribeX has two alternatives. One, it can adapt the SD by refining
@xmath from @xmath to @xmath and then get the candidate documents as in
the previous case. Two, it can get all documents in the extent of @xmath
and run the structural subquery of @xmath on them in order to get the
candidates. Once the candidate documents are found, finding the answer
documents entails running @xmath on all candidates.

###### Example 6.5

Consider query @xmath for our running example. We could evaluate @xmath
using the label SD from Figure 3.8 . In that case, the only node whose
AxPRE is contained in @xmath is @xmath with AxPRE @xmath . For
simplicity, let us assume that every node in the extent of @xmath
belongs to a different document, so there will be as many elements as
documents, both candidates and answer. From the SD graph we know that
not all participants in the extent of @xmath contain an @xmath element
because the edge @xmath is not forward-stable. So we conclude that
@xmath contains only a superset of the answer, so we get the six
documents from the extent and evaluate the query in all of them in order
to get the answer.

Alternatively, we could use the refined SD from Figure 3.9 . This SD
could have been obtained from the label SD after adapting it to @xmath .
Regardless of how the SD was created, we found that three nodes have
AxPREs contained in @xmath : @xmath , @xmath , and @xmath . However, we
notice from the SD graph that only node @xmath has a forward-stable
neighbourhood for @xmath . (Note that it is the only @xmath node with an
edge @xmath , followed by a @xmath and an @xmath , all forward-stable.)
That means that both nodes (and thus documents) in the extent of @xmath
are candidates, and thus we need to run @xmath only in those two
documents. If @xmath did not have the second predicate (in grey), the
extent of @xmath would be the exact answer of @xmath . @xmath

The process of exploring candidates is not unidirectional: a developer
can move back and forth between the query explanations described here
and the structural exploration described in Chapter 1.2 . For instance,
she may create an SD and run a query on some candidate documents. Next,
she might decide to relax the query in order to further investigate its
impact on the collection. Then, she may want to get a more or less
refined description of the collection by changing the SD using AxPRE
refinements, and then start the process again. DescribeX provides the
developer with this interactive functionality for describing and
evaluating XPath queries on large XML collections.

## Chapter 7 DescribeX engine

In previous chapters we introduced DescribeX, a powerful framework
capable of declaratively describing complex structural summaries of XML
collections that captures and generalizes many proposals in the
literature. We also showed how summary descriptors (SDs) are created and
refined to selectively produce more or less detailed descriptions of the
data. In this chapter, we discuss how the DescribeX framework is
implemented in the summarization engine and present two strategies for
refining an SD: one is based on materializing the SD partitions, the
other is a virtual approach that relies on constructing XPath
expressions that compute extents.

The DescribeX architecture is tailored to process XML collections one
file at a time, the prevalent data processing model for the Web. Each
file is parsed, processed and stored before continuing with the next
file in the collection. Such an approach supports the interactive
creation and refinement of AxPRE SDs for large collections of XML
documents.

The DescribeX engine is implemented in Java using Berkeley DB Java
Edition ¹ ¹ 1 http://www.oracle.com/technology/products/berkeley-db/je/
to store and manage indexed collections (tables). The implementation can
invoke an arbitrary JAXP 1.3 ² ² 2 http://jaxp.dev.java.net/1.3/ XPath
processor for the evaluation of XPath expressions. JAXP is an
implementation independent portable API for processing XML with Java.
For the experiments reported later in this paper, the Saxon ³ ³ 3
http://saxon.sourceforge.net/ XPath processor was employed. The Saxon
implementation conforms to the XPath 1.0 standard set by the W3C [ W3C99
] and therefore satisfies the semantic characterization formalized in
Appendix A .

The DescribeX implementation stores the extents in an indexed table
named elemDB that has schema elemDB ( SID , docID , endPos , startPos,
SID2), where the underlined attributes are the key (also used for
indexing). The elemDB table contains a tuple for each XML element in the
collection. Each SD node is identified by a unique id called SID. Each
element belongs to the extent of a unique SD node, whose SID is stored
in the SID attribute. The attribute docID holds the identifier of the
document in which the element appears. The startPos and endPos are the
positions, in the document, where the element starts and ends,
respectively. SID2 allows us to maintain an SID for a second SD.

Alternatively, the user can decide to keep the extents virtual and thus
make the DescribeX engine store a docDB table instead of the elemDB
table described above. The schema of the docDB table is docDB( SID ,
docID ), which contains for each sid @xmath the docIDs of all XML
documents containing elements in the extent of @xmath . This can be used
to efficiently locate the XML documents to be evaluated by the EE of
@xmath in order to get the extent of @xmath . The EEs are stored in a
separate XML file.

A third scenario in which both elemDB and docDB tables coexist is also
possible. In such a case, some SIDs would be kept in the elemDB table
(with their extents materialized) and some others would be stored
without extents in the docDB table. In this thesis we have not studied
the trade offs emerging from this scenario.

The DescribeX engine keeps the SD graph in main memory in separate hash
tables for each axis relation in the SD, e.g. the parentsMap and
childrenMap maps contain the edge definitions for the @xmath and @xmath
SD axes respectively. In other words, each binary @xmath relation is
stored as a map between a key SID @xmath and a set of SIDs @xmath such
that @xmath , @xmath . In addition, there is a label map, labelMap, that
contains the label of each SD node.

### 7.1 Initial SD construction

Some SDs can be constructed in one pass over the collection. This is
possible when the parsing information collected at either the start tag
or the end tag of an element @xmath is enough to construct the AxPRE
neighbourhood @xmath of the element, compute the AxPRE partition and
thus decide to what extent @xmath belongs. For instance, the start tag
itself is enough to classify an element @xmath when constructing the
@xmath SD (the @xmath contains just node @xmath ). For the @xmath and
@xmath SDs, it suffices to keep the sequence of the last @xmath open
elements (for the @xmath ) or all of them (for the @xmath ) for creating
@xmath and @xmath . Thus, @xmath and @xmath SDs can also be constructed
in one pass over the collection.

Algorithm 7.10 (buildP(k)) illustrates the use of the DescribeX data
structures. The algorithm computes the @xmath , @xmath and @xmath SDs.
The parameter @xmath encodes the SD as follows: @xmath corresponds to
@xmath , @xmath to @xmath , and all other values represent @xmath . For
each XML document in the collection, the algorithm parses the document
and creates a XOM ⁴ ⁴ 4 http://www.xom.nu/ tree (a lightweight XML
object model). The algorithm uses the XOM tree created for composing the
elemDB tuple of each element in the document containing SID, docID, and
its beginning and end offset position. Both the XOM tree and the SD are
constructed simultaneously during parsing time.

Once an SD has been constructed from scratch, the user can refine any SD
node or set of nodes by changing the node’s AxPRE, as described in
Chapter 5 . In the next section we provide algorithms for computing such
refinements.

### 7.2 Computing refinements

Following the materialized extents approach, a refinement can be
evaluated with Algorithm 7.11 (refineMaterialized), whereas virtual
extents can be refined by Algorithm 7.12 (refineVirtual). Both
algorithms are invoked with sid @xmath to be refined, its current EE
@xmath , and a family @xmath of refining EEs, constructed as described
in Chapter 6.3 .

Suppose that SD node @xmath with EE @xmath is one of the refinements of
SD node @xmath with EE @xmath . The extent of @xmath is computed by
evaluating @xmath on the set of documents that contain elements in the
extent of @xmath , which entails evaluating the expression @xmath (line
6 of Algorithms 7.12 (refineVirtual) and 7.11 (refineMaterialized). This
set of documents are obtained from ElemDB (if the extent of @xmath is
materialized) or from docDB (if the extent of @xmath is virtual). Once
we have the extent of @xmath , the edges in the SD graph can be
constructed either from the EE when the extent is virtual (by
computeEdgeByXPath, line 10 of Algorithm refineVirtual) or from ElemDB
when the extent is materialized (by computeEdgeByMerge, line 13 of
Algorithm refineMaterialized).

In order to update the edges, we need to check whether there is an
@xmath edge between @xmath and a set of candidate SD nodes @xmath such
that @xmath . This is performed by Algorithm 7.13 (computeEdgeByXPath)
by computing the expression @xmath , where @xmath is the EE of candidate
@xmath (line 4). If the evaluation of the expression is not empty, then
there exists an edge from @xmath to @xmath , otherwise there is no edge
(lines 5 and 6).

Algorithm computeEdgeByMerge (not shown), in contrast, simply computes a
merge of the ElemDB using the startPos and endPos attributes to check
for containment (in case of @xmath , @xmath , @xmath , @xmath , and
@xmath axes) or precedence (for @xmath , @xmath , @xmath , and @xmath
axes).

In this chapter, we presented an implementation of the
DescribeX framework that supports the interactive creation and
refinement/stabilization of AxPRE SDs for XML collections. We introduced
two strategies for locally updating an SD: one based on materializing
the SD partitions (extents), the other relies on a novel virtual
approach based on XPath expressions. The next chapter presents
experimental results that demonstrate the scalability of our strategies,
even to multi gigabyte web collections.

## Chapter 8 Experimental results

We present here the results of an extensive empirical study we conducted
using the DescribeX framework introduced in this thesis.

The first part of our study evaluates the performance of the initial SD
construction and the feasibility of the different approaches
(materialized, virtual, edges, etc.) to DescribeX main exploration
operations: refinement and stabilization. The objective here is twofold.
First, to understand how key parameters (e.g., extent size, number of
documents involved, and number of SD nodes and edges affected) impact on
each operation. Second, to determine what method performs better under
what kind of conditions.

The goal of the second part of our experimental evaluation is to study
the impact of various summaries on XPath query processing performance.
This part also provides a comparison with variations of incoming and
outgoing path summaries capturing existing proposals like 1-index, APEX,
A(k)-index, D(k)-index, and F+B-Index. We want to emphasize that query
evaluation times on collections the size of Wikipedia are rarely
reported in the literature. In fact, XML DB systems (and not just
research prototypes) become challenged when working with collections at
this scale. The experiments demonstrate that DescribeX easily scales up
to gigabyte sized XML collections with important performance results.

### 8.1 Initial SD construction

Our experiments were conducted over four collections of documents. Table
8.1 summarizes the size and number of documents in each collection, and
the number of nodes and load times for the @xmath and label SDs, which
includes computing the SD graph and the partitions, and storing the
extents in the ElemDB table.

For measuring times, we conducted five separate runs starting with a
cold Java Virtual Machine (JVM) for each query. The best and worst times
were ignored and the reported runtime is the average of the remaining
three times. The experiments were carried out on a Windows XP machine
with a 2.4GHz Intel Core 2 Quad processor, and the JVM was allocated
1 GB of RAM.

The selected collections have different characteristics, namely total
size, size and number of individual documents, and document
heterogeneity. The first collection (RSS2) was obtained by collecting
RSS feeds from thousands of different sites. The second collection
(PSIMI2) is a fragment of the IntAct PSI-MI dataset ¹ ¹ 1
http://psidev.sourceforge.net/mi/xml/doc/user/ . The third and fourth
collections (Wiki5 and Wiki45, respectively) were created from the
Wikipedia XML Corpus provided in INEX 2006 [ DG06 ] . PSIMI2 is a very
small collection in terms of number of documents (only 156 in total) but
a medium-sized collection with respect to total size (about 234 MB). In
contrast, Wiki5 is about twice the PSIMI2 size but has almost 200 times
the number of documents. Consequently, the average document size in both
collections ranges from 1.5 MB in PSIMI2 to 18 KB in Wiki 5. Documents
in RSS2 are similar in size to Wiki5. The largest collection (Wiki45
with 4.5GB spanning 660 thousand files) is also the one with the
smallest average document size (only 6.8 KB).

The number of nodes in both @xmath and label SDs provide a measure of
heterogeneity and structural complexity. PSIMI2 is the most homogeneous
of our collections, with only 54 different element names and 199
different label paths from the root. In contrasts, the most heterogenous
one is Wiki45 with over one thousand different labels and over 66
thousand different label paths from the root.

### 8.2 Refinements

We tested the performance of two types of SD updates: refinements and
stabilization. In this section we discuss the results for refinements
and we provide the stabilization results in the next one.

Tables 8.2 , 8.3 and 8.4 show the SIDs and EEs of the selected @xmath SD
nodes in our test collections. These are the nodes we use for
refinements and edge stabilization in our experiments reported below.
For instance, @xmath corresponds to the @xmath SD node that has
/rss/channel/image as its EE in the RSS2 collection. Our benchmark
refinements were selected with scalability in mind: smallest and largest
extents and number of documents involved are three orders of magnitude
apart, ranging from 4 documents in the @xmath refinement (Table 8.6 ) to
6509 documents in the @xmath refinement (Table 8.5 ).

We evaluated two different types of refinements, one given by a generic
AxPRE ( @xmath ) and the other defined by a very specific one. Tables
8.5 through 8.8 report @xmath refinement times for the selected SD
nodes. We choose the @xmath refinement to show the performance with
AxPREs involving common axes used throughout the summary literature.

Tables 8.5 through 8.8 are divided into two parts, the first half
provides information on the number of documents and elements in the
extent of the @xmath SD nodes being refined ( # Docs and # Elems
columns, respectively) , and the second half contains numbers relative
to the @xmath refinement itself. The numbers under # Docs indicate how
many documents need to be opened to evaluate the refinement. The number
of new SD nodes created by the refinements (which is the same as the
number of EEs evaluated) are reported in the # EEs columns. For
instance, the @xmath refinement partitions node @xmath into 201 new SD
nodes, which means that 201 XPath expressions have to be evaluated in
6509 documents in order to obtain the @xmath of node @xmath . In
general, refinement times increase proportionally to the number of
documents that need to be opened for computing the refinement.

We consider two scenarios, one in which extents are materialized in the
ElemDB table (reported under columns V , M and P ), and another in which
the extents are virtual and are thus represented only by the EEs
(reported under columns X ). Times reported in V , M and P columns
comprise locating the affected files using the SD, opening them and
evaluating the EE in order to update the materialized extent information
in the ElemDB table. In addition to extent updates, columns V and M
times include edge computations using Algorithms 7.12 and 7.11 ,
respectively. (The labels V and M , which stand for ‘‘virtual’’ and
‘‘materialized’’, refers only to the different approaches to edge
computation). In contrast, times under the P column correspond to extent
computation only (without edges). Comparing column P against columns V
and M gives us an idea of how much overhead DescribeX incurs on the
edges. Finally, the X column displays how long it takes just to obtain
the expressions for both edges and extents under the virtual approach.
Thus, the X column corresponds to a ‘‘purely virtual’’ approach in which
no materialization is used for either edges nor extents. Since edges are
computed from the EEs, the SD graph is still maintained.

The time differences between the V and M columns come from the fact that
computing the edges between the new SD nodes using XPath is usually more
costly than computing them from the information stored in the ElemDB
table. However, we are not aware of any technique for computing general
XPath expressions from the region encodings in the ElemDB table, so
using just the materialized extents is not always possible.

Tables 8.9 through 8.12 report refinements that were chosen to study SDs
involving novel axes (e.g., @xmath , @xmath , @xmath ) and more
expressive AxPREs with label predicates. The tables show the refining
AxPRE for each @xmath SD node, the number of documents and elements that
contain neighbourhoods matching the entire AxPRE ( # Docs and # Elems
columns, respectively), together with how long it takes to compute the
extent ( Times column). For any given expression, the number of elements
with either empty neighbourhoods or matching prefixes of the AxPRE is
the complement of the number reported under # Elems . For instance, the
@xmath row of Table 8.9 indicates that 37 elements in 9 documents have
exact @xmath neighbourhoods and obtaining them from the @xmath extent
takes 10.8 seconds. In addition, we know that the number of elements
either matching prefixes or with empty neighbourhoods is 90546, which
comes from the number in column # Elems and row @xmath in Table 8.5
(90583) minus the number in column # Elems and row @xmath in Table 8.9
(37). Such subtraction would not be meaningful for the # Docs columns
because the same document may contain elements in different extents
(remember that an SD contains a partition of elements, not documents, so
document extents may overlap).

These results suggest that, even though computing generic refinements
like @xmath may be expensive, more specific refinements can be performed
in less than a minute and many of them in just a few seconds for the
smaller test collections.

### 8.3 Edge stabilization

In this section, we report experimental results for stabilization of SD
edges from our selected @xmath nodes.

Tables 8.13 through 8.16 report edge stabilization times and extent
sizes for the selected SD nodes. The edge stabilized is indicated in the
tables by an AxPRE containing the axis and the label of the target node.
The four Resulting Extents columns show the number of document and
elements that do contain the edge and the number of those that do not.
The times reported under columns V and M correspond to the materialized
extent approach with edge computation using EEs (the former) and the
ElemDB table (the latter), as explained in the previous section for
refinements.

We stabilize two different edges for some @xmath SD nodes. After one
edge stabilization, the resulting SD node that does not have the
stabilized edge is indicated by the SID with an apostrophe. The second
edge stabilized always corresponds to a node with an apostrophe from the
previous stabilization. For instance, the first edge stabilized from
node @xmath (Table 8.13 ) was the @xmath edge to an @xmath node, which
resulted in two SD nodes: one containing a stable @xmath edge with 84063
elements in its extent, and another one ( @xmath ) with no edge and 6520
elements. From node @xmath we stabilize then the @xmath edge to a @xmath
node obtaining again two nodes: one with a stable @xmath edge with 15
elements in its extent, and the other one with 6505 elements and no
edge. The time for computing the @xmath edge stabilization is 12.5
seconds when computing the edges with EEs, and 2.9 seconds when using
the ElemDB table. The times for the @xmath edge stabilization are 10.9
and 3.7 seconds respectively.

Our results show that DescribeX can provide interactive response times
(from sub second to just a few seconds) for all edge stabilizations
tested when using the materialized approach for both extents and edges.
Moreover, when using the more expensive EE-based approach for finding
the SD edges, we still obtain response times in the order of a minute in
the vast majority of test cases. This is compelling evidence that
DescribeX can be used in scenarios in which SDs need to be manipulated
interactively in order to selectively explore the structure of an XML
collection (e.g., aggregating thousands of RSS feed from dozens of
content providers).

### 8.4 XPath query evaluation using SDs

In this section, we provide performance results for obtaining answer
documents for several XPath queries using a variety of SDs. These
results considerably expand the preliminary study presented in [ CR07 ]
.

Tables 8.17 , 8.18 , and 8.19 show the twelve queries in our benchmark
(the structural subqueries appear in black, the non-structural
predicates are in grey). These queries were selected to show how the
system scales with respect to key query parameters like answer size and
number of candidate documents (those that provide a non-empty answer for
the structural subquery). Our benchmark focuses on the navigational
features of XPath, following the approach of the MemBeR XQuery
Micro-Benchmark [ AMM05 ] , which provides a form of standardization for
studying XQuery evaluation.

Tables 8.20 through 8.23 show the times for obtaining the answer
documents and evaluating the queries in our collections using a variety
of SDs. The SD column indicates the type of SD used to obtain the
candidate documents (next column) on which the entire query is
evaluated. The three columns under Answer show the time it takes to
evaluate the query in the candidate documents, and the number of
documents and elements in the final answer. Since these are XPath
queries, the number of documents and elements returned by each query are
independent of the SD used for evaluation.

Each row of SD , # Candidate Docs and Times corresponds to a different
SD used for evaluating the query. The ‘‘label’’ row in each section
shows the evaluation times when using the label SD node corresponding to
the element returned by the query. For instance, query R2 returns
‘‘item’’ elements, so the extent documents used are those from the
‘‘item’’ node in the label SD (8122 documents in total), taking 19.9
seconds to evaluate the query on them. The @xmath rows report the
respective numbers when using the @xmath node whose AxPRE contains the
query (note that the SIDs from Tables 8.2 , 8.3 , and 8.4 are
indicated). For instance, for query R2 we use node @xmath from the
@xmath SD, taking 15.1 seconds to evaluate the query on the 6509
documents in the extent of @xmath . Similarly, @xmath rows show the
evaluation times when using @xmath SD nodes (there may be more than one
containing the query). For instance, the @xmath node(s) used for query
R2 have 181 documents and evaluating R2 on them takes 1.2 seconds.
Finally, the last row in each section labeled ‘‘specific’’ shows
DescribeX performance when using an AxPRE refinement obtained from the
structural subquery. For instance, for query R2 the refining AxPRE would
be @xmath (row @xmath in Table 8.9 ) which has 9 documents in its extent
and evaluating R2 on them takes just 0.1 seconds. This is the AxPRE we
obtain by adapting the SD to R2.

Not surprisingly, our results indicate that query evaluation performance
gains are heavily dependant on both the query and the collection. In
some cases, just having the label SD is description enough and provides
good performance, whereas the label SD is not of much help in others.
For instance, using the most specific SD for PSIMI2 query P4 (Table 8.21
) only reduces query evaluation time by less than 50% over the label SD.
At the other end of the spectrum, using the most specific SD for query
W1 on Wiki45 (Table 8.23 ) produces a performance improvement of almost
four orders of magnitude, going from half an hour (label SD) to
sub-second (specific SD) evaluation time. In that same table, there are
also cases (like query W3) in which a @xmath by itself provides a big
gain, whereas the most specific SD only brings a modest further
improvement. In contrast, query W4 gets the greatest gain from the most
specific SD (over two orders of magnitude against both the @xmath and
the @xmath SDs).

These results show that, even though creating the most refined SD is not
always valuable, having the right SD for the right query does have an
important impact on the overall performance, and DescribeX provides a
powerful mechanism for defining and creating them.

#### 8.4.1 Comparison with summary proposals

The results in Tables 8.20 through 8.23 also provide a comparison with
the summary literature. Proposals like 1-index [ MS99 ] , APEX [ CMS02 ]
, A(k)-index [ KSBG02 ] , and D(k)-index [ QLO03 ] can provide, at best,
a description equivalent to the @xmath SD and thus a similar performance
to that reported on the first row of each query. The @xmath rows give an
indication of the performance provided by the F+B-Index [ KBNK02 ] .
DescribeX can create SDs tailored to a workload that yield query
evaluation times one to three orders of magnitude faster than these
proposals (last row of each query). Using a precise SD can have a
significant impact on both candidate and answer documents selection, and
thus on overall query evaluation. Note that no summary in the literature
(even recent proposals that cluster together nodes with the same subtree
structure [ BCF @xmath 05 ] ) can capture AxPREs such as @xmath or
@xmath .

In addition, we compared DescribeX’s initial construction time against
an open-source XML summarization tool, XSum [ ABMP08 ] , which
constructs an annotated @xmath SD graph (a dataguide). Table 8.24 shows
comparable results for SD graph construction times between DescribeX and
XSum. We restricted the comparison to SD graph construction times
because XSum does not store either the materialized extents or the EEs;
it only creates a @xmath SD graph. To the best of our knowledge, this is
the only structural summarization system publicly available. Moreover,
no other work in the extensive literature on summaries [ GW97 , MS99 ,
KBNK02 , KSBG02 , QLO03 , BCF @xmath 05 , PG06b ] reports construction
times for their systems.

Since XSum can only summarize individual files, we were not able to test
it with our benchmark collections. Thus, we decided to do the
comparative evaluation using the XMark benchmark [ BCF @xmath 03 ] ,
which creates one single file of a chosen size.

These results show that DescribeX provides SD graph construction times
comparable to an open-source structural summarization tool that is
tailored to only one particular kind of SD ( @xmath ).

#### 8.4.2 Comparison with XPath evaluators

We performed a comparative analysis against two DB systems, one
commercial (X-Hive/DB ² ² 2 http://www.x-hive.com/products/db/ ), and
the other one open source (XQuest DB ³ ³ 3 http://www.axyana.com/xquest/
). X-Hive/DB and XQuest DB were selected because of their good
performance in published XQuery benchmarks [ AFM06 ] . In addition, a
comparison against a Saxon ⁴ ⁴ 4 http://saxon.sourceforge.net/
evaluation without summaries is provided. Saxon was selected for being a
popular processor that can also evaluate XQuery and XSLT in a
file-at-a-time fashion. Saxon is the XPath processor integrated in the
DescribeX’ default implementation (see Chapter 7 ), but for this
comparison we use the XPath processor stand-alone.

Keep in mind that the selected DB-like XML processors may have
additional functionality (such as transaction processing capabilities).
The comparison aims to show that the DescribeX architecture with the
default implementation (combining summaries with Saxon) can achieve
results competitive with that of XML indexing engines, even with
gigabyte sized collections. In addition, comparing against Saxon
provides a performance base line for a file-at-a-time evaluation when
the collection is stored as XML text files in the file system and no
summary structures are available. The results confirm that, without
summaries, Saxon itself lags by several orders of magnitude. We also
tried to run our queries on DB2 v9 ⁵ ⁵ 5
http://www-306.ibm.com/software/data/db2/9/ , but the version we
currently have does not support following-sibling or preceding-sibling
axes, so our benchmark queries could not be run on DB2.

Tables 8.25 and 8.26 report the times for selecting answer documents
using DescribeX, X-Hive/DB , XQuest DB , and Saxon (without summaries)
on the RSS2 and Wiki5 collections, respectively. Comparative times for
Wiki45 are not reported because neither XHive/DB nor XQuest DB could
load the entire collection. XQuest DB returned an incorrect answer for
some of the queries, which are marked with an asterisk. DescribeX times
span selecting the answer documents and evaluating the entire query
using the most refined SD (i.e., the ‘‘specific’’ AxPRE refinements
reported in Tables 8.20 , 8.21 , and 8.22 ). These times are obtained by
adding up the times for getting the candidate documents and the times
for evaluating the entire query on them (using Saxon).

The extensive empirical study presented here shows that DescribeX’s
file-at-a-time XPath evaluation architecture can be a competitive
alternative (in terms of query response times) to DB-like XML query
engines, even on gigabyte sized collections. Our experimental results
also demonstrate that DescribeX’s powerful mechanism for adapting
summaries to a workload can provide speedups of one to three orders of
magnitude compared to other proposals.

## Chapter 9 Conclusion

This thesis focuses on addressing the need to describe the actual
heterogeneous structure of web collections of XML documents.
Understanding the metadata structure of such collections is fundamental
for writing meaningful XPath queries and evaluating them efficiently. We
propose a novel framework for describing the structure of a web
collection based on highly customizable summaries that can be
conveniently tailored by axis paths regular expressions (AxPREs).

Our main results demonstrate the scalability of the AxPRE summary
refinement and stabilization (the key enablers for tailoring summaries)
using gigabyte XML collections. In addition, DescribeX’s powerful
mechanism for adapting summaries to a workload can provide speedups of
one to three orders of magnitude compared to other proposals. The
experiments also show that DescribeX’s file-at-a-time XPath evaluation
architecture (supporting fast evaluation of complex XPath workloads over
large web document collections) can be a very competitive alternative
(in terms of query response times) to DB-like XML query engines, even on
gigabyte sized collections.

Familiar research issues can be re-visited in the context of AxPRE
summaries, such as providing guidelines for selecting good summaries
(similar to schema design) and inferring general and succinct AxPRE
expressions from an XML collection (similar to DTD inference from
instances). Developing tools for metadata management is also addressed
by a recent schema summarization proposal [ YJ06 ] . In this direction,
creating summaries that describe how metadata labels (including some
generated using schema abstraction and summarization techniques) are
used in a given instance seems promising.

In the context of XML messaging, we came across the problem of doing
schema mapping when the schemas are too general and only very small
subsets are normally used. The schema mapping problem consists of
defining correspondences between two schemas in order to translate data
from one to the other [ PVM @xmath 02 ] . If we need to define a
complete mapping between two very lax, broad schemas, we will end up
with a large number of correspondences that are irrelevant for any
single instance. An interesting research direction would be to develop a
strategy to do summary mapping in the same spirit of schema mapping,
perhaps using EEs definitions to create the correspondences in XPath.
Another option would be to use DescribeX summaries to determine what
schema elements do not apply to a given collection and then only define
correspondences for those elements that are actually used. This would
significantly reduce the number of correspondences needed to define a
meaningful mapping hence simplifying the overall data translation
process.

The notion of bisimulation originated in fields other than databases
(concurrency theory, verification, modal logic, set theory), where it
continues to find applications. It would be interesting to explore
whether the more flexible notion introduced in this thesis (selective
bisimilarity applied to subgraphs described by AxPREs) can also find
novel applications in such areas.

Since this XPath-to-AxPRE syntactic translation can be applied to any
XPath query, it can also be used to translate XPlainer queries [ CLR07 ]
to AxPREs. XPlainer expressions have the same syntax as XPath but a
different semantics which provides an explanation in the form of the
intermediate nodes, a kind of data provenance of the answer.

Open research issues also include creating AxPREs for the
XPlainer expressions of a query, so that DescribeX can adapt SDs to
accelerate the retrieval of intermediate nodes. In addition, we plan to
study the impact of adjusting the workload (e.g, by finding frequent
patterns), and also how to optimize SD selection given budget
constraints. There are also opportunities for exploiting the flexibility
available in AxPRE summaries in the context of the more traditional
summary applications to indexing, selectivity estimation, and query
optimization.