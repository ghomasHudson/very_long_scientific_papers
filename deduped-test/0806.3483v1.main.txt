##### Contents

-    I Introduction
    -    1 Quantum cryptography
        -    1.1 Introduction
        -    1.2 Setting the state
            -    1.2.1 Terminology
            -    1.2.2 Assumptions
            -    1.2.3 Quantum properties
        -    1.3 Primitives
            -    1.3.1 Bit commitment
            -    1.3.2 Secure function evaluation
            -    1.3.3 Secret sharing
            -    1.3.4 Anonymous transmissions
            -    1.3.5 Other protocols
        -    1.4 Challenges
        -    1.5 Conclusion
-    II Information in quantum states
    -    2 Introduction
        -    2.1 Quantum mechanics
            -    2.1.1 Quantum states
            -    2.1.2 Multipartite systems
            -    2.1.3 Quantum operations
        -    2.2 Distinguishability
        -    2.3 Information measures
            -    2.3.1 Classical
            -    2.3.2 Quantum
        -    2.4 Mutually unbiased bases
            -    2.4.1 Latin squares
            -    2.4.2 Generalized Pauli matrices
        -    2.5 Conclusion
    -    3 State discrimination with post-measurement information
        -    3.1 Introduction
            -    3.1.1 Outline
            -    3.1.2 Related work
        -    3.2 Preliminaries
            -    3.2.1 Notation and tools
            -    3.2.2 Definitions
            -    3.2.3 A trivial bound: guessing the basis
        -    3.3 No post-measurement information
            -    3.3.1 Two simple examples
            -    3.3.2 An upper bound for all Boolean functions
            -    3.3.3 AND function
            -    3.3.4 XOR function
        -    3.4 Using post-measurement information
            -    3.4.1 A lower bound for balanced functions
            -    3.4.2 Optimal bounds for the AND and XOR function
        -    3.5 Using post-measurement information and quantum memory
            -    3.5.1 An algebraic framework for perfect prediction
            -    3.5.2 Using two bases
            -    3.5.3 Using three bases
        -    3.6 Conclusion
    -    4 Uncertainty relations
        -    4.1 Introduction
        -    4.2 Limitations of mutually unbiased bases
            -    4.2.1 MUBs in square dimensions
            -    4.2.2 MUBs based on Latin squares
            -    4.2.3 Using a full set of MUBs
        -    4.3 Good uncertainty relations
            -    4.3.1 Preliminaries
            -    4.3.2 A meta-uncertainty relation
            -    4.3.3 Entropic uncertainty relations
        -    4.4 Conclusion
    -    5 Locking classical information
        -    5.1 Introduction
            -    5.1.1 A locking protocol
            -    5.1.2 Locking and uncertainty relations
        -    5.2 Locking using mutually unbiased bases
            -    5.2.1 An example
            -    5.2.2 MUBs from generalized Pauli matrices
            -    5.2.3 MUBs from Latin squares
        -    5.3 Conclusion
-    III Entanglement
    -    6 Introduction
        -    6.1 Introduction
            -    6.1.1 Bell’s inequality
            -    6.1.2 Tsirelson’s bound
        -    6.2 Setting the stage
            -    6.2.1 Entangled states
            -    6.2.2 Other Bell inequalities
            -    6.2.3 Non-local games
        -    6.3 Observations
            -    6.3.1 Simple structural observations
            -    6.3.2 Vectorizing measurements
        -    6.4 The use of post-measurement information
        -    6.5 Conclusion
    -    7 Finding optimal quantum strategies
        -    7.1 Introduction
        -    7.2 A simple example: Tsirelson’s bound
        -    7.3 The generalized CHSH inequality
        -    7.4 General approach and its applications
            -    7.4.1 General approach
            -    7.4.2 Applications
        -    7.5 Conclusion
    -    8 Bounding entanglement in NL-games
        -    8.1 Introduction
        -    8.2 Preliminaries
            -    8.2.1 Random access codes
            -    8.2.2 Non-local games and state discrimination
        -    8.3 A lower bound
        -    8.4 Upper bounds
        -    8.5 Conclusion
    -    9 Interactive Proof Systems
        -    9.1 Introduction
            -    9.1.1 Classical interactive proof systems
            -    9.1.2 Quantum multi-prover interactive proof systems
        -    9.2 Proof systems and non-local games
            -    9.2.1 Non-local games
            -    9.2.2 Multiple classical provers
            -    9.2.3 A single quantum prover
        -    9.3 Simulating two classical provers with one quantum
            prover
        -    9.4 Conclusion
-    IV Consequences for Crytography
    -    10 Limitations
        -    10.1 Introduction
        -    10.2 Preliminaries
            -    10.2.1 Definitions
            -    10.2.2 Model
            -    10.2.3 Tools
        -    10.3 Impossibility of quantum string commitments
        -    10.4 Possibility
        -    10.5 Conclusion
    -    11 Possibilities: Exploiting storage errors
        -    11.1 Introduction
            -    11.1.1 Related work
        -    11.2 Preliminaries
            -    11.2.1 Definitions
        -    11.3 Protocol and analysis
            -    11.3.1 Protocol
            -    11.3.2 Analysis
        -    11.4 Practical oblivious transfer
        -    11.5 Example: depolarizing noise
            -    11.5.1 Optimal cheating strategy
            -    11.5.2 Noise tradeoff
        -    11.6 Conclusion
    -    A Linear algebra and semidefinite programming
        -    A.1 Linear algebra prerequisites
        -    A.2 Definitions
        -    A.3 Semidefinite programming
        -    A.4 Applications
    -    B @xmath -Algebra
        -    B.1 Introduction
        -    B.2 Some terminology
        -    B.3 Observables, states and representations
            -    B.3.1 Observables and states
            -    B.3.2 Representations
        -    B.4 Commuting operators
            -    B.4.1 Decompositions
            -    B.4.2 Bipartite structure
            -    B.4.3 Invariant observables and states
        -    B.5 Conclusion
    -    C Clifford Algebra
        -    C.1 Introduction
        -    C.2 Geometrical interpretation
            -    C.2.1 Inner and outer product
            -    C.2.2 Reflections
            -    C.2.3 Rotations
        -    C.3 Application
        -    C.4 Conclusion
    -    Index

###### Acknowledgements. Research has been an extremely enjoyable
experience for me, and I had the opportunity to learn many exciting new
things. However, none of this would have been possible without the help
and support of many people. First, I would like to thank my supervisor
Harry Buhrman for our interesting discussions and for giving me the
opportunity to be at CWI which is a truly great place to work. For the
freedom to pursue my own interests, I am deeply grateful. My time as a
PhD student would have been very different without Andreas Winter, and I
would especially like to thank him for our many enjoyable discussions
and conversations. I have learned about many interesting things from
him, ranging from the beautiful topic of algebras, that I discovered way
too late, to his way of taking notes which I have shamelessly adopted. I
would also like to thank him for much encouragement, without which I may
not have dared to pursue my ideas about uncertainty relations much
further. Much of Chapter 4.3 is owed to him. I would also like thank
him, as well as Sander Bais, Ronald Cramer, Robbert Dijkgraaf, and
Ronald de Wolf for taking part in my PhD committee. Thanks also to
Ronald de Wolf for supervising my Master’s thesis, which was of
tremendous help to me during my time as a PhD student. Furthermore, I
would like to thank Matthias Christandl for our fun collaborations, a
great trip to Copenhagen, and the many enjoyable visits to Cambridge.
Thanks also to Artur Ekert for making these visits possible, and for the
very nice visit to Singapore. I am very grateful for his persistent
encouragement, and his advice on giving talks is still extremely helpful
to me. For many interestings dicussions and insights I would furthermore
like to thank Serge Fehr, Julia Kempe, Iordanis Kerenidis, Oded Regev,
Renato Renner and Pranab Sen, as well as my collaborators Manuel
Ballester, Harry Buhrman, Matthias Christandl, Andrew Doherty, Patrick
Hayden, Hoi-Kwong Lo, Christian Schaffner, Graeme Smith, John Smolin,
Barbara Terhal, Ben Toner, Falk Unger, Andreas Winter, Ronald de Wolf,
and Jürg Wullschleger. Thanks also to Nebošja Gvozdenović, Dennis
Hofheinz, Monique Laurent, Serge Massar and Frank Vallentin for useful
pointers, and to Boris Tsirelson for supplying me with copies of [ Tsi80
] and [ Tsi87 ] . Many thanks also to Tim van Erven, Peter Grünwald,
Peter Harremoes, Steven de Rooij, and Nitin Saxena for the enjoyable
time at CWI, and to Paul Vitányi who let me keep his comfy armchair on
which many problems were solved. Fortunately, I was able to visit many
other places during my time as a PhD student. I am grateful to Dorit
Aharanov, Claude Crépeau, Artur Ekert, Julia Kempe, Iordanis Kerenidis,
Michele Mosca, Michael Nielsen, David Poulin, John Preskill, Barbara
Terhal, Oded Regev, Andreas Winter and Andrew Yao for their generous
invitations. For making my visits so enjoyable, I would furthermore like
to thank Almut Beige, Agata Branczyk, Matthias Christandl, Andrew
Doherty, Marie Ericsson, Alistair Kay, Julia Kempe, Jiannis Pachos, Oded
Regev, Peter Rohde and Andreas Winter. Thanks to Manuel Ballester, Cor
Bosman, Serge Fehr, Sandor Héman, Oded Regev, Peter Rohde, and
especially Christian Schaffner for many helpful comments on this thesis;
any remaining errors are of course my own responsibility. Thanks also to
Frans Bartels for drawing the thesis cover and the illustrations of
Alice and Bob. I am still grateful to Torsten Grust and Peter Honeyman
who encouraged me to go to university in the first place. Finally, many
thanks to my family and friends for being who they are.
Amsterdam Stephanie Wehner
February, 2008.

## Part I Introduction

### Chapter 1 Quantum cryptography

Cryptography is the art of secrecy. Nearly as old as the art of writing
itself, it concerns itself with one of the most fundamental problems
faced by any society whose success crucially depends on knowledge and
information: With whom do we want to share information, and when, and
how much?

#### 1.1 Introduction

Starting with the first known encrypted texts from 1900 BC in Egypt [
Wik ] , cryptography has a fascinating history [ Kah96 ] . Its goal is
simple: to protect secrets as best as is physically possible. Following
our increased understanding of physical processes with the advent of
quantum mechanics, Wiesner [ Wie83 ] proposed using quantum techniques
for cryptography in the early 1970’s. Unfortunately, his groundbreaking
work, which contained the seed for quantum key distribution, oblivious
transfer (as described below), and a form of quantum money, was
initially met with rejection [ Bra05 ] . In 1982, Bennett, Brassard,
Breitbart and Wiesner joined forces to publish ‘‘Quantum cryptography,
or unforgeable subway tokens’’ which luckily found acceptance [ BBBW82 ]
, leading to the by now vast field of research in quantum key
distribution (QKD). Quantum key distribution allows two remote parties
who are only connected via a quantum channel to generate an arbitrarily
long secret key that they can then use to perfectly shield their
messages from prying eyes. The idea is beautiful in its simplicity:
unlike with classical data, quantum mechanics prevents us from copying
an unknown quantum state. What’s more is that any attempt to extract
information from such a state can be detected! That is, we can now
determine whether an eavesdropper has been trying to intercept our
secrets. Possibly the most famous QKD protocol known to date was
proposed in 1983 by Bennett and Brassard [ BB83 ] , and is more commonly
known as BB84 from its 1984 full publication [ BB84 ] . Indeed, many
quantum cryptographic protocols to date are inspired in some fashion by
BB84. It saw its first experimental implementation in 1989, when
Bennett, Bessette, Brassard, Salvail and Smolin built the first QKD
setup covering a staggering distance of 32.5 cm [ BB89 , BBB @xmath 92 ]
! In 1991, Ekert proposed a beautiful alternative view of QKD based on
quantum entanglement and the violation of Bell’s theorem, leading to the
protocol now known as E91 [ Eke91 ] . His work paved the way to
establishing the security of QKD protocols, and led to many other
interesting tasks such as entanglement distillation. Since then, many
other protocols such as B92 [ Ben92 ] have been suggested. Today, QKD
and its related problems form a well-established part of quantum
information, with countless proposals and experimental implementations.
It especially saw increased interest after the discovery of Shor’s
quantum factoring algorithm in 1994 [ Sho97 ] that renders almost all
known classical encryption systems insecure, once a quantum computer is
built. Some of the first security proofs were provided by Mayers [
May96a ] , Lo and Chau [ LC99 ] , and Shor and Preskill [ SP00 ] ,
finally culminating in the wonderful work of Renner [ Ren05 ] who
supplied the most general framework for proving the security of any
known QKD protocol. QKD systems are already available commercially today
[ Qua , Tec ] . The best known experimental implementations now cover
distances of up to 148.7 km in optical fiber [ HRP @xmath 06 ] , and 144
km in free space [ UTSM @xmath ] in an experiment conducted between two
Canary islands.

Traditional cryptography is concerned with the secure and reliable
transmission of messages. With the advent of widespread electronic
communication, however, new cryptographic tasks have become increasingly
important. We would like to construct secure protocols for electronic
voting, online auctions, contract signing and many other applications
where the protocol participants themselves do not trust each other. Two
primitives that can be used to construct all such protocols are bit
commitment and oblivious transfer. We will introduce both primitives in
detail below. Interestingly, it turns out that despite many initially
suggested protocols [ BBBW82 , Cré94 ] , both primitives are impossible
to achieve when we ask for unconditional security. Luckily, as we will
see in Chapter 11 we can still implement both building blocks if we
assume that our quantum operations are affected by noise. Here, the very
problem that prevents us from implementing a full-scale quantum computer
can be turned to our advantage.

In this chapter, we give an informal introduction to cryptography in the
quantum setting. We first introduce necessary terminology, before giving
an overview over the most well-known cryptographic primitives. Since our
goal is to give an overview, we will restrict ourselves to informal
definitions. Surprisingly, even definitions themselves turn out to be a
tricky undertaking, especially when entering the quantum realm. Finally,
we discuss what makes the quantum setting so different from the
classical one, and identify a range of open problems.

#### 1.2 Setting the state

##### 1.2.1 Terminology

In this text, we consider protocols among multiple participants @xmath ,
also called players . When considering only two players, we generally
identify them with the protagonists Alice and Bob. Each player may hold
a private input , that is classical and quantum data unknown to the
other players. In addition, the players may have access to a shared
resource such as classical shared randomness or quantum entanglement
that has been distributed before the start of the protocol. We will
refer to any information that is available to all players as public . A
subset of players may also have access to shared information that is
known only to them, but not to the remaining players. Such an input is
called private shared input . In the case of shared randomness, this is
also known as private shared randomness . The players can be connected
by classical as well as quantum channels, and use them to exchange
messages during the course of the protocol. A given protocol consists of
a set of messages as well as a specification of actions to be undertaken
by the players. At the end of the protocol, each player may have a
classical as well as a quantum output.

A player is called honest , if he follows the protocol exactly as
dictated. He is called honest-but-curious , if he follows the protocol,
but nevertheless tries to gain additional information by processing the
information supplied by the protocol in a way which is not intended by
the protocol. An honest player, for example, will simply ignore parts of
the information he is given, as he will do exactly as he is told.
However, a player that is honest-but-curious will take advantage of all
information he is given, i.e., he may read and copy all messages as
desired, and never forgets any information he is given. ¹ ¹ 1 Note that
since an honest-but-curious player never forgets any information, he
effectively makes a copy of all messages. He will erase his memory
needed for the execution of the protocol if dictated by the protocol:
his copy lies outside this memory. Yet, the execution of the protocol
itself is unaffected as the player does not change any information used
in the protocol, he merely reads it. But what does this mean in a
quantum setting? Indeed, this question appears to be a frequent point of
debate. We will see in Chapter 2 that he cannot copy arbitrary quantum
information, and extracting non-classical information from a quantum
state will necessarily lead to disturbance. Evidently, disturbance
alters the quantum states during the protocol. Hence, the player
actually took actions to alter the execution of the protocol, and we can
no longer regard him as honest. After examining quantum operations in
Chapter 2 we will return to the definition of an honest-but-curious
player in the quantum setting. Finally, a player can also be dishonest :
he will do anything in his power to break the protocol. Evidently, this
is the most realistic setting, and we will always consider it here.

An adversary is someone who is trying to break the protocol. An
adversary is generally modeled as an entity outside of the protocol that
can either be an eavesdropper, or take part in the protocol by taking
control of specific players. This makes it easier to model protocols
among multiple players, where we assume that all dishonest players
collaborate to form a single adversary.

##### 1.2.2 Assumptions

In an ideal world, we could implement any cryptographic protocol
described below. Interestingly though, even in the quantum world we
encounter physical limits which prevent us from doing so with
unconditional security. Unconditional security most closely corresponds
to the intuitive notion of “secure”. A protocol that is unconditionally
secure fulfills its purpose and is secure even if an attacker is granted
unlimited resources. We happily provide him with the most powerful
computer we could imagine and as much memory space as he wants. The main
question of unconditional security is thus whether the attacker obtains
enough information to defeat the security of the system. Unconditional
security is also called perfect secrecy in the context of encryption
systems, and forms part of information-theoretic security .

Most often, however, unconditional security can never be achieved. We
must therefore resign ourselves to introducing additional limitations on
the adversary: the protocol will only be secure if certain assumptions
hold. In practise, these assumptions can be divided into two big
categories: In the first, we assume that the players have access to a
common resource with special properties. This includes models such as a
trusted initializer [ Riv99 ] , or another source that provides the
players with shared randomness drawn from a fixed distribution. An
example of this is also a noisy channel [ CK88 ] : Curiously, a noisy
channel that neither player can influence too much turns out to be an
incredibly powerful resource. The second category consists of clear
limitations on the ability of the adversary. For example, the adversary
may have limited storage space available [ Mau92 , DFSS05 ] , or
experience noise when trying to store qubits as we will see in Chapter
11 . In multi-player protocols we can also demand that dishonest players
cannot communicate during the course of the protocol, that messages
between different players take a certain time to be transmitted, or that
only a minority of the players is dishonest. In the quantum case, other
known assumptions include limiting the adversary to measure not more
than a certain number of qubits at a time [ Sal98 ] , or introducing
superselection rules [ KMP04 ] , where the adversary can only make a
limited set of quantum measurements. When introducing such assumptions,
we still speak of information-theoretic security : Except for these
limitations, the adversary remains all-powerful. In particular, he has
unlimited computational resources.

Classically, most forms of practical cryptography are shown to be
computationally secure . In this security model, we do not grant an
adversary unlimited computational resources. Instead, we are concerned
with the amount of computation required to break the security of a
system. We say that a system is computationally secure , if the believed
level of computation necessary to defeat it exceeds the computational
resources of any hypothetical adversary by a comfortable margin. The
adversary is thereby allowed to use the best possible attacks against
the system. Generally, the adversary is modeled as having only
polynomial computational power. This means that any attacks are
restricted to time and space polynomial in the size of the underlying
security parameters of the system. In this setting the difficulty of
defeating the system’s security is often proven to be as difficult as
solving a well-known problem which is believed to be hard. The most
popular problems are often number-theoretic problems such as factoring.
Note that for example in the case of factoring, it is not known whether
these problems are truly difficult to solve classically. Many such
problems, such as factoring, fold with the advent of a quantum computer
[ Sho97 ] . It is an interesting open problem to find classical hardness
assumptions, which are still secure given a quantum computer. Several
proposals are known [ Reg03 ] , but so far none of them have been proven
secure.

In the realm of quantum cryptography, we are so far only interested in
information-theoretic security: we may introduce limitations on the
adversary, but we do not resort to computational hardness assumptions.

##### 1.2.3 Quantum properties

Quantum mechanics introduces several exciting aspects to the realm of
cryptography, which we can exploit to our benefit, but which also
introduce additional complications even in existing classical primitives
whose security does not depend on computational hardness assumptions.
Here, we give a brief introduction to some of the most striking aspects,
which we will explain in detail later on.

1.   Quantum states cannot be copied: In classical protocols, an
    adversary can always copy any messages and his classical data at
    will. Quantum states, however, differ: We will see in Chapter 2 that
    we cannot copy an arbitrary qubit. This property led to the
    construction of the unforgeable subway tokens [ BBBW82 ] mentioned
    earlier.

2.   Information gain can be detected: Classically there is no way for
    an honest player to determine whether messages have been read
    maliciously outside the scope of the protocol. However, in a quantum
    setting we can detect whether an adversary tried to extract
    information from a transmitted message. This property forms the
    heart of quantum key distribution described below. It also allows us
    to construct cheat-sensitive protocols, a concept which is foreign
    to classical cryptography: even though we cannot prevent an
    adversary from gaining information if he intends to do so, we will
    be able to detect such cheating and take appropriate action. We will
    return to this aspect in Chapter 2 .

3.   Uncertainty relations exist: Unlike in the classical world, quantum
    states allow us to encode multiple bits into a single state in such
    a way that we cannot extract all of them simultaneously. This
    property is closely related to cheat-sensitivity, and is a
    consequence of the existence of uncertainty relations we will
    encounter in Chapter 4 . It is also closely related to what is known
    as quantum random access codes, which will we employ in Chapter 8 .

4.   Information can be “locked”: Another aspect we need to take into
    account when considering quantum protocols is an effect known as
    locking classical information in quantum states. Surprisingly, the
    amount of correlation between two parties can increase by much more
    than the data transmitted. We will examine this effect for a
    specific measure of correlation in more detail in Chapter 5 .

5.   Entanglement allows for stronger correlations: Entanglement is
    another concept absent from the classical realm. Whereas
    entanglement has many useful applications such as quantum
    teleportation and can also be used to analyze the security of
    quantum key distribution, it also requires us to be more cautious:
    In Chapter 9 , we will see that the parameters of classical
    protocols can change dramatically if dishonest players share
    entanglement, even if they do not have access to a full quantum
    computer. In Chapter 10 , entanglement will enable an adversary to
    break any quantum string commitment protocol.

6.   Measurements can be delayed: Finally, we encounter an additional
    obstacle, which is also entirely missing from classical protocols:
    Players may delay quantum measurements. In any classical protocol,
    we can be assured that any input and output is fixed once the
    protocol ends. In the quantum case, however, players may alter their
    protocol input retroactively by delaying quantum measurements that
    depend on their respective inputs. Essentially, in a classical
    protocol the players will automatically be “committed” to the run of
    the protocol, whereas in the quantum setting this property is
    entirely missing. This can make an important difference in
    reductions among several protocols as we will see in Section 1.3.2
    below.

#### 1.3 Primitives

We now present an overview of the most common multi-party protocol
primitives, and what is known about them in the quantum setting. We
already encountered quantum key distribution (QKD) in the introduction.
In this thesis, our focus lies on cryptographic protocols other than
QKD.

##### 1.3.1 Bit commitment

Possibly the most active area of quantum cryptography in the early
stages next to QKD was quantum bit commitment: Imagine two mutually
distrustful parties Alice and Bob at distant locations. They can only
communicate over a channel, but want to play the following game: Alice
secretly chooses a bit @xmath . Bob wants to be sure that Alice indeed
has made her choice. Yet, Alice wants to keep @xmath hidden from Bob
until she decides to reveal @xmath . To convince Bob that she made up
her mind, Alice sends Bob a commitment. From the commitment alone, Bob
cannot deduce @xmath . At a later time, Alice reveals @xmath and enables
Bob to open the commitment. Bob can now check if Alice is telling the
truth. This scenario is known as bit commitment .

Commitments play a central role in modern-day cryptography. They form an
important building block in the construction of larger protocols in, for
example, gambling and electronic voting, and other instances of secure
two-party computation. In the realm of quantum mechanics, it has been
shown that oblivious transfer [ BBCS92b ] (defined in Section 1.3.2 )
can be achieved provided there exists a secure bit commitment scheme [
Yao95 , Cré94 ] . In turn, classical oblivious transfer can be used to
perform any secure two-party computation defined below [ CvdGT95 ] .
Commitments are also useful for constructing zero-knowledge proofs [
Gol01 ] and lead to coin tossing [ Blu83 ] . Informally, bit commitment
can be defined as follows: {definition} Bit commitment (BC) is a
two-party protocol between Alice (the committer) and Bob (the verifier),
which consists of three stages, the committing and the revealing stage,
and a final declaration stage in which Bob declares “accept” or
“reject”. The following requirements should hold:

-   (Correctness) If both Alice and Bob are honest, then before the
    committing stage Alice picks a bit @xmath . Alice’s protocol depends
    on @xmath and any randomness used. At the revealing stage, Alice
    reveals to Bob the committed bit @xmath . Bob accepts.

-   (Binding) If Alice wants to reveal a bit @xmath , then

      -- -------- --
         @xmath   
      -- -------- --

-   (Concealing) If Alice is honest, Bob does not learn anything about
    @xmath before the revealing stage.

Classically, unconditionally secure bit commitment is known to be
impossible. Indeed, this is very intuitive if we consider the
implications of the concealing condition: This condition implies that
exactly the same information exchange must have occurred if Alice
committed herself to @xmath or @xmath , otherwise Bob would be able to
gain information about @xmath . But this means that even if Alice
initially made a commitment to @xmath , she can later reconstruct the
run of the protocol as if she had committed herself to @xmath and thus
send the right message to Bob to reveal @xmath instead. Unfortunately,
even quantum communication cannot help us to implement unconditionally
secure bit commitment without further assumptions: After several quantum
schemes were suggested [ BB84 , BC90a , BCJL93 ] , quantum bit
commitment was shown to be impossible, too [ May96b , LC97 , May97 ,
LC96 , BCMS97 , CL98 , DKSW06 ] , even in the presence of superselection
rules [ KMP04 ] , where the adversary can only perform a certain
restricted set of measurements. In the face of the negative results,
what can we still hope to achieve?

Evidently, we need to assume that the adversary is limited in certain
ways. In the classical case, bit commitment is possible if the adversary
is computationally bounded [ Gol01 ] , if one-way functions exist [
Nao91 , HR07 ] , if Alice and Bob are connected via a noisy channel that
neither player can influence too much [ CK88 , DKS99 , DFMS04 ] , or if
the adversary is bounded in space instead of time, i.e., he is only
allowed to use a certain amount of storage space [ Mau92 ] .
Unfortunately, the security of the bounded classical storage model [
Mau92 , CCM98 ] is somewhat unsatisfactory: First, a dishonest player
needs only quadratically more memory than the honest one to break the
security. Second, as classical memory is very cheap, most of these
protocols require huge amounts of communication in order to achieve
reasonable bounds on the adversaries memory.

Do we gain anything by using quantum communication? Interestingly, even
without any further assumptions, quantum cryptography at least allows us
to implement imperfect forms of bit commitment, where Alice and Bob both
have a limited ability to cheat. That is, we allow Alice to change her
mind, and Bob to learn the committed bit with a small probability. These
protocols are based on the fact that quantum protocols can exhibit a
form of cheat sensitivity unavailable to classical communication [ HK04
, ATSVY00 ] . Exact tradeoffs on how well we can implement bit
commitment in the quantum world can be found in [ SR02a ] . Protocols
that make use of this tradeoff are cheat-sensitive, as described in
Section 1.2.2 . Examples of such protocols have been used to implement
coin tossing [ Amb01 ] as described in Section 1.3.2 . In Chapter 10 ,
we will consider commitments to an entire string of bits at once.
Whereas this task turns out to be impossible as well for a strong
security definition, we will see that non-trivial quantum protocols do
exist for a very weak security definition. Bit commitment can also be
implemented under the assumption that faster than light communication is
impossible, provided that Alice and Bob are located very far apart [
Ken99 ] , or if Alice and Bob are given access to non-local boxes [ BCU
@xmath 06 ] which provide superstrong non-local correlations.

But even a perfect commitment can be implemented, if we make quantum
specific assumptions. For example, it is possible to securely implement
BC provided that an adversary cannot measure more than a fixed number of
qubits simultaneously [ Sal98 ] . With current-day technology, it is
very difficult to store states even for a very short period of time.
This leads to the protocol presented in [ BBCS92a , Cré94 ] , which
shows how to implement BC and OT (defined below) if the adversary is not
able to store any qubits at all. In [ DFSS05 , DFR @xmath 07 ] , these
ideas have been generalized in a very nice way to the
bounded-quantum-storage model , where the adversary is computationally
unbounded and is allowed to have an unlimited amount of classical
memory. However, he is only allowed a limited amount of quantum memory.
The advantages over the classical bounded-storage model are two-fold:
First, given current day technology it is indeed very hard to store
quantum states. Secondly, the honest players do not require any quantum
storage at all, making the protocol much more efficient. It has been
shown that such protocols remain secure when executed many times in a
row [ WW07 ] .

##### 1.3.2 Secure function evaluation

An important aspect of modern day cryptography is the primitive known as
secure function evaluation, and its multi-player analogue, secure
multi-party computation, first suggested by Yao [ Yao82 ] . Imagine that
Alice and Bob are trying to decide whether to attend an unpopular
administrative event. If Alice attends, Bob feels forced to attend as
well and vice versa. However, neither of them wants to announce publicly
whether they are planning to attend or whether they would rather make up
an excuse to remain at home, as this may have dire consequences. How can
Alice and Bob solve their dilemma? Note that their problem can be
phrased in the following form: Let @xmath be Alice’s private input bit,
where @xmath if Alice is planning to attend and @xmath if Alice skips
the event. Similarly, let @xmath be Bob’s private input bit. Alice and
Bob now want to compute @xmath in such a way that both of them learn the
result, but neither of them learns anything more about the input of the
other player than can be inferred from the result. In our example, if
@xmath , at least one of the players is planning to attend the event.
Both Alice and Bob now attend the event, and both of them can safely
claim that they really did plan to do so in the first place. If @xmath ,
Alice and Bob learn that they both agree, and do not need to fear any
political consequences.

Secure function evaluation enables Alice and Bob to solve any such task.
Protocols for secure function evaluation enable us to construct
protocols for electronic voting and secure auctions. Informally, we
define: {definition} Secure function evaluation (SFE) is a two-party
protocol between Alice and Bob, where Alice holds a private input @xmath
and Bob holds a private input @xmath such that

-   (Correctness) If both Alice and Bob are honest, then they both
    output the same value @xmath .

-   (Security) If Alice (Bob) is dishonest, then Alice (Bob) does not
    learn more about @xmath ( @xmath ) then can be inferred from @xmath
    .

A common variant of SFE is so-called one-sided SFE: Here, only one of
the two players receives the result of the computation, @xmath . Sadly,
we cannot implement SFE for an arbitrary function @xmath classically
without additional assumptions, akin to bit commitment. Even in the
quantum world, the situation is equally bleak: SFE remains impossible in
the quantum setting [ Lo97 ] ! Fortunately, the situations improves when
we consider multi-party protocols as mentioned below.

###### Oblivious transfer

A special case of secure function evaluation is the problem of oblivious
transfer, which was first introduced by Rabin [ Rab81 ] . The variant of
1-2 OT appeared in a paper by Even, Goldreich and Lempel [ EGL85 ] and
also, under a different name, in the well-known paper by Wiesner [ Wie83
] . 1-2 OT allows Alice and Bob to solve a seemingly uninteresting
problem: The sender (Alice) secretly chooses two bits @xmath and @xmath
, the receiver (Bob) secretly chooses a bit @xmath . The primitive of
oblivious transfer allows Bob to retrieve @xmath in such a way, that
Alice cannot gain any information about @xmath . At the same time, Alice
is ensured that Bob only retrieves @xmath and gets no information about
the other input bit @xmath . Oblivious transfer can be used to perform
any secure two-party computation [ Kil88 , CvdGT95 ] , and is therefore
a very important primitive.

Unlike in the classical setting, oblivious transfer in the quantum world
requires additional caution: We want that after the protocol ends, both
of Alice’s inputs bits @xmath and Bob’s choice bit @xmath have been
determined. That is, they are fixed and the players can no longer change
their mind. In particular, we do not want Bob to delay his choice of
@xmath indefinitely, possibly by delaying a quantum measurement.
Similarly, Alice should not be able to change her mind about, for
example, the parity of @xmath after the end of the protocol by delaying
a measurement. Informally, we define

{definition}

@xmath - oblivious transfer (1-2 OT @xmath ) is a two-party protocol
between Alice (the sender) and Bob (the receiver), such that

-   (Correctness) If both Alice and Bob are honest, the protocol depends
    on Alice’s two input bits @xmath and Bob’s input bit @xmath . At the
    end of the protocol Bob knows @xmath .

-   (Security against Alice) If Bob is honest, Alice does not learn
    @xmath .

-   (Security against Bob) If Alice is honest, Bob does not learn
    anything about @xmath .

After the protocol ends, @xmath and @xmath have been chosen.
Classically, 1-2 OT can be obtained from the following simpler
primitive, also known as Rabin-OT [ Rab81 ] or erasure channel.
Conversely, OT can be obtained from 1-2 OT. {definition} Rabin Oblivious
transfer (Rabin-OT) is a two-party protocol between Alice (the sender)
and Bob (the receiver), such that

-   (Correctness) If both Alice and Bob are honest, the protocol depends
    on Alice’s input bit @xmath . At the end of the protocol, Bob
    obtains @xmath with probability @xmath and knows whether he obtained
    @xmath or not.

-   (Security against Alice) If Bob is honest, Alice does not learn
    whether Bob obtained @xmath .

-   (Security against Bob) If Alice is honest, Bob’s probability of
    learning bit @xmath does not exceed @xmath .

After the protocol ends, @xmath has been chosen.

The fact that Alice and Bob may delay their measurements makes an
important difference, as the following simple example shows: Consider
the standard reduction of Rabin-OT to 1-2 OT: Alice uses inputs @xmath
and @xmath with @xmath . Bob uses input @xmath , for a randomly chosen
@xmath . The players now perform 1-2 OT @xmath after which the receiver
holds @xmath . Subsequently, Alice announces @xmath . If @xmath , Bob
succeeded in retrieving @xmath and otherwise he learns nothing. This
happens with probability @xmath and thus we have constructed Rabin-OT
from one instance of 1-2 OT. Clearly, this reduction fails if we use an
1-2 OT protocol in which Bob can defer his choice of @xmath , possibly
by delaying a quantum measurement that depends on @xmath . He simply
waits until Alice announces @xmath , to retrieve @xmath with certainty.
This simple example makes it clear that implementing 1-2 OT is far from
a trivial task in the quantum setting. Even the classical definitions
need to be revised carefully. In this brief overview, we restricted
ourselves to the informal definition given above, and refer to [ Wul07 ]
for an extensive treatment of the definition of oblivious transfer.

Note that oblivious transfer forms an instance of secure function
evaluation with @xmath satisfying @xmath , where only one player (Bob)
learns the output. Hence by Lo’s impossibility result for SFE discussed
earlier, oblivious transfer is not possible in the quantum setting
either without introducing additional assumptions. Indeed, note that
there exists a classical reduction of bit commitment to oblivious
transfer (up to a vanishing probability), where we reverse the roles of
Alice and Bob for bit commitment: Alice simply chooses two @xmath -bit
strings @xmath , and @xmath . Alice and Bob now use @xmath rounds of 1-2
OT, where Bob retrieves @xmath when he wants to commit to a bit @xmath .
To reveal, he then sends @xmath and @xmath to Alice. Intuitively, one
can thus hope to use the impossibility proof of bit commitment to show
that oblivious transfer is impossible as well, without resorting to [
Lo97 ] . However, note that we would first have to show the security of
this reduction with respect to a quantum adversary. Fortunately,
oblivious transfer becomes possible if we make the same assumptions as
for bit commitment described in Section 1.3.1 . We will consider how to
implement oblivious transfer if the adversary’s quantum storage is
subject to noise in Chapter 11 .

###### Coin tossing

Another example of SFE is the well-known primitive of coin tossing [
Blu83 ] , which can be viewed as an instance of randomized secure
function evaluation defined in [ Gol01 ] . Imagine that Alice and Bob
want to toss a coin, solely by communicating over a classical and a
quantum channel. We thereby want to ensure that neither party can
influence the outcome of the coin toss by too much. Unfortunately, we
cannot implement this primitive classically without relying on
additional assumptions.

What assumptions do we need to implement coin tossing? It is easy to see
that we can implement one form of coin tossing, if we could perform bit
commitment: Alice chooses a random bit @xmath and commits herself to
@xmath . Subsequently, Bob chooses a random bit @xmath and sends it to
Alice. After receiving @xmath , Alice opens her commitment and reveals
@xmath . Both parties now output @xmath as their outcome. Thus, any
assumptions that enable us to implement bit commitment also lead to coin
tossing. Some assumptions even allow for very simple protocols: If we
assume that Alice and Bob are located far apart and faster-than-light
communication is impossible, they can simply both flip a coin themselves
and send it over the channel. They then take the xor of the two bits as
the outcome of the coin flip. If Alice and Bob do not receive the
other’s bit within a certain time frame they reject this execution of
the protocol and restart. Since it takes the bit a specific time to
travel over the channel, both parties can be sure that it must have been
sent before a certain time, i.e., before receiving the other’s bit.

Many definitions of coin tossing are known in the literature, which
exhibit subtle differences especially whether aborts are allowed during
the protocol. In the quantum literature, strong coin tossing ² ² 2
Unfortunately, these names carry a slightly different meaning in the
classical literature. has been informally defined as follows:
{definition} A quantum strong coin tossing protocol with bias @xmath is
a two-party protocol, where Alice and Bob communicate and finally decide
on a value @xmath such that

-   If both parties are honest, then @xmath .

-   If one party is honest, then for any strategy of the dishonest
    player @xmath and @xmath .

Sadly, strong coin tossing cannot be implemented perfectly with bias
@xmath [ LC98 ] . However, one might hope that one could still achieve
an arbitrarily small bias @xmath . Many protocols have been proposed for
quantum strong coin tossing and subsequently been broken [ MSC99 , ZLG00
] . Sadly, it was shown that strong coin tossing cannot be implemented
with an arbitrarily small bias, and @xmath is the best we could hope to
achieve [ Kit02 ] . So far, quantum protocols for strong coin tossing
with a bias of @xmath [ ATSVY00 ] and finally @xmath [ Amb01 , SR02a ,
KN04 , Col07 ] are known. No formal definition of strong coin tossing in
the quantum setting is known to date, that specifies how to deal with an
abort in the case when the protocol is executed multiple times.

To circumvent this problem, a slightly weaker primitive has been
proposed, which carries the name weak coin tossing in the quantum
literature. Here, we explicitly allow the dishonest party to bias the
coin entirely in one direction, but limit his ability to bias the coin
the other way. This scenario corresponds to a setting where, for
example, Alice wins if the outcome is @xmath and Bob if @xmath .
However, we do allow each player to give in and loose at will.
Intuitively, this setting makes more sense in all common practical
examples when considering a standalone run of such a protocol, where
each player has a preferred outcome. Informally, we define {definition}
A quantum weak coin tossing protocol with bias @xmath is a two-party
protocol, where Alice and Bob communicate and finally decide on a value
@xmath such that

-   If both parties are honest, then @xmath .

-   If Alice is honest, then for any strategy of Bob

      -- -------- --
         @xmath   
      -- -------- --

-   If Bob is honest, then for any strategy of Alice

      -- -------- --
         @xmath   
      -- -------- --

Weakening the definition in this way indeed helps us! It has been shown
that we can construct a quantum protocol for weak coin tossing that
achieves a bias of @xmath [ KN04 ] , @xmath [ SR02b ] , @xmath [ Moc04 ]
, and @xmath [ Moc05 ] . Very recently, however, a protocol with an
arbitrarily small bias has been suggested [ Moc07b ] ! To date, there is
also no formal definition of weak coin tossing in the quantum setting.

###### Multiple players

Secure multi-party computation (SMP) concerns an analogous task to SFE,
involving @xmath players @xmath , where @xmath has a private input
@xmath . Their goal is to compute @xmath , such that none of them can
learn more about the input of any other player than they can infer from
@xmath ). Fortunately, the situation changes dramatically when extending
the protocol to multiple players. SMP can be implemented with
unconditional security even classically, provided that @xmath of the
players are dishonest [ Gol01 ] . If the adversary is not dishonest, but
merely honest-but-curious, it is possible to increase @xmath up to
@xmath [ Gol01 ] . We refer to [ Cra99 ] for an overview of classical
secure multi-party computation.

Quantumly, one can generalize secure multi-party computation to the
following setting. Each player @xmath holds an input state @xmath (see
Chapter 2 for details). Let @xmath denote the joint state of players
@xmath . Then quantum secure multi-party computation (QSMP) allows the
players to compute any quantum transformation @xmath to obtain @xmath ,
where player @xmath receives the quantum state on @xmath as his output.
QSMP can be implemented securely if @xmath of the players are dishonest
[ CGS02 , CGS05 ] .

Coin tossing has also been studied in the multi-party setting.
Classically, multi-party coin tossing forms part of secure multi-party
computation [ Gol01 ] , and can thus be implemented under the same
assumptions. Quantumly, multi-party coin tossing has been studied in [
ABRD04 ] .

##### 1.3.3 Secret sharing

Another interesting problem concerns the sharing of a classical or
quantum secret. Imagine Alice holding an important piece of information,
for example the launch code to her personal missile silo. Alice would
like to enable members of her community to gain access, but wants to
prevent a single individual from launching a missile on his own. Secret
sharing enables Alice to distribute some secret data @xmath among a set
of @xmath players, such that at least @xmath players need to combine
their individual shares to reconstruct the original secret @xmath . A
trivial secret sharing scheme for a bit @xmath involving just two
players is as follows: Alice picks @xmath and hands @xmath to the first
player, and @xmath to the second player. Clearly, if @xmath is chosen
uniformly at random from @xmath , none of the individual players can
gain any information about @xmath . Yet, when combining their individual
shares they can compute @xmath .

General secret-sharing schemes were introduced by Shamir [ Sha79 ] and
Blakey [ Bla79 ] . They have found a wide range of applications, most
notably to construct protocols for secure multi-party computation as
described in Section 1.3.2 . Many classical secret sharing schemes are
known today [ MvOV97 ] . Quantum secret sharing was first introduced in
[ HBB99 ] and shortly after in [ CGL99 ] , which also formed a link
between quantum secret sharing schemes and error correcting codes.
Quantumly, we can distinguish two types of secret sharing schemes: The
first allows to share a quantum secret, i.e., Alice holds a quantum
state @xmath and wants to construct @xmath quantum shares @xmath such
that when @xmath such shares are combined @xmath can be reconstructed [
HBB99 , CGL99 , Got00 ] . The second allows us to share classical
secrets using quantum states that have very nice data-hiding properties
[ DLT02 , DHT03 , EW02 , HLS05 ] : it is not sufficient for @xmath
parties to perform local measurements and communicate classically in
order to reconstruct the secret. To reconstruct the secret data they
must communicate quantumly to perform a coherent measurement on their
states. It is an exciting open question whether such schemes can be used
to implement quantum protocols for secure multi-party computations with
classical inputs that remain secure as long as the dishonest players can
only communicate classically, but not quantumly.

##### 1.3.4 Anonymous transmissions

In all applications we considered so far, we were concerned with two
aspects: either, we wanted to protect protocol participants from being
cheated by the other players, or, we wanted to protect the secrecy of
data from a third party as in the setting of key distribution described
in Section 1.1 . In the problem of key distribution, sender and receiver
know each other, but are trying to protect their data exchange from
prying eyes. Anonymity, however, is the secrecy of identity. Primitives
to hide the sender and receiver of a transmission have received
considerable attention in classical computing. Such primitives allow any
member of a group to send and receive data anonymously, even if all
transmissions can be monitored. They play an important role in protocols
for electronic auctions [ SA99 ] , voting protocols and sending
anonymous email [ Cha81 ] . An anonymous channel which is completely
immune to any active attacks, would be a powerful primitive. It has been
shown how two parties can use such a channel to perform key-exchange [
AS83 ] .

A considerable number of classical schemes have been suggested for
anonymous transmissions. An unconditionally secure classical protocol
was introduced by Chaum [ Cha88 ] in the context of the Dining
Cryptographers Problem. Such a protocol can also be considered an
instance of secure multi-party computation considered above.

Boykin [ Boy02 ] considered a quantum protocol to send classical
information anonymously where the players distribute and test pairwise
shared EPR pairs, which they then use to obtain key bits. His protocol
is secure in the presence of noise or attacks on the quantum channel. In
[ CW05a ] , we presented a protocol for anonymous transmissions of
classical data that achieves a novel property that cannot be achieved
classically: it is completely traceless . This property is related, but
stronger than the notion of incoercibility in secure multi-party
protocols [ CG96 ] . Informally, a protocol is traceless, if a player
cannot be forced to reveal his true input at the end of the protocol.
Even when forced to hand out his input, output and randomness used
during the course of the protocol, a player is able to generate fake
input that is consistent with all other data gathered from the run of
the protocol. The protocols suggested in [ Boy02 ] are not traceless,
but can be modified to exhibit this property. It would be interesting to
see whether it is possible to make general protocols for secure
multi-party computation similarly traceless.

The first protocol for the anonymous transmission of qubits was
constructed in [ CW05a ] . Whereas the anonymous transmissions of
classical bits can be implemented via secure multi-party computation,
the scenario is different when we wish to transmit qubits: as we will
see in Chapter 2 , qubits cannot be copied. Thus we cannot expect each
player to obtain a copy of the output. New protocols for creating
anonymous entanglement and anonymously transmitting qubits have since
been suggested in [ BS05 , BBF @xmath ] .

##### 1.3.5 Other protocols

Besides the protocols above, a variety of other primitives making use of
particular quantum effects have been proposed. One of the oldest
suggested applications is the one of quantum money that is resistant to
copying [ Wie83 ] , also proposed as unforgeable subway tokens [ BBBW82
] . Quantum seals [ BP03 , Cha03 , SS05 ] employ the notion of cheat
sensitivity in order to provide data with a seal that is “broken” once
the data is extracted. That is, we can detect whether the data has been
read. Perfect quantum seals that allow us to detect tampering with
certainty have been shown to be impossible [ BPDM05 ] . Nevertheless,
non-trivial constructions are can be implemented.

Furthermore, quantum signature schemes [ GC01 ] have been proposed which
exhibit unconditional security: here Bob can verify Alice’s signature
using a public key given to him ahead of time. Sadly, such a scheme
slowly consumes the necessary public key. Finally, protocols have been
suggested for the encryption of quantum data which allow @xmath qubits
to be encoded using a @xmath bit key achieving perfect secrecy [ BR03 ,
AMTdW00 ] . Much smaller keys are possible, if we allow for small
imperfections [ DN06 , AS04 ] . Such encryption schemes have also been
used to allow for private circuit evaluation [ Chi05 ] : Here, Alice
encrypts her quantum state before handing it to Bob who is capable of
running a certain quantum operation that Alice would like to apply. This
allows Alice to let her quantum operations be performed by Bob without
revealing her quantum input.

#### 1.4 Challenges

As we saw in Section 1.2.3 , introducing quantum elements into
cryptography leads to interesting new effects. Much progress has been
made to exploit these quantum effects, although many open questions
remain. In particular, not much is known about how well quantum
protocols compose. That is, when we use one protocol as a building block
inside a larger application, does the protocol still remain secure as
expected? Recall from Section 1.2.3 that especially our ability to delay
quantum measurements has a great influence on composition. Fortunately,
quantum key distribution has been shown composable [ BOHL @xmath 05 ,
Ren05 , RK05 ] . However, composability remains a particularly tricky
question in protocols where we are not faced with an external
eavesdropper, but where the players themselves are dishonest.
Composability of quantum protocols was first considered in [ vdG98 ] ,
followed by [ CGS02 ] who addressed the composability of QSMP, and the
general composability frameworks of [ Unr04 , BOM04 ] applied to QKD [
BOHL @xmath 05 ] . Great care must also be taken when composing quantum
protocols in the bounded quantum storage model [ WW07 ] . Even though
these composability frameworks exist, very few protocols have been
proven secure when composed.

Secondly, we need to consider what happens if an adversary is allowed to
store even small amounts of quantum information. There are many examples
known where quantum memory can prove much more useful to an adversary
than classical memory [ GKK @xmath 06 ] , and we will encounter such
examples in Chapters 3 and 5 .

Furthermore, it is often assumed that the downfall of computational
assumptions such as factoring is the only consequence that quantum
computing has on the security of classical protocols. Sadly, this is by
no means the only problem. Classical protocols where the security
depends on the fact that different players cannot communicate during the
course of the protocol may be broken when the players can share quantum
entanglement and perform even a very limited set of quantum operations,
well within the reach of current day technology. We will encounter such
an example in Chapter 9 .

Furthermore, we may conceive new primitives, unknown to the classical
setting. One such primitive is the distribution of shared quantum states
in the presence of dishonest players. Here, our goal is to create a
protocol among @xmath players such that at the end of the protocol
@xmath players share a specified state @xmath , where the dishonest
players may apply any measurement to their share. It is conceivable to
extend the QSMP protocol of [ CGS02 ] to address this problem, yet, much
more efficient protocols may be possible. Such a primitive would also
enable us to build up the resources needed by other protocols such as [
CW05a ] .

Finally, it is an interesting question by itself, what cryptographic
primitives are possible in a quantum mechanical world. Conversely, it
has even been shown that the axioms governing quantum mechanics can in
part be obtained from the premise that perfect bit commitment is
impossible [ CBH03 ] . Perhaps such connections may lead to novel
insights.

#### 1.5 Conclusion

Quantum cryptography beyond quantum key distribution is an exciting
subject. In this thesis, we will investigate several aspects that play
an important role in nearly all cryptographic applications in the
quantum setting.

In part I , we will examine how to extract information from quantum
states. We first consider the problem of state discrimination. Here, our
goal is to determine the identity of a state @xmath within a finite set
of possible states @xmath . In Chapter 3 , we will examine a special
case of this problem that is of particular relevance to quantum
cryptography in the bounded quantum storage model: How well can we
perform state discrimination if we are given additional information
after an initial quantum measurement, i.e., after a quantum memory bound
is applied? In Chapter 4 , we address uncertainty relations, which play
an important role in nearly all cryptographic applications. We will
prove tight bounds for uncertainty relations for certain mutually
unbiased measurements. We will also present optimal uncertainty
relations for anti-commuting measurements. Finally, in Chapter 5 , we
then examine a peculiar quantum effect known as locking classical
information in quantum states. Such effects are important in the
security of QKD, and also play a role in quantum string commitments
which we will encounter in part III. In particular, we address the
following question: Can we always obtain good locking effects for
mutually unbiased measurements?

In part II , we turn to investigate quantum entanglement. In Chapter 7 ,
we show how to find optimal quantum strategies for two parties who
cannot communicate, but share quantum entanglement. Understanding such
strategies plays an important part in understanding the effect of
entanglement in otherwise classical protocols. In Chapter 8 , we then
present some initial weak result on the amount of entanglement such
strategies require. Finally, in Chapter 9 , we show how the security of
classical protocols can be affected considerably in the presence of
entanglement.

In part III , we investigate two cryptographic problems directly. In
Chapter 10 , we first consider commitments: Quantumly, one may hope that
committing to an entire string of bits at once, and allowing Alice and
Bob a limited ability to cheat, may still be within the realm of
possibilities. This does not contradict that bit commitment itself is
impossible. Unfortunately, we will see that for any reasonable security
measure, string commitments are also impossible. However, non-trivial
protocols do become possible for very weak notions of security.

In Chapter 11 , we then introduce the model of noisy-quantum storage
that in spirit is very similar to the setting of bounded-quantum
storage: Here we assume that the adversary’s quantum operations and
storage are subject to noise. We show that oblivious transfer can be
implemented securely in this model. We give an explicit tradeoff between
the amount of noise and the security of our protocol.

## Part II Information in quantum states

### Chapter 2 Introduction

To investigate the limitations and possibilities of cryptographic
protocols in a physical world, we must familiarize ourselves with its
physical theory: quantum mechanics. What are quantum states and what
sets them apart from the classical scenario? Here, we briefly recount
the most elementary facts that will be necessary for the remainder of
this text. We refer to [ Per93 ] for a more gentle introduction to
quantum mechanics, to Appendix A for linear algebra prerequisites, and
to the symbol index on page IV for unfamiliar notation. In later
chapters, we examine some of the most striking aspects of quantum
mechanics, such as uncertainty relations and entanglement in more
detail.

#### 2.1 Quantum mechanics

##### 2.1.1 Quantum states

A @xmath -dimensional quantum state is a positive semidefinite operator
@xmath of norm 1 (i.e., @xmath has no negative eigenvalues and @xmath )
living in a @xmath -dimensional Hilbert space ¹ ¹ 1 A complete vector
space with an inner product. Here, we always consider a vector space
over the complex numbers. @xmath . We commonly refer to @xmath as a
density operator or density matrix . A special case of a quantum state
is a pure state , which has the property that @xmath . That is, there
exists some vector @xmath such that we can write @xmath , where @xmath
is a projector onto the vector @xmath . If @xmath is a basis for @xmath
, we can thus write @xmath for some coefficients @xmath . Note that our
normalization constraint implies that @xmath . We also say that @xmath
is in a superposition of vectors @xmath . Clearly, for a pure state we
have that @xmath and thus @xmath .

Let’s first look at an example of pure states. Suppose we consider a
@xmath dimensional quantum system @xmath , also called a qubit . We call
@xmath the computational basis , where

  -- -------- --
     @xmath   
  -- -------- --

Any pure qubit state can then be written as @xmath for some @xmath with
@xmath . We take an encoding of ’0’ or ’1’ in the computational basis to
be @xmath or @xmath respectively, and use the subscript ’+’ to refer to
an encoding in the computational basis. An alternative choice of basis
would be the Hadamard basis , given by vectors @xmath , where

  -- -------- --
     @xmath   
  -- -------- --

We use ’ @xmath ’ to refer to an encoding in the Hadamard basis. We will
often consider systems consisting of @xmath qubits. If @xmath is a
2-dimensional Hilbert space corresponding to a single qubit, the system
of @xmath qubits is given by the @xmath -fold tensor product @xmath with
dimension @xmath . A basis for this larger Hilbert space can easily be
found by forming the tensor products of the basis vectors of a single
qubit. For example, the computational basis for an @xmath -qubit system
is given by the basis vectors @xmath where @xmath . We will often omit
the tensor product and use the shorthand @xmath .

If @xmath is not pure, then @xmath is a mixed state and can be written
as a mixture of pure states. That is, for any state @xmath there exist
@xmath with @xmath and vectors @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

Since @xmath is Hermitian, we can take @xmath and @xmath to be the
eigenvalues and eigenvectors of @xmath respectively. We thus have for
any quantum state that @xmath , where equality holds if and only if
@xmath is a pure state. We can also consider a mixture of quantum
states, pure or mixed. Suppose we have a physical system whose state
@xmath depends on some value @xmath of a classical random variable
@xmath drawn from @xmath according to a probability distribution @xmath
. For anyone who does not know the value of @xmath (but does know the
distribution @xmath ), the state of the system is given as

  -- -------- --
     @xmath   
  -- -------- --

We also call the set @xmath an ensemble , that gives rise to the density
matrix @xmath . We generally use the common shorthand @xmath . Clearly,
for any state @xmath we can take its eigendecomposition as above to find
one possible ensemble that gives rise to @xmath . With this
interpretation in mind, it is now intuitive why we wanted @xmath and
@xmath : the first condition ensures that @xmath has no negative
eigenvalues and hence all probabilities @xmath are non-negative. The
second condition ensures that the resulting distribution in indeed
normalized. We will use @xmath and @xmath to denote the set of all
density matrices and the set of all bounded operators on a system @xmath
respectively.

Let’s look at a small example illustrating the concept of mixed quantum
states. The density matrices corresponding to @xmath and @xmath are
@xmath and @xmath , and the density matrices corresponding to @xmath and
@xmath are given by @xmath and @xmath . Let’s suppose we are now told
that we are given a ’0’ but encoded in either the computational or
Hadamard basis, each with probability @xmath . Our quantum state
corresponding to this encoding of ’0’ is now

  -- -------- --
     @xmath   
  -- -------- --

The state corresponding to an encoding of ’1’ is similarly given by

  -- -------- --
     @xmath   
  -- -------- --

It is important to note that the same density matrix can be generated by
two different ensembles. As a simple example, consider the matrix @xmath
. Clearly, @xmath and @xmath and thus @xmath forms a valid one qubit
quantum state. However, @xmath and @xmath with @xmath and @xmath both
give rise to @xmath :

  -- -------- --
     @xmath   
  -- -------- --

Classical vs. Quantum
Quantum states exhibit an important property known as ‘‘no-cloning’’:
very much unlike classical states, we cannot create a copy of an
arbitrary quantum state! This is only possible with a small probability.
We refer to [ SIGA05 ] for an excellent overview of known results.

In the following, we call an ensemble classical if all states @xmath
commute. This is an interesting special case, we discuss in more detail
below.

##### 2.1.2 Multipartite systems

We frequently need to talk about a quantum state shared by multiple
players in a protocol. Let @xmath denote the Hilbert spaces
corresponding to the quantum systems of players 1 up to @xmath . As
outlined in the case of multiple qubits above, the joint system @xmath
of all players is formed by taking the tensor product. For example,
suppose that we have only two players, Alice and Bob. Let @xmath and
@xmath be the Hilbert spaces corresponding to Alice’s and Bob’s quantum
systems respectively. Any bipartite state @xmath shared by Alice and Bob
is a state living in the joint system @xmath . Bipartite states can
exhibit an interesting property called entanglement, which we
investigate in Chapter 6 . In short, if @xmath is a pure state, we say
that @xmath is separable if and only if there exist states @xmath and
@xmath such that @xmath . A separable pure state is also called a
product state . A state that is not separable is called entangled . An
example of an entangled pure state is the so-called EPR-pair

  -- -------- --
     @xmath   
  -- -------- --

For mixed states the definition is slightly more subtle. Let @xmath be a
mixed state. Then @xmath is called a product state if there exist @xmath
and @xmath such that @xmath . The state @xmath is called separable , if
there exists an ensemble @xmath such that @xmath with @xmath and @xmath
for all @xmath , such that

  -- -------- --
     @xmath   
  -- -------- --

Intuitively, if @xmath is separable then @xmath corresponds to a mixture
of separable pure states according to a classical joint probability
distribution @xmath . We return to such differences in Chapter 6 . From
a cryptographic perspective, it is for now merely important to note that
if the state @xmath shared between Alice and Bob is a pure state, then
@xmath is not entangled with any third system @xmath held by Charlie.
That is, @xmath does not depend on any classical random variable @xmath
held by Charlie whose value is unknown to Alice and Bob. An important
consequence is that the outcomes of any measurement (see below) that
Alice and Bob may perform on @xmath are therefore independent of @xmath
, and hence secret with respect to Charlie.

Given a quantum state in a combined, larger, system, what can we say
about the state of the individual systems? For example, given a state
@xmath shared between Alice and Bob, the reduced state of Alice’s system
alone is given by @xmath , where @xmath is the partial trace over Bob’s
system. The partial trace operation @xmath is thereby defined as the
unique linear operator that for all @xmath and all @xmath maps @xmath .
We also say that we trace out Bob’s system from @xmath to obtain @xmath
. Furthermore, given any state @xmath , we can always find a second
system @xmath and a pure state @xmath such that @xmath . We call @xmath
a purification of @xmath .

Classical vs. Quantum
In the quantum world, we encounter a particular effect known as
entanglement. Intuitively, entanglement leads to very strong
correlations among Alice and Bob’s system, which we will examine in
detail in Chapter 6 .

##### 2.1.3 Quantum operations

###### Unitary evolution

The evolution of any closed quantum system is described by a unitary
evolution @xmath that maps

  -- -------- --
     @xmath   
  -- -------- --

It is important to note that unitary operations are reversible: We can
always apply an additional unitary @xmath to retrieve the original state
since @xmath . In particular, we often make use of the following single
qubit unitaries known as the Pauli matrices

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Note that @xmath . Furthermore, we also use the Hadamard, and the
K-transform given by

  -- -------- --
     @xmath   
  -- -------- --

Note that @xmath .

###### Measurements

Besides unitary operations, we can also perform measurements on the
quantum state. A quantum measurement of a state @xmath is a set of
operators @xmath acting on @xmath , satisfying @xmath . We will call
operators @xmath measurement operators . The probability of obtaining
outcome @xmath when measuring the state @xmath is given by

  -- -------- --
     @xmath   
  -- -------- --

Conditioned on the event that we obtained outcome @xmath , the
post-measurement state of the system is now

  -- -------- --
     @xmath   
  -- -------- --

Most measurements disturb the quantum state and hence @xmath generally
differs from @xmath . We will discuss this effect in more detail below.
Note that we have @xmath , and hence the distribution over outcomes
@xmath is appropriately normalized.

A special case of a quantum measurement is a projective measurement ,
where all measurement operators @xmath are orthogonal projectors which
we write as @xmath . Projective measurements are also described via an
observable @xmath , where @xmath . Note that @xmath is a Hermitian
matrix with eigenvalues @xmath . For any given basis @xmath we speak of
measuring in the basis @xmath to indicate that we perform a projective
measurement given by operators @xmath with @xmath .

If we are only interested in the measurement outcome, but do not care
about the post-measurement state, it is often simpler to make use of the
POVM (positive operator valued measure) formalism. A POVM is a set of
Hermitian operators @xmath such that @xmath and for all @xmath we have
@xmath . Evidently, from a general measurement we can obtain a POVM by
letting @xmath . We now have

  -- -------- --
     @xmath   
  -- -------- --

The advantage of this approach is that we can easily solve optimization
problems involving probabilities @xmath over the operators @xmath ,
instead of considering the individual operators @xmath . Since @xmath
such problems can be solved using semidefinite programming, which we
describe in Appendix A . Finally, it is important to note that quantum
measurements do not always commute: it matters crucially in which order
we execute them. Indeed, as we will see later it is this property that
leads to all the interesting quantum effects we will consider.

Let’s consider a small example. Suppose we are given a pure quantum
state @xmath . When measuring @xmath in the computational basis, we
perform a measurement determined by operators @xmath and @xmath .
Evidently, we have

  -- -------- --
     @xmath   
  -- -------- --

and

  -- -------- --
     @xmath   
  -- -------- --

If we obtained outcome ’0’, the post-measurement state is given by

  -- -------- --
     @xmath   
  -- -------- --

Similarly, if we obtained outcome ’1’, the post-measurement state is

  -- -------- --
     @xmath   
  -- -------- --

###### Quantum channel

The most general way to describe an operation is by means of a CP
(completely positive) map @xmath , where @xmath and @xmath denote the in
and output systems respectively. We also call @xmath a channel . Any
channel @xmath can be written as @xmath where @xmath is a linear
operator from @xmath to @xmath , and @xmath . @xmath is also referred to
as a Kraus operator . @xmath is trace preserving if @xmath . Any quantum
operation can be expressed by means of a CPTP (completely positive trace
preserving) map . We sometimes also refer to such a map as a
superoperator , a quantum channel , or a (measurement) instrument , if
we think of a POVM with elements @xmath . A channel is called unital ,
if in addition @xmath : we then have @xmath .

We give two simple examples. Consider the unitary evolution @xmath of a
state @xmath : here we have @xmath . When we perform our single qubit
measurement in the computational basis described above, and ignore the
measurement outcome, we implement the channel @xmath . Since @xmath and
@xmath form a measurement and are projectors we also have that @xmath
and hence the channel is unital.

Any quantum channel can be described by a unitary transformation on the
original and an ancilla system, where the ancilla system is traced out
to recover the original operation. More precisely, given a channel
@xmath we can choose a Hilbert space @xmath identical to @xmath , a pure
state @xmath and a unitary matrix @xmath acting on @xmath such that for
any @xmath @xmath . This is all that we need here, and we refer to [
Hay06 ] for detailed information.

Of particular interest, especially with regard to constructing
cheat-sensitive protocols, is the following statement which specifies
which operations leave a given set of states invariant. Clearly, any
cheating party may always perform such operations without being
detected. It has been shown that {lemma} (HKL) [ HKL03 ] Let @xmath be a
unital quantum channel with @xmath , and let @xmath be a set of quantum
states. Then

  -- -------- --
     @xmath   
  -- -------- --

Indeed, the converse direction is easy to see. If we have that for all
@xmath and for all @xmath @xmath , then @xmath , since @xmath is unital.
If a quantum channel is not of this form, i.e. it does not leave the
state invariant, we also say that it disturbs the state. The statement
above has interesting consequences: consider an ensemble of states
@xmath with @xmath , and suppose that there exists a decomposition
@xmath such that for all @xmath we have @xmath where @xmath is a
projector onto @xmath . If we perform the measurement given by operators
@xmath then (ignoring the outcome) the states @xmath are invariant under
such a measurement, since clearly @xmath for all @xmath and @xmath . The
outcome of the measurement tells us which @xmath we reside in. However,
Lemma 2.1.3 tells us a lot more: We will see in Chapter 3.5.1 that if
the measurement operators from a projective measurement commute with all
the states @xmath , they are in fact of this very form (see also
Appendix B ). In the following, we call the information about which
@xmath we reside in the classical information of the ensemble @xmath .
Any attempt to gain more information, i.e. by performing measurements
which do not satisfy these commutation properties, necessarily leads to
disturbance and can be detected.

An adversary can thus always extract this classical information without
affecting the quantum state. Looking back at Chapter 1 , we can now see
that for unital adversary channels we can define an honest-but-curious
player to be honest-but-curious with regard to the classical
information, and honest with regard to the quantum information: he may
extract, copy and memorize the classical information as desired.
However, if he wants to leave the protocol execution itself unaltered,
he cannot perform any other measurements and must thus be honest on the
remaining quantum part of the ensemble.

Classical vs. Quantum
Clearly, Lemma 2.1.3 also tells us that if all the states @xmath in our
ensemble commute, i.e. the ensemble is classical as defined above, then
we can always perform a measurement in their common eigenbasis “for
free”. Furthermore, if our ensemble is classical we have @xmath , i.e.
@xmath itself is also classical: it is just a scalar. We thus see that
such an ensemble has no quantum properties: we can extract and copy
information at will. Informally, we may think of the different states
within the ensemble as different classical probability distributions
over their common eigenstates. We will return to this idea shortly.

Furthermore, we can look at measurements or observables themselves. Note
again from the above that since a quantum measurement may disturb a
state, it matters in which order measurements are executed. That is,
quantum operations do not commute. It is this fact that leads to all the
interesting effects we observe: uncertainty relations, locking and Bell
inequality violations using quantum entanglement are all consequences of
the existence of non-commuting measurements in the quantum world. This
lies in stark contrast to the classical world, where all our measurement
do commute, and we therefore do not encounter such effects.

#### 2.2 Distinguishability

How can we distinguish several quantum states? Suppose we are given
states @xmath where @xmath is a random variable drawn according to a
probability distribution @xmath over some finite set @xmath . Our goal
is now to determine the value of @xmath given an unknown state @xmath .
Cryptographically, this gives an intuitive measure on how well we can
guess the value of @xmath . The problem of finding the optimal
distinguishing measurement is called state discrimination , where
optimal refers to finding the measurement that maximizes the probability
of successfully guessing @xmath . For two states, the optimal guessing
probability is particularly simple to evaluate. To this end, we first
need to introduce the trace distance, and the trace norm: {definition}
The trace distance of two states @xmath and @xmath is given by

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the trace norm of @xmath . Alternatively, the trace
distance may also be expressed as [ Hay06 ]

  -- -------- --
     @xmath   
  -- -------- --

where the maximization is taken over all @xmath . Indeed, @xmath is
really a “distance” measure, as it is clearly a metric on the space of
density matrices: We have @xmath if and only if @xmath , and evidently
@xmath . Finally, the triangle inequality holds:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

When considering single qubits (such as for example in Chapter 11 ) it
is often intuitive to note that for a single qubit, the trace distance
has a particularly simple form. Note that @xmath , @xmath , @xmath and
@xmath form a basis for the space of @xmath complex matrices. Since we
have @xmath for any quantum state, we can thus write any single qubit
state as

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath is the Bloch vector as given in Figure 2.1 .

For @xmath with @xmath we then have

  -- -------- --
     @xmath   
  -- -------- --

where we used the fact that all Pauli matrices anti-commute. Thus, the
trace distance between @xmath and @xmath is exactly half the Euclidean
distance of the corresponding Bloch vectors.

Using the trace distance, we can address the problem of distinguishing
two quantum states: {theorem} [Helstrom [ Hel67 ] ] Suppose we are given
states @xmath with probability @xmath , and @xmath with probability
@xmath . Then the probability to determine whether the state was @xmath
and @xmath is at most

  -- -------- --
     @xmath   
  -- -------- --

The measurement that achieves @xmath is given by @xmath , and @xmath ,
where @xmath is the projector onto the positive eigenspace of @xmath .

For @xmath , this gives us @xmath . Indeed, it is easy to see why such
@xmath and @xmath form the optimal measurement. Note that here we are
only interested in finding a POVM. To find the optimal POVM we must
solve the following optimization problem for variables @xmath and @xmath
:

  ------------ ----------
  maximize     @xmath
  subject to   @xmath ,
               @xmath .
  ------------ ----------

We can rewrite our target function as

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
                       @xmath   
  -- -------- -------- -------- --

where @xmath . Hence, to maximize the above expression, we need to
choose @xmath .

Unfortunately, computing the optimal measurement to distinguish more
than two states is generally not so easy. Yuen, Kennedy and Lax [ YKL75
] first showed that this problem can be solved using semidefinite
programming, a technique we describe in Appendix A . This technique has
since been refined to address other variants such as unambiguous state
discrimination where we can output “don’t know”, but are never allowed
to make a mistake [ Eld03 ] . Evidently, we can express the optimization
problem for any state discrimination problem as

  ------------ ----------
  maximize     @xmath
  subject to   @xmath ,
               @xmath .
  ------------ ----------

In Chapter 3 , we will use the above formulation. We also show how to
address a variant of this problem, where we receive additional classical
information after performing the measurement.

Closely related to the trace distance is the notion of fidelity.
{definition} The fidelity of states @xmath and @xmath is given by

  -- -------- --
     @xmath   
  -- -------- --

Note that if @xmath is a pure state, this becomes

  -- -------- --
     @xmath   
  -- -------- --

The fidelity is closely related to the trace distance. In particular, we
have that for any states @xmath and @xmath

  -- -------- --
     @xmath   
  -- -------- --

A proof can be found in [ NC00 , Section 9.2.3] . If @xmath is a pure
state, the lower bound can be improved to

  -- -------- --
     @xmath   
  -- -------- --

Many other distance measures of quantum states are known, which may be a
more convenient choice for particular problems. We refer to [ Fuc95 ,
Hay06 ] for an overview.

Classical vs. Quantum
Suppose again we are given a classical ensemble of states @xmath and
@xmath . That is, both operators commute and hence have a common
eigenbasis @xmath . We can thus write @xmath and @xmath , which allows
us to write the trace distance of @xmath and @xmath as

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the classical variational distance between the
distributions @xmath and @xmath . Again, we see that there is nothing
quantum in this setting. We can view @xmath and @xmath as two different
probability distributions over the set @xmath . Similarly, it is easy to
see that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the classical fidelity of the distributions @xmath and
@xmath .

#### 2.3 Information measures

##### 2.3.1 Classical

We also need the following ways of measuring information. Let @xmath be
a random variable distributed over a finite set @xmath according to
probability distribution @xmath . The Shannon entropy of @xmath is then
given by

  -- -------- --
     @xmath   
  -- -------- --

Intuitively, the Shannon entropy measures how much information we gain
on average by learning @xmath . A complementary view point is that
@xmath quantifies the amount of uncertainty we have about @xmath before
the fact. We will also use @xmath , if our discussion emphasizes a
certain distribution @xmath . If @xmath , we also use the term binary
entropy and use the shorthand

  -- -------- --
     @xmath   
  -- -------- --

Let @xmath be a second random variable distributed over a finite set
@xmath according to distribution @xmath . The joint entropy of @xmath
and @xmath can now be expressed as

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the joint distribution over @xmath . Furthermore, we can
quantify the uncertainty about @xmath given @xmath by means of the
conditional entropy

  -- -------- --
     @xmath   
  -- -------- --

To quantify the amount of information @xmath and @xmath may have in
common we use the mutual information

  -- -------- --
     @xmath   
  -- -------- --

Intuitively the mutual information captures the amount of information we
gain about @xmath by learning @xmath . The Shannon entropy has many
interesting properties, summarized, for example, in [ NC00 , Theorem
11.3] , but we do not require them here. In Chapter 5 , we only need the
classical mutual information of a bipartite quantum state @xmath , which
is the maximum classical mutual information that can be obtained by
local measurements @xmath on the state @xmath [ THLD02 ] :

  -- -------- -- -------
     @xmath      (2.1)
  -- -------- -- -------

where @xmath and @xmath are the random variables corresponding to
Alice’s and Bob’s measurement outcomes respectively.

In a cryptographic setting, the Shannon entropy is not always a
desirable measure as it merely captures our uncertainty about @xmath on
average . Often, the Rényi entropy allows us to make stronger statements
The Rényi entropy [ Rén60 ] of order @xmath is defined as

  -- -------- --
     @xmath   
  -- -------- --

Indeed, the Shannon entropy forms a special case of the Rényi entropy by
taking the limit @xmath , i.e., @xmath , where we omit the subscript. Of
particular importance is the min-entropy , for @xmath :

  -- -------- --
     @xmath   
  -- -------- --

and the collision entropy

  -- -------- --
     @xmath   
  -- -------- --

We have

  -- -------- --
     @xmath   
  -- -------- --

Intuitively, the min-entropy is determined by the highest peak in the
distribution and most closely captures the notion of “guessing” @xmath .
Consider the following example: Let @xmath and let @xmath be the all 0
string. Suppose that @xmath and @xmath for @xmath , i.e., with
probability @xmath we choose @xmath and with probability @xmath we
choose one string uniformly at random. Then @xmath , whereas @xmath ! If
@xmath would correspond to an encryption key used to encrypt an @xmath
bit message, we would certainly not talk about security if we can guess
the key with probability @xmath ! Yet, the Shannon entropy is quite
high. We refer to [ Cac97 ] for an in-depth discussion of security
measures in classical cryptography.

##### 2.3.2 Quantum

Similar to the Shannon entropy, the von Neumann entropy of a quantum
states @xmath is given by

  -- -------- --
     @xmath   
  -- -------- --

Taking the eigendecomposition of @xmath we can also write

  -- -------- --
     @xmath   
  -- -------- --

which corresponds to the Shannon entropy arising from measuring @xmath
in the basis given by @xmath . We refer to [ NC00 , Section 11.3] for
the properties of the von Neumann entropy.

Here, we will only be concerned with the accessible information [ Per93
, Eq. (9.75)] of an ensemble @xmath which we encounter again in Chapter
5 .

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and the maximization is taken over all POVMs @xmath . It
has been shown that we can take all POVM elements to be of rank 1 [
Dav78 ] . However, maximizing this quantity still remains a hard task [
Per93 ] . Some upper and lower bounds are known [ Fuc95 ] , but sadly
none of them are generally very strong. The most well-known upper bound
is given by the Holevo quantity , which is given by

  -- -------- --
     @xmath   
  -- -------- --

Holevo’s theorem [ NC00 ] states that

  -- -------- -- -------
     @xmath      (2.2)
  -- -------- -- -------

Classical vs. Quantum
Equality in Eq. ( 2.2 ) is achieved if all states @xmath have a common
eigenbasis (i.e., all @xmath commute). Hence, for classical ensembles we
do not have a gap between these two quantities. The fact that quantumly
we can obtain such a gap leads to a peculiar effect known as locking
classical information in quantum states in Chapter 5 . However, even if
the states @xmath do not commute, we can still extract the “classical
information” of the ensemble: Suppose for all @xmath from our ensemble
there exists a decomposition @xmath such that for all @xmath , @xmath ,
where @xmath is a projector onto @xmath . That is, there exists a way to
simultaneously block-diagonalize all states. Note that for any
measurement maximizing the accessible information above, we can find an
equivalent measurement with measurement operators @xmath , since
evidently, @xmath . Intuitively, this means that we can always first
determine which block we are in “for free”, followed by our original
measurement constrained to this block. Note that @xmath for all @xmath
and @xmath . Hence, looking back at Section 2.1.3 this is not so
surprising: the measurement leaves our states invariant. In general,
such commutation relations lead to interesting structural consequences
which we examine in more detail in Appendix B and also exploit in
Chapter 3 . Finally, it will be useful in Chapter 10 that the accessible
information is additive [ Hol73 , DLT02 ] : For @xmath independent draws
of an ensemble @xmath of separable states (see Chapter 6 ), i.e., we
choose @xmath states from @xmath identical ensembles independently, we
have @xmath .

#### 2.4 Mutually unbiased bases

In the following chapters, we will be particularly concerned with
measurements in mutually unbiased bases (MUBs). MUBs were initially
introduced in the context of state estimation [ WF89 ] , but feature in
many other problems in quantum information. The following definition
closely follows the one given in [ BBRV02 ] . {definition} [MUBs] Let
@xmath and @xmath be two orthonormal bases in @xmath . They are said to
be mutually unbiased if @xmath , for every @xmath . A set @xmath of
orthonormal bases in @xmath is called a set of mutually unbiased bases
if each pair of bases is mutually unbiased.

As an example, consider the computational and the Hadamard basis defined
above, and note that we can write @xmath and @xmath . We then have for
@xmath that

  -- -------- --
     @xmath   
  -- -------- --

Hence, the computational and the Hadamard basis are mutually unbiased in
dimension @xmath .

We use @xmath to denote the maximal number of MUBs in dimension @xmath .
In any dimension @xmath , we have that @xmath [ BBRV02 ] . If @xmath is
a prime power, we have that @xmath and explicit constructions are known
[ BBRV02 , WF89 ] . If @xmath is a square, @xmath where @xmath denotes
the number of mutually orthogonal @xmath Latin squares [ WB05 ] . In
general, we have @xmath for all @xmath [ Zau99 , KR03 ] . It is also
known that in any dimension, there exists an explicit construction for 3
MUBs [ Gra04 ] . Unfortunately, not much else is known. For example, it
is still an open problem whether there exists a set of @xmath MUBs in
dimension @xmath . We say that a unitary @xmath transforms the
computational basis into the @xmath -th MUB @xmath if for all @xmath we
have @xmath . In the next two chapters, we will be particularly
concerned with two specific constructions of mutually unbiased bases.
There exists a third construction based on Galois rings [ KR04 ] , which
we do not consider here.

##### 2.4.1 Latin squares

First, we consider MUBs based on mutually orthogonal Latin squares [
WB05 ] . Informally, an @xmath Latin square over the symbol set @xmath
is an arrangement of elements of @xmath into an @xmath square such that
in each row and each column every element occurs exactly once. Let
@xmath denote the entry in a Latin square in row @xmath and column
@xmath . Two Latin squares @xmath and @xmath are called mutually
orthogonal if and only if @xmath . Intuitively, this means that if we
place one square on top of the other, and look at all pairs generated by
the overlaying elements, all possible pairs occur. An example is given
in Figures 2.3 and 2.3 below. From any @xmath Latin square we can obtain
a basis for @xmath . First, we construct @xmath of the basis vectors
from the entries of the Latin square itself. Let

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is a predicate such that @xmath if and only if @xmath .
Note that for each @xmath we have exactly @xmath pairs @xmath such that
@xmath , because each element of @xmath occurs exactly @xmath times in
the Latin square. Secondly, from each such vector we obtain @xmath
additional vectors by adding successive rows of an @xmath complex
Hadamard matrix @xmath as coefficients to obtain the remaining @xmath
for @xmath , where @xmath with @xmath and @xmath . Two additional MUBs
can then be obtained in the same way from the two non-Latin squares
where each element occurs for an entire row or column respectively. From
each mutually orthogonal Latin square and these two extra squares which
also satisfy the above orthogonality condition, we obtain one basis.
This construction therefore gives @xmath many MUBs. It is known that if
@xmath is a prime power itself, we obtain @xmath MUBs from this
construction. Note, however, that there do exist many more MUBs in prime
power dimensions, namely @xmath . If @xmath is not a prime power, it is
merely known that @xmath [ WB05 ] .

As an example, consider the @xmath Latin square depicted in Figure 2.3
and the @xmath complex Hadamard matrix

  -- -------- --
     @xmath   
  -- -------- --

where @xmath . First, we obtain vectors

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

With the help of @xmath we obtain 3 additional vectors from the ones
above. From the vector @xmath , for example, we obtain

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

This gives us basis @xmath for @xmath . The construction of another
basis follows in exactly the same way from a mutually orthogonal Latin
square. The fact that two such squares @xmath and @xmath are mutually
orthogonal ensures that the resulting bases will be mutually unbiased.
Indeed, suppose we are given another such basis, @xmath belonging to
@xmath . We then have for any @xmath that @xmath , as there exists
exactly only one pair @xmath such that @xmath . Clearly, the same
argument holds for the additional vectors derived from the complex
Hadamard matrix.

##### 2.4.2 Generalized Pauli matrices

The second construction we consider is based on the generalized Pauli
matrices @xmath and @xmath [ BBRV02 ] , defined by their actions on the
computational basis @xmath as follows:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

where @xmath . We say that @xmath for @xmath and @xmath is a string of
Pauli matrices .

If @xmath is a prime, it is known that the @xmath MUBs constructed first
by Wootters and Fields [ WF89 ] can also be obtained as the eigenvectors
of the matrices @xmath [ BBRV02 ] . If @xmath is a prime power, consider
all @xmath possible strings of Pauli matrices excluding the identity and
group them into sets @xmath such that @xmath and @xmath for @xmath and
all elements of @xmath commute. Let @xmath be the common eigenbasis of
all elements of @xmath . Then @xmath are MUBs [ BBRV02 ] . A similar
result for @xmath has also been shown in [ LBZ02 ] . A special case of
this construction are the three mutually unbiased bases in dimension
@xmath given by the unitaries @xmath , @xmath and @xmath (as defined on
page 2.1.3 ) applied to the computational basis.

#### 2.5 Conclusion

We summarized the most important elements of quantum theory that we need
here. We refer to [ Per93 , NC00 , Hay06 ] for more information about
each topic. In Chapters 4 and 6 we investigate the two most striking
aspects of quantum theory in detail: uncertainty relations and
entanglement. But first, let’s examine the case of state discrimination
with additional post-measurement information.

### Chapter 3 State discrimination with post-measurement information

In this chapter, we investigate an extension of the traditional state
discrimination problem we encountered in Chapter 2.2 : what if we are
given some additional information after the measurement? Imagine that
you are given a string @xmath encoded in an unknown basis chosen from a
known set of bases. You may perform any measurement, but you can only
store at most @xmath qubits of quantum information afterwards. Later on,
you are told which basis was used. How well can you compute a function
@xmath of @xmath , given the initial measurement outcome, the @xmath
qubits and the additional basis information?

#### 3.1 Introduction

This question is of central importance for protocols in the bounded
quantum storage model [ DFSS05 ] , which we encountered in Chapter 1 .
The security of such protocols rests on the realistic assumption that a
dishonest player cannot store more than @xmath qubits for long periods
of time. In this model, even bit commitment and oblivious transfer can
be implemented securely which is otherwise known to be impossible as we
saw in Chapter 1 . We formalize this general setting as a state
discrimination problem: Here, we are given additional information about
the state after the measurement or, more generally, after a quantum
memory bound is applied. We prove general bounds on the success
probability for any balanced function. We also show that storing just a
single qubit allows you to compute any Boolean function perfectly when
two bases are used. However, we also construct three bases for which you
need to keep all qubits.

In general, we consider the following problem: Take an ensemble of
quantum states, @xmath , with double indices @xmath , and an integer
@xmath . Suppose Alice sends Bob the state @xmath , where she alone
knows indices @xmath and @xmath . Bob can perform any measurement on his
system, but afterwards store at most @xmath qubits, and an unlimited
amount of classical information. Afterwards, Alice tells him @xmath .
Bob’s goal is now to approximate @xmath as accurately as possible, which
means that he has to make a guess @xmath that maximizes the success
probability @xmath For @xmath , i.e., no post-measurement information is
available, @xmath is irrelevant and Bob’s task is to discriminate among
states @xmath . This is the well-known state discrimination problem,
which we encountered in Chapter 2.2 , a problem studied since the early
days of quantum information science.

A particular case that isolates the aspect of the timing between
measurements and side-information is one where for each fixed @xmath ,
the states @xmath are mutually orthogonal: if Bob knew @xmath , he could
actually compute @xmath perfectly. A special case of this problem is
depicted in Figure 3.1 . Here, Alice picks a string @xmath , and a basis
@xmath . She then encodes the string in the chosen basis and sends the
resulting state to Bob. Bob’s goal is now to determine @xmath for a
fixed function @xmath . The states in this particular problem are thus
of the form @xmath , for a function @xmath , and a set of mutually
unbiased bases (MUBs) @xmath , given by the unitaries @xmath on a
Hilbert space with basis @xmath , where the string @xmath and a basis
@xmath are drawn from the distribution @xmath . We mostly focus on this
special case.

This problem also has an interpretation in terms of communication
complexity. Suppose Alice is given @xmath , and Bob is given the state
@xmath . If classical communication is free, what is the minimum number
of qubits Bob needs to send to Alice such that Alice learns @xmath ?
Note that Bob needs to send exactly @xmath qubits if and only if there
exists a strategy for Bob to compute @xmath in our task, while storing
only @xmath qubits.

##### 3.1.1 Outline

In the following, we will close in on our problem in several stages.
First, we briefly recall the case of state discrimination without any
post-measurement information in Section 3.3 . This enables us to draw
comparisons later.

Second, in Section 3.4 we assume that Bob does receive post-measurement
information, but has no quantum memory at all, i.e. @xmath . His goal
then is to compute @xmath given the classical outcome obtained by
measuring @xmath and the later announcement of @xmath . Clearly, a
trivial strategy for Bob is to simply guess the basis, measure to obtain
some string @xmath and take @xmath as his answer. We thus want to find a
better strategy. In particular, we will see that for any number of MUBs,
any number of function outcomes, and any balanced @xmath , Bob has a
systematic advantage over guessing the basis, independent of @xmath .
Furthermore, we show that for any Boolean @xmath , Bob can succeed with
probability at least @xmath even if he cannot store any qubits at all.
The latter result is relevant to the question of whether deterministic
privacy amplification is possible in the protocols of [ DFSS05 ] . Here,
Alice uses two MUBs, and secretly chooses a function from a set of
predetermined functions. She later tells Bob which function he should
evaluate, together with the basis information @xmath . Is it possible to
use a fixed Boolean function instead? Our result shows that this is not
possible.

It is interesting to consider when post-measurement information is
useful for Bob, and how large his advantage is compared to the case
where he does not receive any post-measurement information. To this end,
we show how to phrase our problem as a semidefinite program (SDP), in
the case where Bob has no quantum memory. In Section 3.4.2 , we examine
in detail the specific functions XOR and AND, for which we prove optimal
bounds on Bob’s success probability. In particular, the XOR on uniformly
distributed strings of length @xmath with two or three MUBs provides an
extreme example of the usefulness of post-measurement information: We
show that for the XOR function with @xmath odd, @xmath . This is the
same as Bob can achieve without the extra basis information. For even
@xmath , @xmath with the additional basis information. Here, @xmath
jumps from @xmath (without) to certainty (with basis information). The
advantage that Bob gains can thus be maximal: without the
post-measurement information, he can do no better than guessing the
basis. However, with it, he can compute @xmath perfectly. For even
@xmath , this was also observed in [ DFSS05 ] . However, our analysis
for odd @xmath shows that the strategy for even @xmath does not work for
any linear function as claimed in [ DFSS05 ] . It remains an interesting
question to find general conditions on the ensemble of states that
determine how useful post-measurement information can be. We return to
this question in Chapter 6.4 .

Finally, we address the case where Bob does have quantum memory
available. The question we are then interested in is: How large does
this memory have to be so that Bob can compute @xmath perfectly? In
Section 3.5.1 , we derive general conditions that determine when @xmath
qubits are sufficient. Our conditions impose a restriction on the rank
of Bob’s measurement operators and require that all such operators
commute with the projector onto the support of @xmath , for all @xmath
and @xmath . In particular, we give a general algebraic framework that
allows us to determine @xmath for any number of bases, functions and
outcomes, in combination with an algorithm given in [ KI02 ] . In
Sections 3.5.2 and 3.5.3 , we then consider two specific examples:
First, we show that for any Boolean @xmath and any two bases, storing
just a single qubit is sufficient for Bob to compute @xmath perfectly.
The latter result again has implications to protocols in the bounded
quantum storage model: for all existing protocols, deterministic privacy
amplification is indeed hopeless. It turns out that part of this
specific example also follows from known results derived for non-local
games as we will discuss below. Surprisingly, things change dramatically
when we are allowed to use three bases: We show how to construct three
bases, such that for any balanced @xmath Bob needs to keep all qubits in
order to compute @xmath perfectly!

##### 3.1.2 Related work

In Chapter 2.2 , we already examined the traditional setting of state
discrimination without post-measurement information. Some of the tools
we need below have found use in this setting as well. Many convex
optimization problems can be solved using semidefinite programming. We
refer to Appendix A for a introduction. Eldar [ Eld03 ] and Eldar,
Megretski and Verghese [ EMV03 ] used semidefinite programming to solve
state discrimination problems, which is one of the techniques we also
use here. The square-root measurement [ HW94 ] (also called pretty good
measurement) is an easily constructed measurement to distinguish quantum
states, however, it is only optimal for very specific sets of states [
EF01 , EMV04 ] . Mochon constructed specific pure state discrimination
problems for which the square-root measurement is optimal [ Moc07a ] .
We use a variant of the square-root measurement as well. Furthermore,
our problem is related to the task of state filtering [ BHH03 , BHH05 ,
BH05 ] and state classification [ WY06 ] . Here, Bob’s goal is to
determine whether a given state is either one specific state or one of
several other possible states, or, more generally, which subset of
states a given state belongs to. Our scenario differs, because we deal
with mixed states and Bob is allowed to use post-measurement
information. Much more is known about pure state discrimination problems
and the case of unambiguous state discrimination where we are not
allowed to make an error. Since we concentrate on mixed states, we refer
to [ BHH04 ] for an excellent survey on the extended field of state
discrimination.

Regarding state discrimination with post-measurement information,
special instances of the general problem have occurred in the literature
under the heading “mean king’s problem” [ AE01 , KR05 ] , where the
stress was on the usefulness of entanglement. Furthermore, it should be
noted that prepare-and-measure quantum key distribution schemes of the
BB84 type also lead to special cases of this problem: When considering
optimal individual attacks, the eavesdropper is faced with the task of
extracting maximal information about the raw key bits, encoded in an
unknown basis, that she learns later during basis reconciliation.

Our result that one qubit of storage suffices for any Boolean function
@xmath demonstrates that storing quantum information can give an
adversary a great advantage over storing merely classical information.
It has also been shown in the context of randomness extraction with
respect to a quantum adversary that storing quantum information can
sometimes convey much more power to the adversary [ GKK @xmath 06 ] .

#### 3.2 Preliminaries

##### 3.2.1 Notation and tools

We need the following notions. The Bell basis is given by the vectors
@xmath and @xmath . Furthermore, let @xmath . We say that a function
@xmath is balanced if and only if any element in the image of @xmath is
generated by equally many elements in the pre-image of @xmath , i.e.
there exists a @xmath such that @xmath .

##### 3.2.2 Definitions

We now give a more formal description of our problem. Let @xmath and
@xmath be finite sets and let @xmath be a probability distribution over
@xmath . Consider an ensemble of quantum states @xmath . We assume that
@xmath , @xmath , @xmath and @xmath are known to both Alice and Bob.
Suppose now that Alice chooses @xmath according to probability
distribution @xmath , and sends @xmath to Bob. We can then define the
tasks:

{definition}

State discRimination ( @xmath ) is the following task for Bob. Given
@xmath , determine @xmath . He can perform any measurement on @xmath
immediately upon receipt.

{definition}

State discRimination with Post-measurement Information ( @xmath ) is the
following task for Bob. Given @xmath , determine @xmath , where Bob can
use the following sources of information in succession:

1.  First, he can perform any measurement on @xmath immediately upon
    reception. Afterwards, he can store at most @xmath qubits of quantum
    information about @xmath , and an unlimited amount of classical
    information.

2.  After Bob’s measurement, Alice announces @xmath .

3.  Then, he may perform any measurement on the remaining @xmath qubits
    depending on @xmath and the measurement outcome obtained in step 1.

We also say that Bob succeeds at @xmath or @xmath with probability
@xmath if and only if @xmath is the average success probability @xmath ,
where @xmath is the probability that Bob correctly determines @xmath
given @xmath in the case of STAR, and in addition using information
sources 1 , 2 and 3 in the case of PI-STAR.

Here, we are interested in the following special case: Consider a
function @xmath between finite sets, and a set of mutually unbiased
bases @xmath as defined in Chapter 2 , generated by a set of unitaries
@xmath acting on a Hilbert space with basis { @xmath }. Take @xmath .
Let @xmath and @xmath be probability distributions over @xmath and
@xmath respectively. We assume that @xmath , @xmath , @xmath , @xmath ,
@xmath , @xmath , and the set of unitaries @xmath are known to both
Alice and Bob. Suppose now that Alice chooses @xmath and @xmath
independently according to probability distributions @xmath and @xmath
respectively, and sends @xmath to Bob. Bob’s goal is now to compute
@xmath . We thus obtain an instance of our problem with states @xmath .
We write @xmath and @xmath to denote both problems in this special case.
We concentrate on the case of mutually unbiased bases, as this case is
most relevant to our initial goal of analyzing protocols for quantum
cryptography in the bounded storage model [ DFSS05 ] .

Here, we make use of the basis set @xmath , where @xmath is the
computational basis, @xmath is the Hadamard basis, and @xmath is what we
call the K-basis. The unitaries that give rise to these bases are @xmath
, @xmath and @xmath with @xmath respectively. Recall from Chapter 2 that
the Hadamard matrix is given by @xmath , and that @xmath , @xmath and
@xmath are the well-known Pauli matrices. We generally assume that Bob
has no a priori knowledge about the outcome of the function and about
the value of @xmath . This means that @xmath is chosen uniformly at
random from @xmath , and, in the case of balanced functions, that Alice
chooses @xmath uniformly at random from @xmath . More generally, the
distribution is uniform on all @xmath and such that each value @xmath is
equally likely.

##### 3.2.3 A trivial bound: guessing the basis

Note that a simple strategy for Bob is to guess the basis, and then
measure. This approach leads to a lower bound on the success probability
for both and . In short: {lemma} Let @xmath for all @xmath . Let @xmath
denote the set of bases. Then for any balanced function @xmath Bob
succeeds at @xmath and @xmath with probability at least

  -- -- --
        
  -- -- --

Our goal is to beat this bound. We show that for , Bob can indeed do
much better.

#### 3.3 No post-measurement information

We first consider the standard case of state discrimination. Here, Alice
does not supply Bob with any additional post-measurement information.
Instead, Bob’s goal is to compute @xmath immediately. This analysis
enables us to gain interesting insights into the usefulness of
post-measurement information later.

##### 3.3.1 Two simple examples

We now examine two simple one-qubit examples of a state discrimination
problem, which we make use of later on. Here, Bob’s goal is to learn the
value of a bit which has been encoded in two or three mutually unbiased
bases while he does not know which basis has been used.

{lemma}

Let @xmath , @xmath and @xmath . Let @xmath with @xmath and @xmath .
Then Bob succeeds at @xmath with probability at most

  -- -------- --
     @xmath   
  -- -------- --

There exists a strategy for Bob that achieves @xmath . Proof. The
probability of success follows from Theorem 2.1 with @xmath , @xmath and
@xmath . @xmath

{lemma}

Let @xmath , @xmath and @xmath . Let @xmath with @xmath , @xmath and
@xmath . Then Bob succeeds at @xmath with probability at most

  -- -------- --
     @xmath   
  -- -------- --

There exists a strategy for Bob that achieves @xmath . Proof. The proof
is identical to that of Lemma 3.3.1 using @xmath , @xmath , and @xmath .
@xmath

##### 3.3.2 An upper bound for all Boolean functions

We now show that for any Boolean function @xmath and any number of
mutually unbiased bases, the probability that Bob succeeds at @xmath is
very limited. {theorem} Let @xmath and let @xmath be a balanced
function. Let @xmath be a set of mutually unbiased bases. Then Bob
succeeds at @xmath with probability at most

  -- -------- --
     @xmath   
  -- -------- --

In particular, for @xmath we obtain @xmath ; for @xmath , we obtain
@xmath . Proof. The probability of success is given by Theorem 2.1 where
for @xmath

  -- -------- --
     @xmath   
  -- -------- --

with @xmath . Using the Cauchy-Schwarz inequality we can show that

  -- -------- -- -------
     @xmath      (3.1)
  -- -------- -- -------

or

  -- -------- --
     @xmath   
  -- -------- --

A simple calculation shows that

  -- -------- --
     @xmath   
  -- -------- --

The theorem follows from the previous equation, together with Theorem
2.1 and Eq. ( 3.1 ). @xmath

##### 3.3.3 AND function

One of the simplest functions to consider is the AND function. Recall,
that we always assume that Bob has no a priori knowledge about the
outcome of the function. In the case of the AND, this means that we are
considering a very specific prior: with probability @xmath Alice will
choose the only string @xmath for which @xmath . Without any
post-measurement information, Bob can already compute the AND quite
well. {theorem} Let @xmath for all @xmath and @xmath . Let @xmath with
@xmath , @xmath and @xmath . Then Bob succeeds at @xmath with
probability at most

  -- -------- -- -------
     @xmath      (3.2)
  -- -------- -- -------

There exists a strategy for Bob that achieves @xmath . Proof. Let @xmath
and @xmath . Eq. ( 3.2 ) is obtained by substituting

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

and @xmath in Theorem 2.1 . @xmath

In Theorem 3.4.2 , we show an optimal bound for the case that Bob does
indeed receive the extra information. By comparing the previous equation
with Eq. ( 3.4 ) later on, we can see that for @xmath announcing the
basis does not help. However, for @xmath we will observe an improvement
of @xmath .

##### 3.3.4 XOR function

The XOR function provides an example of a Boolean function where we
observe both the largest advantage as well as the smallest advantage in
receiving post-measurement information: For strings of even length we
show that without the extra information Bob can never do better than
guessing the basis. For strings of odd length, however, he can do quite
a bit better. Interestingly, it turns out that in this case the
post-measurement information is completely useless to him. We first
investigate how well Bob does at @xmath for two bases:

{theorem}

Let @xmath for all @xmath . Let @xmath with @xmath , @xmath and @xmath .
Then Bob succeeds at @xmath with probability at most

  -- -- --
        
  -- -- --

There exists a strategy for Bob that achieves @xmath . Proof. Our proof
works by induction on @xmath . The case of @xmath was addressed in Lemma
3.3.1 . Now, consider @xmath : Let @xmath and @xmath , where @xmath and
@xmath are defined as @xmath with @xmath and @xmath . A straightforward
calculation shows that @xmath .

We now show that the trace distance does not change when we go from
strings of length @xmath to strings of length @xmath : Note that we can
write

  -- -------- -- -------
     @xmath      (3.3)
  -- -------- -- -------

Let @xmath and @xmath . A small calculation shows that

  -- -- --
        
  -- -- --

We then get that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath . Consider the unitary @xmath if @xmath is odd,
and @xmath if @xmath is even. It is easy to verify that @xmath and
@xmath . We thus have that @xmath and therefore

  -- -------- --
     @xmath   
  -- -------- --

It then follows from Helstrom’s Theorem 2.1 that the maximum probability
to distinguish @xmath from @xmath and thus compute the XOR of the @xmath
bits is given by

  -- -------- --
     @xmath   
  -- -------- --

which gives the claimed result. @xmath

A similar argument is possible, if we use three mutually unbiased bases.
Intuitively, one might expect Bob’s chance of success to drop as we had
more bases. Interestingly, however, we obtain the same bound of 3/4 if
@xmath is even.

{theorem}

Let @xmath for all @xmath . Let @xmath with @xmath , @xmath , and @xmath
with @xmath . Then Bob succeeds at @xmath with probability at most

  -- -- --
        
  -- -- --

There exists a strategy for Bob that achieves @xmath . Proof. Our proof
is very similar to the case of only 2 mutually unbiased bases. The case
of @xmath follows from Lemma 3.3.1 . This time, we have for @xmath :
@xmath and @xmath . We have @xmath .

We again show that the trace distance does not change when we go from
strings of length @xmath to strings of length @xmath . We use the
definitions from Eq. ( 3.3 ) and let

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

We can compute

  -- -------- --
     @xmath   
  -- -------- --

where @xmath , @xmath , @xmath , @xmath , @xmath , and @xmath . Consider
the unitaries @xmath , @xmath , and @xmath if @xmath is odd, and @xmath
, @xmath , and @xmath if @xmath is even. It is easily verified that
@xmath , @xmath , @xmath , @xmath , @xmath , and @xmath . We then get
that

  -- -------- --
     @xmath   
  -- -------- --

from which the claim follows. @xmath

Surprisingly, if Bob does have some a priori knowledge about the outcome
of the XOR the problem becomes much harder for Bob. By expressing the
states in the Bell basis and using Helstrom’s result, it is easy to see
that if Alice chooses @xmath such that with probability @xmath , @xmath
, and with probability @xmath , @xmath , Bob’s probability of learning
@xmath correctly is minimized for @xmath . In that case, Bob succeeds
with probability at most @xmath , which can be achieved by the trivial
strategy of ignoring the state he received and always outputting 1. This
is an explicit example where making a measurement does not help in state
discrimination. It has previously been noted by Hunter [ Hun03 ] that
such cases can exist in mixed-state discrimination.

#### 3.4 Using post-measurement information

We are now ready to advance to the core of our problem. We first
consider the case where Bob does receive post-measurement information,
but still has no quantum memory at his disposal. Consider an instance of
@xmath with a function @xmath and @xmath bases, and some priors @xmath
and @xmath on the sets @xmath and @xmath . If Bob cannot store any
quantum information, all his nontrivial actions are contained in the
first measurement, which must equip him with possible outputs @xmath for
each basis @xmath . In other words, his most general strategy is a POVM
with @xmath outcomes, each labeled by the strings @xmath for @xmath and
@xmath . Once Alice has announced @xmath , Bob outputs @xmath . Here we
first prove a general lower bound on the usefulness of post-measurement
information that beats the guessing bound. Then, we analyze in detail
the AND and the XOR function on @xmath bits.

##### 3.4.1 A lower bound for balanced functions

We first give a lower bound on Bob’s success probability for any
balanced function and any number of mutually unbiased bases, by
constructing an explicit measurement that achieves it. Without loss of
generality, we assume in this section that @xmath , as otherwise we
could consider a lexicographic ordering of @xmath .

{theorem}

Let @xmath be a balanced function, and let @xmath and @xmath be the
uniform distributions over @xmath and @xmath respectively. Let the set
of unitaries @xmath give rise to @xmath mutually unbiased bases, and
choose an encoding such that @xmath . Then Bob succeeds at @xmath with
probability at least

  -- -- --
        
  -- -- --

where @xmath is the probability that Bob can achieve by guessing the
basis as given in Lemma 3.2.3 . In particular, we always have @xmath .
Proof. Our proof works by constructing a square-root type measurement
that achieves the lower bound. As explained above, Bob’s strategy for
learning @xmath is to perform a measurement with @xmath possible
outcomes, labeled by the strings @xmath for @xmath and @xmath . Once
Alice has announced @xmath , Bob outputs @xmath .

Take the projector @xmath and @xmath , where @xmath . Let @xmath denote
the measurement operator corresponding to outcome @xmath . Note that
outcome @xmath is the correct outcome for input state @xmath if and only
if @xmath . We can then write Bob’s probability of success as

  -- -------- --
     @xmath   
  -- -------- --

We make use of the following measurement:

  -- -- --
        
  -- -- --

Clearly, we have @xmath and @xmath by construction and thus we indeed
have a valid measurement. We first show that @xmath :

  -- -- --
        
  -- -- --

where @xmath and we have used the definition that for any @xmath ,
@xmath is a projector and @xmath which gives @xmath . We can then write
Bob’s probability of success using this particular measurement as

  -- -------- --
     @xmath   
  -- -------- --

It remains to evaluate this expression. Using the circularity of the
trace, we obtain

  -- -- --
        
  -- -- --

where we have again used the assumption that for any @xmath , @xmath is
a projector and @xmath with @xmath . For the last term we have used the
following: Note that @xmath , because we assumed mutually unbiased
bases. Let @xmath . Using Cauchy-Schwarz, we can then bound @xmath ,
where @xmath is the @xmath -th eigenvalue of a matrix @xmath , by noting
that @xmath since @xmath . Putting things together we obtain

  -- -------- --
     @xmath   
  -- -------- --

where @xmath , @xmath and function @xmath defined as @xmath This
expression can be simplified to obtain the claimed result. @xmath

Note that we have only used the assumption that Alice uses mutually
unbiased bases in the very last step to say that @xmath . One could
generalize our argument to other cases by evaluating @xmath
approximately.

In the special case @xmath (i.e. binary function, with two bases) we
obtain: {corollary} Let @xmath be a balanced function and let @xmath for
all @xmath . Let @xmath with @xmath , @xmath and @xmath . Then Bob
succeeds at @xmath with probability @xmath . Observe that this almost
attains the upper bound of @xmath of Lemma 3.3.1 in the case of no
post-measurement information. In Section 3.5.2 we show that indeed this
bound can always be achieved when post-measurement information is
available.

It is perhaps interesting to note that our general bound depends only on
the number of function values @xmath and the number of bases @xmath .
The number of function inputs @xmath itself does not play a direct role.

##### 3.4.2 Optimal bounds for the AND and XOR function

We now show that for some specific functions, the probability of success
can even be much larger. We hereby concentrate on the case where Alice
uses two or three mutually unbiased bases to encode her input. Our
proofs thereby lead to explicit measurements. In the following, we again
assume that Bob has no a priori knowledge of the function value. It
turns out that the optimal measurement directly lead us to the essential
idea underlying our algebraic framework of Section 3.5.1 .

###### AND function {theorem}

Let @xmath for all @xmath and @xmath . Let @xmath with @xmath , @xmath
and @xmath . Then Bob succeeds at @xmath with probability at most

  -- -------- -- -------
     @xmath      (3.4)
  -- -------- -- -------

There exists a strategy for Bob that achieves @xmath . Proof. To learn
the value of @xmath , Bob uses the same strategy as in Section 3.4.1 :
he performs a measurement with @xmath possible outcomes, labeled by the
strings @xmath with @xmath . Once Alice has announced her basis choice
@xmath , Bob outputs @xmath . Note that without loss of generality we
can assume that Bob’s measurement has only @xmath outcomes, i.e. Bob
only stores 2 bits of classical information because he will only
condition his answer on the value of @xmath later on.

Following the approach in the last section, we can write Bob’s optimal
probability of success as a semidefinite program:

  ------------ ----------
  maximize     @xmath
  subject to   @xmath ,
               @xmath ,
  ------------ ----------

where

  -- -------- -------- -- --
     @xmath   @xmath      
     @xmath   @xmath      
  -- -------- -------- -- --

with @xmath . Consider @xmath , the @xmath -dimensional Hilbert space
spanned by @xmath and @xmath . Let @xmath and @xmath be the state
vectors orthogonal to @xmath and @xmath respectively. They can be
expressed as:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Then @xmath is a projector onto @xmath . Let @xmath be a projector onto
the orthogonal complement of @xmath . Note that the @xmath are all
composed of two blocks, one supported on @xmath and the other on its
orthogonal complement. We can thus write

  -- -------- -- -------
     @xmath      (3.5)
  -- -------- -- -------

We give an explicit measurement that achieves @xmath and then show that
it is optimal. Take

  -- -------- -------- -- --
     @xmath   @xmath      
     @xmath   @xmath      
  -- -------- -------- -- --

with @xmath where

  -- -------- -------- -- --
     @xmath   @xmath      
     @xmath   @xmath      
     @xmath   @xmath      
  -- -------- -------- -- --

with @xmath and @xmath real and satisfying @xmath . We also set @xmath .
We take

  -- -------- --
     @xmath   
  -- -------- --

Putting it all together, we thus calculate Bob’s probability of success:

  -- -------- --
     @xmath   
  -- -------- --

We now show that this is in fact the optimal measurement for Bob. For
this we consider the dual of our semidefinite program above:

  ------------ ----------
  minimize     @xmath
  subject to   @xmath .
  ------------ ----------

Our goal is now to find a @xmath such that @xmath and @xmath is dual
feasible. We can then conclude from the duality of SDP that @xmath is
optimal. Consider

  -- -------- -------- -- --
     @xmath   @xmath      
              @xmath      
  -- -------- -------- -- --

Now we only need to show that the @xmath above satisfies the
constraints, i.e. @xmath . Let @xmath and @xmath . By taking a look at
Eq. ( 3.5 ) one can easily see that @xmath so that it is only left to
show that

  -- -------- --
     @xmath   
  -- -------- --

These are @xmath matrices and this can be done straightforwardly. We
thus have @xmath and the result follows from the duality of semidefinite
programming. @xmath

It also follows that if Bob just wants to learn the value of a single
bit, he can do no better than what he could achieve without waiting for
Alice’s announcement of the basis @xmath : {corollary} Let @xmath ,
@xmath and @xmath . Let @xmath with @xmath and @xmath . Then Bob
succeeds at @xmath with probability at most

  -- -------- --
     @xmath   
  -- -------- --

There exists a strategy for Bob that achieves @xmath .

The AND function provides an intuitive example of how Bob can compute
the value of a function perfectly by storing just a single qubit.
Consider the measurement with elements @xmath from the previous section.
It is easy to see that the outcome @xmath has zero probability if @xmath
. Thus, if Bob obtains that outcome he can immediately conclude that
@xmath . If Bob obtains outcome @xmath then the post-measurement states
live in a @xmath -dimensional Hilbert space ( @xmath ), and can
therefore be stored in a single qubit. Thus, by keeping the remaining
state we can calculate the AND perfectly once the basis is announced.
Our proof in Section 3.5.2 , which shows that in fact all Boolean
functions can be computed perfectly if Bob can store only a single
qubit, makes use of a very similar effect to the one we observed here
explicitly.

###### XOR function

We now examine the XOR function. This will be useful in order to gain
some insight into the usefulness of post-measurement information later.
For strings of even length, there exists a simple strategy for Bob even
when three mutually unbiased bases are used.

{theorem}

Let @xmath be even, and let @xmath for all @xmath . Let @xmath with
@xmath , @xmath and @xmath , where @xmath . Then there is a strategy
where Bob succeeds at @xmath with probability @xmath . Proof. We first
construct Bob’s measurement for the first 2 qubits, which allows him to
learn @xmath with probability 1. Note that the 12 possible states that
Alice sends can be expressed in the Bell basis as follows:

  -- -------- -------- -- --
     @xmath   @xmath      
     @xmath   @xmath      
     @xmath   @xmath      
     @xmath   @xmath      
  -- -------- -------- -- --

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Bob now simply measures in the Bell basis and records his outcome. If
Alice now announces that she used the computational basis, Bob concludes
that @xmath if the outcome is one of @xmath and @xmath otherwise. If
Alice announces she used the Hadamard basis, Bob concludes that @xmath
if the outcome was one of @xmath and @xmath otherwise. Finally, if Alice
announces that she used the @xmath basis, Bob concludes that @xmath if
the outcome was one of @xmath and @xmath otherwise. Bob can thus learn
the XOR of two bits with probability 1. To learn the XOR of the entire
string, Bob applies this strategy to each two bits individually and then
computes the XOR of all answers. @xmath

Analogously to the proof of Theorem 3.4.2 , we obtain: {corollary} Let
@xmath be even, and let @xmath for all @xmath . Let @xmath with @xmath
and @xmath . Then there is a strategy where Bob succeeds at @xmath with
probability @xmath .

Interestingly, there is no equivalent strategy for Bob if @xmath is odd.
In fact, as we show in the next section, in this case the
post-measurement information gives no advantage to Bob at all.

{theorem}

Let @xmath be odd, and let @xmath for all @xmath . Let @xmath with
@xmath , @xmath and @xmath . Then Bob succeeds at @xmath with
probability at most

  -- -------- --
     @xmath   
  -- -------- --

There exists a strategy for Bob that achieves @xmath . Proof. Similar to
the proof of the AND function, we can write Bob’s optimal probability of
success as the following semidefinite program in terms of the length of
the input string, @xmath :

  ------------ ----------
  maximize     @xmath
  subject to   @xmath ,
               @xmath ,
  ------------ ----------

where

  -- -------- -------- -- --
     @xmath   @xmath      
  -- -------- -------- -- --

and @xmath . The dual can be written as

  ------------ ----------
  minimize     @xmath
  subject to   @xmath .
  ------------ ----------

Our proof is now by induction on @xmath . For @xmath , let @xmath . It
is easy to verify that @xmath and thus @xmath is a feasible solution of
the dual program.

We now show that for @xmath , @xmath is a feasible solution to the dual
for @xmath , where @xmath is a solution for the dual for @xmath . Note
that the XOR of all bits in the string can be expressed as the XOR of
the first @xmath bits XORed with the XOR of the last two. Recall Eq. (
3.3 ) and note that we can write

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

It is easy to see that @xmath and @xmath . By substituting from the
above equation we then obtain

  -- -------- --
     @xmath   
  -- -------- --

where we have used the fact that @xmath is a feasible solution for the
dual for @xmath and that @xmath . The argument for @xmath , @xmath and
@xmath is analogous. Thus @xmath satisfies all constraints.

Putting things together, we have for odd @xmath that @xmath and since
the dual is a minimization problem we know that

  -- -------- --
     @xmath   
  -- -------- --

as claimed. Clearly, there exists a strategy for Bob that achieves
@xmath . He can compute the XOR of the first @xmath bits perfectly, as
shown in Theorem 3.4.2 . By Corollary 3.4.2 he can learn the value of
the remaining @xmath -th bit with probability @xmath . @xmath

We obtain a similar bound for three bases:

{theorem}

Let @xmath be odd, and let @xmath for all @xmath . Let @xmath with
@xmath , @xmath and @xmath , where @xmath , with @xmath . Then Bob
succeeds at @xmath with probability at most

  -- -------- --
     @xmath   
  -- -------- --

There exists a strategy for Bob that achieves @xmath . Proof. The proof
follows the same lines as Theorem 3.4.2 . Bob’s optimal probability of
success is:

  ------------ ----------
  maximize     @xmath
  subject to   @xmath ,
               @xmath ,
  ------------ ----------

where

  -- -------- --
     @xmath   
  -- -------- --

and

  -- -------- --
     @xmath   
  -- -------- --

The dual can be written as

  ------------ ----------
  minimize     @xmath
  subject to   @xmath .
  ------------ ----------

Again, the proof continues by induction on @xmath . For @xmath , let
@xmath . It is easy to verify that @xmath and thus @xmath is a feasible
solution of the dual program. The rest of the proof is done exactly in
the same way as in Theorem 3.4.2 using that

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

@xmath

#### 3.5 Using post-measurement information and quantum memory

##### 3.5.1 An algebraic framework for perfect prediction

So far, we had assumed that Bob is not allowed to store any qubits and
can only use the additional post-measurement information to improve his
guess. Now, we investigate the case where he has a certain amount of
quantum memory at his disposal. In particular, we present a general
algebraic approach to determine the minimum dimension @xmath of quantum
memory needed to succeed with probability @xmath at an instance of
@xmath , for any ensemble @xmath as long as the individual states for
different values of @xmath are mutually orthogonal for a fixed @xmath ,
i.e., @xmath . In particular, we are looking for an instrument
consisting of a family of completely positive maps @xmath , adding up to
a trace preserving map, such that @xmath . This ensures that the
post-measurement state “fits” into @xmath qubits, and thus takes care of
the memory bound. The fact that after the announcement of @xmath the
remaining state @xmath gives full information about @xmath is expressed
by demanding orthogonality of the different post-measurement states:

  -- -------- -- -------
     @xmath      (3.6)
  -- -------- -- -------

Note that here we explicitly allow the possibility that, say, @xmath :
this means that if Bob obtains outcome @xmath and later learns @xmath ,
he can exclude the output value @xmath . What Eq. ( 3.6 ) also implies
is that for all states @xmath and @xmath in the support of @xmath and
@xmath , respectively, one has @xmath . Hence, introducing the support
projectors @xmath of the @xmath , we can reformulate Eq. ( 3.6 ) as

  -- -------- --
     @xmath   
  -- -------- --

which can equivalently be expressed as

  -- -- -- -------
           (3.7)
  -- -- -- -------

by noting that @xmath as well as the projectors are
positive-semidefinite operators. As expected, we see that only the POVM
operators @xmath of the instrument play a role in this condition. Our
conditions can therefore also be written as @xmath . From this
condition, we now derive the following lemma.

{lemma}

Bob, using a POVM with operators @xmath , succeeds at @xmath with
probability @xmath , if and only if

1.  for all @xmath , @xmath ,

2.  for all @xmath and @xmath , @xmath , where @xmath is the projection
    on the support of @xmath .

Proof. We first show that these two conditions are necessary. Note that
only the commutation condition has to be proved. Let @xmath be a
measurement operator from a POVM succeeding with probability @xmath .
Then, for any @xmath , @xmath , we have by Eq. ( 3.7 ) that

  -- -------- --
     @xmath   
  -- -------- --

Thus, by the positivity of the trace on positive operators, the
cyclicity of the trace, and @xmath we have that

  -- -------- --
     @xmath   
  -- -------- --

But that means that the commutator @xmath has to be @xmath .

Sufficiency is easy: since the measurement operators commute with the
states’ support projectors @xmath , and these are orthogonal to each
other for fixed @xmath , the post-measurement states of these
projectors, @xmath are also mutually orthogonal for fixed @xmath . Thus,
if Bob learns @xmath , he can perform a measurement to distinguish the
different values of @xmath perfectly. The post-measurement states are
clearly supported on the support of @xmath , which can be stored in
@xmath qubits. Since Bob’s strategy succeeds with probability @xmath ,
it succeeds with probability @xmath for any states supported in the
range of the @xmath . @xmath

Note that the operators @xmath of the instrument need not commute with
the originally given states @xmath . Nevertheless, the measurement
preserves the orthogonality of @xmath and @xmath with @xmath for fixed
@xmath , i.e., @xmath . Now that we know that the POVM operators of the
instrument have to commute with all the states’ support projectors
@xmath , we can invoke some well-developed algebraic machinery to find
the optimal such instrument.

Looking at Appendix B , we see that @xmath has to come from the
commutant of the operators @xmath . These themselves generate a @xmath
-subalgebra @xmath of the full operator algebra @xmath of the underlying
Hilbert space @xmath , and the structure of such algebras and their
commutants in finite dimension is well understood. We know from Theorem
B.4.2 that the Hilbert space @xmath has a decomposition (i.e., there is
an isomorphism which we write as an equality)

  -- -------- -- -------
     @xmath      (3.8)
  -- -------- -- -------

into a direct sum of tensor products such that the @xmath -algebra
@xmath and its commutant algebra @xmath can be written

  -- -------- -------- -- --------
     @xmath   @xmath      (3.9)
     @xmath   @xmath      (3.10)
  -- -------- -------- -- --------

Koashi and Imoto [ KI02 ] , in the context of finding the quantum
operations which leave a set of states invariant, have described an
algorithm to find the commutant @xmath , and more precisely the Hilbert
space decomposition of Eq. ( 3.8 ), of the states @xmath . They show
that for this decomposition, there exist states @xmath on @xmath , a
conditional probability distribution @xmath , and states @xmath on
@xmath which are independent of @xmath , such that we can write them as

  -- -------- --
     @xmath   
  -- -------- --

Looking at Eq. ( 3.10 ), we see that the smallest rank operators @xmath
are of the form @xmath for some @xmath and @xmath , and that they are
all admissible. Since we need a family of operators @xmath that are
closed to a POVM (i.e., their sum is equal to the identity), we know
that all @xmath have to occur. Hence, the minimal quantum memory
requirement is

  -- -------- -- --------
     @xmath      (3.11)
  -- -------- -- --------

The strategy Bob has to follow is this: For each @xmath , pick a basis
@xmath for @xmath and measure the POVM @xmath , corresponding to the
decomposition

  -- -------- --
     @xmath   
  -- -------- --

which commutes with the @xmath . For each outcome, he can store the
post-measurement state in @xmath qubits [as in Eq. ( 3.11 )], preserving
the orthogonality of the states for different @xmath but fixed @xmath .
Once he learns @xmath he can thus obtain @xmath with certainty.

Of course, carrying out the Koashi-Imoto algorithm may not be a
straightforward task in a given situation. We now consider two explicit
examples that one can understand as two special cases of this general
method: First, we show that in fact all Boolean functions with two bases
(mutually unbiased or not) can be computed perfectly when Bob is allowed
to store just a single qubit. Second, however, we show that there exist
three bases such that for any balanced function, Bob must store all
qubits to compute the function perfectly. We also give a recipe how to
construct such bases.

##### 3.5.2 Using two bases

For two bases, Bob needs to store only a single qubit to compute any
Boolean function perfectly. As outlined in Section 3.5.1 , we need to
show that there exists a measurement with the following properties:
First, the post-measurement states of states corresponding to strings
@xmath such that @xmath are orthogonal to the post-measurement states of
states corresponding to strings @xmath such that @xmath . Indeed, if
this is true and we keep the post-measurement state, then after the
basis is announced, we can distinguish perfectly between both types of
states. Second, of course, we need that the post-measurement states are
supported in subspaces of dimension at most @xmath . The following
little lemma shows that this is the case for any Boolean function. The
same statement has been shown independently many times before in a
variety of different contexts. For example, Masanes and also Toner and
Verstraete have shown the same in the context of non-local games [ Mas06
, TV06 ] . The key ingredient is also present in Bathia’s textbook [
Bha97 ] . Indeed, there is a close connection between the amount of
post-measurement information we require, and the amount of entanglement
we need to implement measurements in the setting of non-local games. We
return to this question in Chapter 6 .

{lemma}

Let @xmath and @xmath where @xmath and @xmath , then there exists a
direct sum decomposition of the Hilbert space

  -- -------- --
     @xmath   
  -- -------- --

such that @xmath and @xmath can be expressed as

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

where @xmath is the orthogonal projector onto @xmath .

Proof. There exists a basis so that @xmath and @xmath can be written as

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the number of strings @xmath such that @xmath , and we
have specified the dimensions of the matrix blocks for clarity. In what
follows these dimensions will be omitted. We assume without loss of
generality that @xmath . It is easy to check that, since @xmath is a
projector, it must satisfy

  -- -------- -- --------
     @xmath      (3.12)
  -- -------- -- --------

Consider a unitary of the following form

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath are @xmath and @xmath unitaries respectively.
Under such a unitary, @xmath and @xmath are transformed to:

  -- -------- -- --------
     @xmath      (3.13)
  -- -------- -- --------

We now choose @xmath and @xmath from the singular value decomposition
(SVD, [ HJ85 , Theorem 7.3.5] ) of @xmath which gives

  -- -------- --
     @xmath   
  -- -------- --

where @xmath , @xmath . Since @xmath and @xmath are supported in
orthogonal subspaces, it also holds that @xmath . Eqs. ( 3.12 ) and (
3.13 ) now give us

  -- -------- -------- -- --
     @xmath   @xmath      
     @xmath   @xmath      
  -- -------- -------- -- --

Suppose for the time being that all the @xmath are different. Since they
are all non-negative, all the @xmath will also be different and it must
hold that

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

for some @xmath , @xmath and @xmath with @xmath .. Note that we can
choose @xmath such that @xmath and @xmath . We can now express @xmath as

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

It is now clear that we can choose all @xmath , and @xmath which are
orthogonal and together add up to @xmath .

In the case that all the @xmath are not different, there is some freedom
left in choosing @xmath and @xmath that still allows us to make @xmath
and @xmath diagonal so that the rest of the proof follows in the same
way. @xmath

In particular, the previous lemma implies that the post-measurement
states corresponding to strings @xmath for which @xmath are orthogonal
to those corresponding to strings @xmath for which @xmath , which is
expressed in the following lemma. {lemma} Suppose one performs the
measurement given by @xmath . If the outcome of the measurement is
@xmath and the state was @xmath , then the post-measurement state is

  -- -------- --
     @xmath   
  -- -------- --

The post-measurement states satisfy

  -- -------- --
     @xmath   
  -- -------- --

Proof. The proof follows straightforwardly from that fact that the
@xmath commute with both @xmath and @xmath (which follows from Lemma
3.5.2 ). @xmath

Now we are ready to prove the main theorem of this section.

{theorem}

Let @xmath , then there exists a strategy for Bob such that he succeeds
at @xmath with probability @xmath , for any function @xmath and prior
@xmath on @xmath . Proof. The strategy that Bob uses is the following:

-   Bob performs the measurement given by @xmath .

-   He obtains an outcome @xmath and stores the post-measurement state
    which is supported in the at most two-dimensional subspace @xmath .

-   After the basis @xmath is announced, he measures @xmath and reports
    the outcome of this measurement.

By Lemma 3.5.2 this leads to success probability @xmath . @xmath

Our result also gives us a better lower bound for all Boolean functions
than what we had previously obtained in Section 3.4.1 . Instead of
storing the qubit, Bob now measures it immediately along the lines of
Lemma 3.3.1 . It is not too difficult to convince yourself that for one
qubit the worst-case post-measurement states to distinguish are in fact
those in Lemma 3.3.1 . {corollary} Let @xmath , then Bob succeeds at
@xmath with probability at least @xmath . In particular, our result
implies that for the task of constructing Rabin-OT in [ DFSS05 ] it is
essential for Alice to choose a random function @xmath from a larger
set, which is initially unknown to Bob.

As a final remark, note that the prior distributions do not play any
role. Likewise, it is not actually important that the states @xmath are
proportional to projectors: we only require that for all @xmath , the
states @xmath and @xmath are orthogonal.

##### 3.5.3 Using three bases

We have just shown that Bob can compute any Boolean function perfectly
when two bases are used. However, we now show that for any balanced
Boolean function there exist three bases, such that Bob needs to store
all qubits in order to compute the function perfectly. The idea behind
our proof is that for a particular choice of three bases, any
measurement operator that satisfies the conditions set out in Lemma
3.5.1 must be proportional to the identity. This means that we cannot
reduce the number of qubits to be stored by a measurement and must keep
everything. First, we prove the following lemma which we need in our
main proof.

{lemma}

Let @xmath be a self-adjoint matrix which is diagonal in two mutually
unbiased bases, then @xmath must be proportional to the identity. Proof.
Let @xmath @xmath @xmath be the two MUBs and let @xmath and @xmath be
the eigenvalues corresponding to @xmath and @xmath respectively, then we
can write

  -- -------- --
     @xmath   
  -- -------- --

From the previous equation, it follows that

  -- -------- --
     @xmath   
  -- -------- --

which implies the desired result. @xmath

We are now ready to prove the main result of this section.

{theorem}

Let @xmath and @xmath , then for any balanced function @xmath and prior
@xmath on @xmath which is uniform on the pre-images @xmath , there exist
three bases such that Bob succeeds at @xmath with probability @xmath if
and only if @xmath . Proof. Let @xmath , @xmath and @xmath . Also, let
@xmath be a bijective map, and let @xmath . By a reordering of the
basis, @xmath , @xmath and @xmath can be written as

  -- -------- --
     @xmath   
  -- -------- --

where all the blocks are of size @xmath . @xmath and @xmath then take
the following form:

  -- -------- --
     @xmath   
  -- -------- --

It follows from Lemma 3.5.1 , that we only have to prove that @xmath
implies that @xmath must be proportional to the identity. Write

  -- -------- --
     @xmath   
  -- -------- --

Commutation with @xmath implies @xmath . Commutation with @xmath and
@xmath implies

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (3.14)
     @xmath   @xmath   @xmath      (3.15)
     @xmath   @xmath   @xmath      (3.16)
     @xmath   @xmath   @xmath      (3.17)
  -- -------- -------- -------- -- --------

We choose @xmath and @xmath in the following way:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

with @xmath , satisfying @xmath if and only if @xmath . Furthermore,
choose @xmath and @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

With this choice for @xmath and @xmath we have that

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

i.e., @xmath and @xmath form an eigenbasis for @xmath and @xmath
respectively. Furthermore, since all the @xmath are different, the
eigenbases are unique. Now, using Eq. ( 3.14 ), we see that @xmath must
commute with both @xmath and @xmath , and since their eigenbases are
unique, it must be true that @xmath is diagonal in both @xmath and
@xmath . Using the result of Lemma 3.5.3 it follows that @xmath . In
exactly the same way we can prove that @xmath using Eq. ( 3.15 ). It
remains to prove that @xmath , which follows directly from either Eq. (
3.16 ) or Eq. ( 3.17 ). @xmath

From our proof it is clear how to construct @xmath and @xmath . For
@xmath as defined above, we could choose vectors of the form @xmath and
@xmath where @xmath to construct @xmath . For @xmath we could then pick
@xmath and analogously @xmath . As we will see in Chapter 6 , our
example shows that for non-local games we cannot hope to prove a
statement analogous to [ Mas06 , TV06 ] for three measurement settings
where each measurement has two outcomes.

Note, however, that whereas we know that for such unitaries Bob must
store all qubits in order to compute the value of the function
perfectly, it remains unclear how close he can get to computing the
function perfectly when storing fewer qubits. In particular, he can
always choose two of the three bases, and employ the strategy outlined
in the previous section: he stores the one qubit that allows him to
succeed with probability @xmath for two of the bases. If he gets the
third basis then he just flips a coin. In this case, he is correct with
probability @xmath for a balanced function and a uniform prior. It
remains an important open question to address the approximate case.

#### 3.6 Conclusion

We have introduced a new state discrimination problem, motivated by
cryptography: discrimination with extra information about the state
after the measurement, or, more generally, after a quantum memory bound
applies. We have left most general questions open, but we found fairly
complete results in the case of guessing @xmath with mutually unbiased
encodings.

We have shown that storing just a single qubit allows Bob to succeed at
PI-STAR perfectly for any Boolean function and any two bases. In
contrast, we showed how to construct three bases such that Bob needs to
store all qubits in order to compute the function perfectly. We have
also given an explicit strategy for two functions, namely the AND and
the XOR. More generally, it would be interesting to determine, how many
qubits Bob needs to store to compute @xmath perfectly for any function
@xmath in terms of the number of outputs @xmath and the number of bases
@xmath . It should be clear that the algebraic techniques of Section
3.5.1 allow us to answer these questions for any given function in
principle. However, so far, we have not been able to obtain explicit
structures for wider classes of functions. Our results imply that in
existing protocols in the bounded quantum storage model [ DFSS05 ] we
cannot restrict ourselves to a single fixed function @xmath to perform
privacy amplification. Note that our algebraic framework can also
address the question of using more than one function, where @xmath is
also announced after the memory bound applies [ DFSS05 ] : we merely
obtain a larger problem. Yet, it is again difficult to determine a
general bound.

In the important case of two mutually unbiased bases and balanced
functions, we have shown (Theorem 3.3.2 and Corollary 3.5.2 ) that there
exists a clear separation between the case where Bob gets the
post-measurement information (PI-STAR) and when he does not (STAR).
Namely, for any such function, Bob’s optimal success probability is
never larger than @xmath for STAR and always at least as large as the
same number for PI-STAR.

In some cases the gap between STAR and PI-STAR can be more dramatic. The
XOR function on strings of even length with two mutually unbiased bases
is one of these cases. We have shown that in this case the advantage can
be maximal. Namely, without the extra information Bob can never do
better than guessing the basis, with it however, he can compute the
value of the function perfectly. This contrasts with the XOR function on
strings of odd length, where the optimal success probabilities of STAR
and PI-STAR are both @xmath and the post-measurement information is
completely useless for Bob. It would be interesting to see, how large
the gap between STAR and PI-STAR can be for any function @xmath where
@xmath . We return to this question in Chapter 6.4 .

It would also be nice to show a general lower bound for non-balanced
functions or a non-uniform prior. As the example for @xmath bases
showed, the uniform prior is not necessarily the one that leads to the
largest gap, and thus the prior can play an important role. Another
generalization would be to consider functions of the form @xmath .

We now turn our attention to uncertainty relations. These will play an
important role in locking in Chapter 5 . In the problem of locking, we
also distinguish measurement with basis information, analogous to our
@xmath with @xmath , and without corresponding to @xmath . So far, our
objective has been to obtain an accurate guess of a value, e.g. @xmath .
In Chapter 5 , we are interested in a slightly different problem: How
can we maximize the classical mutual information? In particular, can we
use mutually unbiased bases to obtain locking effects?

### Chapter 4 Uncertainty relations

Uncertainty relations lie at the very core of quantum mechanics.
Intuitively, they quantify how much we can learn about different
properties of a quantum system simultaneously. Some properties lead to
very strong uncertainty relations: if we decide to learn one, we remain
entirely ignorant about the others. But what characterizes such
properties? In this chapter, we first investigate whether choosing our
measurements to be mutually unbiased bases allows us to obtain strong
uncertainty relations. Sadly, it turns out that mutual unbiasedness is
not sufficient. Instead, we need to consider anti-commuting
measurements.

#### 4.1 Introduction

Heisenberg first realized that quantum mechanics leads to uncertainty
relations for conjugate observables such as position and momentum [
Hei27 ] . Uncertainty relations are probably best known in the form
given by Robertson [ Rob29 ] , who extended Heisenberg’s result to any
two observables @xmath and @xmath . Robertson’s relation states that if
we prepare many copies of the state @xmath , and measure each copy
individually using either @xmath or @xmath , we have

  -- -------- --
     @xmath   
  -- -------- --

where @xmath for @xmath is the standard deviation resulting from
measuring @xmath with observable @xmath . Recall from Chapter 2 , that
classically we always have @xmath , and there is no such limiting lower
bound. Hence, uncertainty relations are another characteristic that sets
apart quantum theory. The consequences are rather striking: even if we
had a perfect measurement apparatus, we are nevertheless limited!

Entropic uncertainty relations are an alternative way to state
Heisenberg’s uncertainty principle. They are frequently a more useful
characterization, because the “uncertainty” is lower bounded by a
quantity that does not depend on the state to be measured [ Deu83 ,
Kra87 ] . Recently, entropic uncertainty relations have gained
importance in the context of quantum cryptography in the bounded storage
model, where proving the security of such protocols ultimately reduces
to establishing such relations [ DFR @xmath 07 ] . Proving new entropic
uncertainty relations could thus give rise to new protocols.
Intuitively, it is clear that uncertainty relations have a significant
impact on what kind of protocols we can obtain in the quantum settings.
Recall the cryptographic task of oblivious transfer from Chapter 1 : the
receiver should be able to extract information about one particular
property of a system, but should learn as little as possible about all
other properties. It is clear that, without placing any additional
restrictions on the receiver, uncertainty relations intuitively quantify
how well we are able to implement such a primitive.

Entropic uncertainty relations were first introduced by
Bialynicki-Birula and Mycielski [ BBM75 ] . For our purposes, we will be
interested in uncertainty relations in the form put forward by Deutsch [
Deu83 ] . Following a conjecture by Kraus [ Kra87 ] , Maassen and Uffink
[ MU88 ] have shown that if we measure the state @xmath with observables
@xmath and @xmath determined by the bases @xmath and @xmath
respectively, we have

  -- -- --
        
  -- -- --

where @xmath , and

  -- -------- --
     @xmath   
  -- -------- --

is the Shannon entropy [ Sha48 ] arising from measuring the state @xmath
in the basis @xmath . In fact, Maassen and Uffink provide a more general
statement which also leads to uncertainty relations for higher order
Rényi entropies. Such relations have also been shown by
Bialynicki-Birula [ BB06 ] for special sets of observables. Note that
the above relation achieves our initial goal: the lower bound no longer
depends on the state @xmath , but only on @xmath and @xmath itself. What
is the strongest possible relation we could obtain? That is, which
choices of @xmath and @xmath maximize @xmath ? It is not hard to see
that choosing @xmath and @xmath to be mutually unbiased (see Section 2.4
) provides us with a lower bound of @xmath which is the strongest
possible uncertainty relation: If we have no entropy for one of the
bases, then the entropy for the other bases must be maximal. For
example, in case of a one qubit system of @xmath choosing @xmath and
@xmath to be the computational and the Hadamard basis respectively, we
obtain a lower bound of @xmath .

Can we derive a similar relation for measurements using three or more
observables? Surprisingly, very little is known for a larger number of
measurement settings [ Aza04 ] . Sanchez-Ruiz [ San93 , SR95 ] (using
results of Larsen [ Lar90 ] ) has shown that for measurements using all
@xmath mutually unbiased bases, we can obtain strong uncertainty
relations. Here, we provide an elementary proof of his result in
dimension @xmath . Given the fact that mutually unbiased bases seem to
be a good choice if we use only two or @xmath measurement settings, it
may be tempting to conclude that choosing our measurements to be
mutually unbiased always gives us good uncertainty relations for which
the lower bound is as large as possible. Numerical results for MUBs in
prime dimensions up to 29 indicate that MUBs may indeed be a good choice
[ DHL @xmath 04 ] . However, we show that merely being mutually unbiased
is not sufficient to obtain strong uncertainty relations. To this end,
we prove tight entropic uncertainty relations for measurements in a
large number of mutually unbiased bases (MUBs) in square dimensions. In
particular, we consider any MUBs derived from mutually orthogonal Latin
squares [ WB05 ] , and any set of MUBs obtained from the set of
unitaries of the form @xmath , where @xmath gives rise to a set of MUBs
in dimension @xmath when applied to the basis elements of the
computational basis. For any @xmath , there are at most @xmath such MUBs
in a Hilbert space of dimension @xmath : recall from Section 2.4 that we
can have at most @xmath MUBs in a space of dimension @xmath . Let @xmath
be the set of MUBs coming from one of these two constructions. We prove
that for any subset @xmath of these bases we have

  -- -------- --
     @xmath   
  -- -------- --

Our result shows that one needs to be careful to think of “maximally
incompatible” measurements as being necessarily mutually unbiased. When
we take entropic uncertainty relations as our measure of
“incompatibility”, mutually unbiased measurements are not always the
most incompatible when considering more than two observables. In
particular, it has been shown [ HLSW04 ] that if we choose approximately
@xmath bases uniformly at random, then with high probability @xmath .
This means that there exist @xmath bases for which this sum of entropies
is very large, i.e., measurements in such bases are very incompatible.
However, we show that when @xmath is large, there exist @xmath mutually
unbiased bases that are much less incompatible according to this
measure. When considering entropic uncertainty relations as a measure of
“incompatibility”, we must therefore look for different properties for
the bases to define incompatible measurements.

Luckily, we are able to obtain maximally strong uncertainty relations
for two-outcome measurements for anti-commuting observables. In
particular, we obtain for @xmath with @xmath that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath , @xmath are projectors onto the positive and
negative eigenspace of @xmath respectively. Thus, if we have zero
entropy for one of the terms, we must have maximal entropy for all
others. For the collision entropy we obtain something slightly
suboptimal

  -- -------- --
     @xmath   
  -- -------- --

for large @xmath , where @xmath . Especially our second uncertainty
relation is of interest for cryptographic applications.

#### 4.2 Limitations of mutually unbiased bases

We first prove tight entropic uncertainty for measurements in MUBs in
square dimensions. We need the result of Maassen and Uffink [ MU88 ]
mentioned above: {theorem} [Maassen and Uffink] Let @xmath and @xmath be
two orthonormal basis in a Hilbert space of dimension @xmath . Then for
all pure states @xmath

  -- -------- --
     @xmath   
  -- -------- --

where @xmath . The case when @xmath and @xmath are MUBs is of special
interest for us. More generally, when one has a set of MUBs a trivial
application of Theorem 4.2 leads to the following corollary also noted
in [ Aza04 ] . {corollary} Let @xmath be a set of MUBs in a Hilbert
space of dimension @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

Proof. Using Theorem 4.2 , one gets that for any pair of MUBs @xmath and
@xmath with @xmath

  -- -------- --
     @xmath   
  -- -------- --

Adding up the resulting equation for all pairs @xmath we get the desired
result. @xmath

We now show that this bound can in fact be tight for a large set of
MUBs.

##### 4.2.1 MUBs in square dimensions

Corollary 4.2 gives a lower bound on the average of the entropies of a
set of MUBs. But how good is this bound? We show that the bound is
indeed tight when we consider product MUBs in a Hilbert space of square
dimension. {theorem} Let @xmath with @xmath be a set of MUBs in a
Hilbert space @xmath of dimension @xmath . Let @xmath be the unitary
operator that transforms the computational basis to @xmath . Then @xmath
, where

  -- -------- --
     @xmath   
  -- -------- --

is a set of MUBs in @xmath , and it holds that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath . Proof. It is easy to check that @xmath is indeed a set of
MUBs. Our proof works by constructing a state @xmath that achieves the
bound in Corollary 4.2 . It is easy to see that the maximally entangled
state

  -- -------- --
     @xmath   
  -- -------- --

satisfies @xmath for any @xmath . Indeed,

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

Therefore, for any @xmath we have that

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

Taking the average of the previous equation over all @xmath we obtain
the result. @xmath

##### 4.2.2 MUBs based on Latin squares

We now consider mutually unbiased bases based on Latin squares [ WB05 ]
as described in Section 2.4.1 . Our proof again follows by providing a
state that achieves the bound in Corollary 4.2 , which turns out to have
a very simple form. {lemma} Let @xmath with @xmath be any set of MUBs in
a Hilbert space of dimension @xmath constructed on the basis of Latin
squares. Then

  -- -------- --
     @xmath   
  -- -------- --

Proof. Consider the state @xmath and fix a basis @xmath coming from a
Latin square. It is easy to see that there exists exactly one @xmath
such that @xmath . Namely this will be the @xmath at position @xmath in
the Latin square. Fix this @xmath . For any other @xmath , we have
@xmath . But this means that there exist exactly @xmath vectors in
@xmath such that @xmath , namely exactly the @xmath vectors derived from
@xmath via the Hadamard matrix. The same argument holds for any such
basis @xmath . We get

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

The result then follows directly from Corollary 4.2 . @xmath

##### 4.2.3 Using a full set of MUBs

We now provide an alternative proof of an entropic uncertainty relation
for a full set of mutually unbiased bases. This has previously been
proved in [ San93 , SR95 ] . We already provided an alternative proof
using the fact that the set of all mutually unbiased bases forms a
2-design [ BW07 ] . Here, we provide a new alternative proof for
dimension @xmath which has the advantage that it neither requires the
introduction of 2-designs, nor the results of [ Lar90 ] that were used
in the previous proof by Sanchez-Ruiz [ San93 , SR95 ] . Instead, our
proof is extremely simple: After choosing a convenient parametrization
of quantum states, the statement follows immediately using only
elementary Fourier analysis.

For the parametrization, we first introduce a basis for the space of
@xmath matrices with the help of mutually unbiased bases. Recall from
Section 2.4 that in dimension @xmath , we can find exactly @xmath MUBs.
{lemma} Consider the Hermitian matrices

  -- -------- --
     @xmath   
  -- -------- --

for @xmath , @xmath and for all @xmath and @xmath we have @xmath . Then
the set @xmath forms a basis for the space of @xmath matrices, where for
all @xmath and @xmath , @xmath is traceless and @xmath . Proof. First,
note that we have @xmath matrices. We now show that they are all
orthogonal. Note that

  -- -------- --
     @xmath   
  -- -------- --

since @xmath , and hence @xmath is traceless. Hence @xmath .
Furthermore,

  -- -------- -- -------
     @xmath      (4.1)
  -- -------- -- -------

For @xmath , Eq. ( 4.1 ) gives us @xmath , since @xmath . For @xmath ,
but @xmath , we get @xmath since @xmath .

Finally, @xmath . @xmath

Since @xmath form a basis for the @xmath matrices, we can thus express
the state @xmath of a @xmath -dimensional system as

  -- -------- --
     @xmath   
  -- -------- --

for some coefficients @xmath . It is now easy to see that {lemma} Let
@xmath be a pure state parametrized as above. Then

  -- -------- --
     @xmath   
  -- -------- --

Proof. If @xmath is a pure state, we have @xmath . Hence

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

from which the claim follows. @xmath
Suppose now that we are given a set of @xmath MUBs @xmath with @xmath .
Then the following simple observation lies at the core of our proof:
{lemma} Let @xmath be the @xmath -th basis vector of the @xmath -th MUB.
Then for any state @xmath

  -- -------- --
     @xmath   
  -- -------- --

Proof. We have

  -- -------- --
     @xmath   
  -- -------- --

Suppose @xmath . Then @xmath , since @xmath . Suppose @xmath . Then
@xmath , from which the claim follows. @xmath

We are now ready to prove an entropic uncertainty relation for @xmath
mutually unbiased bases. {theorem} Let @xmath be a set of mutually
unbiased bases. Then

  -- -------- --
     @xmath   
  -- -------- --

Proof. First, note that we can define functions @xmath for @xmath and
@xmath . Then @xmath is the Fourier transform of @xmath and @xmath by
Lemma 4.2.3 . Thus

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

where the first inequality follows from Jensen’s inequality and the
concavity of @xmath . The next equality follows from Parseval’s
equality, and the last follows from the fact that @xmath is a pure state
and Lemma 4.2.3 . @xmath

{corollary}

Let @xmath be a set of mutually unbiased bases. Then

  -- -------- --
     @xmath   
  -- -------- --

In particular, for a full set of @xmath MUBs we have @xmath . Proof.
This follows immediately from Theorem 4.2.3 and the fact that @xmath .
@xmath

It is interesting to note that this bound is the same that arises from
interpolating between the results of Sanchez-Ruiz [ San93 , SR95 ] and
Maassen and Uffink [ MU88 ] as was done by Azarchs [ Aza04 ] .

#### 4.3 Good uncertainty relations

As we saw, merely choosing our measurements to be mutually unbiased is
not sufficient to obtain good uncertainty relations. However, we now
investigate measurements using anti-commuting observables for which we
do obtain maximally strong uncertainty relations! In particular, we
consider the matrices @xmath , satisfying the anti-commutation relations

  -- -------- -- -------
     @xmath      (4.2)
  -- -------- -- -------

for all @xmath . Such operators @xmath form generators for the Clifford
algebra, which we explain in more detail in Appendix C .

Intuitively, these operators have a property that is very similar to
being mutually unbiased: Recall from Appendix C that we can write for
all @xmath

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath are projectors onto the positive and negative
eigenspace of @xmath respectively. We also have that for all @xmath with
@xmath

  -- -------- --
     @xmath   
  -- -------- --

Hence the positive and negative eigenspaces of such operators are
similarly mutually unbiased as bases can be: from

  -- -------- --
     @xmath   
  -- -------- --

we immediately see that if we would pick a vector lying in the positive
or negative eigenspace of @xmath and perform a measurement with @xmath ,
the probability to obtain outcome @xmath or outcome @xmath must be the
same. Thus, one might intuitively hope to obtain good uncertainty
relations for measurements using such operators. We now show that this
is indeed the case.

##### 4.3.1 Preliminaries

Before we can turn to proving our uncertainty relations, we recall a few
simple observations from Appendix C . The operators @xmath have a unique
(up to unitary) representation in terms of the matrices

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

for @xmath . We now fix this representation. The product @xmath is also
called the pseudo-scalar. A particularly useful fact is that the
collection of operators

  -- -------- --
     @xmath   
  -- -------- --

forms an orthogonal basis for the @xmath complex matrices for @xmath ,
where in the definition of the above operators we introduce a factor of
@xmath to all with an even number of indices to make the whole set a
basis for the Hermitian operators with real valued coefficients. Hence
we can write every state @xmath as

  -- -------- -- -------
     @xmath      (4.3)
  -- -------- -- -------

The real valued coefficients @xmath in this expansion are called
“vector” components, the ones belonging to higher degree products of
@xmath ’s are “tensor” or “k-vector” components.

Recall that we may think of the operators @xmath as the basis vectors of
a @xmath -dimensional real vector space. Essentially, we can then think
of the positive and negative eigenspace of such operators as the
positive and negative direction of the basis vectors. We can visualize
the @xmath basis vectors with the help of a @xmath -dimensional
hypercube. Each basis vector determines two opposing faces of the
hypercube ¹ ¹ 1 Note that the face of an @xmath -dimensional hypercube
is a @xmath dimensional hypercube itself. , where we can think of the
two faces as corresponding to the positive and negative eigenspace of
each operator as illustrated in Figures 4.1 and 4.2 .

Finally, recall that within the Clifford algebra two vectors are
orthogonal if and only if they anti-commute. Hence, if we transform the
generating set of @xmath linearly,

  -- -------- --
     @xmath   
  -- -------- --

the set @xmath satisfies the anti-commutation relations if and only if
@xmath is an orthogonal matrix. In that case there exists a matching
unitary @xmath of @xmath which transforms the operator basis as

  -- -------- --
     @xmath   
  -- -------- --

We thus have an @xmath symmetry of the generating set @xmath . Indeed,
this can be extended to a @xmath symmetry by viewing @xmath as an
additional ”vector”: It is not difficult to see that @xmath
anti-commutes with @xmath . We are thus free to remove one of these
operators from the generating set and replace it with @xmath to obtain a
new set of generators. Evidently, we may also view these as basis
vectors. This observation forms the basis of the following little lemma,
which allows us to prove our uncertainty relations: {lemma} The linear
map @xmath taking @xmath as in Eq. ( 4.3 ) to

  -- -------- -- -------
     @xmath      (4.4)
  -- -------- -- -------

is positive. I.e., if @xmath is a state, then so is @xmath , and in this
case @xmath . Conversely, if @xmath , then

  -- -------- --
     @xmath   
  -- -------- --

is positive semidefinite, hence a state. Proof. First, we show that
there exists a unitary @xmath such that @xmath has no pseudo-scalar
@xmath , and only one nonzero vector component, say at @xmath . Hence,
our goal is to find the transformation @xmath that rotates @xmath to the
vector @xmath , where we let @xmath . Finding such a transformation for
only the first @xmath generators can easily be achieved, as we saw in
Appendix C . The challenge is thus to include @xmath . To this end we
perform three individual operations: First, we rotate @xmath onto the
vector @xmath with @xmath . Second, we exchange @xmath and @xmath . And
finally we rotate the vector @xmath onto the vector @xmath .

First, we rotate @xmath onto the vector @xmath : This is exactly
analogous to the transformation constructed in Appendix C . Consider the
vector @xmath . We have @xmath and thus the vector is of length 1. Let
@xmath denote the vector lying in the plane spanned by @xmath and @xmath
located exactly halfway between @xmath and @xmath . Let @xmath with
@xmath . It is easy to verify that @xmath and hence the vector @xmath
has length 1. To rotate the vector @xmath onto the vector @xmath , we
now need to first reflect @xmath around the plane perpendicular to
@xmath , and then around the plane perpendicular to @xmath . Hence, we
now define @xmath . Evidently, @xmath is unitary since @xmath . First of
all, note that

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

Hence,

  -- -------- --
     @xmath   
  -- -------- --

as desired. Using the geometry of the Clifford algebra, one can see that
@xmath -vectors remain @xmath -vectors when transformed with the
rotation @xmath (see Appendix C ). Similarly, it is easy to see that
@xmath is untouched by the operation @xmath

  -- -------- --
     @xmath   
  -- -------- --

since @xmath for all @xmath . We can thus conclude that

  -- -------- --
     @xmath   
  -- -------- --

for some coefficients @xmath and similar for the terms involving higher
products.

Second, we exchange @xmath and @xmath : To this end, recall that @xmath
is also a generating set for the Clifford algebra. Hence, we can now
view @xmath itself as a vector with respect to the new generators. To
exchange @xmath and @xmath , we now simply rotate @xmath onto @xmath .
Essentially, this corresponds to a rotation about 90 degrees in the
plane spanned by vectors @xmath and @xmath . Consider the vector @xmath
located exactly halfway between both vectors. Let @xmath be the
normalized vector. Let @xmath . A small calculation analogous to the
above shows that

  -- -------- --
     @xmath   
  -- -------- --

We also have that @xmath , @xmath are untouched by the operation: for
@xmath and @xmath , we have that

  -- -------- --
     @xmath   
  -- -------- --

since @xmath . How does @xmath affect the @xmath -vectors in terms of
the original generators @xmath ? Using the anti-commutation relations
and the definition of @xmath it is easy to convince yourself that all
@xmath -vectors are mapped to @xmath -vectors with @xmath (except for
@xmath itself). Hence, the coefficient of @xmath remains untouched. We
can thus conclude that

  -- -------- --
     @xmath   
  -- -------- --

for some coefficients @xmath and so on.

Finally, we now rotate the vector @xmath onto the vector @xmath . Note
that @xmath . Let @xmath be the normalized vector. Our rotation is
derived exactly analogous to the first step: Let @xmath , and let @xmath
. Let @xmath . A simple calculation analogous to the above shows that

  -- -------- --
     @xmath   
  -- -------- --

as desired. Again, we have @xmath for @xmath and @xmath . Furthermore,
@xmath -vectors remain @xmath -vectors under the actions of @xmath [
DL03 ] . Summarizing, we obtain

  -- -------- --
     @xmath   
  -- -------- --

for some coefficients @xmath and so on. Thus, we can take @xmath to
arrive at a new, simpler looking, state

  -- -------- --
     @xmath   
  -- -------- --

for some @xmath , etc.

Similarly, there exist of course orthogonal transformations @xmath that
take @xmath to @xmath . Such transformations flip the sign of a chosen
Clifford generator. In a similar way to the above, it is easy to see
that @xmath fulfills this task: we rotate @xmath by 90 degrees in the
plane given by @xmath and @xmath as in the example we examined in
Appendix C . Now, consider

  -- -------- --
     @xmath   
  -- -------- --

for @xmath . Clearly, if @xmath was a state, @xmath is a state as well.
Note that we no longer have terms involving @xmath in the basis
expansion: Note that if we flip the sign of precisely those terms that
have an index @xmath (i.e., they have a factor @xmath in the definition
of the operator basis), and then the coefficients cancel with those of
@xmath .

We now iterate this map through @xmath , and we are left with a final
state @xmath of the form

  -- -------- --
     @xmath   
  -- -------- --

By applying @xmath from above, we now transform @xmath to @xmath , which
is the first part of the lemma.

Looking at @xmath once more, we see that it can be positive semidefinite
only if @xmath , i.e., @xmath . Evidently, @xmath and hence @xmath is a
state.

Conversely, if @xmath , then the (Hermitian) operator @xmath has the
property

  -- -------- --
     @xmath   
  -- -------- --

i.e. @xmath , so @xmath . @xmath

##### 4.3.2 A meta-uncertainty relation

We now first use the above tools to prove a “meta”-uncertainty relation,
from which we will then derive two new entropic uncertainty relations.
Evidently, we have immediately from the above that {lemma} Let @xmath
with @xmath be a quantum state, and consider @xmath anti-commuting
observables @xmath . Then,

  -- -------- --
     @xmath   
  -- -------- --

Our result is essentially a generalization of the Bloch sphere picture
to higher dimensions: For @xmath ( @xmath ) the state is parametrized by
@xmath where @xmath , @xmath and @xmath are the familiar Pauli matrices.
Lemma 4.3.2 tells us that @xmath , i.e., the state must lie inside the
Bloch sphere (see Figure 2.1 ). Our result may be of independent
interest, since it is often hard to find conditions on the coefficients
@xmath such that @xmath is a state.

Notice that the @xmath are directly interpreted as the expectations of
the observables @xmath . Indeed, @xmath is precisely the bias of the
@xmath -variable @xmath :

  -- -------- --
     @xmath   
  -- -------- --

Hence, we can interpret Lemma 4.3.2 as a form of uncertainty relation
between the observables @xmath : if one or more of the observables have
a large bias (i.e., they are more precisely defined), this limits the
bias of the other observables (i.e., they are closer to uniformly
distributed).

##### 4.3.3 Entropic uncertainty relations

It turns out that Lemma 4.3.2 has strong consequences for the Rényi and
von Neumann entropic averages

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the Rényi entropy at @xmath of the probability
distribution arising from measuring the state @xmath with observable
@xmath . The minima over all states @xmath of such expressions can be
interpreted as giving entropic uncertainty relations, as we shall now do
for @xmath (the collision entropy) and @xmath (the Shannon entropy).

{theorem}

Let @xmath , and consider @xmath anti-commuting observables as defined
in Eq. ( 4.2 ). Then,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath , and the minimization is taken over all states @xmath .
The latter holds asymptotically for large @xmath . Proof. Using the fact
that @xmath we can first rewrite

  -- -------- --
     @xmath   
  -- -------- --

where the first inequality follows from Jensen’s inequality and the
concavity of the log, and the second from Lemma 4.3.2 . Clearly, the
minimum is attained if all @xmath . It follows from Lemma 4.3.1 that our
inequality is tight. Via the Taylor expansion of @xmath we obtain the
asymptotic result for large @xmath . @xmath

For the Shannon entropy ( @xmath ) we obtain something even nicer:
{theorem} Let @xmath , and consider @xmath anti-commuting observables as
defined in Eq. ( 4.2 ). Then,

  -- -------- --
     @xmath   
  -- -------- --

where @xmath , and the minimization is taken over all states @xmath .
Proof. To see this, note that by rewriting our objective as above, we
observe that we need to minimize the expression

  -- -------- --
     @xmath   
  -- -------- --

subject to @xmath and @xmath , via the identification @xmath . An
elementary calculation shows that the function @xmath is concave in
@xmath :

  -- -------- --
     @xmath   
  -- -------- --

and so

  -- -------- --
     @xmath   
  -- -------- --

Since we are only interested in the sign of the second derivative, we
ignore the (positive) factors in front of the bracket, and are done if
we can show that

  -- -------- --
     @xmath   
  -- -------- --

is non-positive for @xmath . Substituting @xmath , which is also between
@xmath and @xmath , we rewrite this as

  -- -------- --
     @xmath   
  -- -------- --

which has derivative

  -- -------- --
     @xmath   
  -- -------- --

and this is clearly positive for @xmath . In other words, @xmath
increases from its value at @xmath (where it is @xmath ) to its value at
@xmath (where it is @xmath ), so indeed @xmath for all @xmath .
Consequently, also @xmath for @xmath .

Hence, by Jensen’s inequality, the minimum is attained with one of the
@xmath being @xmath and the others @xmath , giving just the lower bound
of @xmath . @xmath

We have shown that anti-commuting Clifford observables obey the
strongest possible uncertainty relation for the von Neumann entropy. It
is interesting that in the process of the proof, however, we have found
three uncertainty type inequalities (the sum of squares bound, the bound
on @xmath , and finally the bound on @xmath ), and all three have a
different structure of attaining the limit. The sum of squares bound can
be achieved in every direction (meaning for every tuple satisfying the
bound we get one attaining it by multiplying all components by some
appropriate factor), the @xmath expression requires all components to be
equal, while the @xmath expression demands exactly the opposite.

#### 4.4 Conclusion

We showed that merely choosing our measurements to be mutually unbiased
does not lead to strong uncertainty relations. However, we were able to
identify another property which does lead to optimal entropic
uncertainty relations for two outcome measurements! Anti-commuting
Clifford observables obey the strongest possible uncertainty relation
for the von Neumann entropy: if we have no uncertainty for one of the
measurements, we have maximum uncertainty for all others. We also obtain
a slightly suboptimal uncertainty relation for the collision entropy
which is strong enough for all cryptographic purposes. Indeed, one could
use our entropic uncertainty relation in the bounded quantum storage
setting to construct, for example, 1-K oblivious transfer protocols
analogous to [ DFR @xmath 07 ] . Here, instead of encoding a single bit
into either the computational or Hadamard basis, which gives us a 1-2
OT, we now encode a single bit into the positive or negative eigenspace
of each of these @xmath operators. It is clear from the representation
of such operators discussed earlier, that such an encoding can be done
experimentally as easily as encoding a single bit into three mutually
unbiased basis given by @xmath , @xmath , @xmath . Indeed, our
construction can be seen as a direct extension of such an encoding: we
obtain the uncertainty relation for the three MUBs previously proved by
Sanchez [ San93 , SR95 ] as a special case of our analysis for @xmath .
It is perhaps interesting to note that the same operators also play a
prominent role in the setting of non-local games as discussed in Chapter
6.3.2 .

Sadly, strong uncertainty relations for measurements with more than two
outcomes remain inaccessible to us. It has been shown [ Feh07 ] that
uncertainty relations for more outcomes can be obtained via a coding
argument from uncertainty relations as we construct them here. Yet,
these are far from optimal. A natural choice would be to consider the
generators of a generalized Clifford algebra, yet such an algebra does
not have such nice symmetry properties which enabled us to implement
operations on the vector components above. It remains an exciting open
question whether such operators form a good generalization, or whether
we must continue our search for new properties.

### Chapter 5 Locking classical information

Locking classical correlations in quantum states [ DHL @xmath 04 ] is an
exciting feature of quantum information, intricately related to entropic
uncertainty relations. In this chapter, we will investigate whether good
locking effects can be obtained using mutually unbiased bases.

#### 5.1 Introduction

Consider a two-party protocol with one or more rounds of communication.
Intuitively, one would expect that in each round the amount of
correlation between the two parties cannot increase by much more than
the amount of data transmitted. For example, transmitting @xmath
classical bits or @xmath qubits (and using superdense coding) should not
increase the amount of correlation by more than @xmath bits, no matter
what the initial state of the two-party system was. This intuition is
accurate when we take the classical mutual information @xmath as our
correlation measure, and require all communication to be classical.
However, when quantum communication was possible at some point during
the protocol, everything changes: there exist two-party mixed quantum
states, such that transmitting just a single extra bit of classical
communication can result in an arbitrarily large increase in @xmath [
DHL @xmath 04 ] . The magnitude of this increase thereby only depends on
the dimension of the initial mixed state. Since then similar locking
effects have been observed, also for other correlation measures [ CW05b
, HHHO05 ] . Such effects play a role in very different scenarios: they
have been used to explain physical phenomena related to black holes [
SO06 ] , but they are also important in cryptographic applications such
as quantum key distribution [ KRBM07 ] and quantum bit string commitment
that we will encounter in Chapter 10 . We are thus interested in
determining how exactly we can obtain locking effects, and how dramatic
they can be.

##### 5.1.1 A locking protocol

The correlation measure considered here, is the classical mutual
information of a bipartite quantum state @xmath , which is the maximum
classical mutual information that can be obtained by local measurements
@xmath on the state @xmath (see Chapter 2 ):

  -- -------- -- -------
     @xmath      (5.1)
  -- -------- -- -------

Recall from Chapter 2 that the mutual information is defined as @xmath
where @xmath is the Shannon entropy. @xmath , @xmath , and @xmath are
the probability distributions corresponding to the individual and joint
outcomes of measuring the state @xmath with @xmath . The mutual
information between @xmath and @xmath is a measure of the information
that @xmath contains about @xmath . This measure of correlation is of
particular relevance for quantum bit string commitments in Chapter 10 .
Furthermore, the first locking effect was observed for this quantity in
the following protocol between two parties: Alice (A) and Bob (B). Let
@xmath with @xmath be a set of @xmath MUBs in @xmath . Alice picks an
element @xmath and a basis @xmath uniformly at random. She then sends
@xmath to Bob, while keeping @xmath secret. Such a protocol gives rise
to the joint state

  -- -------- --
     @xmath   
  -- -------- --

Clearly, if Alice told her basis choice @xmath to Bob, he could measure
in the right basis and obtain the correct @xmath . Alice and Bob would
then share @xmath bits of correlation, which is also their mutual
information @xmath , where @xmath is the state obtained from @xmath
after the announcement of @xmath . But, how large is @xmath , when Alice
does not announce @xmath to Bob? It was shown [ DHL @xmath 04 ] that in
dimension @xmath , using the two MUBs given by the unitaries @xmath and
@xmath applied to the computational basis we have @xmath (see Figure 5.1
, where @xmath ). This means that the single bit of basis information
Alice transmits to Bob “unlocks” @xmath bits: without this bit, the
mutual information is @xmath , but with this bit it is @xmath .

To get a good locking protocol, we want to use only a small number of
bases, i.e., @xmath should be as small as possible, while at the same
time forcing @xmath to be as low as possible. That is, we want @xmath to
be small.

It is also known that if Alice and Bob randomly choose a large set of
unitaries from the Haar measure to construct @xmath , then @xmath can be
brought down to a small constant [ HLSW04 ] . However, no explicit
constructions with more than two bases are known that give good locking
effects. Based on numerical studies for spaces of prime dimension @xmath
, one might hope that adding a third MUB would strengthen the locking
effect and give @xmath [ DHL @xmath 04 ] .

Here, however, we show that this intuition fails us. We prove that for
three MUBs given by @xmath , @xmath , and @xmath where @xmath and
dimension @xmath for some even integer @xmath , we have

  -- -------- -- -------
     @xmath      (5.2)
  -- -------- -- -------

the same locking effect as with two MUBs. We also show that for any
subset of the MUBs based on Latin squares and the MUBs in square
dimensions based on generalized Pauli matrices [ BBRV02 ] , we again
obtain Eq. ( 5.2 ), i.e., using two or all @xmath of them makes no
difference at all! Finally, we show that for any set of MUBs @xmath
based on generalized Pauli matrices in any dimension, @xmath , i.e., it
is enough to determine a bound on the entropic uncertainty relation to
determine the strength of the locking effect. Although bounds for
general MUBs still elude us, our results show that merely choosing the
bases to be mutually unbiased is not sufficient and we must look
elsewhere to find bases which provide good locking.

##### 5.1.2 Locking and uncertainty relations

We first explain the connection between locking and entropic uncertainty
relations. In particular, we will see that for MUBs based on generalized
Pauli matrices, we only need to look at such uncertainty relations to
determine the exact strength of the locking effect.

In order to determine how large the locking effect is for some set of
mutually unbiased bases @xmath , and the shared state

  -- -------- -- -------
     @xmath      (5.3)
  -- -------- -- -------

we must find the value of @xmath or at least a good upper bound. That
is, we must find a POVM @xmath that maximizes Eq. ( 5.1 ). Here, @xmath
is a probability distribution over @xmath . It has been shown in [ DHL
@xmath 04 ] that we can restrict ourselves to taking @xmath to be the
local measurement determined by the projectors @xmath . It is also known
that we can limit ourselves to take the measurement @xmath consisting of
rank one elements @xmath only [ Dav78 ] , where @xmath and @xmath is
normalized. Maximizing over @xmath then corresponds to maximizing Bob’s
accessible information as defined in Chapter 2 for the ensemble @xmath

  -- -- -------- -------- -------
        @xmath            (5.4)
                 @xmath   
  -- -- -------- -------- -------

where @xmath and @xmath . Therefore, we have @xmath . As we saw in
Chapter 2 , maximizing the accessible information is often a very hard
task. Nevertheless, for our choice of MUBs, the problem will turn out to
be quite easy in the end.

#### 5.2 Locking using mutually unbiased bases

##### 5.2.1 An example

We now determine how well we can lock information using specific sets of
mutually unbiased bases. We first consider a very simple example with
only three MUBs that provides the intuition behind the remainder of our
proof. The three MUBs we consider now are generated by the unitaries
@xmath , @xmath and @xmath when applied to the computational basis. For
this small example, we also investigate the role of the prior over the
bases and the encoded basis elements. It turns out that this does not
affect the strength of the locking effect positively, i.e., we do not
obtain a stronger locking affect using a non-uniform prior. Actually, it
is possible to show the same for encodings in many other bases. However,
we do not consider this case in full generality as to not obscure our
main line of argument.

{lemma}

Let @xmath , @xmath , and @xmath , and take @xmath where @xmath is an
even integer. Let @xmath with @xmath be a probability distribution over
the set @xmath . Suppose that @xmath and let @xmath with @xmath be the
joint distribution over @xmath . Consider the ensemble @xmath , then

  -- -------- --
     @xmath   
  -- -------- --

If, on the other hand, there exists a @xmath such that @xmath , then
@xmath . Proof. We first give an explicit measurement strategy and then
prove a matching upper bound on @xmath . Consider the Bell basis vectors
@xmath , @xmath , @xmath , and @xmath . Note that we can write for the
computational basis

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

The crucial fact to note is that if we fix some @xmath , then there
exist exactly two Bell basis vectors @xmath such that @xmath . For the
remaining two basis vectors the inner product with @xmath will be zero.
A simple calculation shows that we can express the two-qubit basis
states of the other two mutually unbiased bases analogously: for each
two qubit basis state there are exactly two Bell basis vectors such that
the inner product is zero and for the other two the inner product
squared is @xmath .

We now take the measurement given by @xmath with @xmath for the binary
expansion of @xmath . Fix a @xmath . By the above argument, there exist
exactly @xmath strings @xmath such that @xmath . Putting everything
together, Eq. ( 5.4 ) now gives us for any prior distribution @xmath
that

  -- -------- -- -------
     @xmath      (5.5)
  -- -------- -- -------

For our particular distribution we have @xmath and thus

  -- -------- --
     @xmath   
  -- -------- --

We now prove a matching upper bound that shows that our measurement is
optimal. For our distribution, we can rewrite Eq. ( 5.4 ) for the POVM
given by @xmath to

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

for the bases @xmath .

It follows from Corollary 4.2 that @xmath and @xmath

  -- -------- -------- -------- --
     @xmath   @xmath            
     @xmath   @xmath            
     @xmath            @xmath   
  -- -------- -------- -------- --

where we used the fact that @xmath . Reordering the terms we now get
@xmath Putting things together and using the fact that @xmath , we
obtain

  -- -------- --
     @xmath   
  -- -------- --

from which the result follows.

If, on the other hand, there exists a @xmath such that @xmath , then by
measuring in the basis @xmath we obtain @xmath , since the entropy will
be 0 for basis @xmath and we have @xmath . @xmath

Above, we have only considered a non-uniform prior over the set of bases
. In Chapter 3 , we observed that when we want to guess the XOR of a
string of length @xmath encoded in one (unknown to us) of these three
bases, the uniform prior on the strings is not the one that gives the
smallest probability of success. This might lead one to think that a
similar phenomenon could be observed in the present setting, i.e., that
one might obtain better locking with three basis for a non-uniform prior
on the strings. In what follows, however, we show that this is not the
case.

Let @xmath be the marginal distribution on the basis, then the
difference in Bob’s knowledge between receiving only the quantum state
and receiving the quantum state and the basis information, where we will
ignore the basis information itself, is given by

  -- -------- --
     @xmath   
  -- -------- --

Consider the post-measurement state @xmath . Using Eq. ( 5.5 ) we obtain

  -- -------- -- -------
     @xmath      (5.6)
  -- -------- -- -------

where @xmath is the von Neumann entropy. Consider the state

  -- -------- --
     @xmath   
  -- -------- --

for which we have that

  -- -------- -------- -- --
     @xmath   @xmath      
              @xmath      
              @xmath      
  -- -------- -------- -- --

Using Eq. ( 5.6 ) and the previous equation we get

  -- -------- --
     @xmath   
  -- -------- --

for any prior distribution. This bound is saturated by the uniform prior
and therefore we conclude that the uniform prior results in the largest
gap possible.

##### 5.2.2 MUBs from generalized Pauli matrices

We now consider MUBs based on the generalized Pauli matrices @xmath and
@xmath as described in Chapter 2.4.2 . We consider a uniform prior over
the elements of each basis and the set of bases. Choosing a non-uniform
prior does not lead to a better locking effect.

{lemma}

Let @xmath be any set of MUBs constructed on the basis of generalized
Pauli matrices in a Hilbert space of prime power dimension @xmath .
Consider the ensemble @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

Proof. We can rewrite Eq. ( 5.4 ) for a POVM @xmath of the form @xmath
as

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

For convenience, we split up the index @xmath into @xmath with @xmath
and @xmath , where @xmath in the following.

We first show that applying generalized Pauli matrices to the basis
vectors of a MUB merely permutes those vectors.

###### Claim 1

Let @xmath be a basis based on generalized Pauli matrices (Chapter 2.4.2
) with @xmath . Then @xmath we have that @xmath such that @xmath .

Proof. Let @xmath for @xmath denote the generalized Pauli’s @xmath ,
@xmath , @xmath , and @xmath . Note that @xmath , where @xmath .
Furthermore, define @xmath to be the Pauli operator @xmath applied to
the @xmath -th qupit. Recall from Section 2.4.2 that there exist sets of
Pauli operators @xmath such that the basis @xmath is the unique
simultaneous eigenbasis of the set of operators in @xmath , i.e., for
all @xmath and @xmath , @xmath and @xmath , we have @xmath . Note that
any vector @xmath that satisfies this equation is proportional to a
vector in @xmath . To prove that any application of one of the
generalized Paulis merely permutes the vectors in @xmath is therefore
equivalent to proving that @xmath are eigenvectors of @xmath for any
@xmath and @xmath . This can be seen as follows: Note that @xmath for
@xmath and @xmath with @xmath [ BBRV02 ] . A calculation then shows that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath for @xmath and @xmath for @xmath . Thus @xmath is an
eigenvector of @xmath for all @xmath and @xmath , which proves our
claim. @xmath

Suppose we are given @xmath that minimizes @xmath . We can then
construct a full POVM with @xmath elements by taking @xmath with @xmath
. However, it follows from our claim above that @xmath such that @xmath
, and thus @xmath from which the result follows. @xmath

Determining the strength of the locking effects for such MUBs is thus
equivalent to proving bounds on entropic uncertainty relations. We thus
obtain as a corollary of Theorem 4.2.1 and Lemma 5.2.2 , that, for
dimensions which are the square of a prime power (i.e. @xmath ), using
any product MUBs based on generalized Paulis does not give us any better
locking than just using 2 MUBs. {corollary} Let @xmath with @xmath be
any set of MUBs constructed on the basis of generalized Pauli matrices
in a Hilbert space of prime (power) dimension @xmath . Define @xmath as
the unitary that transforms the computational basis into the @xmath -th
MUB, i.e., @xmath . Let @xmath be the set of product MUBs with @xmath in
dimension @xmath . Consider the ensemble @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

Proof. The claim follows from Theorem 4.2.1 and the proof of Lemma 5.2.2
, by constructing a similar measurement formed from vectors @xmath with
@xmath and @xmath , where @xmath and @xmath are defined like @xmath and
@xmath in the proof of Lemma 5.2.2 , and @xmath from above. @xmath

The simple example we considered above is in fact a special case of
Corollary 5.2.2 . It shows that if the vector that minimizes the sum of
entropies has certain symmetries, the resulting POVM can even be much
simpler. For example, the Bell states are vectors which such symmetries.

##### 5.2.3 MUBs from Latin squares

At first glance, one might think that maybe the product MUBs based on
generalized Paulis are not well suited for locking just because of their
product form. Perhaps MUBs with entangled basis vectors do not exhibit
this problem? Let’s examine how well MUBs based on Latin squares can
lock classical information in a quantum state. All such MUBs are highly
entangled, with the exception of the two extra MUBs based on non-Latin
squares. Surprisingly, it turns out, however, that any set of at least
two MUBs based on Latin squares, does equally well at locking as using
just 2 such MUBs. Thus such MUBs perform equally “badly”, i.e., we
cannot improve the strength of the locking effect by using more MUBs of
this type.

{lemma}

Let @xmath with @xmath be any set of MUBs in a Hilbert space of
dimension @xmath constructed on the basis of Latin squares. Consider the
ensemble @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

Proof. Note that we can again rewrite @xmath as in the proof of Lemma
5.2.2 . Consider the simple measurement in the computational basis
@xmath . The result then follows by the same argument as in Lemma 4.2.2
. @xmath

Intuitively, our measurement outputs one sub-square of the Latin square
used to construct the MUBs as depicted in Figure 5.2 . As we saw in the
construction of MUBs based on Latin squares in Chapter 2.4.1 , each
entry “occurs” in exactly @xmath MUBs.

#### 5.3 Conclusion

We have shown tight bounds on locking for specific sets of mutually
unbiased bases. Surprisingly, it turns out that using more mutually
unbiased basis does not always lead to a better locking effect. It is
interesting to consider what may make these bases so special. The
example of three MUBs considered in Lemma 5.2.1 may provide a clue.
These three bases are given by the common eigenbases of @xmath , @xmath
and @xmath respectively [ BBRV02 ] . However, @xmath , @xmath and @xmath
commute and thus also share a common eigenbasis, namely the Bell basis.
This is exactly the basis we will use as our measurement. For all MUBs
based on generalized Pauli matrices, the MUBs in prime power dimensions
are given as the common eigenbasis of similar sets consisting of strings
of Paulis. It would be interesting to determine the strength of the
locking effect on the basis of the commutation relations of elements of
different sets. Furthermore, perhaps it is possible to obtain good
locking from a subset of such MUBs where none of the elements from
different sets commute.

It is also worth noting that the numerical results of [ DHL @xmath 04 ]
indicate that at least in dimension @xmath using more than three bases
does indeed lead to a stronger locking effect. It would be interesting
to know, whether the strength of the locking effect depends not only on
the number of bases, but also on the dimension of the system in
question.

Whereas general bounds still elude us, we have shown that merely
choosing mutually unbiased bases is not sufficient to obtain good
locking effects. We thus have to look for different properties. Sadly,
whereas we were able to obtain good uncertainty relations in Chapter 4.3
, the same approach does not work here: To obtain good locking we must
not only find good uncertainty relations, but also find a way to encode
many bits using only a small number of encodings.

## Part III Entanglement

### Chapter 6 Introduction

Entanglement is possibly the most intriguing element of quantum theory.
It plays a crucial role in quantum algorithms, quantum cryptography and
the understanding of quantum mechanics itself. It enables us to perform
quantum teleportation, as well as superdense coding [ NC00 ] . In this
part, we investigate one particular aspect of quantum entanglement: the
violation of Bell-inequalities, and their implications for classical
protocols. But first, let’s take a brief look at the history of
entanglement, and introduce the essential ingredients we need later.

#### 6.1 Introduction

In 1935, Einstein, Podolsky and Rosen (EPR) identified one of the
striking consequences of what latter became known as entanglement. In
their seminal article [ EPR35 ] ”Can Quantum Mechanical Description of
Physical Reality Be Considered Complete?” the authors define “elements
of reality” as follows:

  If, without in any way disturbing a system, we can predict with
  certainty (i.e. with probability equal to unity) the value of a
  physical quantity, then there exists an element of physical reality
  corresponding to this physical quantity.

EPR call a theory that satisfies this condition complete . They put
forward the now famous EPR-Paradox, here stated informally using
discrete variables as put forward by Bohm [ Per93 ] . EPR assume that if
we have a state shared between two spatially separated systems, Alice
and Bob, that do not interact at the time of a measurement,

  no real change can take place in the second system as a consequence of
  anything that may be done to the first system.

That means that Alice and Bob cannot use the shared state itself to
transmit information. We will also refer to this as the no-signaling
condition. Now consider the shared state

  -- -------- -- -------
     @xmath      (6.1)
  -- -------- -- -------

Suppose that we measure Alice’s system in the computational basis to
obtain outcome @xmath . Note that we can now predict the outcome of a
measurement of Bob’s system in the computational basis with certainty:
@xmath , without having disturbed Bob’s system in any way. Thus @xmath
is an “element of physical reality”. However, we might as well have
measured Alice’s system in the Hadamard basis to obtain outcome @xmath .
Likewise, we can now predict with certainty the outcome of measuring
Bob’s system in the Hadamard basis, @xmath , again without causing any
disturbance to the second system. Thus @xmath should also be an “element
of physical reality”. But as we saw in Chapter 4 , quantum mechanics
forbids us to assign exact values to both @xmath and @xmath
simultaneously, as measurements in the computational and Hadamard basis
are non-commutative. Indeed, in Chapter 4.2 , we saw that these two
measurements give the strongest entropic uncertainty relation for two
measurements. EPR thus conclude

  that the quantum mechanical description of reality given by the wave
  function is not complete.

EPR’s article spurred a flurry of discussion that continues up to the
present day. Shortly after the publication of their article, Schrödinger
published two papers in which he coined the term entanglement (German:
Verschränkung) [ Sch35b , Sch35a ] and investigated this phenomenon
which he described as “not one, but rather the characteristic trait of
quantum mechanics, the one that enforces its entire departure from
classical lines of thought” [ Sch35b ] . One point of discussion in the
ensuing years was whether the fact that quantum mechanics is not
complete, means that there might exist a more detailed description of
nature which is complete. Even though, these more detailed descriptions
also called ‘‘hidden variables’’ had remained inaccessible to us so far:
a better theory and better technology might enable us to learn them.
Thus quantum mechanical observations would merely appear to be
probabilistic in the absence of our knowledge of such hidden variables.

##### 6.1.1 Bell’s inequality

This idea was put to rest by Bell [ Bel65 ] in 1964, when he proposed
conditions that any classical theory, i.e. any theory based on local
hidden variables, has to satisfy, and which can be verified
experimentally. These conditions are known as Bell inequalities .
Intuitively, Bell inequalities measure the strength of non-local
correlations attainable in any classical theory. Non-local correlations
arise as the result of measurements performed on a quantum system shared
between two spatially separated parties. Imagine two parties, Alice and
Bob, who are given access to a shared quantum state @xmath , but cannot
communicate. In the simplest case, each of them is able to perform one
of two possible measurements. Every measurement has two possible
outcomes labeled @xmath . Alice and Bob now measure @xmath using an
independently chosen measurement setting and record their outcomes. In
order to obtain an accurate estimate for the correlation between their
measurement settings and the measurement outcomes, they perform this
experiment independently many times using an identically prepared state
@xmath in each round.

Both classical and quantum theories impose limits on the strength of
non-local correlations. In particular, both should not violate the
non-signaling condition of special relativity as put forward by EPR
above. That is, the local choice of the measurement setting does not
allow Alice and Bob to transmit information. Limits on the strength of
correlations which are possible in the framework of any classical theory
are the Bell inequalities. The best known Bell inequality is the
Clauser, Horne, Shimony and Holt (CHSH) inequality [ CHSH69 ]

  -- -------- -- -------
     @xmath      (6.2)
  -- -------- -- -------

where @xmath and @xmath are the observables representing the measurement
settings of Alice and Bob respectively and we use @xmath to denote the
mean value of @xmath and @xmath . Quantum mechanics allows for a
violation of the CHSH inequality, and is thus indeed non-classical: If
we take the shared state @xmath and let @xmath , @xmath , @xmath , and
@xmath we obtain

  -- -------- --
     @xmath   
  -- -------- --

Most importantly, this violation can be experimentally verified allowing
us to test the validity of the theory. The first such tests were
performed by Clauser [ Cla76 ] and Aspect, Dalibard, Grangier, and Roger
[ AGR82 , ADR82 ] . Over the years these tests have been refined
considerably, ruling out many loopholes present in the initial
experiments such as for example detector inefficiency [ RKM @xmath 01 ]
. Yet, no conclusive test has been achieved so far. Unfortunately, such
experimental concerns are outside the scope of this thesis, and we
merely point to an overview of such issues [ Asp99 ] .

##### 6.1.2 Tsirelson’s bound

Curiously, even quantum mechanics itself still limits the strength of
non-local correlations. Tsirelson’s bound [ Tsi80 ] says that for
quantum mechanics

  -- -------- --
     @xmath   
  -- -------- --

and thus the above measurements are optimal. We provide a simple proof
of this fact in Chapter 7 . It is interesting to consider what would
happen if quantum mechanics allowed for more powerful non-local
correlations. To this end, it is convenient to rewrite the CHSH
inequality from Eq. ( 6.2 ) in the form

  -- -------- --
     @xmath   
  -- -------- --

Here, @xmath and @xmath denote the choice of Alice’s and Bob’s
measurement, @xmath and @xmath the respective binary outcomes, and
@xmath addition modulo @xmath (see Section 6.2.3 for details). In this
form, quantum mechanics allows a violation up to the maximal value of
@xmath . Since special relativity would even allow a violation of
Tsirelson’s bound, Popescu and Rohrlich [ PR94 , PR96 , PR97 ] raised
the question why nature is not more ’non-local’? That is, why does
quantum mechanics not allow for a stronger violation of the CHSH
inequality up to the maximal value of 4? To gain more insight into this
question, they constructed a toy-theory based on non-local boxes. Each
such box takes inputs @xmath from Alice and Bob respectively and always
outputs measurement outcomes @xmath , @xmath such that @xmath . Alice
and Bob still cannot use this box to transmit any information. However,
since for all @xmath and @xmath , @xmath , the above sum equals 4 and
thus non-local boxes lead to a maximum violation of the CHSH inequality.

Van Dam [ vD05 , vD00 ] has shown that having access to such non-local
boxes allows Alice and Bob to perform any kind of distributed
computation by transmitting only a single bit of information. This is
even true for slightly less perfect boxes achieving weaker correlations
[ BBL @xmath 06 ] . In [ BCU @xmath 06 ] , we showed that given any
non-local boxes, Alice and Bob could perform bit commitment and
oblivious transfer, which is otherwise known to be impossible. Thus,
such cryptographic principles are in principle compatible with the
theory of non-signaling: non-signaling itself does not prevent us from
implementing them.

Looking back to the uncertainty relations in Chapter 4 , which rest at
the heart of the EPR paradox, we might suspect that the violation of the
CHSH inequality likewise depends on the commutation relations between
the local measurements of Alice and Bob. Indeed, it has been shown by
Landau [ Lan87 ] , and Khalfin and Tsirelson [ KT87 ] , there exists a
state @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

for any @xmath , @xmath and @xmath , @xmath , where we use the
superscripts ’0’ and ’1’ to denote the projectors onto the positive and
negative eigenspace respectively. Thus, given any observables @xmath and
@xmath , the CHSH inequality is violated if and only if @xmath .

#### 6.2 Setting the stage

##### 6.2.1 Entangled states

The state given in Eq. ( 6.1 ) is just one possible example of an
entangled state. Recall from Chapter 2 that if @xmath is a pure state,
we say that @xmath is separable if and only if there exist states @xmath
and @xmath such that @xmath . A separable pure state is also called a
product state . A state that is not separable is called entangled . For
mixed states the definition is slightly more subtle. Let @xmath be a
mixed state. Then @xmath is called a product state if there exist @xmath
and @xmath such that @xmath . The state @xmath is called separable , if
there exists an ensemble @xmath such that @xmath with @xmath and @xmath
for all @xmath , such that

  -- -------- --
     @xmath   
  -- -------- --

Intuitively, if @xmath is separable then @xmath corresponds to a mixture
of separable pure states according to a joint probability distribution
@xmath , a purely classical form of correlation. Given a description of
a mixed state @xmath it is an NP-hard problem to decide whether @xmath
is separable [ Gur03 ] . However, many criteria and approximation
algorithms have been proposed [ DPS02 , DPS04 , DPS05 , IT06 , ITCE04 ]
. It is an interesting question to determine the maximal violation of a
given Bell-inequality for a fixed state @xmath [ LD07 ] . Here, we only
concern ourselves with maximal violations of Bell inequalities, and
refer to [ Ioa07 ] for an overview of the separability problem.
Generally, the maximal violation is obtained by using the maximally
entangled state. However, there are cases for which the maximal
violation is achieved by a non maximally entangled state [ CGL @xmath 02
] . Note that we can never observe a Bell inequality violation for a
separable state: it is no more than a classical mixture of separable
pure states. On the other hand, any two-qubit pure state that is
entangled violates the CHSH inequality [ Gis91 ] . However, not all
entangled mixed states violate the CHSH inequality! A counterexample was
given by Werner [ Wer81 ] with the so-called Werner-state

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath are projectors onto the symmetric and the
anti-symmetric subspace respectively. For @xmath this state is
separable, but it is entangled for @xmath . Yet, the CHSH inequality is
not violated. A lot of work has been done to quantify the amount of
entanglement in quantum states, and we refer to [ Ter99 , Eis01 , Chr05
] for an overview.

##### 6.2.2 Other Bell inequalities

The CHSH inequality we encountered above is by no means the only Bell
inequality. Recall that non-local correlations arise as the result of
measurements performed on a quantum system shared between two spatially
separated parties. Let @xmath and @xmath be the variables corresponding
to Alice and Bob’s choice of measurement. Let @xmath and @xmath denote
the corresponding outcomes ¹ ¹ 1 For simplicity, we assume that the set
of possible outcomes is the same for each setting. . Let @xmath be the
probability of obtaining outcomes @xmath given settings @xmath . What
values are allowed for @xmath ? Clearly, we want that for all @xmath we
have that @xmath and @xmath . From the no-signaling condition we
furthermore obtain that the marginals obey @xmath and likewise for
@xmath , i.e. the probability of Alice’s measurement outcome is
independent of Bob’s choice of measurement setting, and vice versa. For
@xmath players, who each perform one of @xmath measurements with @xmath
possible outcomes, we have @xmath such probabilities to assign, giving
us a @xmath dimensional vector. To find all Bell inequalities, we now
look for inequalities that bound the classically accessible region (a
convex polytope) for such assignments. It is clear that we can find a
huge number of such inequalities. Of course, often the most interesting
inequalities are the ones that are satisfied only classically, but where
we can find a better quantum strategy. Much work has been done to
identify such inequalities, and we refer to [ WW01b ] for an excellent
overview. In the following chapters, we are interested in the following
related question: Given an inequality, what is the optimal quantum
measurement strategy that maximizes the inequality?

##### 6.2.3 Non-local games

It is often convenient to view Bell experiments as a game between two,
or more, distant players, who cooperate against a special party. We call
this special party the verifier . In a two player game with players
Alice and Bob, the verifier picks two questions, say @xmath and @xmath ,
and hands them to Alice and Bob respectively, who now need to decide
answers @xmath and @xmath . To this end, they may agree on any strategy
beforehand, but can no longer communicate once the game starts. The
verifier then decides according to a fixed set of public rules, whether
Alice and Bob win by giving answers @xmath to questions @xmath . In a
quantum game, Alice and Bob may perform measurements on a shared
entangled state to determine their answers. We can thus think of the
questions as measurement settings and the answers as measurement
outcomes.

More formally, we consider games among @xmath players @xmath . Let
@xmath and @xmath be finite sets corresponding to the possible questions
and answers respectively. Let @xmath be a probability distribution on
@xmath , and let @xmath be a predicate on @xmath . Then @xmath is the
following @xmath -player cooperative game: A set of questions @xmath is
chosen at random according to the probability distribution @xmath .
Player @xmath receives question @xmath , and then responds with answer
@xmath . The players win if and only if @xmath . We write @xmath to
emphasize the fact that @xmath are the answers given questions @xmath .

The value of the game @xmath is the probability that the players win the
game, maximized over all possible strategies. We use @xmath and @xmath
to differentiate between the value of the game in the classical and
quantum case respectively. Classically, @xmath can always be attained by
a deterministic strategy [ CHTW04a ] . We can thus write

  -- -------- -- -------
     @xmath      (6.3)
  -- -------- -- -------

where the maximization is taken over all functions @xmath that determine
answers @xmath .

Quantumly, the strategy of the players consists of their choice of
measurements and shared entangled state. Let @xmath denote the players’
choice of state, and let @xmath denote the POVM of player @xmath for
question @xmath . Here, we always assume that the underlying Hilbert
space is finite-dimensional. The value of the quantum game is then

  -- -------- -- -------
     @xmath      (6.4)
  -- -------- -- -------

where the maximization is taken over all POVMS @xmath for all @xmath and
@xmath . In the following, we say that a set of measurement operators
achieves @xmath , if

  -- -------- --
     @xmath   
  -- -------- --

Of particular relevance in the next chapters is a special class of
two-player games known as XOR-games [ CHTW04a ] : Here, @xmath and we
assume that @xmath . The two players @xmath (Alice) and @xmath (Bob)
each have only two possible measurement outcomes. Furthermore, the
winning condition only depends on the XOR of answers @xmath and @xmath
and thus we write @xmath with @xmath . It can be shown [ CHTW04a ] that
the optimal POVM in this case consists only of projectors. We can thus
write @xmath and @xmath as observables with two eigenvalues: @xmath and
@xmath where @xmath and @xmath . A small calculation using the fact that
@xmath and @xmath shows that we can rewrite the optimal value of a
quantum XOR-game as

  -- -------- -------- -- -------
     @xmath               (6.5)
              @xmath      (6.6)
  -- -------- -------- -- -------

From the above, we can see that XOR-games correspond to correlation
inequalities with two-outcome measurements. We will see in Chapter 7
that this reformulation enables us to determine the optimal measurements
for such XOR-games in a very simple manner. Indeed, the CHSH inequality
can be rephrased as a simple quantum XOR-game. Here, Alice and Bob win
if and only if given questions @xmath they return answers @xmath such
that @xmath , i.e. we have @xmath if and only if @xmath . Recalling
Eq. ( 6.2 ) we can write

  -- -------- --
     @xmath   
  -- -------- --

from which we obtain @xmath vs. @xmath .

#### 6.3 Observations

In the following chapters, we are concerned with finding the optimal
quantum measurement strategies for Bell inequalities. To this end, we
first make a few simple observations that help us understand the
structural properties of our problem. In particular, this also enables
us to understand the relation between Bell inequalities and the problem
of post-measurement information in Chapter 6.4 . We then present a
theorem by Tsirelson [ Tsi80 , Tsi87 ] that plays a crucial role in the
subsequent chapters.

##### 6.3.1 Simple structural observations

Suppose we are given a set of measurements for Alice and Bob and a
shared state @xmath . Can we reduce the dimension of Alice and Bob’s
measurements operators and the thereby amount of entanglement they need?
As we saw in Chapter 2 , we can often simplify our problem by
identifying its classical and quantum part. Indeed, this is also the
case here. {lemma} Let @xmath and let @xmath and @xmath be the set of
Alice and Bob’s measurement operators respectively. Let @xmath be the
state shared by Alice and Bob. Suppose that for such operators we have

  -- -------- --
     @xmath   
  -- -------- --

Then there exist measurement operators @xmath and @xmath and a state
@xmath such

  -- -------- --
     @xmath   
  -- -------- --

and the @xmath -algebra generated by @xmath and @xmath is simple. Proof.
Let @xmath and @xmath . If @xmath and @xmath are simple, we are done. If
not, we know from Lemma B.4.1 and Lemma B.4.2 that there exists a
decomposition @xmath . Consider @xmath , where @xmath . It follows from
the above that @xmath , where @xmath and @xmath are projectors onto
@xmath and @xmath respectively. Let @xmath . Clearly,

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

The statement now follows immediately by convexity: Alice and Bob can
now measure @xmath using @xmath and record the classical outcomes @xmath
. The new measurements are then @xmath and @xmath on state @xmath . By
construction, @xmath and @xmath are simple.

Let @xmath denote the probability that we obtain outcomes @xmath , and
let

  -- -------- --
     @xmath   
  -- -------- --

Then @xmath . Let @xmath be such that @xmath . Hence, we can skip the
initial measurement and instead use measurements @xmath , @xmath and
state @xmath . @xmath

It also follows immediately from the above proof that {corollary} @xmath

We can thus assume without loss of generality, that the algebra
generated by Alice and Bob’s optimal measurements is always simple. We
also immediately see why we can simulate the quantum measurement
classically if Alice or Bob’s measurements commute locally. Indeed, the
above proof tells us how to construct the appropriate classical
strategy: {corollary} Let @xmath and let @xmath and @xmath be the set of
Alice and Bob’s measurement operators respectively. Let @xmath be the
state shared by Alice and Bob. Let @xmath be the value of the non-local
game achieved using these measurements. Suppose that for all @xmath ,and
@xmath we have that @xmath (or for all @xmath , @xmath @xmath ). Then
there exists a classical strategy for Alice and Bob that achieves @xmath
. Proof. Our conditions imply that either @xmath or @xmath is abelian.
Suppose wlog that @xmath is abelian. Hence, by the above proof we have
@xmath . Again, Alice and Bob perform the measurements determined by
@xmath and @xmath and record their outcomes @xmath . Since @xmath ,
Alice’s post-measurement state is in fact classical, and we have no
further entanglement between Alice and Bob. @xmath

To violate a Bell inequality, Alice and Bob must thus use measurements
which do not commute locally. However, since Alice and Bob are spatially
separated, we can write Alice and Bob’s measurement operators as @xmath
and @xmath respectively as for any @xmath we can write @xmath . Thus
@xmath . Thus from a bipartite structure we obtain certain commutation
relations. How about the converse? As it turns out, in any
finite-dimensional @xmath -algebra ² ² 2 or indeed any Type-I von
Neumann algebra , these two notions are equivalent: From commutation we
immediately obtain a bipartite structure! We encounter this well-known,
rather beautiful observation in Appendix B .

##### 6.3.2 Vectorizing measurements

In Chapter 7 , we show how to obtain the optimal measurements for any
bipartite correlation inequality. At first sight, this may appear to be
a daunting problem: We must simultaneously maximize Eq. ( 6.5 ) over the
state @xmath as well as measurement operators of the form @xmath , a
problem which is clearly not convex. Yet, the following brilliant
observation by Tsirelson [ Tsi80 , Tsi87 ] greatly simplifies our
problem.

{theorem}

[Tsirelson] Let @xmath and @xmath be observables with eigenvalues in the
interval @xmath . Then for any state @xmath and for all @xmath , @xmath
, there exist real unit vectors @xmath , @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the standard inner product. Conversely, let @xmath be
real unit vectors. Let @xmath be any maximally entangled state where
@xmath . Then for all @xmath , @xmath there exist observables @xmath on
@xmath and @xmath on @xmath with eigenvalues in @xmath such that

  -- -------- --
     @xmath   
  -- -------- --

In fact, by limiting ourselves onto the space spanned by the vectors
@xmath or @xmath , we could further decrease the dimension of the
vectors to @xmath [ Tsi87 ] . The result was proven by Tsirelson in a
more general form for any finite-dimensional @xmath -algebra. Here, we
do not consider this more abstract argument, but instead simply sketch
how to obtain the vectors and state how to find the corresponding
measurement operators in turn [ Tsi93 ] . To find vectors @xmath and
@xmath , we merely need to consider the vectors

  -- -------- --
     @xmath   
  -- -------- --

where may take the vectors to be real [ Tsi80 ] . Recall that we are
only interested in the inner products. But clearly we can then bound the
dimension of our vectors as the number of our vectors is strictly
limited and thus cannot span a space of dimension larger than @xmath .

To construct observables corresponding to a given set of vectors,
consider the generators of a Clifford algebra @xmath with @xmath even ³
³ 3 If @xmath is odd, we obtain one additional element from @xmath .
that we already encountered in Section 4.3 , i.e., we have that for all
@xmath , @xmath and @xmath . Note that we also have @xmath as the two
matrices anti-commute. Consider two vectors @xmath with @xmath and
@xmath . Define @xmath and @xmath and let @xmath with @xmath be the
maximally entangled state. We then have

  -- -------- --
     @xmath   
  -- -------- --

Note that in principle we could have chosen any set of orthogonal
operators @xmath to obtain the stated equality. However, we obtain from
their anti-commutation that

  -- -------- --
     @xmath   
  -- -------- --

since @xmath . Hence, @xmath has eigenvalues in @xmath as desired.
Curiously, @xmath were also the right choice of operators to obtain good
uncertainty relations in Chapter 4.3 .

#### 6.4 The use of post-measurement information

Looking back to Chapter 3 , we see that we have already encountered the
same structure in the context of post-measurement information. Recall
that there our goal was to determine @xmath given some @xmath after
receiving additional post-measurement information @xmath . In
particular, as we explain in more detail in Chapter 8 we see that the
question of how much post-measurement information is required is the
same as the following: given a set of observables, how large does our
quantum state have to be in order to implement the resulting non-local
game? However, we can further exploit the relationship between these two
problems to prove a gap between the optimal success probability in the
setting of state discrimination (STAR) and the setting of state
discrimination with post-measurement information (PI-STAR). In
particular, we show that for some problems, if we can succeed perfectly
in the setting of PI-STAR without keeping any qubits at all, our success
at STAR can in fact be bounded by a Bell-type inequality! Of course,
PI-STAR itself is not a non-local problem. However, as we saw in
Appendix B , the commutation relations which are necessary for Bob to
succeed at PI-STAR perfectly in Lemma 3.5.1 , do induce a bipartite
structure. We now exploit the structural similarity of the two problems.

We first consider the very simple case of two bases and a Boolean
function. Here, it turns out that we can bound the value of the STAR
problems using the CHSH inequality. We do this by showing a bound on the
average of two equivalent STAR problems, illustrated in Figures 6.4 and
6.4 . The XOR function considered in Chapter 3 is an example of such a
problem. Below we construct a generalization of the CHSH inequality
which allows us to make more general statements. We state our result in
the notation introduced in Chapter 3 . For simplicity, we use indices
@xmath and @xmath to denote two arbitrary bases and use the notation
@xmath to refer to a state discrimination problem between @xmath
different states.

{lemma}

Let @xmath for all @xmath and let @xmath be any Boolean function. Let
@xmath denote a set of two bases, and suppose there exists a unitary
@xmath such that @xmath , @xmath , @xmath and @xmath . Suppose Bob
succeeds at @xmath with probability @xmath . Then he succeeds at @xmath
with probability at most 3/4, where @xmath , @xmath . Proof. Let @xmath
, @xmath , @xmath and @xmath be projectors onto the support of @xmath ,
@xmath , @xmath and @xmath respectively. Suppose that Bob succeeds with
probability @xmath at @xmath . Then there exists a strategy for Alice
and Bob to succeed at the CHSH game with probability @xmath , where
Alice’s measurements are given by @xmath and @xmath :

Let @xmath and @xmath . Note that since there exists such a @xmath , we
have that Bob succeeds at @xmath with probability @xmath as well.
Suppose that Alice and Bob share the maximally entangled state @xmath
with @xmath . With probability @xmath Alice chooses measurement setting
@xmath and then her measurement is given by @xmath . Let @xmath denote
her measurement outcome. Bob’s system is now in the state @xmath .
Similarly, with probability @xmath Alice sets @xmath and measures @xmath
, which leaves Bob’s system in the state @xmath . Let @xmath denote
Bob’s measurement setting. The CHSH game now requires Bob to obtain a
measurement outcome @xmath such that @xmath . Thus, for @xmath , Bob
always tries to obtain @xmath which means he wants to solve @xmath . For
@xmath , Bob tries to obtain @xmath for @xmath but @xmath for @xmath ,
i.e., he wants to solve @xmath . Since Bob chooses @xmath uniformly at
random, we obtain the stated result.

Now suppose that Bob succeeds at @xmath with probability @xmath . We
know from Lemma 3.5.1 that for all @xmath and @xmath we have @xmath
where @xmath is a projector onto the support of @xmath . Now, suppose
that on the contrary he succeeds at @xmath with probability greater than
@xmath . Then we know from the above argument that there exists a
strategy for Alice and Bob to succeed at the CHSH game with probability
greater than @xmath where Alice measures two commuting observables,
which contradicts Corollary 6.3.1 . @xmath

It may appear unrealistic to assume that the two STAR problems are
essentially equal. Note however, that this is indeed the case in the
example of the XOR function and two mutually unbiased bases (e.g.
computational and Hadamard). The unitary here is just @xmath , as @xmath
acts as a bit-flip in the Hadamard basis, but leaves the computational
basis invariant. We saw in the proof of Theorem 3.3.4 that such
unitaries exist for any choice of two bases from the computational,
Hadamard and K-basis. Indeed, for the XOR function on a string of length
@xmath with @xmath even we saw that for STAR the optimal probability is
@xmath , whereas for PI-STAR we obtained @xmath , as expected.

To generalize this approach, we need to consider more complicated
inequalities. In general, there are many possibilities for such
inequalities, and one should choose an inequality that reflects the
equivalences of possible STAR problems: For example, for the XOR
function the CHSH inequality is a good choice as we could identify
@xmath to give us an equivalence between the two problems. Of course, we
would like to ensure that for one of Bob’s measurement settings he needs
to solve the original STAR problem where Bob’s goal is to determine
Alice’s measurement outcome. At the same time, we would like to minimize
the number of possibly inequivalent additional STAR problems created in
a similar proof, i.e. we would like to find an inequality where Bob has
only a small number of measurement settings. As an example, we consider
the following easy way to extend the CHSH inequality. Here, we assume
that Alice has equally many measurement outcomes as she has measurement
settings. In the language of PI-STAR that means we have wlog @xmath . We
fix the number of Bob’s measurement settings to 2, but allow an
arbitrarily large number of settings @xmath for Alice. Wlog we use
@xmath and @xmath . We now define the predicate @xmath with the help of
the function @xmath for @xmath and @xmath . Let @xmath for all @xmath
and let @xmath and @xmath for all @xmath , where @xmath is the cyclic
permutation. We now define the inequality as a non-local game with
predicate @xmath if and only if @xmath . Intuitively, this means that if
Bob chooses setting @xmath he is required to solve the original STAR
problem, where he tries to guess Alice’s measurement outcome. For the
setting @xmath he has to solve the problem where the values of @xmath
are shifted depending on the basis. Note that the CHSH inequality is a
special case of this inequality. Recall from Section 6.2.3 that the
optimal value of a classical game can always be attained by a
deterministic strategy. Let @xmath and @xmath denote the functions
implementing this strategy for Alice and Bob respectively. Looking at
Eq. ( 6.3 ) we see that we can write

  -- -------- --
     @xmath   
  -- -------- --

where @xmath if and only if @xmath . It is easy to see that for a
uniform choice of Alice and Bob’s measurements, the best thing Bob can
do is answer @xmath for all @xmath where we choose any fixed @xmath and
let @xmath for all @xmath , i.e. Alice and Bob agree on a particular
outcome which will always be their answer regardless of their setting.
For @xmath this means that Bob is always correct, and for @xmath he will
be correct if Alice obtained @xmath . We then have @xmath . For the CHSH
case, this gives us @xmath as expected. It is now possible to make a
similar statement then in Lemma 6.4 for a bigger PI-STAR problem.

The connection to Bell inequalities helped us understand the case where
there exists a clear gap between the two problems. Here,
post-measurement information was extremely helpful to us. However, as we
saw in Chapter 3 there do exist cases where post-measurement information
is entirely useless: we can do equally well without it, if we cannot
store any quantum information. Interestingly, in the example of the XOR
function on an odd number of input bits this happens exactly when the
corresponding states correspond to a measurement that maximally violates
CHSH. We have thus reached an extremal point of our problem. Is it
possible to find conditions on a set of states which determine when
post-measurement information is indeed useful?

#### 6.5 Conclusion

As we saw, entanglement is an inherent aspect of quantum theory. We can
experimentally violate Bell’s inequality, because we can indeed measure
non-commuting observables. The existence of such violations is, next to
uncertainty relations and locking, another consequence of the existence
of non-commuting measurements within quantum theory. This illustrates
their close link to uncertainty relations, locking and even
post-measurement information we encountered in the preceding chapters.
In essence, in all these tasks we are faced with exactly the same
problem: what are the consequences of non-commuting measurements? And
how can we find maximally “incompatible” measurements?

In the following chapters, we examine entanglement from a variety of
viewpoints. In Chapter 7 , we first consider Bell inequalities, and show
how to find upper bounds on their violation in a quantum setting. Our
approach allows us to find the optimal measurements for any bipartite
correlation inequality with two-outcome measurements in a very easy
manner. We then consider more general multipartite inequalities. Sadly,
our method does not easily apply for more general inequalities. In fact,
it is not even clear how large our optimization problem would have to
be. We therefore consider a related problem in Chapter 8 : Given a
probability distribution over measurement outcomes, how large a state do
we need to implement such a strategy? We prove a very weak lower bound
on the dimension on the resulting state for a very restricted class of
games. Finally, we consider the effects that entanglement has on
classical protocols in Chapter 9 . To this end we examine interactive
proof systems where the two provers are allowed to share entanglement.
Surprisingly, it turns out that two such provers can be simulated by
just a single quantum prover.

### Chapter 7 Finding optimal quantum strategies

In the previous chapter, we encountered the CHSH inequality and its
generalizations in the guise of quantum games. Tsirelson has proven an
upper bound on the CHSH inequality that can be achieved using a quantum
strategy. But how can we prove upper bounds for more general
inequalities? Or actually, how can we find the optimal measurement
strategy? In this chapter, we answer these questions for a restricted
class of inequalities by presenting a method that yields the optimal
strategy for any two-player correlation inequality with @xmath
measurement settings and two measurement outcomes, i.e. an XOR-game.

#### 7.1 Introduction

Optimal strategies for generalized inequalities not only have
applications in computer science with regard to interactive proof
systems, but may also be important to ensure security in cryptographic
protocols. From a physical perspective finding such bounds may also be
helpful. As Braunstein and Caves [ BC90b ] have shown, it is interesting
to consider inequalities based on many measurement settings, in
particular, the chained CHSH inequality in Eq. 7.1 below: Here, the gap
between the classical and the quantum bound is larger than for the
original CHSH inequality with only two measurement settings. This can be
helpful in real experiments that inevitably include noise, as this
inequality leads to a larger gap achieved by the optimal classical and
the quantum strategy, and may thus lead to a better test. However,
determining bounds on the correlations that quantum theory allows
remains a difficult problem [ BM05 ] . All Tsirelson-type bounds are
known for correlation inequalities with two measurement settings and two
outcomes for both Alice and Bob [ Tsi93 ] . Landau [ Lan88 ] has taken a
step towards finding Tsirelson-type bounds by considering when two-party
correlations of two measurement settings for both Alice and Bob can be
realized using quantum measurements. Filipp and Svozil [ FS04 ] have
considered the case of three measurement settings analytically and
conducted numerical studies for a larger number of settings. Werner and
Wolf [ WW01a ] also considered obtaining Tsirelson-type bounds for
two-outcome measurements for multiple parties and studied the case of
three and four settings explicitly. However, their method is hard to
apply to general inequalities. Finally, Buhrman and Massar have shown a
bound for a generalized CHSH inequality using three measurement settings
with three outcomes each [ BM05 ] . It is not known whether this bound
can be attained.

Our approach is based on semidefinite programming in combination with
Tsirelson’s seminal results [ Tsi80 , Tsi87 , Tsi93 ] as outlined in
Section 6.3.2 . See Appendix A for a brief introduction to semidefinite
programming. It is very easy to apply and gives tight bounds as we can
find the optimal measurements explicitly. Let @xmath and @xmath be
Alice’s and Bob’s observables, and let @xmath be a state shared by Alice
and Bob. The key benefit we derive from Tsirelson’s construction is that
it saves us from the need to maximize over all states @xmath and
observables. Instead, we can replace any terms of the form @xmath with
the inner product of two real unit vectors @xmath , and then maximize
over all such vectors instead. Our method is thereby similar to methods
used in computer science for the two-way partitioning problem [ BV04 ]
and the approximation algorithm for MAXCUT by Goemans and Williamson [
GW95 ] . Semidefinite programming allows for an efficient way to
approximate Tsirelson’s bounds for any CHSH-type inequalities
numerically. However, it can also be used to prove Tsirelson type bounds
analytically. As an illustration, we first give an alternative proof of
Tsirelson’s original bound using semidefinite programming. We then prove
a new Tsirelson-type bound for the following generalized CHSH inequality
[ Per93 , BC90b ] . Classically, it can be shown that

  -- -------- -- -------
     @xmath      (7.1)
  -- -------- -- -------

Here, we show that for quantum mechanics

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath are observables with eigenvalues @xmath employed
by Alice and Bob respectively, corresponding to their @xmath possible
measurement settings. It is well known that this bound can be achieved [
Per93 , BC90b ] for a specific set of measurement settings if Alice and
Bob share a singlet state. Here, we show that this bound is indeed
optimal for any state @xmath and choice of measurement settings. This
method generalizes to other CHSH inequalities, for example, the
inequality considered by Gisin [ Gis99 ] .

#### 7.2 A simple example: Tsirelson’s bound

To illustrate our approach we first give a detailed proof of Tsirelson’s
bound using semidefinite programming. This proof is more complicated
than Tsirelson’s original proof. However, it serves as a good
introduction to the following section. Let @xmath and @xmath denote the
observables with eigenvalues @xmath used by Alice and Bob respectively.
Our goal is now to show an upper bound for

  -- -------- --
     @xmath   
  -- -------- --

From Theorem 6.3.2 we know that there exist real unit vectors @xmath
such that for all @xmath @xmath . In order to find Tsirelson’s bound, we
thus want to solve the following problem: maximize @xmath , subject to
@xmath . Note that we can drop the absolute value since any set of
vectors maximizing the above equation, simultaneously leads to a set of
vectors minimizing it by taking @xmath instead. We now phrase this as a
semidefinite program. Let @xmath be the Gram matrix of the vectors
@xmath with respect to the inner product:

  -- -------- --
     @xmath   
  -- -------- --

@xmath can thus be written as @xmath where the columns of @xmath are the
vectors @xmath . By [ HJ85 , Theorem 7.2.11] we can write @xmath if and
only if @xmath is positive semidefinite. We thus impose the constraint
that @xmath . To make sure that we obtain unit vectors, we add the
constraint that all diagonal entries of @xmath must be equal to @xmath .
Define

  -- -------- --
     @xmath   
  -- -------- --

Note that the choice of order of the vectors in @xmath is not unique,
however, a different order only leads to a different @xmath and does not
change our argument. We can now rephrase our optimization problem as the
following SDP:

  ------------ -------------------
  maximize     @xmath
  subject to   @xmath and @xmath
  ------------ -------------------

We can then write for the Lagrangian

  -- -------- --
     @xmath   
  -- -------- --

where @xmath . The dual function is then

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

We then obtain the following dual formulation of the SDP

  ------------ --------
  minimize     @xmath
  subject to   @xmath
  ------------ --------

Let @xmath and @xmath denote optimal values for the primal and Lagrange
dual problem respectively. From weak duality it follows that @xmath .
For our example, it is not difficult to see that this is indeed true as
we show in Appendix A .

In order to prove Tsirelson’s bound, we now exhibit an optimal solution
for both the primal and dual problem and then show that the value of the
primal problem equals the value of the dual problem. The optimal
solution is well known [ Tsi80 , Tsi87 , Per93 ] . Alternatively, we
could easily guess the optimal solution based on numerical optimization
by a small program for Matlab ¹ ¹ 1 See
http://www.cwi.nl/~wehner/tsirel/ for the Matlab example code. and the
package SeDuMi [ SA ] for semidefinite programming. Consider the
following solution for the primal problem

  -- -------- --
     @xmath   
  -- -------- --

which gives rise to the primal value @xmath . Note that @xmath since all
its eigenvalues are non-negative [ HJ85 , Theorem 7.2.1] , and all its
diagonal entries are 1. Thus all constraints are satisfied. The lower
left quadrant of @xmath is in fact the same as the well known
correlation matrix for 2 observables [ Tsi93 , Equation 3.16] . Next,
consider the following solution for the dual problem

  -- -------- --
     @xmath   
  -- -------- --

The dual value is then @xmath . Because @xmath , @xmath satisfies the
constraint. Since @xmath , @xmath and @xmath are in fact optimal
solutions for the primal and dual respectively. We can thus conclude
that

  -- -------- --
     @xmath   
  -- -------- --

which is Tsirelson’s bound [ Tsi80 ] . By Theorem 6.3.2 , this bound is
achievable.

#### 7.3 The generalized CHSH inequality

We now show how to obtain bounds for inequalities based on more than 2
observables for both Alice and Bob. In particular, we prove a bound for
the chained CHSH inequality for the quantum case. It is well known [
Per93 ] that it is possible to choose observables @xmath and @xmath ,
and the maximally entangled state, such that

  -- -------- --
     @xmath   
  -- -------- --

We now show that this is optimal. Our proof is similar to the last
section. However, it is more difficult to show feasibility for all
@xmath . {theorem} Let @xmath be an arbitrary state, where @xmath and
@xmath denote the Hilbert spaces of Alice and Bob. Let @xmath and @xmath
be observables with eigenvalues @xmath on @xmath and @xmath
respectively. Then

  -- -------- --
     @xmath   
  -- -------- --

Proof. By Theorem 6.3.2 , our goal is to find the maximum value for
@xmath for real unit vectors @xmath . As above we can drop the absolute
value. Let @xmath be the Gram matrix of the vectors @xmath . As before,
we can thus write @xmath , where the columns of @xmath are the vectors
@xmath , if and only if @xmath . To ensure we obtain unit vectors, we
again demand that all diagonal entries of @xmath equal @xmath . Define
@xmath matrix @xmath and @xmath matrix @xmath by

  -- -------- --
     @xmath   
  -- -------- --

We can now phrase our maximization problem as the following SDP:

  ------------ -------------------
  maximize     @xmath
  subject to   @xmath and @xmath
  ------------ -------------------

Analogous to the previous section, the dual SDP is then:

  ------------ --------
  minimize     @xmath
  subject to   @xmath
  ------------ --------

Let @xmath and @xmath denote optimal values for the primal and dual
problem respectively. As before, @xmath .

###### Primal

We now show that the vectors suggested in [ Per93 ] are optimal. For
@xmath , choose unit vectors @xmath to be of the form

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

where @xmath and @xmath . The angle between @xmath and @xmath is given
by @xmath and thus @xmath . The angle between @xmath and @xmath is
@xmath and thus @xmath . Finally, the angle between @xmath and @xmath is
@xmath and so @xmath . The value of our primal problem is thus given by

  -- -------- --
     @xmath   
  -- -------- --

Let @xmath be the Gram matrix constructed from all vectors @xmath as
described earlier. Note that our constraints are satisfied: @xmath and
@xmath , because @xmath is symmetric and of the form @xmath .

###### Dual

Now consider the @xmath -dimensional vector

  -- -------- --
     @xmath   
  -- -------- --

In order to show that this is a feasible solution to the dual problem,
we have to prove that @xmath and thus the constraint is satisfied. To
this end, we first show that

###### Claim 2

The eigenvalues of @xmath are given by @xmath with @xmath .

Proof. Note that if the lower left corner of @xmath were @xmath , @xmath
would be a circulant matrix [ Gra71 ] , i.e. each row of @xmath is
constructed by taking the previous row and shifting it one place to the
right. We can use ideas from circulant matrices to guess eigenvalues
@xmath with eigenvectors

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath . By definition, @xmath is an eigenvector of
@xmath with eigenvalue @xmath if and only if @xmath . Here, @xmath if
and only if

  -- -------- -- -------- --
     @xmath      @xmath   
     @xmath      @xmath   
  -- -------- -- -------- --

Since for any @xmath

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

(i) is satisfied. Furthermore (ii) is satisfied, since

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

@xmath

###### Claim 3

The largest eigenvalue of @xmath is given by @xmath .

Proof. By [ HJ85 , Theorem 7.3.7] , the eigenvalues of @xmath are given
by the singular values of @xmath and their negatives. It follows from
Claim 2 that the singular values of @xmath are

  -- -------- --
     @xmath   
  -- -------- --

Considering the shape of the cosine function, it is easy to see that the
largest singular value of @xmath is given by @xmath , the largest
eigenvalue of @xmath is @xmath . @xmath

Since @xmath and @xmath are both Hermitian, Weyl’s theorem [ HJ85 ,
Theorem 4.3.1] implies that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the smallest eigenvalue of a matrix @xmath . It then
follows from the fact that @xmath is diagonal and Claim 3 that

  -- -------- --
     @xmath   
  -- -------- --

Thus @xmath and @xmath is a feasible solution to the dual problem. The
value of the dual problem is then

  -- -------- --
     @xmath   
  -- -------- --

Because @xmath , @xmath and @xmath are optimal solutions for the primal
and dual respectively, which completes our proof. @xmath

Note that for the primal problem we are effectively dealing with @xmath
-dimensional vectors, @xmath . As we saw in Section 6.3.2 , it follows
from Tsirelson’s construction [ Tsi93 ] that in this case we just need a
single EPR pair such that we can find observables that achieve this
bound. In fact, these vectors just determine the measurement directions
as given in [ Per93 ] .

#### 7.4 General approach and its applications

##### 7.4.1 General approach

Our approach can easily be generalized to other correlation
inequalities. For another inequality, we merely use a different matrix
@xmath in @xmath . For example, for Gisin’s CHSH inequality [ Gis99 ] ,
@xmath is the matrix with 1’s in the upper left half and on the
diagonal, and -1’s in the lower right part. Otherwise our approach stays
exactly the same, and thus we do not consider this case here. Numerical
results provided by our Matlab example code suggest that Gisin’s
observables are optimal. Given the framework of semidefinite
programming, the only difficulty in proving bounds for other
inequalities is to determine the eigenvalues of the corresponding @xmath
, a simple matrix. All bounds found this way are tight, as we can always
implement the resulting strategy using a maximally entangled state as
shown in Section 6.3.2 .

With respect to finding numerical bounds, we see that the optimal
strategy can be found in time exponential in the number of measurement
settings: The size of the vectors scales exponentially with the number
of settings, however, we can fortunately find the optimal vectors in
time polynomial in the length of the vectors using well-known algorithms
for semidefinite programming [ BV04 ] .

##### 7.4.2 Applications

In Chapter 9 , we will see that the mere existence of such a
semidefinite program has implications for the computational complexity
of interactive proof systems with entanglement. Cleve, Høyer, Toner and
Watrous [ CHTW04a ] have also remarked during their presentation at
CCC’04 that Tsirelson’s constructions leads to an approach by
semidefinite programming in the context of multiple interactive proof
systems with entanglement, but never gave an explicit argument.

The above semidefinite program has also been used to prove results about
compositions of quantum games, in particular, parallel repetitions of
quantum XOR-games [ CSUU07 ] . One particular type of composition
studied by Cleve, Slofstra, Unger and Upadhyay [ CSUU07 ] is the
XOR-composition of non-local games. For example, an XOR-composition of a
CHSH game is a new game where Alice and Bob each have @xmath inputs
@xmath and @xmath with @xmath and must give answers @xmath and @xmath
such that @xmath . In terms of our semidefinite program, this is indeed
easy to analyze. The matrix defining the game is now given by

  -- -------- -------- -- --
     @xmath   @xmath      
  -- -------- -------- -- --

Note that the eigenvalues of @xmath are given by @xmath where @xmath is
an eigenvalue of @xmath . Consider the matrix @xmath . Clearly, @xmath
has eigenvalues @xmath so we have @xmath . Thus @xmath is a valid
solution to our primal problem, for which we obtain @xmath . Consider
@xmath . Clearly, it is a valid solution to our dual problem as @xmath ,
again using Weyl’s theorem. This gives for our dual problem @xmath and
thus our primal solution is optimal. For more general problems, such a
composition may be more complicated as the dual solution is not
immediately related to the eigenvalues of @xmath . Nevertheless, it can
be readily evaluated using Schur’s complement trick [ CSUU07 ] . By
rewriting, one can then relate such compositions to the questions of
parallel repetition: Given multiple runs of the game, does there exist a
better quantum measurement than executing the optimal strategy of each
round many times? It is very interesting that this is in fact not true
for XOR-games [ CSUU07 ] . However, there exist inequalities and
specific quantum states for which collective measurements are better.
Such examples can be found in the works of Peres [ Per96 ] and Liang and
Doherty [ LD06 ] . Sadly, our approach fails here.

#### 7.5 Conclusion

We have provided a simple method to obtain the optimal measurements for
any bipartite correlation inequality, i.e. any two-player XOR game. Our
method easily allows us to obtain bounds using numerical analysis, but
also suits itself to construct analytical proofs as demonstrated by our
examples. However, the above discussion immediately highlights the
shortcomings of our approach. How can we find the optimal strategies for
more generalized inequalities, where we have more than two players or a
non-correlation inequality? Or more than two measurement outcomes? How
can we find the optimal strategy for a fixed quantum state that is given
to Alice and Bob? To address more than two measurement outcomes, we can
rescale the observables such that they have eigenvalues in the interval
@xmath . Indeed, examining Tsirelson’s proof, it is easy to see that we
could achieve the same by demanding that the vectors have a length
proportional to the number of settings. However, it is clear that the
converse of Tsirelson’s theorem that allows us to construct measurement
from the vectors can no longer hold. Indeed, any matrix @xmath that can
be written as a sum of anti-commuting matrices @xmath with @xmath and
@xmath must have eigenvalues @xmath itself since @xmath .

Since the completion of this work, exciting progress has been made to
answer the above questions. Liang and Doherty [ LD07 ] have shown how to
obtain lower and upper bounds on the optimal strategy achievable using a
fixed quantum state using semidefinite programming relaxations. Kempe,
Kobayashi, Matsumoto, Toner and Vidick [ KKM @xmath 07 ] have since
shown that there exist three-player games for which the optimal quantum
strategy cannot be computed using a semidefinite program that is
exponential in the number of measurement settings unless P=NP. Finally,
Navascués, Pironio and Acín [ NPA07 ] have shown how to obtain bounds
for general two-party inequalities with more measurement outcomes using
semidefinite programming, inspired by Landau [ Lan88 ] . Their beautiful
approach used successive hierarchies of semidefinite programs to obtain
better and better bounds. In their approach, they consider whether a
given distribution over outcomes can be obtained using a quantum
strategy. Sadly, it does not give a general method to construct actual
measurements and thus show that an obtained bound is tight. A similar
result obtained using an approach that is essentially dual to [ NPA07 ]
has been obtained in [ DLTW08 ] , which also proves a convergence result
for such a hierarchy.

One of the difficulties we face when trying to find tight bounds for
more general inequalities is to determine how large our optimization
problem has to be. But even if we are given some distribution over
possible outcomes, how can we decide how large our system has to be in
order to implement a quantum strategy? In general, this is a tricky
problem which we will consider in the next chapter.

### Chapter 8 Bounding entanglement in NL-games

In the previous chapter, we provided a simple method to determine the
optimal quantum strategy for two-outcome XOR games. However, when trying
to find the optimal strategies for more general games, we are faced with
a fundamental issue: How large do we have to choose our state and
measurements such that we can achieve the optimal quantum value?

#### 8.1 Introduction

Determining an upper bound and the amount of entanglement we need, given
the description of the game alone, turns out to be a tricky problem in
the general case. Hence, we address an intermediate problem: Given the
description of a non-local game and associated probabilities, how large
a state do Alice and Bob need to implement such a strategy? Navascués,
Pironio and Acín [ NPA07 ] and also [ DLTW08 ] have shown how to obtain
upper bounds for the violation of more general quantum games using
multiple hierarchies of semidefinite programs. However, their method
does not provide us with an explicit strategy, and it remains unclear
how many levels of the hierarchy we need to consider in order to obtain
a tight bound. Yet, from their method we can obtain a probability
distribution over measurement outcomes. Using our approach, we can then
determine an extremely weak lower bound on the dimension of the quantum
state we would need in order to implement a corresponding quantum
strategy.

The idea behind our approach is to transform a non-local game into a
random access code. A random access code is an encoding of a string into
a quantum state such that we can retrieve at least one entry of our
choice from this string with some probability. Intuitively, Alice’s
measurements will create an encoding. Bob’s choice of measurement then
determines which bit of this “encoding” he wants to retrieve. We prove a
general lower bound for any independent one-to-one non-local game among
@xmath players, where a one-to-one non-local game is a game where for
each possible measurement setting there exists exactly one correct
measurement outcome. In particular, we show that in any one-to-one
non-local game where player @xmath obtains the correct outcome @xmath
for any measurement setting @xmath with probability @xmath the dimension
@xmath of player @xmath ’s state obeys

  -- -------- --
     @xmath   
  -- -------- --

Even though our bound is very weak, and the class of games very
restricted, we are hopeful that our approach may lead to stronger
results in the future. Finally, we discuss how we could obtain upper
bounds from the description of the non-local game alone without
resorting to probability distributions.

#### 8.2 Preliminaries

Before we can prove our lower bound, we first introduce the notion of a
random access code. For our purposes, we need to generalize the existing
results on random access codes. We use @xmath to denote the random
variable corresponding to the outcome of a measurement @xmath on a state
@xmath . We also use @xmath to denote an @xmath -element string where
each element is chosen from an alphabet @xmath . We will also use the
notation @xmath to denote the string @xmath without the element @xmath .

##### 8.2.1 Random access codes

A quantum @xmath -random access code (RAC) [ ANTV99 , Nay99 ] over a
binary alphabet is an encoding of an @xmath -bit string @xmath into an
@xmath -qubit state @xmath such that for any @xmath we can retrieve
@xmath from @xmath with probability @xmath . Note that we are only
interested in retrieving a single bit of the original string @xmath from
@xmath . In general, it is unlikely we will be able to retrieve more
than a single bit. For such codes the following lower bound has been
shown [ Nay99 , Theorem 2.3] , where it is assumed that the original
strings @xmath are chosen uniformly at random:

{theorem}

[Nayak] Any @xmath -random access code has @xmath .

In the following, we make use of a generalization of random access codes
to larger alphabets. We also need two additional generalizations: First,
we also want to obtain a bound on such a RAC encoding if the string
@xmath is chosen from a slightly more general, possibly non-uniform,
distribution. Let @xmath be a probability distribution over @xmath and
let @xmath be a probability distribution over @xmath . That is, a
particular string @xmath is chosen with probability @xmath . Note that
we assume that the individual entries of @xmath are chosen
independently.

Second, we allow for unbalanced random access codes, where each entry of
the string @xmath may have a different probability of being decoded
correctly. We define {definition} An @xmath -unbalanced random access
code (URAC) over a finite alphabet @xmath is an encoding of an @xmath
-element string @xmath into an @xmath -qubit state @xmath such that for
any @xmath , there exists a measurement @xmath with outcomes @xmath such
that for all @xmath we have @xmath .

Fortunately, it is straightforward to extend the analysis of Nayak [
Nay99 ] to this setting. We extend the proof by Nayak as opposed to
other known proofs of this lower bound in order to deal with unbalanced
random access codes more easily. {lemma} Let @xmath be a probability
distribution over @xmath . Then any @xmath -unbalanced random access
code has

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is a random variable chosen from @xmath according to the
probability distribution @xmath . Proof. The proof follows along the
same lines as Lemma 4.1 and Claim 4.6 of [ Nay99 ] . We state the
adaption for clarity:

We first consider decoding a single element. Let @xmath with @xmath be
density matrices, and let @xmath be a probability distribution over
@xmath . Define @xmath . Let @xmath be a measurement with outcomes
@xmath that given any state @xmath gives the correct outcome @xmath with
average probability @xmath . Let @xmath be a random variable over @xmath
chosen according to probability distribution @xmath , and let @xmath be
a random variable over @xmath corresponding to the outcome of the
measurement. It now follows from Fano’s inequality (see for example [
Hay06 , Theorem 2.2] ) that @xmath . Using Holevo’s bound, we then have
@xmath .

We now consider an entire string @xmath encoded as a state @xmath .
Consider @xmath with @xmath and define @xmath with @xmath where we used
indices @xmath and @xmath to denote the probability distribution over
@xmath according to which the @xmath -th entry was encoded. We now claim
that @xmath . The proof follows by downward induction over @xmath :
Consider @xmath , clearly @xmath and the claim is valid. Now suppose our
claim holds for @xmath . Note that we have @xmath . Note that strings
encoded by the density matrices @xmath only differ by one element @xmath
. We can therefore distinguish them with probability @xmath . From the
above discussion we have that @xmath .

Using the inductive hypothesis, letting @xmath be the empty string and
using the fact that @xmath then completes the proof. @xmath

##### 8.2.2 Non-local games and state discrimination

For our purpose, we need to think of non-local games as a special form
of state discrimination. When each subset of players performs a
measurement on their part of the state, they effectively prepare a
certain state on the system of the remaining players. Let @xmath denote
the state of Player @xmath if the remaining players chose measurement
settings @xmath and obtained outcomes @xmath . Note that the probability
that player @xmath holds @xmath is @xmath . Define the state

  -- -------- --
     @xmath   
  -- -------- --

where @xmath to ensure normalization. We call a game independent , if
the sets of probabilities @xmath and @xmath are uncorrelated for all
measurement settings @xmath with @xmath . Note that @xmath is the
probability that player @xmath holds state @xmath , and that @xmath
since the game is one-to-one. If player @xmath now chooses measurement
setting @xmath he is effectively trying to solve a state discrimination
problem, given the ensemble @xmath .

Note that we already encountered this viewpoint in Chapter 6.4 .
Consider the simple case of the CHSH game. Here, Alice (Player 1) and
Bob (Player 2) had to give answers @xmath and @xmath for settings @xmath
and @xmath such that @xmath . Let @xmath denote Bob’s state if Alice
chose measurement setting @xmath and obtained outcome @xmath . If Bob
chooses setting @xmath , he has to solve the state discrimination
problem described by Figure 6.4 : he must answer @xmath , and hence his
goal is to learn @xmath . That is, he must solve the state
discrimination problem given by @xmath and @xmath . For @xmath , he has
to solve the problem given by Figure 6.4 : For @xmath , he must answer
@xmath , but for @xmath he must answer @xmath . Hence, he must solve the
state discrimination problem given by @xmath and @xmath .

#### 8.3 A lower bound

We now show how to obtain a random access encoding from a one-to-one
non-local game. This enables us to find a lower bound on the dimension
of the quantum state necessary for any player @xmath to implement
particular non-local strategies. Recall that we are trying to give a
bound given all parameters of the game. In particular, we are given the
probabilities @xmath that the remaining players obtain outcomes @xmath
for their measurement settings @xmath , as well as the value of the
game. Note that we do not need to know an actual state and measurement
strategy for the players. We just want to give a lower bound for a
chosen set of parameters, whether these can be obtained or not.

{theorem}

Any one-to-one independent non-local game where player @xmath obtains
the correct outcome @xmath for measurement setting @xmath with
probability @xmath for all @xmath and @xmath is a @xmath -unbalanced
random access code. Proof. To encode a string, the other players choose
measurement settings @xmath and measure their part of the state as in
the non-local game to obtain outcomes @xmath . Note that the string is
chosen randomly by the measurement. Since our game was one-to-one we can
define a function

  -- -------- --
     @xmath   
  -- -------- --

Let @xmath be the encoded string and note that @xmath . We have @xmath ,
since our game is one-to-one. Since our game is independent, we have
that @xmath is a product distribution. To retrieve the @xmath -th entry
of @xmath , player @xmath then has to distinguish @xmath as in the
non-local game which he can do with probability @xmath by assumption.
@xmath

Now that we can obtain a random access code from a non-local game, we
can easily give a lower bound on the dimension of the state from a lower
bound of the size of the random access code. It follows immediately from
Theorem 8.3 and Lemma 8.2.1 that

{corollary}

In any one-to-one independent non-local game where player @xmath obtains
the correct outcome @xmath for measurement setting @xmath with
probability @xmath for all measurement settings @xmath and outcomes
@xmath of the other players, the dimension @xmath of player @xmath ’s
state obeys

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is a random variable chosen from @xmath where @xmath .

For almost all known games, we can obtain a simplified bound as each
player will choose a measurement setting uniformly at random. Likewise,
in most cases we can assume that the probability that the players obtain
certain outcomes is also uniform. Indeed, if we do not know a particular
measurement strategy for a given game, we can find a bound if we assume
that the distribution over the outcomes given the choice of measurement
settings is uniform. In this case, we also assume that the probability
of giving the correct answer is the same for each possible choice of
measurement settings and is equal to the value of the game. We then
obtain

{corollary}

In any one-to-one independent non-local game where player @xmath obtains
the correct outcome @xmath for any measurement setting @xmath with
probability @xmath where @xmath for all @xmath and measurement settings
@xmath and outcomes @xmath of the other players, the dimension @xmath of
player @xmath ’s state obeys

  -- -------- --
     @xmath   
  -- -------- --

Note that if we are willing to assume that the optimal value of the game
is achieved when the players share a maximally entangled state, we can
improve this bound to @xmath .

Let’s look at a small example which illustrates the proof. Consider the
CHSH inequality. Here, we have only two players, Alice (Player 1) and
Bob (Player 2). Bob’s goal is to obtain an outcome @xmath such that
@xmath . This means we define the function @xmath as @xmath , @xmath ,
@xmath and @xmath . For the lower bound we do not need to consider a
specific encoding, however, for the well-known CHSH state and
measurements we would have an encoding of @xmath , @xmath , @xmath , and
@xmath and @xmath for all @xmath . How many qubits does Bob need to use
if he wants to give the correct answers with probability @xmath ? Since
everything is uniform we obtain @xmath , i.e., Bob needs to keep at
least one qubit.

Our bound contains a tradeoff between the probability @xmath of giving
the correct answer, the number of measurement settings, and the number
of possible outcomes. Clearly, our bound will only be good, if the
number of measurement settings is large. It is also clear that it
performs badly as @xmath approaches @xmath and @xmath is large, and thus
for most cases our bound will be very unsatisfactory. The following
figures illustrate the tradeoff between the different parameters of
Corollary 8.3 .

#### 8.4 Upper bounds

Ideally, we would find an upper bound on the amount of entanglement we
need purely from the description of the game alone. Clearly, Tsirelson’s
construction from Chapter 6.3.2 tells us that for any XOR game the local
dimension of Alice’s and Bob’s system is @xmath , where @xmath is the
number of measurement settings. Similarly to XOR games, we can consider
mod @xmath -games. Here, Alice and Bob have to give answers @xmath ,
@xmath given questions @xmath , @xmath such that @xmath for some
function @xmath . One may hope that for mod @xmath -games, similarly
than for XOR-games, the following holds: {conjecture} For any mod @xmath
-game, the dimension of Alice’s and Bob’s systems obeys @xmath , where
@xmath is the number of measurement settings for Alice and Bob.

An alternative approach to bounding the dimension would be to consider
how far we can reduce the size of an existing state and observables
using Lemma 6.3.1 . Suppose that Alice has only two measurement settings
@xmath and @xmath with @xmath and @xmath . We know from Lemma 3.5.2 that
there exist projectors @xmath such that we can decompose @xmath as
@xmath for @xmath , where @xmath . Hence, we can immediately conclude
from Lemma 6.3.1 that if Alice only measures two possible observables
with two outcomes each, the dimension of her state does not need to
exceed @xmath . This has previously been proved by Masanes [ Mas06 ] .
Could we prove something similar for three measurement settings? Sadly,
Theorem 3.5.3 tells us that this is not possible! There do exist three
measurements for which no such decomposition exists. It is not hard to
see that the question of how large Alice’s entangled state has to be
given a specific set of measurement operators is essentially equivalent
to the question of how many qubits we need to store in the problem of
post-measurement information to achieve perfect success. In both
settings we are interested in reducing the dimension by finding a way to
block-diagonalize the matrices.

#### 8.5 Conclusion

Bounding the amount of entanglement that we need to implement the
optimal strategy in non-local games remains a tricky problem. We have
given a simple lower bound on the amount of entanglement necessary for
an extremely restricted class of games. The CHSH game forms an instance
of such a game. Even though our bound is very weak, and the class of
games quite restricted, we are hopeful that our approach may lead to
stronger statements in the future. We also showed how our earlier
considerations and Tsirelson’s construction led to an upper bound for
the specific case of XOR-games. Sadly, better bounds still elude us so
far.

### Chapter 9 Interactive Proof Systems

As we saw in the past chapters, two spatially separated parties, Alice
and Bob, can use entanglement to obtain correlations that are impossible
to achieve classically, without any additional communication. However,
there do exist classical systems whose strength, or security, indeed
depends crucially on the fact that specific parties cannot communicate
during the course of the protocol. How are such systems affected by the
presence of entanglement? Can Alice and Bob use their shared
entanglement to gain a significant advantage? Here, we study interactive
proof systems which are a specific case of such a classical system.
Surprisingly, it turns out that the space-like separation is lost
alltogether and we can simulate two classical parties with just a single
quantum one.

#### 9.1 Introduction

##### 9.1.1 Classical interactive proof systems

Before getting to the heart of the matter, we first need to take a
closer look at interactive proof systems. Classical interactive proof
systems have received considerable attention [ BFL91 , BOGKW88 , CCL90 ,
Fei91 , LS91 , FL92 ] since their introduction by Babai [ Bab85 ] and
Goldwasser, Micali and Rackoff [ GMR89 ] in 1985. An interactive proof
system takes the form of a protocol of one or more rounds between two
parties, a verifier and a prover. Whereas the prover is computationally
unbounded, the verifier is limited to probabilistic polynomial time.
Both the prover and the verifier have access to a common input string
@xmath . The goal of the prover is to convince the verifier that @xmath
belongs to a pre-specified language @xmath . The verifier’s aim, on the
other hand, is to determine whether the prover’s claim is indeed valid.
In each round, the verifier sends a polynomial (in @xmath ) size query
to the prover, who returns a polynomial size answer. At the end of the
protocol, the verifier decides to accept, and conclude @xmath , or
reject based on the messages exchanged and his own private randomness. A
language has an interactive proof if there exists a verifier @xmath and
a prover @xmath such that: If @xmath , the prover can always convince
@xmath to accept. If @xmath , no strategy of the prover can convince
@xmath to accept with non-negligible probability. IP denotes the class
of languages having an interactive proof system. Watrous [ Wat99 ] first
considered the notion of quantum interactive proof systems. Here, the
prover has unbounded quantum computational power whereas the verifier is
restricted to quantum polynomial time. In addition, the two parties can
now exchange quantum messages. QIP is the class of languages having a
quantum interactive proof system. Classically, it is known that @xmath [
Sha92 , She92 ] , where is the class of languages decidable using only
polynomial space. For the quantum case, it has been shown that @xmath [
Wat99 , KW00 ] . If, in addition, the verifier is given polynomial size
quantum advice, the resulting class @xmath contains all languages [
Raz05 ] . Let @xmath denote the class where the prover and verifier are
restricted to exchanging @xmath messages. It is known that @xmath [ KW00
] and @xmath [ Vya03 , MW05 ] , where is the class of all problems
solvable by a probabilistic machine in polynomial time. We refer to [
MW05 ] for an overview of the extensive work done on @xmath , also known
as . Very little is known about @xmath and its relation to either or .

In multiple-prover interactive proof systems the verifier can interact
with multiple, computationally unbounded provers. Before the protocol
starts, the provers are allowed to agree on a joint strategy, however
they can no longer communicate during the execution of the protocol. Let
MIP denote the class of languages having a multiple -prover interactive
proof system. Here, we are especially interested in two-prover
interactive proof systems as introduced by Ben-Or, Goldwasser, Kilian
and Widgerson [ BOGKW88 ] . Babai, Fortnow and Lund [ BFL91 ] , and
Feige and Lovász [ FL92 ] have shown that a language is in NEXP if and
only if it has a two-prover one-round proof system, i.e., MIP[2] = NEXP.
Feige and Lovász have also shown that a system using more than
two-provers is thus no more powerful than a system with only two
provers, i.e., MIP[2] = MIP. Let @xmath denote the restricted class
where the verifier’s output is a function of the XOR of two binary
answers. Even for such a system @xmath , for certain soundness and
completeness parameters [ CHTW04a ] . Classical multiple-prover
interactive proof systems are thus more powerful than classical proof
systems based on a single prover, assuming @xmath .

##### 9.1.2 Quantum multi-prover interactive proof systems

Given the advent of quantum computing, one can also consider quantum
interactive proof systems with multiple provers. These can be grouped
into two categories: First, one can consider provers and a verifier that
are quantum themselves and can exchange quantum messages. Kobayashi and
Matsumoto have considered such quantum multiple-prover interactive proof
systems which form an extension of quantum single prover interactive
proof systems as described above. Let denote the resulting class. In
particular, they showed that @xmath if the provers do not share quantum
entanglement [ KM03 ] . If the provers share at most polynomially many
entangled qubits the resulting class is contained in [ KM03 ] .

Secondly, one can consider proof systems where all communication remains
classical, but the provers can share any entangled state as part of
their strategy on which they are allowed to perform arbitrary
measurements. Cleve, Høyer, Toner and Watrous [ CHTW04a ] have raised
the question whether a classical two-prover system is weakened in such a
setting. We write @xmath if the provers share entanglement. The authors
provide a number of examples which demonstrate that the soundness
condition of a classical proof system can be compromised, i.e. the
interactive proof system is weakened, when entanglement is used. In
their paper, it is proved that @xmath . Later, the same authors also
showed that @xmath using semidefinite programming [ CHTW04b ] .
Entanglement thus clearly weakens an interactive proof system, assuming
@xmath .

Intuitively, entanglement allows the provers to coordinate their
answers, even though they cannot use it to communicate. By measuring the
shared entangled state the provers can generate correlations which they
can use to deceive the verifier. Tsirelson [ Tsi80 , Tsi87 ] has shown
that even quantum mechanics limits the strength of such correlations, as
we saw in Chapter 6 . Recall that Popescu and Roehrlich [ PR94 , PR96 ,
PR97 ] have raised the question why nature imposes such limits. To this
end, they constructed a toy-theory based on non-local boxes [ PR94 ,
vD00 ] , which are hypothetical “machines” generating correlations
stronger than possible in nature. In their full generalization,
non-local boxes can give rise to any type of correlation as long as they
cannot be used to signal. Preda [ Pre05 ] showed that sharing non-local
boxes allows two provers to coordinate their answers perfectly and
obtained @xmath , where we write @xmath to indicate that the two provers
share non-local boxes.

Kitaev and Watrous [ KW00 ] mention that it is unlikely that a
single-prover quantum interactive proof system can simulate multiple
classical provers, because then from @xmath and @xmath it follows that
@xmath .

Surprisingly, it turns out that when the provers are allowed to share
entanglement it can be possible to simulate two such classical provers
by one quantum prover. This indicates that entanglement among provers
truly leads to a weaker proof system. In particular, we show that a
two-prover one-round interactive proof system where the verifier
computes the XOR of two binary answers and the provers are allowed to
share an arbitrary entangled state, can be simulated by a single quantum
interactive proof system with two messages: @xmath . Since very little
is known about @xmath so far [ KW00 ] , we hope that our result may help
shed some light on its relation to or . Our result also leads to a proof
that @xmath .

#### 9.2 Proof systems and non-local games

##### 9.2.1 Non-local games

For our proof, it is necessary to link interactive proof systems to
non-local games, as we described in Chapter 6.2.3 . Since we consider
only two parties, we omit unnecessary indices and use separate letters
to refer to the sets of possible questions and answers. We briefly recap
our setup, summarized in Figure 9.1 : Let @xmath , @xmath , @xmath and
@xmath be finite sets, and @xmath a probability distribution on @xmath .
Let @xmath be a predicate on @xmath . Then @xmath is the following
two-person cooperative game ¹ ¹ 1 Players 1 and 2 collaborate against
the verifier : A pair of questions @xmath is chosen at random according
to the probability distribution @xmath . Then @xmath is sent to player
1, henceforth called Alice, and @xmath to player 2, which we call Bob.
Upon receiving @xmath , Alice has to reply with an answer @xmath .
Likewise, Bob has to reply to question @xmath with an answer @xmath .
They win if @xmath and lose otherwise. Alice and Bob may agree on any
kind of strategy beforehand, but they are no longer allowed to
communicate once they have received questions @xmath and @xmath . The
value @xmath of a game @xmath is the maximum probability that Alice and
Bob win the game. We write @xmath instead of @xmath to emphasize the
fact that @xmath and @xmath are answers given questions @xmath and
@xmath .

Here, we are particularly interested in non-local games. Alice and Bob
are allowed to share an arbitrary entangled state @xmath to help them
win the game. Let @xmath and @xmath denote the Hilbert spaces of Alice
and Bob respectively. The state @xmath is part of the quantum strategy
that Alice and Bob can agree on beforehand. This means that for each
game, Alice and Bob can choose a specific @xmath to maximize their
chance of success. In addition, Alice and Bob can agree on quantum
measurements. For each @xmath , Alice has a projective measurement
described by @xmath on @xmath . For each @xmath , Bob has a projective
measurement described by @xmath on @xmath . For questions @xmath , Alice
performs the measurement corresponding to @xmath on her part of @xmath
which gives her outcome @xmath . Likewise, Bob performs the measurement
corresponding to @xmath on his part of @xmath with outcome @xmath . Both
send their outcome, @xmath and @xmath , back to the verifier. The
probability that Alice and Bob answer @xmath is then given by

  -- -------- --
     @xmath   
  -- -------- --

The probability that Alice and Bob win the game is now given by

  -- -------- -- -------
     @xmath      (9.1)
  -- -------- -- -------

The quantum value @xmath of a game @xmath is the maximum probability
over all possible quantum strategies that Alice and Bob win. Recall that
XOR game is a game where the value of @xmath only depends on @xmath and
not on @xmath and @xmath independently. For XOR games we write @xmath
instead of @xmath . Here, we are only interested in the case that @xmath
and @xmath and XOR games. Alice and Bob’s measurements are then
described by @xmath for @xmath and @xmath for @xmath respectively. Note
that @xmath and @xmath and thus these measurements can be expressed in
the form of observables @xmath and @xmath with eigenvalues @xmath :
@xmath and @xmath . Recall from Chapter 6.3.2 that Tsirelson [ Tsi80 ,
Tsi87 ] has shown that for any @xmath there exists real unit vectors
@xmath with @xmath such that @xmath . It is then easy to see from Eq. (
9.1 ) that for XOR games we can express the maximum winning probability
as

  -- -------- -- -------
     @xmath      (9.2)
  -- -------- -- -------

where the maximization is taken over all unit vectors @xmath .

##### 9.2.2 Multiple classical provers

It is well known [ CHTW04a , FL92 ] , that two-prover one-round
interactive proof systems with classical communication can be modeled as
(non-local) games. Here, Alice and Bob take the role of the two provers.
The verifier now poses questions @xmath and @xmath , and evaluates the
resulting answers. A proof system associates with each string @xmath a
game @xmath , where @xmath determines the probability that the verifier
accepts (and thus concludes @xmath ). The string @xmath , and thus the
nature of the game @xmath is known to both the verifier and the provers.
Ideally, for all @xmath the value of @xmath is close to one, and for
@xmath the value of @xmath is close to zero. It is possible to extend
the game model for MIP[2] to use a randomized predicate for the
acceptance predicate @xmath . This corresponds to @xmath taking an extra
input string chosen at random by the verifier. However, known
applications of MIP[2] proof systems do not require this extension [
Fei95 ] . Our argument in Section 9.3 can easily be extended to deal
with randomized predicates. Since @xmath is not a randomized predicate
in [ CHTW04a ] , we follow this approach.

We concentrate on proof systems involving two provers, one round of
communication, and single-bit answers. The provers are computationally
unbounded, but limited by the laws of quantum physics. However, the
verifier is probabilistic polynomial time bounded. As defined by Cleve,
Høyer, Toner and Watrous [ CHTW04a ] , {definition} For @xmath , let
@xmath denote the class of all languages @xmath recognized by a
classical two-prover interactive proof system of the following form:

-   They operate in one round, each prover sends a single bit in
    response to the verifier’s question, and the verifier’s decision is
    a function of the parity of those two bits.

-   If @xmath then there exists a strategy for the provers for which the
    probability that the verifier accepts is at least @xmath (the
    completeness probability).

-   If @xmath then, whatever strategy the two provers follow, the
    probability that the verifier accepts is at most @xmath (the
    soundness probability).

{definition}

For @xmath , let @xmath denote the class corresponding to a modified
version of the previous definition: all communication remains classical,
but the provers may share prior quantum entanglement, which may depend
on @xmath , and perform quantum measurements. We generally omit indices
@xmath , @xmath , unless they are explicitly relevant.

In Chapter 7 , we discussed how to find the optimal strategies for
XOR-games. In particular, we saw that we can determine the optimal value
of @xmath in time exponential in @xmath using semidefinite programming.
This implies immediately that @xmath , as was shown by Cleve, Høyer,
Toner and Watrous [ CHTW04a ] during their presentation at CCC’04. Here,
we show something stronger, namely that @xmath .

##### 9.2.3 A single quantum prover

Instead of two classical provers, we can also consider a system
consisting of a single quantum prover @xmath and a quantum polynomial
time verifier @xmath as defined by Watrous [ Wat99 ] . Again, the
quantum prover @xmath is computationally unbounded, however, he is
limited by the laws of quantum physics. The verifier and the prover can
communicate over a quantum channel. In this thesis, we are only
interested in one round quantum interactive proof systems: the verifier
sends a single quantum message to the prover, who responds with a
quantum answer. We here express the definition of @xmath [ Wat99 ] in a
form similar to the definition of @xmath :

{definition}

Let @xmath denote the class of all languages @xmath recognized by a
quantum one-prover one-round interactive proof system of the following
form:

-   If @xmath then there exists a strategy for the quantum prover for
    which the probability that the verifier accepts is at least @xmath .

-   If @xmath then, whatever strategy the quantum prover follows, the
    probability that the quantum verifier accepts is at most @xmath .

#### 9.3 Simulating two classical provers with one quantum prover

We now show that an interactive proof system where the verifier bases
his decision only on the XOR of two binary answers is in fact no more
powerful than a system based on a single quantum prover. The main idea
behind our proof is to combine two classical queries into one quantum
query, and thereby simulate the classical proof system with a single
quantum prover. Similar techniques have been used to prove results about
classical locally decodable codes [ KW03 , WdW05 ] . Recall that the two
provers can use an arbitrary entangled state as part of their strategy.

For our proof we make use of the fact that we can write the optimal
value of the game as in Eq. ( 9.2 ).

{theorem}

For all @xmath and @xmath such that @xmath , @xmath . Proof. Let @xmath
and let @xmath be a verifier witnessing this fact. Let @xmath (Alice)
and @xmath (Bob) denote the two provers sharing entanglement. Fix an
input string @xmath . As mentioned above, interactive proof systems can
be modeled as games indexed by the string @xmath . It is therefore
sufficient to show that there exists a verifier @xmath and a quantum
prover @xmath , such that @xmath , where @xmath is the value of the
simulated game.

Let @xmath , @xmath be the questions that @xmath sends to the two
provers @xmath and @xmath in the original game. The new verifier @xmath
now constructs the following state in @xmath

  -- -- --
        
  -- -- --

and sends register @xmath to the single quantum prover @xmath .

We first consider the honest strategy of the prover. Let @xmath and
@xmath denote the answers of the two classical provers to questions
@xmath and @xmath respectively. The quantum prover now transforms the
state to

  -- -------- --
     @xmath   
  -- -------- --

and returns register @xmath back to the verifier. The verifier @xmath
now performs a measurement on @xmath described by the following
projectors

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

where @xmath . If he obtains outcome “reject”, he immediately aborts and
concludes that the quantum prover is cheating. If he obtains outcome
@xmath , the verifier concludes that @xmath . Note that @xmath , so the
verifier can reconstruct the answer perfectly.

We now consider the case of a dishonest prover. In order to convince the
verifier, the prover applies a transformation on @xmath and send
register @xmath back to the verifier. We show that for any such
transformation the value of the resulting game is at most @xmath : Note
that the state of the total system in @xmath can now be described as

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath with @xmath and @xmath . Any transformation
employed by the prover can be described this way. We now have that

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (9.3)
     @xmath   @xmath   @xmath      (9.4)
  -- -------- -------- -------- -- -------

The probability that the prover wins is given by

  -- -------- --
     @xmath   
  -- -------- --

The prover will try to maximize his chance of success by maximizing
@xmath or @xmath . We can therefore restrict ourselves to considering
real unit vectors for which @xmath and @xmath , as the dimension of our
vectors is directly determined by their number. Hence, we may also
assume that @xmath iff @xmath and @xmath iff @xmath : any other strategy
can lead to rejection and thus to a lower probability of success. By
substituting into Eqs. ( 9.3 ) and ( 9.4 ), it follows that the
probability that the quantum prover wins the game (when he avoids
rejection) is

  -- -------- -- -------
     @xmath      (9.5)
  -- -------- -- -------

In order to convince the verifier, the prover’s goal is to choose real
vectors @xmath and @xmath which maximize Eq. ( 9.5 ). Since in @xmath
and @xmath we sum over @xmath elements respectively, the dimension of
@xmath need not exceed @xmath . Thus, it is sufficient to restrict the
maximization to vectors in @xmath . Given Eq. ( 9.5 ), we thus have

  -- -------- --
     @xmath   
  -- -------- --

where the maximization is taken over vectors @xmath , and @xmath .
However, we know from Eq. ( 9.2 ) that

  -- -------- --
     @xmath   
  -- -------- --

where the maximization is taken over unit vectors @xmath and @xmath . We
thus have

  -- -------- --
     @xmath   
  -- -------- --

which completes our proof. @xmath

{corollary}

For all @xmath and @xmath such that @xmath , @xmath . Proof. This
follows directly from Theorem 9.3 and the result that @xmath [ KW00 ] .
@xmath

#### 9.4 Conclusion

As we have shown, the strength of classical systems can be weakened
considerably in the presence of entanglement. In our example above, we
showed that the systems can be weakened so much that all space-like
separation is lost: we saw that two classical parties with entanglement
are as powerful as a single quantum party.

It would be interesting to show that this result also holds for a proof
system where the verifier is not restricted to computing the XOR of both
answers, but some other Boolean function. However, the approach based on
vectors from Tsirelson’s results does not work for binary games. Whereas
it is easy to construct a single quantum query which allows the verifier
to compute an arbitrary function of the two binary answers with some
advantage, it thus remains unclear how the value of the resulting game
is related to the value of a binary game. Furthermore, mere classical
tricks trying to obtain the value of a binary function from XOR itself
seem to confer extra cheating power to the provers.

Examples of non-local games with longer answers [ CHTW04a ] , such as
the Kochen-Specker or the Magic Square game, seem to make it even easier
for the provers to cheat by taking advantage of their entangled state.
Furthermore, existing proofs that @xmath break down if the provers share
entanglement. It is therefore an open question whether @xmath or, @xmath
.

As described, non-locality experiments between two space-like separated
observers, Alice and Bob, can be cast in the form of non-local games.
For example, the experiment based on the well known CHSH inequality [
CHSH69 ] , is a non-local game with binary answers of which the verifier
computes the XOR [ CHTW04a ] . Our result implies that this non-local
game can be simulated in superposition by a single prover/observer: Any
strategy that Alice and Bob might employ in the non-local game can be
mirrored by the single prover in the constructed “superposition game”,
and also vice versa, due to Tsirelson’s constructions [ Tsi80 , Tsi87 ]
mentioned earlier. This means that the ‘‘superposition game’’
corresponding to the non-local CHSH game is in fact limited by
Tsirelson’s inequality [ Tsi80 ] , even though it itself has no
non-local character. Whereas this may be purely coincidental, it would
be interesting to know its physical interpretation, if any. Perhaps it
may be interesting to ask whether Tsirelson-type inequalities have any
consequences on local computations in general, beyond the scope of these
very limited games.

## Part IV Consequences for Crytography

### Chapter 10 Limitations

Finally, we turn our attention to cryptographic protocols directly. As
we saw in Chapter 1 , it is impossible to implement bit commitment even
in the quantum setting! In the face of the negative results, what can we
still hope to achieve?

#### 10.1 Introduction

Here, we consider the task of committing to an entire string of @xmath
bits at once when both the honest player and the adversary have
unbounded resources. Since perfect bit commitment is impossible, perfect
bit string commitment is clearly impossible as well. Curiously, however,
we can still make interesting statements in the quantum setting, if we
give both Alice and Bob a limited ability to cheat. That is, we allow
Alice to change her mind about the committed string within certain
limited parameters, and allow Bob to gain some information about the
committed string. It turns out that it matters crucially how we measure
Bob’s information gain.

First, we introduce a framework for the classification of bit string
commitments in terms of the length @xmath of the string, Alice’s ability
to cheat on at most @xmath bits and Bob’s ability to acquire at most
@xmath bits of information before the reveal phase. We say that Alice
can cheat on @xmath bits if she can reveal up to @xmath strings
successfully. Bob’s security definition is crucial to our investigation:
If @xmath determines a bound on his probability to guess Alice’s string,
then we prove that @xmath is at least @xmath . This implies that the
trivial protocol, where Alice’s commitment consists of sending @xmath
bits of her string to Bob, is optimal. If, however, @xmath is a bound on
the accessible information that the quantum states contain about Alice’s
string, then we show that non-trivial schemes exist. More precisely, we
construct schemes with @xmath and @xmath . This is impossible
classically. We also present a simple, implementable, protocol, that
achieves @xmath and @xmath . This protocol can furthermore be made
cheat-sensitive. Quantum commitments of strings have previously been
considered by Kent [ Ken03 ] , who pointed out that in the quantum world
useful bit string commitments could be possible despite the no-go
theorem for bit commitment. His scenario differs significantly from ours
and imposes an additional constraint, which is not present in our work:
Alice does not commit to a superposition of strings.

#### 10.2 Preliminaries

##### 10.2.1 Definitions

We first formalize the notion of quantum string commitments in a quantum
setting.

{definition}

An @xmath - Quantum Bit String Commitment (QBSC) is a quantum
communication protocol between two parties, Alice (the committer) and
Bob (the receiver), which consists of two phases:

-   (Commit Phase) Assume that both parties are honest. Alice chooses a
    string @xmath with probability @xmath . Alice and Bob communicate
    and at the end Bob holds state @xmath .

-   (Reveal Phase) If both parties are honest, Alice and Bob communicate
    and at the end Bob outputs @xmath . Bob accepts.

We have the following two security requirements:

-   (Concealing) If Alice is honest, then for any strategy of Bob

      -- -------- --
         @xmath   
      -- -------- --

    where @xmath is the probability that Bob correctly guesses @xmath
    before the reveal phase.

-   (Binding) If Bob is honest, then for any strategy of Alice

      -- -------- --
         @xmath   
      -- -------- --

    where @xmath is the probability that Alice successfully reveals
    @xmath (Bob accepts the opening of @xmath ).

Bob thereby accepts the opening of a string @xmath , if he performs a
test depending on the individual protocol to check Alice’s honesty and
concludes that she was indeed honest. Note that quantumly, Alice can
always commit to a superposition of different strings without being
detected. Thus even for a perfectly binding bit string commitment (i.e.
@xmath ) we only demand that @xmath , whereas classically one wants that
@xmath . Note that our concealing definition reflects Bob’s a priori
knowledge about @xmath . We choose an a priori uniform distribution
(i.e. @xmath ) for @xmath -QBSCs, which naturally comes from the fact
that we consider @xmath -bit strings. A generalization to any @xmath
-QBSC where @xmath is an arbitrary distribution is possible but omitted
in order not to obscure our main line of argument.

Instead of Bob’s guessing probability, one can take any information
measure @xmath to express the security against Bob. In general, we
consider an @xmath - @xmath where the new Concealing-condition reads

-   (General Concealing) If Alice is honest, then for any ensemble
    @xmath that Bob can obtain by a cheating strategy @xmath .

Later, we will show that for @xmath being the accessible information ,
non-trivial protocols, i.e. protocols with @xmath , do exist. Recall
that the accessible information was defined in Section 2.3.2 as @xmath ,
where @xmath is the prior distribution of the random variable @xmath ,
@xmath is the random variable of the outcome of Bob’s measurement on
@xmath , and the maximization is taken over all measurements @xmath .

##### 10.2.2 Model

We work in the model of two-party non-relativistic quantum protocols of
Yao [ Yao95 ] , simplified by Lo and Chau [ LC97 ] which is usually
adopted in this context. Here, any two-party quantum protocol can be
regarded as a pair of quantum machines (Alice and Bob), interacting
through a quantum channel. Consider the product of three Hilbert spaces
@xmath , @xmath and @xmath of bounded dimensions, representing the
Hilbert spaces of Alice’s and Bob’s machines and the channel,
respectively. Without loss of generality, we assume that each machine is
initially in a specified pure state. Alice and Bob perform a number of
rounds of communication over the channel. Each such round can be modeled
as a unitary transformation on @xmath and @xmath respectively. Since the
protocol is known to both Alice and Bob, they know the set of possible
unitary transformations used in the protocol. We assume that Alice and
Bob are in possession of both a quantum computer and a quantum storage
device. This enables them to add ancillae to the quantum machine and use
reversible unitary operations to replace measurements. The state of this
ancilla can then be read off only at the end of the protocol, and by
doing so, Alice and Bob can effectively delay any measurements until the
very end. The resulting protocol will be equivalent to the original and
thus we can limit ourselves to protocols where both parties only measure
at the very end. Moreover, any classical computation or communication
that may occur can be simulated by a quantum computer.

##### 10.2.3 Tools

We now gather the essential ingredients for our proof. First, we now
show that every @xmath - is an @xmath - @xmath . The security measure
@xmath is defined by

  -- -------- -- --------
     @xmath      (10.1)
  -- -------- -- --------

where @xmath and @xmath are only dependent on the ensemble @xmath .
@xmath is an entropic quantity defined in [ Ren05 ]

  -- -------- --
     @xmath   
  -- -------- --

Interestingly, this quantity is directly connected to Bob’s maximal
average probability of successfully guessing the string: {lemma} Bob’s
maximal average probability of successfully guessing the committed
string, i.e. @xmath where @xmath ranges over all measurements and @xmath
is the conditional probability of outputting @xmath given @xmath , obeys

  -- -------- --
     @xmath   
  -- -------- --

Proof. By definition, the maximum average guessing probability is lower
bounded by the average guessing probability for a particular measurement
strategy. We choose the square-root measurement which has operators

  -- -------- --
     @xmath   
  -- -------- --

We use @xmath to denote the probability that Bob guesses @xmath given
@xmath , hence

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

@xmath

Related estimates were derived in [ BK02 ] .

Furthermore, we make use of the following theorem, known as privacy
amplification against a quantum adversary with two-universal hash
functions, which we state in a form that is most convenient for our
purposes in this chapter. A class @xmath of functions @xmath is thereby
called two-universal if for all @xmath and for uniformly at random
chosen @xmath we have @xmath . For example, the set of all affine
functions ¹ ¹ 1 Geometrically, an affine function is a linear function
plus a translation . from @xmath to @xmath is two-universal [ CW79 ] .
The following theorem expresses how hash functions can decrease Bob’s
knowledge about a random variable when he holds some quantum
information. In our case, Bob will hold some quantum memory and privacy
amplification is used to find Alice’s attack. {theorem} [Th. 5.5.1 in [
Ren05 ] (see also [ KMR05 ] )] Let @xmath be a class of two-universal
hash functions from @xmath to @xmath . Application of @xmath to the
random variable @xmath maps the ensemble @xmath to @xmath with
probabilities @xmath and quantum states @xmath . Then

  -- -------- -- --------
     @xmath      (10.2)
  -- -------- -- --------

where @xmath (and similarly for @xmath ).

Finally, the following reasoning that is used to prove the impossibility
of quantum bit commitment [ LC97 , May96b ] will be essential: Suppose
@xmath and @xmath are density operators that correspond to the state of
Bob’s system if Alice committed a “0” or a “1” respectively. Let @xmath
and @xmath be the corresponding purifications on the joint system of
Alice and Bob: Alice holds the purification of @xmath and @xmath . If
@xmath equals @xmath then Alice can find a local unitary transformation
@xmath that Alice can apply to her part of the system such that @xmath .
This enables Alice to change the total state from @xmath to @xmath and
thus cheat using entanglement! This reasoning also holds in an
approximate sense [ May96b ] , here used in the following form: {lemma}
Let @xmath and assume that the bit-commitment protocol is error-free if
both parties are honest. Then there exists a method for Alice to cheat
such that the probability of successfully revealing a @xmath during the
reveal phase, given that she honestly committed herself to a @xmath
during the commit phase, is at least @xmath . Proof. @xmath implies
@xmath by Uhlmann’s theorem [ Uhl76 ] . Here, @xmath and @xmath
correspond to the joint states after the commit phase if Alice committed
to a ’0’ or ’1’ respectively where the maximization ranges over all
unitaries @xmath on Alice’s (i.e. the purification) side. Let @xmath for
a @xmath achieving the maximization, be the state that Alice prepares by
applying @xmath to the state on her side when she wants to reveal a ’1’,
given a prior honest commitment to ’0’. We then have

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

If Bob is honest, the reveal phase can be regarded as a measurement
resulting in a distribution @xmath (or @xmath ) if @xmath (or @xmath )
was the state before the reveal phase. The random variables @xmath and
@xmath can take values @xmath (corresponding to the opened bit) or the
value ‘reject (r)’. Since the trace distance does not increase under
measurements, @xmath . Hence @xmath . Since @xmath corresponds to
Alice’s honest commitment to @xmath we have @xmath , @xmath and hence
@xmath . @xmath

#### 10.3 Impossibility of quantum string commitments

As we saw above, any @xmath -QBSC is also an @xmath - @xmath with the
security measure @xmath defined in Eq. ( 10.1 ). To prove our
impossibility result we now prove that an @xmath - @xmath can only exist
for values @xmath , @xmath and @xmath obeying @xmath , where @xmath is a
small constant independent of @xmath , @xmath and @xmath . This in turn
implies the impossibility of an @xmath -QBSC for such parameters.
Finally, we show that if we execute the protocol many times in parallel,
the protocol can only be secure if @xmath .

The intuition behind our proof is simple: To cheat, Alice first chooses
a two-universal hash function @xmath . She then commits to a
superposition of all strings for which @xmath for a specific @xmath . We
now know from the privacy amplification theorem above, that even though
Bob may gain some knowledge about @xmath , he is entirely ignorant about
@xmath . But then Alice can change her mind and reveal a string from a
different set of strings for which @xmath with @xmath as we saw above!
The following figure illustrates this idea.

{theorem}

@xmath - @xmath schemes with @xmath do not exist, where @xmath is a
constant. Proof. Consider an @xmath - @xmath and the case where both
Alice and Bob are honest. Alice committed to @xmath . We denote the
joint state of the system Alice-Bob-Channel @xmath after the commit
phase by @xmath for input state @xmath . Let @xmath be Bob’s reduced
density matrix, and let @xmath where @xmath .

Assuming that Bob is honest, we will give a cheating strategy for Alice
in the case where @xmath . The strategy will depend on the two-universal
hash function @xmath , for appropriately chosen @xmath . Alice picks a
@xmath and constructs the state @xmath . She then gives the second half
of this state as input to the protocol and stays honest for the rest of
the commit phase. The joint state of Alice and Bob at the end of the
commit phase is thus @xmath . The reduced states on Bob’s side are
@xmath with probability @xmath . We denote this ensemble by @xmath . Let
@xmath .

We now apply Theorem 1 with @xmath and @xmath and obtain @xmath where
@xmath . Hence, there is at least one @xmath such that @xmath .
Intuitively, this means that Bob knows only very little about the value
of @xmath . This @xmath defines Alice’s cheating strategy. It is
straightforward to verify that @xmath implies

  -- -------- -- --------
     @xmath      (10.3)
  -- -------- -- --------

We therefore assume without loss of generality that Alice chooses @xmath
with @xmath .

We first observe that the probability to successfully reveal some @xmath
in @xmath given @xmath is one ² ² 2 Alice learns @xmath , but can’t pick
it: she committed to a superposition and @xmath is chosen randomly by
measurement. . We say that Alice reveals @xmath if she reveals an @xmath
such that @xmath . We then also have that the probability for Alice to
reveal @xmath given @xmath successfully is one. Let @xmath and @xmath
denote the probabilities to successfully reveal @xmath and @xmath
respectively and @xmath be the conditional probability to successfully
reveal @xmath , given @xmath . We have

  -- -------- --
     @xmath   
  -- -------- --

where the inequality follows from our observation above.

As in the impossibility proof of bit commitment, Alice can now transform
@xmath approximately into @xmath if @xmath is sufficiently close to
@xmath by using only local transformations on her part. Indeed, Lemma
10.2.3 tells us how to bound the probability of revealing @xmath , given
that the state was really @xmath . Since this reasoning applies to all
@xmath , on average, we have

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

where the first inequality follows from Lemma 10.2.3 , the second from
Jensen’s inequality and the concavity of the square root function, the
third from the triangle inequality and the fourth from Eq. ( 10.3 ) and
@xmath . Recall that to be secure against Alice, we require @xmath . We
insert @xmath , define @xmath and take the logarithm on both sides to
get

  -- -------- -- --------
     @xmath      (10.4)
  -- -------- -- --------

where @xmath . Keeping in mind that @xmath (or equivalently @xmath ), we
find that the minimum value of @xmath for which Eq. ( 10.4 ) is
satisfied is @xmath and arises from @xmath . Thus, no @xmath - @xmath
with @xmath exists. @xmath

It follows immediately that the same restriction holds for an @xmath
-QBSC: {corollary} @xmath - schemes, with @xmath do not exist, where
@xmath is a constant. Proof. For the uniform distribution @xmath , we
have from the concealing condition that @xmath , which by Lemma 10.2.3
implies @xmath . Thus, a @xmath -QBSC is an @xmath - @xmath from which
the result follows. @xmath

Since the constant @xmath does not depend on @xmath , @xmath and @xmath
, multiple parallel executions of the protocol can only be secure if
@xmath . This follows by considering @xmath parallel executions of the
protocol as a single execution with a string of length @xmath .
{corollary} Let @xmath be an @xmath -QBSC with @xmath an @xmath -QBSC.
Then @xmath . In particular, no @xmath -QBSC with @xmath can be executed
securely an arbitrary number of times in parallel. Thus, we can indeed
hope to do no better than the trivial protocol. It follows directly from
[ KMP04 ] that the results in this section also hold in the presence of
superselection rules, where, very informally, quantum actions are
restricted to act only on certain subspaces of a larger Hilbert space.

#### 10.4 Possibility

Surprisingly, if one is willing to measure Bob’s ability to learn @xmath
using a weaker measure of information, the accessible information,
non-trivial protocols become possible. These protocols are based on a
discovery known as “locking of classical information in quantum states”
which we already encountered in Chapter 5 .

The protocol, which we call LOCKCOM( @xmath , @xmath ), uses this effect
and is specified by a set @xmath of unitaries. We have

We now first show that our protocol is secure with respect to Definition
10.2.1 if Alice is dishonest. Note that our proof only depends on the
number of unitaries used, and is independent of a concrete instantiation
of the protocol. {lemma} For any LOCKCOM @xmath protocol the security
against a dishonest Alice is bounded by @xmath , Proof. Let @xmath
denote the probability that Alice reveals @xmath successfully. Then,
@xmath , where @xmath is the probability that @xmath is accepted by Bob
when the reveal information was @xmath . Let @xmath denote the state of
Bob’s system. Summation over @xmath now yields

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

@xmath

In order to examine security against a dishonest Bob, we have to
consider the actual form of the unitaries. We first show that there do
indeed exist interesting protocols. Secondly, we present a simple,
implementable, protocol. To see that interesting protocols can exist,
let Alice choose a set of @xmath unitaries independently according to
the Haar measure (approximately discretized) and announce the resulting
set @xmath to Bob. They then perform LOCKCOM( @xmath ). Following the
work of [ HLSW04 ] , we now show that this variant is secure against Bob
with high probability. That is, there exist @xmath unitaries that bring
Bob’s accessible information down to a constant: @xmath : {theorem} For
@xmath , there exist @xmath - @xmath protocols. Proof. Let @xmath denote
the set of @xmath randomly chosen bases and consider the LOCKCOM( @xmath
) scheme using unitaries @xmath . Security against Alice is again given
by Lemma 10.4 . We now need to show that this choice of unitaries
achieves the desired locking effect and thus security against Bob.
Again, let @xmath denote the dimension. As we saw in Section 5.2.1 we
have that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath denotes the outcome of the measurement of @xmath in basis
@xmath and the maximum is taken over all pure states @xmath . According
to [ HLSW04 , Appendix B] there is a constant @xmath such that

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

for @xmath and @xmath . Set @xmath . The RHS of the above equation then
decreases provided that @xmath . Thus with @xmath and @xmath , the
accessible information of the ensemble corresponding to the commitment
is then @xmath for our choice of @xmath . @xmath

Unfortunately, the protocol is inefficient both in terms of computation
and communication. It remains open to find an efficient constructive
scheme with those parameters.

In contrast, for only two bases, an efficient construction exists and
uses the identity and the Hadamard transform as unitaries. For this
case, the security of the standard LOCKCOM protocol follows immediately
from the locking arguments of Chapter 5 . It has been shown that this
protocol can be made cheat-sensitive [ Chr05 ] .

{theorem}

LOCKCOM( @xmath ) using @xmath is a @xmath - @xmath protocol. Proof. The
result follows immediately from Lemma and the fact that by Corollary
5.2.2 @xmath for Bob. @xmath

We can thus obtain non-trivial protocols by exploiting the locking
effects discussed in Chapter 5 . Note, however, that the security
parameters are very weak. Indeed, if Alice uses only two possible bases
chosen with equal probability then Bob is always able to obtain the
encoded string with probability at least @xmath : he simply guesses the
basis and performs the corresponding measurement.

#### 10.5 Conclusion

We have introduced a framework for quantum commitments to a string of
bits. Even if we consider string commitments that are weaker than bit
commitments, no non-trivial protocols can exist if we choose a very
strong measure of security. A property of quantum states known as
locking , however, allowed us to propose meaningful protocols for a much
weaker security demand. One could extend our method to the case of weak
secure function evaluation as was done for the original bit commitment
protocol in [ Lo97 ] . After completion of our work, Jain [ Jai05 ] has
also shown using a different method that @xmath protocols with @xmath
cannot exist.

A drawback of weakening the security requirement is that LOCKCOM
protocols are not necessarily composable. Thus, if LOCKCOM is used as a
sub-protocol in a larger protocol, the security of the resulting scheme
has to be evaluated on a case by case basis. However, LOCKCOM protocols
are secure when executed in parallel. This is a consequence of the
definition of Alice’s security parameter and the additivity of the
accessible information (see Chapter 2 ), and sufficient for many
cryptographic purposes.

However, two important open questions remain: First, how can we
construct efficient protocols using more than two bases? It may be
tempting to conclude that we could simply use a larger number of
mutually unbiased bases, such as given by the identity and Hadamard
transform. Yet, as we saw in Chapter 4 using more mutually unbiased
bases does not necessarily lead to a better locking effect and thus
better string commitment protocols. Finally, are there any novel
applications for this weak quantum string commitment?

Fortunately, it turns out that we can implement protocol with very
strong security parameters if we are willing to introduce additional
assumptions. We now show how to obtain oblivious transfer from the
assumption that qubits are affected by noise during storage.

\addappheadtotoc

### Chapter 11 Possibilities: Exploiting storage errors

Given the negative results from the last chapter, what can we still hope
to achieve? Fortunately, the situation is not quite as bleak if we are
taking advantage of the technical limitation that quantum storage is
necessarily noisy. Here, the very problem that still prevents us from
implementing a quantum computer can actually be turned to our advantage!
As we saw in Chapter 1 the primitive of oblivious transfer allows us to
implement essentially all cryptographic protocols among two mutually
distrustful players, and hence we focus on this primitive.

#### 11.1 Introduction

As outlined in Chapter 1 , it was recently shown that secure OT is
possible when the receiver Bob has a limited amount of quantum memory [
DFSS05 , DFR @xmath 07 ] at his disposal. Within this
‘bounded-quantum-storage model’ OT can be implemented securely as long
as a dishonest receiver Bob can store at most @xmath qubits coherently,
where @xmath is the number of qubits transmitted from Alice to Bob. The
problem with this approach is that it assumes an explicit limit on the
physical number of qubits (or more precisely, the rank of the
adversary’s quantum state). However, at present we do not know of any
practical physical situation which enforces such a limit for quantum
information. On the other hand it is a fact that currently and in the
near-future storing photonic qubits is noisy. We therefore propose an
alternative model of noisy-quantum storage inspired by present-day
physical implementations: We require no explicit memory bound, but we
assume that any qubit that is placed into quantum storage undergoes a
certain amount of noise. Here, we take the 1-2 OT protocol from [ DFR
@xmath 07 ] as our starting point, and analyze it in this model. This
simple 1-2 OT protocol can be implemented using photonic qubits (using
polarization or phase-encoding) with standard BB84 quantum key
distribution [ BB84 , GRTZ02 ] hardware, only with different classical
post-processing.

Our adversary model is that of collective attacks (in analogy with
collective eavesdropping attacks in the quantum key distribution
setting). More precisely:

-   Bob may choose to (partially) measure (a subset of) his qubits
    immediately upon reception using an error-free product measurement.

-   Bob may store each incoming qubit, or post-measurement state from a
    prior partial measurement, separately and wait until he gets
    additional information from Alice (at Step 3 in Protocol 1).

-   Once he obtained the additional information he may perform an
    arbitrary coherent measurement on his stored qubits and stored
    classical data.

We assume that a qubit @xmath undergoes some noise while in storage,
where we denote the combined channel given by Bob’s initial (partial)
measurement, followed by the noise by super-operator @xmath . The source
of noise can be due to the transfer of qubit onto a different physical
carrier, such as an atomic ensemble or atomic state for example, or into
an error-correcting code with fidelity less than 1. In addition, the
(encoded) qubit will undergo noise once it has been transferred into
‘storage’. Hence, the quantum operation @xmath in any real world setting
will necessarily include some form of noise. Note that such noise is
typically much larger than the noise experienced by honest players who
only need to make immediate complete measurements in the BB84 basis.

First of all, we show that for any initial measurement by Bob, and any
noisy superoperator @xmath the 1-2 OT protocol is secure if the honest
players can perform perfect noise-free quantum operations. As an
explicit example, we consider depolarizing noise for which reduce the
set of optimal attacks to two simple ones: measure in the so-called
Breidbart basis or let the qubits undergo depolarizing noise. This
allows us to obtain an explicit tradeoff between the amount of noise in
storage and the security of the protocol.

In a real implementation using photonic qubits the execution of the
protocol by the honest players is imperfect: their quantum operations
can be inaccurate or noisy, weak laser pulses instead of single photon
sources are used and qubits undergo decoherence in transmission. Note,
however, that unlike in QKD, we also want to execute such protocols over
very short distances (for example in banking applications) such that the
depolarization rate during transmission in free-space is very low. Our
practical 1-2 OT-protocol is a small modification of the perfect
protocol, so that we can separately deal with erasure errors (i.e.
photon loss) and the rate of these errors does not affect the security
of the protocol. We then show for this practical protocol how one can
derive trade-offs between the amount of storage noise, the amount of
noise for the operations performed by the honest players, and the
security of the protocol. At the end, we discuss the issue of analyzing
fully coherent attacks for our protocol. Indeed, there is a close
relation between the 1-2 OT protocol and BB84 quantum key distribution.

Our security analysis can in principle be carried over to obtain a
secure identification scheme in the noisy-quantum-storage model
analogous to [ DFSS07 ] . This scheme achieves password-based
identification and is of particular practical relevance as it can be
used for banking applications.

##### 11.1.1 Related work

Precursors of the idea of basing the security of 1-2 OT on storage-noise
are already present in [ BBCS92b ] which laid the foundations for the
protocol in [ DFR @xmath 07 ] , but no rigorous analysis was carried
through in that paper. Furthermore, it was pointed out in [ Sch07 ,
DFSS08 ] how the original bounded-quantum-storage analysis applies in
the case of noise levels which are so large that the rank of a dishonest
player’s quantum storage is reduced to @xmath . In contrast, we are able
to give an explicit security tradeoff even for small amounts of noise.
We furthermore note that our security proof is not exploiting the noise
in the communication channel (which has been done in the classical
setting to achieve cryptographic tasks, see e.g. [ CK88 , Cré97 , CMW04
] ), but is solely based on the fact that the dishonest receiver’s
quantum storage is noisy. Another technical limitation has been
considered in [ Sal98 ] where a bit-commitment scheme was shown secure
under the assumption that the dishonest committer can only measure a
limited number of qubits coherently. Our analysis differs in that we
allow any coherent measurement at the very end. Furthermore, the
security analysis of our protocol is considerably simpler and more
promising to be extended to cover more general cases.

#### 11.2 Preliminaries

##### 11.2.1 Definitions

We start by introducing some tools, definitions and technical lemmas. To
define the security of 1-2 OT, we need to express what it means for a
dishonest quantum player not to gain any information. Let @xmath be a
state that is part classical, part quantum, i.e. a cq-state @xmath .
Here, @xmath is a classical random variable distributed over the finite
set @xmath according to distribution @xmath . In this Chapter, we will
write the non-uniformity of @xmath given @xmath as

  -- -------- --
     @xmath   
  -- -------- --

Intuitively, if @xmath the distribution of @xmath is @xmath -close to
uniform even given @xmath , i.e., @xmath gives hardly any information
about @xmath . A simple property of the non-uniformity which follows
from its definition is that for any cq-state of the form @xmath , we
have

  -- -------- -- --------
     @xmath      (11.1)
  -- -------- -- --------

We prove the security of a randomized version of OT. In such a protocol,
Alice does not choose her input strings herself, but instead receives
two strings @xmath , @xmath chosen uniformly at random by the protocol.
Randomized OT (ROT) can easily be converted into OT: after the ROT
protocol is completed, Alice uses her strings @xmath obtained from ROT
as one-time pads to encrypt her original inputs @xmath and @xmath ,
i.e. she sends an additional classical message consisting of @xmath and
@xmath to Bob. Bob can retrieve the message of his choice by computing
@xmath . He stays completely ignorant about the other message @xmath
since he is ignorant about @xmath . The security of a quantum protocol
implementing ROT is defined in [ DFSS05 , DFR @xmath 07 ] for a
standalone setting. A more involved definition allowing for
composability can be found in [ WW07 ] . In the following, we use @xmath
to denote the complete quantum state of Bob’s lab at the end of the
protocol including any additional classical information he may have
received directly from Alice. Similarly, we use @xmath and @xmath to
denote the c-q states corresponding to the state of Alice’s lab at the
end of the protocol including her classical information about Bob’s
choice bit @xmath and outputs @xmath and @xmath as defined below.

{definition}

An @xmath -secure 1-2 @xmath is a protocol between Alice and Bob, where
Bob has input @xmath , and Alice has no input. For any distribution of
@xmath :

-   (Correctness) If both parties are honest, Alice gets output @xmath
    and Bob learns @xmath except with probability @xmath .

-   (Receiver-security) If Bob is honest and obtains output @xmath ,
    then for any cheating strategy of Alice resulting in her state
    @xmath , there exist random variables @xmath and @xmath such that
    @xmath and @xmath is @xmath -independent of @xmath , @xmath and
    @xmath , i.e., @xmath .

-   (Sender-security) If Alice is honest, then for any cheating strategy
    of Bob resulting in his state @xmath , there exists a random
    variable @xmath such that @xmath .

Note that cheating Bob may of course not choose a @xmath beforehand.
Intuitively, our requirement for security states that whatever Bob does,
he will be ignorant about at least one of Alice’s inputs. This input is
determined by his cheating strategy. Our requirement for receiver
security states that @xmath is independent of Alice’s output, and hence
Alice learns nothing about @xmath .

The protocol makes use of two-universal hash functions that are used for
privacy amplification similar as in QKD, which we already encountered in
Section 10.2.3 . For the remainder of this Chapter, we first define

{definition}

For a measurement @xmath with POVM elements @xmath let @xmath the
probability of outputting guess @xmath given @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

is the maximal average success probability of guessing @xmath given the
reduced state @xmath of the cq-state @xmath . We will employ privacy
amplification in the form of the following Lemma, which is an immediate
consequence of Lemma 10.2.3 and Theorem 1 (Theorem 5.5.1 in [ Ren05 ] ):

{lemma}

Let @xmath be a class of two-universal hash functions from @xmath to
@xmath . Let @xmath be a random variable that is uniformly and
independently distributed over @xmath , and let @xmath be a cq-state.
Then,

  -- -------- --
     @xmath   
  -- -------- --

If we have an additional @xmath bits of classical information @xmath
about @xmath ,

  -- -------- --
     @xmath   
  -- -------- --

Furthermore, we will need the following lemma which states that the
optimal strategy to guess @xmath given individual quantum information
about the bits of @xmath is to measure each register individually.
{lemma} Let @xmath be a cq-state with uniformly distributed @xmath and
@xmath . Then the maximum probability of guessing @xmath given state
@xmath is @xmath , which can be achieved by measuring each register
separately. Proof. For simplicity, we will assume that each bit is
encoded using the same states @xmath and @xmath . The argument for
different encodings is analogous, but harder to read. First of all, note
that we can phrase the problem of finding the optimal probability of
distinguishing two states as a semi-definite program (SDP)

  ------------ --------
  maximize     @xmath
  subject to   @xmath
               @xmath
  ------------ --------

with the dual program

  ------------ ----------
  minimize     @xmath
  subject to   @xmath
               @xmath .
  ------------ ----------

Let @xmath and @xmath denote the optimal values of the primal and dual
respectively. From the weak duality of SDPs, we have @xmath . Indeed,
since @xmath are feasible solutions, we even have strong duality: @xmath
[ VB96 ] .

Of course, the problem of determining the entire string @xmath from
@xmath can also be phrased as a SDP:

  ------------ --------
  maximize     @xmath
  subject to   @xmath
               @xmath
  ------------ --------

with the corresponding dual

  ------------ ----------
  minimize     @xmath
  subject to   @xmath .
  ------------ ----------

Let @xmath and @xmath denote the optimal values of this new primal and
dual respectively. Again, @xmath .

Note that when trying to learn the entire string @xmath , we are of
course free to measure each register individually and thus @xmath . We
now show that @xmath by constructing a dual solution @xmath from the
optimal solution to the dual of the single-register case, @xmath : Take
@xmath . Since @xmath and @xmath it follows that @xmath . Thus @xmath is
satisfies the dual constraints. Clearly, @xmath and thus we have @xmath
as promised. But from @xmath , @xmath , and @xmath we immediately have
@xmath . @xmath

The next tool we need is an uncertainty relation for noisy channels and
measurements. Let @xmath , @xmath , @xmath and @xmath denote the
BB84-states corresponding to the encoding of a bit @xmath into basis
@xmath (computational resp. Hadamard basis). Let @xmath and @xmath .
Consider the state @xmath for some super-operator @xmath . Note that
@xmath (see Lemma 11.2.1 ) denotes the maximal average success
probability for guessing a uniformly distributed @xmath when @xmath or
@xmath . An uncertainty relation for such success probabilities can be
stated as

  -- -------- -- --------
     @xmath      (11.2)
  -- -------- -- --------

where @xmath is a function from the set of superoperators to the real
numbers. For example, when @xmath is a quantum measurement @xmath
mapping the state @xmath onto purely classical information it can be
argued (e.g. by using a purification argument and Corollary 4.15 in [
Sch07 ] ) that @xmath which can be achieved by a measurement in the
Breidbart basis, where the Breidbart basis is given by @xmath with

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

It is clear that for a unitary superoperator @xmath we have @xmath which
can be achieved. It is not hard to show that {lemma} The only
superoperators @xmath with @xmath for which @xmath are reversible
operations. Proof. Using Helstrom’s formula [ Hel67 ] we have that
@xmath and thus for @xmath we need that for both @xmath , @xmath . This
implies that @xmath and @xmath are states which have support on
orthogonal sub-spaces for both @xmath . Let @xmath and @xmath where for
all @xmath @xmath . Consider the purification of @xmath using an
ancillary system i.e. @xmath . We can write @xmath and @xmath . Hence
@xmath and similar for @xmath . So we can write

  -- -------- --
     @xmath   
  -- -------- --

For this quantity to be equal to 2 we observe that it is necessary that
@xmath . Thus we set @xmath . We observe that if any of the states
@xmath (or @xmath ) are non-orthogonal, i.e. @xmath , then we have
@xmath .

Let @xmath be the two-dimensional subspace spanned by the orthogonal
vectors @xmath and @xmath . By the arguments above, the spaces @xmath
are mutually orthogonal. We can reverse the super-operator @xmath by
first projecting the output into one of the orthogonal subspaces @xmath
and then applying a unitary operator @xmath that maps @xmath and @xmath
onto the states @xmath and @xmath . @xmath

Finally, we need the following little technical lemma: {lemma} For any
@xmath with @xmath , we have

  -- -------- -- --------
     @xmath      (11.3)
  -- -------- -- --------

Proof. With @xmath , it is easy to verify that @xmath for @xmath and
therefore,

  -- -------- --
     @xmath   
  -- -------- --

@xmath

#### 11.3 Protocol and analysis

##### 11.3.1 Protocol

We use @xmath to denote the uniform choice of an element from a set. We
further use @xmath to denote the string @xmath restricted to the bits
indexed by the set @xmath . For convenience, we take @xmath instead of
@xmath as domain of Bob’s choice bit @xmath and denote by @xmath the bit
different from @xmath .

##### 11.3.2 Analysis

We now show that this protocol is secure according to Definition 11.2.1
.

(i) Correctness: It is clear that the protocol is correct. Bob can
determine the string @xmath (except with negligible probability @xmath
the set @xmath is non-empty) and hence obtains @xmath .

(ii) Security against dishonest Alice: this holds in the same way as
shown in [ DFR @xmath 07 ] . As the protocol is non-interactive, Alice
never receives any information from Bob at all, and Alice’s input
strings can be extracted by letting her interact with an unbounded
receiver.

(iii) Security against dishonest Bob: Our goal is to show that there
exists a @xmath such that Bob is completely ignorant about @xmath . In
our adversary model, Bob’s collective storage cheating strategy can be
described by some superoperator

  -- -------- --
     @xmath   
  -- -------- --

that is applied on the qubits between the time they arrive at Bob’s and
the time @xmath that Alice sends the classical information. We define
the choice bit @xmath as a fixed function of Bob’s cheating strategy
@xmath . Formally, we set @xmath if @xmath and @xmath otherwise.

Due to the uncertainty relation for each @xmath (from Eq. ( 11.2 )) it
then holds that

  -- -------- --
     @xmath   
  -- -------- --

where @xmath . This will be used in the proof below.

In the remainder of this section, we show that the non-uniformity

  -- -------- --
     @xmath   
  -- -------- --

is negligible in @xmath for a collective attack. Here @xmath is the
complete quantum state of Bob’s lab at the end of the protocol including
the classical information @xmath he got from Alice and his quantum
information @xmath . Expressing the non-uniformity in terms of the
trace-distance allows us to observe that @xmath . Now, for fixed @xmath
, it is clear from the construction that @xmath and @xmath are
independent of @xmath and we can use Eq. ( 11.1 ). Hence, one can bound
the non-uniformity as in Lemma 11.2.1 , i.e. by the square-root of the
probability of correctly guessing @xmath given the state @xmath . Lemma
11.2.1 tells us that to guess @xmath , Bob can measure each remaining
qubit individually and hence we obtain

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

where we used the concavity of the square-root function in the last
inequality. Lemma 11.2.1 together with the bound @xmath lets us conclude
that

  -- -------- --
     @xmath   
  -- -------- --

Lemma 11.2.1 shows that for essentially any noisy superoperator @xmath .
This shows that for any collective attacks there exists an @xmath which
yields arbitrarily high security.

#### 11.4 Practical oblivious transfer

In this section, we prove the security of a ROT protocol that is robust
against noise for the honest parties. Our protocol is thereby a small
modification of the protocol considered in [ Sch07 ] . Note that for our
analysis, we have to assume a worst-case scenario where a dishonest
receiver Bob has access to a perfect noise-free quantum channel and only
experiences noise during storage. First, we consider erasure noise (in
practice corresponding to photon loss) during preparation, transmission
and measurement of the qubits by the honest parties. Let @xmath be the
total constant probability for an honest Bob to measure and detect a
photon in the @xmath basis given that an honest Alice prepares a qubit
(or weak laser pulse) in her lab and sends it to him. The probability
@xmath is determined among others by the mean photon number in the
pulse, the loss on the channel and the quantum efficiency of the
detector. In our protocol we assume that the (honest) erasure rate
@xmath is independent of whether qubits were encoded or measured in the
@xmath - or @xmath -basis. This assumption is necessary to guarantee the
correctness and the security against a cheating Alice only. Fortunately,
this assumption is well matched with physical capabilities.

Any other noise source during preparation, transmission and measurement
can be characterized as an effective classical noisy channel resulting
in the output bits @xmath that Bob obtains at Step LABEL:step:reception
of Protocol LABEL:prot:practical . For simplicity, we model this
compound noise source as a classical binary symmetric channel acting
independently on each bit of @xmath . Typical noise sources for
polarization-encoded qubits are depolarization during transmission, dark
counts in Bob’s detector and misaligned polarizing beam-splitters. Let
the effective bit-error probability of this binary symmetric channel be
@xmath .

Before engaging in the actual protocol, Alice and Bob agree on the
system parameters @xmath and @xmath similarly to Step 1 of the protocol
in [ BBCS92b ] . Furthermore, they agree on a family @xmath of linear
error correcting codes of length @xmath capable of efficiently
correcting @xmath errors. For any string @xmath , error correction is
done by sending the syndrome information @xmath to Bob from which he can
correctly recover @xmath if he holds an output @xmath obtained by
flipping each bit of @xmath independently with probability @xmath . It
is known that for large enough @xmath , the code @xmath can be chosen
such that its rate is arbitrarily close to @xmath and the syndrome
length (the number of parity check bits) are asymptotically bounded by
@xmath [ Cré97 ] , where @xmath is the binary Shannon entropy. We assume
the players have synchronized clocks. In each time slot, Alice sends one
qubit (laser pulse) to Bob.

Let us consider the security and correctness of this modified protocol.
(i) Correctness: By assumption, @xmath is independent of the basis in
which Alice sent the qubits. Thus, @xmath is with high probability a
random subset of the transmitted qubits of of size @xmath qubits
independent of the value of bases @xmath . This implies that in Step
LABEL:step:alicecheck the protocol is aborted with a probability
exponentially small in @xmath , and hence in @xmath . The codes are
chosen such that Bob can decode except with negligible probability.
These facts imply that if both parties are honest the protocol is
correct (i.e. @xmath ) with exponentially small probability of error.
(ii) Security against dishonest Alice: Even though in this scenario Bob
does communicate to Alice, the information stating which qubits were
erased is by assumption independent of the basis in which he measured
and thus of his choice bit @xmath . Hence Alice does not learn anything
about his choice bit @xmath . Her input strings can be extracted as in
Protocol 1.
(iii) Security against dishonest Bob: Our analysis is essentially
identical to our analysis for Protocol 1 where we address the
error-correcting properties as in [ Sch07 ] . First of all, we note that
Bob can always make Alice abort the protocol by reporting back an
insufficient number of received qubits. If this is not the case, then we
define @xmath as in the analysis of Protocol 1 and we need to bound the
non-uniformity @xmath as before. Let us for simplicity assume that
@xmath (this is true with high probability, up to a factor of @xmath
which becomes negligible for large @xmath ) with @xmath . We perform the
same analysis, where we restrict ourselves to the set of remaining
qubits. We first follow through the same steps simplifying the
non-uniformity using that the total attack superoperator @xmath is a
product of superoperators. Then we use the bound in Lemma 11.2.1 for
each @xmath where we now have to condition on the additional information
@xmath which is @xmath bits long. Note that Bob does not gain any
information when Alice aborts the protocol, since her decision to abort
is a function of the bits Bob reported as being erased and he can thus
compute Alice’s decision himself. Using the second part of Lemma 11.2.1
and following identical steps in the remainder of the proof implies

  -- -------- -- --------
     @xmath      (11.4)
  -- -------- -- --------

From this expression it is clear that the security depends crucially on
the value of @xmath versus the binary entropy @xmath . The trade-off in
our bound is not extremely favorable for security as we will see.

#### 11.5 Example: depolarizing noise

Let us now consider the security in an explicit example, where Bob’s
storage is affected by depolarizing noise, and he is not able to encode
the incoming qubits into a higher-dimensional system such as an error
correcting code.

Again, we first address the simpler setting where the honest players
experience no noise themselves. In order to explicitly bound @xmath we
should allow for intermediate strategies of Bob in which he partially
measures the incoming qubits leaving some quantum information undergoing
depolarizing noise. To model this noise we let @xmath , where @xmath is
any noiseless quantum operation of Bob’s choosing from one qubit to one
qubit that generates some classical output. For example, @xmath could be
a partial measurement providing Bob with some classical information and
a slightly disturbed quantum state, or just a unitary operation. Let

  -- -------- --
     @xmath   
  -- -------- --

be the fixed depolarizing ’quantum storage’ channel that Bob cannot
influence (see Figure 11.1 ).

To determine @xmath , we have to find an uncertainty relation similar to
Eq. ( 11.2 ) by optimizing over all possible partial measurements @xmath
,

  -- -------- -- --------
     @xmath      (11.5)
  -- -------- -- --------

We solve this problem for depolarizing noise using the symmetries
inherent in our problem. In Section 11.5.1 we prove the following.
{theorem} Let @xmath be the depolarizing channel and let @xmath be
defined as above. Then

  -- -------- --
     @xmath   
  -- -------- --

Our result shows that for @xmath a direct measurement @xmath in the
Breidbart basis is the best attack Bob can perform. For this
measurement, we have @xmath . If the depolarizing noise is low ( @xmath
), then our result states that the best strategy for Bob is to simply
store the qubit as is.

##### 11.5.1 Optimal cheating strategy

We now prove Theorem 11.5 in a series of steps. Recall, that to
determine the security bound, we have to find an uncertainty relation
similar to Eq. ( 11.2 ) by optimizing over all possible partial
measurements @xmath and final measurements @xmath as in Eq. 11.5 . To
improve readability, we will drop the index @xmath and use @xmath in
place of @xmath to denote the cheating operation acting on a single
qubit. For our analysis, it will be convenient to think of @xmath as a
partial measurement of the incoming qubit. Note that this corresponds to
letting Bob perform an arbitrary CPTP map from the space of the incoming
qubit to the space carrying the stored qubit. It will furthermore be
convenient to consider the maximizing the sum instead:

  -- -------- --
     @xmath   
  -- -------- --

This immediately gives us the bound @xmath . In the following, we will
use the shorthand

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

for the probabilities that Bob correctly decodes the bit after Alice has
announced the basis information.

Any measurement Bob may perform can be characterized by a set of
measurement operators @xmath such that @xmath . The probability that Bob
succeeds in decoding the bit after the announcement of the basis is
simply the average over the probability that he correctly decodes the
bit, conditioned on the fact that he obtained outcome @xmath . I.e., for
@xmath

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

where

  -- -------- --
     @xmath   
  -- -------- --

is the probability of obtaining measurement outcome @xmath conditioned
on the fact that the basis was @xmath (and we even see from the above
that it is actually independent of @xmath ), @xmath is the
post-measurement state for outcome @xmath , and @xmath is the
probability that we are given this state. Definitions are analogous for
the bit @xmath .

We now show that Bob’s optimal strategy is to measure in the Breidbart
basis for @xmath , and to simply store the qubit for @xmath . This then
immediately allows us to evaluate @xmath . To prove our result, we
proceed in three steps: First, we will simplify our problem considerably
until we are left with a single Hermitian measurement operator over
which we need to maximize. Second, we show that the optimal measurement
operator is diagonal in the Breidbart basis. And finally, we show that
depending on the amount of noise, this measurement operator is either
proportional to the identity, or proportional to a rank one projector.
Our individual claims are indeed very intuitive.

For any measurement @xmath , let @xmath for the measurement @xmath ,
where @xmath and @xmath are the success probabilities similar to Eq. (
11.5.1 ), but restricted to using the measurement @xmath . First of all,
note that we can easily combine two measurements. Intuitively, the
following statement says that if we choose one measurement with
probability @xmath , and the other with probability @xmath our average
success probability will be the average of the success probabilities
obtained via the individual measurements:

###### Claim 4

Let @xmath and @xmath be two measurements. Then @xmath , where where
@xmath for @xmath and @xmath .

Proof. Let @xmath and @xmath be measurements, @xmath and @xmath be the
measurement @xmath with probability @xmath and measurement @xmath with
probability @xmath . We denote by @xmath the probabilities corresponding
to measurements @xmath respectively. Observe that for @xmath , @xmath
and analogously for @xmath , we have @xmath . We observe furthermore
that for @xmath and @xmath , @xmath cancels out by the normalization,
@xmath and similarly for @xmath . Finally, we can convince ourselves
that @xmath , as the probability to be given state @xmath is the same
when the measurement outcome and the basis is fixed. Putting everything
together, we obtain

  -- -------- -------- --
     @xmath   @xmath   
              @xmath   
              @xmath   
              @xmath   
  -- -------- -------- --

@xmath

We can now make a series of observations.

###### Claim 5

Let @xmath and @xmath . Then for all @xmath we have @xmath .

Proof. This claim follows immediately from that fact that for the trace
norm we have @xmath for all unitaries @xmath , and by noting that for
all @xmath , @xmath can at most exchange the roles of @xmath and @xmath
. I.e., we perform a bit flip before the measurement which we can
correct for afterwards by applying classical post-processing: we have
for all @xmath that

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

@xmath

It also follows that {corollary} For all @xmath we have for all @xmath
and @xmath that

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

Proof. This follows from the proof of Claim 5 . @xmath

###### Claim 6

Let @xmath . There exists a measurement operator @xmath such that the
maximum of @xmath over all measurements @xmath is achieved by a
measurement proportional to @xmath .

Proof. Let @xmath be a measurement. Let @xmath be the number of
measurement operators. Clearly, @xmath with

  -- -------- --
     @xmath   
  -- -------- --

is also a quantum measurement since @xmath . It follows from Claims 4
and 5 that @xmath . Define operators

  -- -------- --
     @xmath   
  -- -------- --

Note that

  -- -------- --
     @xmath   
  -- -------- --

(see for example Hayashi [ Hay06 ] ). Hence @xmath is a valid quantum
measurement. Now, note that @xmath can be obtained from @xmath by
averaging. Hence, by Claim 4 we have

  -- -------- --
     @xmath   
  -- -------- --

Let @xmath be the optimal measurement. Clearly, @xmath by the above and
Corollary 11.5.1 from which our claim follows. @xmath

Note that Claim 6 also gives us that we have at most 4 measurement
operators. Wlog, we will take the measurement outcomes to be labeled
@xmath .

Finally, we note that we can restrict ourselves to optimizing over
positive-semidefinite (and hence Hermitian) matrices only.

###### Claim 7

Let @xmath be a measurement operator, and let

  -- -------- --
     @xmath   
  -- -------- --

with @xmath and @xmath . Then there exists a Hermitian operator @xmath ,
such that @xmath .

Proof. Let @xmath be the polar decomposition of @xmath , where @xmath is
positive semidefinite and @xmath is unitary [ HJ85 , Corollary 7.3.3] .
Evidently, since the trace is cyclic, all probabilities remain the same.
It follows immediately from the definition of the trace norm that @xmath
for all unitaries @xmath , which completes our proof. @xmath

To summarize, our optimization problem can now be simplified to

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

where the maximization is now taken over a single operator @xmath , and
we have used the fact that we can write @xmath and we have 4 measurement
operators.

###### F is diagonal in the Breidbart basis

Now that we have simplified our problem already considerably, we are
ready to perform the actual optimization. Since we are in dimension
@xmath and @xmath is Hermitian, we may express @xmath as

  -- -------- --
     @xmath   
  -- -------- --

for some state @xmath and real numbers @xmath . We first of all note
that from @xmath , we obtain that

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

and hence @xmath . Furthermore using that @xmath we then have

  -- -------- -- --------
     @xmath      (11.6)
  -- -------- -- --------

with @xmath . Our first goal is now to show that @xmath is a Breidbart
vector (or the bit-flipped version thereof). To this end, we first
formalize our intuition that we may take @xmath to lie in the XZ plane
of the Bloch sphere only. Since we are only interested in the
trace-distance term of @xmath , we restrict ourselves to considering

  -- -------- -- -------- --
     @xmath      @xmath   
  -- -------- -- -------- --

###### Claim 8

Let @xmath be the operator that maximizes @xmath , and write @xmath as
in Eq.( 11.6 ). Then @xmath lies in the XZ plane of the Bloch sphere.
(i.e. @xmath ).

Proof. We first parametrize the state in terms of its Bloch vector:

  -- -------- --
     @xmath   
  -- -------- --

Since @xmath is pure we can write @xmath . Hence, we can express @xmath
as

  -- -------- --
     @xmath   
  -- -------- --

Noting that @xmath and @xmath we can compute for the computational basis

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

and for the Hadamard basis:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

Note that @xmath , where @xmath is the @xmath -th eigenvalue of @xmath .
A lengthy computation (using Mathematica), and plugging in @xmath and
@xmath shows that we have

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Similarly, we obtain for the Hadamard basis that

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

We define

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Note that our optimization problem now takes the form

  ------------ ----------
  maximize     @xmath
  subject to   @xmath
               @xmath
               @xmath ,
  ------------ ----------

where we can introduce the last two inequality constraints without loss
of generality, since the remaining three measurement operators will be
given by @xmath , @xmath , and @xmath .

To show that we can let @xmath for the optimal solution, we have to show
that for all @xmath and all @xmath , the function @xmath is increasing
on the interval @xmath (and indeed Mathematica will convince you in an
instant that this is the case). Our analysis is is further complicated
by the absolute values. We therefore first consider

  -- -------- --
     @xmath   
  -- -------- --

where we have used the fact that @xmath and @xmath are real valued
functions. In principle, we can now analyze @xmath and @xmath separately
on their respective domains. By rewriting, we obtain

  -- -------- --
     @xmath   
  -- -------- --

and

  -- -------- --
     @xmath   
  -- -------- --

Luckily, the first derivatives of @xmath and @xmath turns out to be
positive everywhere for our choice of parameters @xmath , and @xmath .
Hence, by further inspection at the transitional points we can conclude
that @xmath is an increasing function of @xmath . But this means that to
maximize our target expression, we must choose @xmath and @xmath as
large as possible. Hence, choosing @xmath is the best choice and our
claim follows. @xmath

We can now immediately extend this analysis to find

###### Claim 9

Let @xmath be the operator that maximizes @xmath , and write @xmath as
in Eq.( 11.6 ). Then

  -- -------- --
     @xmath   
  -- -------- --

for some @xmath .

Proof. Extending our analysis from the previous proof, we can compute
the second derivative of both functions. It turns out that also the
second derivatives are positive, and hence @xmath is convex in @xmath .
By Claim 8 , we can rewrite our optimization problem as

  ------------ --------
  maximize     @xmath
  subject to   @xmath
               @xmath
               @xmath
  ------------ --------

It now follows from the fact that @xmath is convex in @xmath and the
constraint @xmath (by computing the Lagrangian of the above optimization
problem), that for the optimal solution we must have @xmath , and our
claim follows. @xmath

###### Optimality of the trivial strategies

Now that we have shown that @xmath is in fact diagonal in the Breidbart
basis (or the bit flipped version thereof) we have only a single
parameter left in our optimization problem. We must now optimize over
all operators @xmath of the form

  -- -------- --
     @xmath   
  -- -------- --

where we may take @xmath to be @xmath or @xmath . Our aim is now to show
that either @xmath is the identity, or @xmath depending on the value of
@xmath .

###### Claim 10

Let @xmath be the operator that maximizes @xmath . Then @xmath (for some
@xmath ) for @xmath , and @xmath for @xmath , where

  -- -------- --
     @xmath   
  -- -------- --

for some @xmath .

Proof. We can now plug in @xmath in the expressions for the eigenvalues
in our previous proof. Ignoring the constant positive factors which do
not contribute to our argument, we can then write

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

And similarly for the Hadamard basis. We again define functions

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Note that our optimization problem now takes the form

  ------------ --------
  maximize     @xmath
  subject to   @xmath
  ------------ --------

Since we are maximizing, we might as well consider the square of our
target function and ignore the leading constant as it is irrelevant for
our argument.

  -- -------- --
     @xmath   
  -- -------- --

To deal with the absolute value, we now perform a case analysis similar
to the one above. Computing the zeros crossings of the function @xmath ,
we analyze each interval separately. Computing the first and second
derivatives on the intervals we find that @xmath has exactly two peaks:
The first at @xmath , and the second at @xmath . We have that @xmath for
all @xmath , and @xmath . Hence, we immediately see that the maximum is
located at @xmath for @xmath , and at @xmath for @xmath . @xmath

Theorem 11.5 now follows directly from Claim 10 : Bob either measures in
the Breidbart basis, or stores the qubit as is. We believe that a
similar analysis can be done for the dephasing channel, by first
symmetrizing the noise by applying a rotation over @xmath to our input
states.

##### 11.5.2 Noise tradeoff

We now consider the more practical setting, where the honest parties
also experience noise. Clearly, there is a strict tradeoff between the
noise @xmath on the channel experienced by the honest parties, and the
noise experienced by dishonest Bob. Our practical security bound is
fairly weak. In the near-future we may anticipate that storage is better
than direct measurement if good photonic memories become available.
However, we are free in our protocol to stretch the waiting time @xmath
between Bob’s reception of the qubits and his reception of the classical
basis information, say, to seconds, which means that one has to consider
the overall noise rate on a qubit that is stored for seconds.

We again consider the case of depolarizing noise during storage. For
@xmath (when it is better for Bob to measure in the Breidbart basis), we
obtain that our protocol is secure as long as

  -- -------- --
     @xmath   
  -- -------- --

Hence, we require that @xmath . This puts a strong restriction on the
noise rate of the honest protocol. Yet, since our protocols are
particularly interesting at short distances (e.g. in the case of secure
identification), we can imagine very short free-space implementations
such that depolarization noise during transmission is negligible and the
main depolarization noise source is due to Bob’s honest measurements.

For @xmath (when it’s better for Bob to store the qubit as is) we also
obtain a tradeoff involving @xmath . As an example, suppose that the
qubits in the honest protocol are also subjected to depolarizing noise
at rate @xmath . The effective classical error rate for a depolarizing
channel is then simply @xmath . Thus we can consider when the function
@xmath goes below 0. If we assume that @xmath , for some scaling factor
@xmath (i.e., the honest party never has more noise than the dishonest
party), we obtain a clear tradeoff between @xmath and @xmath depicted in
Figure 11.2 .

#### 11.6 Conclusion

We have introduced the model of noisy-quantum storage. In this model, we
have determined security bounds for a perfect ROT protocol given
collective storage attacks by Bob. Furthermore, we showed how to
construct a practical ROT where we do allow the honest parties to
experience noise during transmissions and their operations as well. We
provided an explicit security tradeoff between the noise affecting the
honest parties, and the noise during storage for a dishonest Bob.

Ideally, we would like to show security against general coherent noisy
attacks. The problem with analyzing a coherent attack of Bob described
by some super-operator @xmath affecting all his incoming qubits is not
merely a technical one: one first needs to determine a realistic noise
model in this setting. It may be possible using variations of de Finetti
theorems as in the proof of QKD [ Ren05 ] to prove for a symmetrized
version of our protocol that any coherent attack by Bob is equivalent to
a collective attack. Yet, the present scenario differs in that it is not
as straightforward to achieve a symmetrization of the protocol. However,
one can in fact analyze a specific type of coherent noise, one that
essentially corresponds to an eavesdropping attack in QKD. Note that the
1-2 OT protocol can be seen as two runs of QKD interleaved with each
other. The strings @xmath and @xmath are then the two keys generated.
The noise must be such that it leaves Bob with exactly the same
information as the eavesdropper Eve in QKD. In this case, it follows
from the security of QKD that the dishonest Bob (learning exactly the
same information as the eavesdropper Eve) does not learn anything about
the two keys.

In terms of long-term security, fault-tolerant photonic computation
(e.g., with the KLM scheme [ KLM01 ] ) might allow a dishonest Bob to
encode the incoming quantum information into a fault-tolerant quantum
memory. This implies that in storage, the effective noise rate can be
made arbitrarily small. However, the encoding of a single unknown state
is not a fault-tolerant quantum operation: already the encoding process
introduces errors whose rates cannot be made arbitrarily small with
increasing effort. Hence, even in the presence of a quantum computer,
there is a residual storage noise rate due to the unprotected encoding
operations. The question of security then becomes a question of a
trade-off between this residual noise rate versus the intrinsic noise
rate. Finally, it remains to address composability of the protocol
within our model, which has already been considered for the
bounded-quantum-storage model [ WW07 ] .

### Appendix A Linear algebra and semidefinite programming

Semidefinite programming is a useful tool to solve optimization
problems. Since we employed semidefinite programming in Chapters 3 , 7 ,
and 11 , we briefly state the most important notions. We refer to [ BV04
] for an in-depth introduction.

#### a.1 Linear algebra prerequisites

Before turning to semidefinite programming in the next section, we first
briefly recall some elementary definitions from linear algebra. We
thereby assume the reader is familiar with basic concepts, such as
matrix multiplication and addition. Unless explicitly indicated, all
vector spaces @xmath considered here are over the field of complex
numbers. We use @xmath to denote a @xmath -dimensional complex vector
space, and @xmath to denote the space of complex @xmath matrices. A set
of vectors @xmath is linearly independent if @xmath implies that @xmath
. A basis of a @xmath -dimensional vector space @xmath is a set of
linearly independent vectors @xmath , the basis vectors , such that any
vector @xmath can be written as a linear combination of basis vectors.
If there exists a vector @xmath with @xmath such that @xmath , we say
that @xmath is an eigenvector of @xmath and the scalar @xmath the
corresponding eigenvalue .

The inner product of two vectors @xmath with @xmath and @xmath is given
by @xmath . The 2- norm of a vector is given by @xmath . Unless
otherwise indicated, all norms of a vector are 2-norms in this text. We
also use @xmath to denote emphasize that the norm is defined on a vector
space @xmath . Two vectors @xmath such that @xmath are orthogonal . If,
in addition, @xmath then they are also called orthonormal .

A Hilbert space is defined as a vector space @xmath with an inner
product, where the vector space is complete. We refer to [ Con90 ] for a
formal definition of the notion of completeness and merely note that
informally a vector space is complete if for any sequence of vectors in
said space approaching a limit, the limit is also an element of the
vector space. A bounded operator is an operator @xmath such that there
exists a @xmath satisfying @xmath for all @xmath . The smallest such
@xmath is also called the operator norm of @xmath .

The transpose of a matrix @xmath is written as @xmath and given by
@xmath , where @xmath denotes the entry of the matrix @xmath at column
@xmath and row @xmath . Similarly, the conjugate transpose @xmath of
@xmath is of the form @xmath . We use @xmath to denote the identity
matrix defined as @xmath with @xmath . A matrix @xmath is called unitary
if @xmath . Furthermore, @xmath is called Hermitian if and only if
@xmath . Any Hermitian matrix can be decomposed in terms of its
eigenvalues @xmath and eigenvectors @xmath as @xmath , where @xmath is a
projector onto the vector @xmath . We also call this the
eigendecomposition of @xmath . The support of @xmath is the space
spanned by all its eigenvectors with non-zero eigenvalue.

The tensor product of an @xmath -matrix @xmath and an @xmath matrix
@xmath is given by the @xmath -matrix

  -- -------- --
     @xmath   
  -- -------- --

The tensor product is also defined for two vector spaces @xmath and
@xmath . In particular, if the basis of the @xmath -dimensional vector
space @xmath is given by @xmath and the basis of the @xmath -dimensional
vector space @xmath is given by @xmath , then @xmath denotes the @xmath
-dimensional vector space @xmath with basis @xmath .

The direct sum of an @xmath -matrix @xmath and an @xmath matrix @xmath
is given by the @xmath matrix

  -- -------- --
     @xmath   
  -- -------- --

Two vector spaces @xmath and @xmath defined as above can also be
composed in an analogous fashion yielding a @xmath dimensional vector
space @xmath , where any @xmath can be written as @xmath for some @xmath
and @xmath with @xmath for @xmath and @xmath .

The trace of a matrix @xmath is given by the sum of its diagonal entries
@xmath . Note that @xmath , and @xmath . If @xmath is an Hermitian
matrix, then @xmath is the sum of its eigenvalues.

Finally, the rank of a matrix @xmath is denoted as @xmath and given by
the maximal number of linearly independent columns (or rows) of @xmath .

#### a.2 Definitions

We now turn to the definitions relevant for our discussion of
semidefinite programming. A Hermitian matrix @xmath is positive
semidefinite if and only if all of its eigenvalues are non-negative [
HJ85 , Theorem 7.2.1] . Throughout this text, we use @xmath to indicate
that @xmath is positive semidefinite. We know from [ HJ85 , Theorem
7.2.11] : {proposition} For a Hermitian matrix @xmath the following
three statements are equivalent:

1.  @xmath ,

2.  @xmath for all vectors @xmath ,

3.  @xmath for some matrix @xmath .

@xmath is called positive definite if and only if all of its eigenvalues
are positive: we have @xmath for all vectors @xmath . We use @xmath to
indicate that @xmath is positive definite. We also encounter projectors,
where a Hermitian matrix @xmath is a projector if and only if @xmath .
Note that this implies that @xmath . We say that two projectors @xmath
and @xmath are orthogonal projectors if and only if @xmath .

Furthermore, we use @xmath to denote the set of all Hermitian matrices,
@xmath , and @xmath for the set of all positive semidefinite matrices. A
set @xmath is a cone , if for any @xmath and @xmath we have @xmath . A
set @xmath is convex , if for any @xmath and @xmath we have @xmath . A
set @xmath is called a convex cone , if @xmath is convex and a cone: for
any @xmath and @xmath we must have that @xmath . Note that @xmath is a
convex cone: Let @xmath , and @xmath . Then for any @xmath we have

  -- -------- --
     @xmath   
  -- -------- --

Hence, @xmath . The following will be of use in Chapter 3 .
{proposition} Let @xmath . Then @xmath if and only if for all @xmath
@xmath . Proof. Suppose that @xmath . Note that we can decompose @xmath
where for all @xmath @xmath since @xmath . Hence, @xmath , since @xmath
.

To prove the converse, suppose on the contrary that for all @xmath we
have @xmath , but @xmath . If @xmath , then there exists some vector
@xmath such that @xmath . Let @xmath . Clearly, @xmath and @xmath which
is a contradiction. @xmath

#### a.3 Semidefinite programming

Semidefinite programming is a special case of convex optimization. Its
goal is to solve the following semidefinite program (SDP) in terms of
the variable @xmath

  ------------ ---------------------
  maximize     @xmath
  subject to   @xmath , and @xmath
  ------------ ---------------------

for given matrices @xmath . The above form is called the standard form
of an SDP, and any SDP can be cast in this fashion (possibly at the
expense of additional variables) [ BV04 ] . To gain some geometric
intuition about this task, note that @xmath means that @xmath must lie
in the cone @xmath . The constraints @xmath determine a set of
hyperplanes which further limit our possible solutions. A matrix @xmath
is called feasible , if it satisfies all constraints.

An important aspect of semidefinite programming is duality. Intuitively,
the idea behind Lagrangian duality is to extend the objective function
(here @xmath ) with a weighted sum of the constraints in such a way,
that we will be penalized if the constraints are not fulfilled. The
weights then correspond to the dual variables. Optimizing over these
weights then gives rise to the dual problem . The original problem is
called the primal problem . For the above SDP in standard form, we can
write down the Lagrangian as

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

where @xmath . The dual function is then

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

From @xmath and @xmath , we obtain that @xmath . This gives us the dual
problem as

  ------------ ----------
  minimize     @xmath
  subject to   @xmath ,
  ------------ ----------

where the optimization is now over the dual variables @xmath .

We generally use @xmath to denote the optimal value of the dual problem,
and @xmath for the optimal value of the primal problem. Weak duality
says that @xmath . Let’s see why this is true in the above construction
of the dual problem. Let @xmath and @xmath be the optimal solutions to
the primal and dual problem respectively. In particular, this means that
@xmath and @xmath must satisfy the constraints. Then

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

by Proposition A.2 since @xmath and @xmath . An important consequence of
weak duality, is that if we have @xmath for a feasible dual and primal
solution respectively, we can conclude that both solutions are optimal.
If solutions exist such that @xmath , we also speak of strong duality.
We know from Slater’s conditions [ BV04 ] , that strong duality holds if
there exists a feasible solution to the primal problem which also
satisfies @xmath .

#### a.4 Applications

In many quantum problems, we want to optimize over states, or
measurement operators. Evidently, semidefinite programming is very well
suited to this case: When optimizing over a state @xmath , we ask that
@xmath and @xmath . When optimizing over measurement operators @xmath
belonging to one POVM, we ask that @xmath for all @xmath and @xmath .
Concrete examples can be found in Chapters 3 , 7 , and 11 .

### Appendix B @xmath-Algebra

As @xmath -algebras are not usually encountered in computer science, we
briefly state the most important results we will refer to for
convenience. In particular, they help us understand the framework of
post-measurement information we encountered in Chapter 3 as well as the
structure of bipartite non-local games in Chapter 6 .

#### b.1 Introduction

Instead of starting out with the usual axioms of quantum states and
their evolutions, any physical system can be characterized by a @xmath
-algebra @xmath of observables. States of this system are now identified
purely by means of measurements of these observables. This starting
point is rather beautiful in its abstraction: So far, nothing has been
said how we can represent elements of this algebra. Yet, it turns out
that all the usual axioms can be derived from this abstract structure:
we can represent observables as operators and states as vectors in a
Hilbert space. In fact, any such algebra @xmath is isomorphic to an
algebra of bounded operators on a Hilbert space. So why should we bother
adopting this abstract viewpoint? It turns out that @xmath -algebras
often make it easier to understand the fundamental differences between
the classical and the quantum setting. If the algebra @xmath is abelian,
we have a classical system. Otherwise, our system is inherently quantum.
Commutativity leads to several nice structural properties of an algebra
which have been exploited to answer many central questions in quantum
information: When can we clone physical states? What information can be
extracted without disturbing the system? That is, what part of a system
is in fact classical and what is truly quantum?

Here, we will mere scratch the surface of this formalism. In particular,
we will focus on finite-dimensional @xmath -algebras only, which is all
we will need in Chapters 3 and 6 . For more information, consult any
textbook on the topic [ Tak79 , BR02 , Arv76 ] . We assume that the
reader is familiar with the basic concepts such as a Hilbert space and
refer to [ Con90 ] for an introduction. First, we need to introduce some
essential definitions in Section B.2 . We then examine states and
observables, and their familiar representation in a Hilbert space in
Section B.3.2 . In Section B.4 , we then concentrate on commutation: We
will sketch how from commutation relations we in fact obtain a bipartite
structure. It turns out that commutation relations also play an
important role in determining which operations leave states invariant.
Looking at the structure of the problem, it turns out that in fact many
problems ranging from cloning to post-measurement information and
bipartite non-local games are quite closely related.

#### b.2 Some terminology

A Banach algebra @xmath is a linear associative algebra ¹ ¹ 1 An
associative algebra over the complex numbers is a vector space over the
complex numbers with a multiplication that is associative. which is also
a Banach space, with the property that for all @xmath and @xmath we have

  -- -------- --
     @xmath   
  -- -------- --

The norm of @xmath is thereby a real number satisfying the usual
requirements that for all @xmath we have @xmath where @xmath if and only
if @xmath , @xmath , @xmath , and @xmath . @xmath is called a @xmath
-algebra if it has the additional property that it admits an involution
@xmath such that for all @xmath and @xmath the following holds: @xmath ,
@xmath , @xmath , and @xmath . A @xmath -algebra is now an even more
special case: in addition we also have that @xmath for all @xmath . This
also gives us @xmath . In the following we will simply use the term
“algebra” to refer to a @xmath -algebra. The trick is not to be
intimidated. It is easier to have a more concrete picture in mind: For
example, the algebra @xmath of all bounded operators on a Hilbert space
@xmath is a @xmath -algebra, when we take sums and products of operators
in the usual way and take our norm to be the operator norm @xmath ,
where @xmath for the inner product @xmath of the Hilbert space. This
algebra is closed under all the usual operations such as addition,
multiplication, and multiplication by scalars ² ² 2 We will take the
underlying field to be @xmath . and the involution operation. This
involution is now the adjoint operation @xmath , which in physics is
usually denoted by @xmath instead of @xmath . In some physics papers,
you will therefore also find the name @xmath -algebra instead. As in the
example of post-measurement information, we are also often interested in
the @xmath -algebra generated by a given set of operators. Any operator
@xmath in a Hilbert space @xmath determines a @xmath -algebra @xmath
which we will denote by @xmath . This is the smallest @xmath -algebra
which contains both @xmath and the identity, i.e. @xmath . What’s
included in @xmath ? Recall that @xmath is closed under the adjoint
operation so we definitely have @xmath . In addition, our conditions
above imply that we will see all possible polynomials in @xmath and
@xmath . For example, @xmath and @xmath are also elements of the
algebra. We use @xmath to denote the @xmath -algebra generated by
operators @xmath , and @xmath to denote the algebra generated by
operators from the set @xmath .

If an algebra @xmath satisfies @xmath , we call @xmath a subalgebra of
@xmath . An algebra @xmath is unital if it contains the identity. We
will always use @xmath to denote the identity element. Since we restrict
ourselves to the finite-dimensional case, we can assume that any @xmath
-algebra is in fact unital [ Tak79 ] . We will always take @xmath to be
unital here. An element @xmath of a Banach algebra @xmath is called
invertible if there exists some @xmath such that @xmath . Furthermore,
for a @xmath -algebra @xmath , the spectrum of @xmath is given by @xmath
. Note that for any @xmath , this is just the spectrum of the operator
relative to @xmath in the usual sense.

A left ideal in some algebra @xmath is a subalgebra @xmath such that for
any elements @xmath and @xmath we have that @xmath . Similarly, @xmath
is called a right ideal if @xmath . A two-sided ideal or simply ideal
has both properties: @xmath is both a left and right ideal of @xmath .
An algebra @xmath is called simple if its only ideals are @xmath and
@xmath itself. An algebra @xmath is called semisimple , if it can be
written as the direct sum of simple algebras. To get a better feeling
for what this actually means, it is perhaps again helpful to think of a
particular representation of the algebra in terms of bounded operators
on a Hilbert space. In terms of representations, being simple means that
the representation is irreducible. Being semisimple then means that the
representation is completely reducible: i.e. for the representation
@xmath of @xmath we can express @xmath as a sum of irreducible
representations. We will examine this decomposition in more detail in
Section B.4.1 .

#### b.3 Observables, states and representations

##### b.3.1 Observables and states

A physical system is characterized by a set of measurable quantities,
i.e. observables. As mentioned above, we will assume that a physical
system is in fact described by a @xmath -algebra @xmath of observables.
As we will see below, we can take the observables to live in a Hilbert
space @xmath , and @xmath . Where do the states come in? In the language
of @xmath -algebras, states are positive linear functionals on @xmath :
A linear functional on an algebra is a function @xmath such that for all
@xmath we have @xmath and @xmath where @xmath is a scalar. A linear
functional is called positive if @xmath for any @xmath whenever @xmath .
A state on @xmath is a positive linear functional @xmath on @xmath with
the additional property that it has norm 1, i.e., @xmath . The set of
states is a convex set of linear functionals and its extreme elements
are called pure states. The set of all states on an algebra @xmath is
also called the state space , often denoted by @xmath . Any observable
@xmath in our algebra is uniquely characterized by the expectation of
all states when we measure @xmath : So the value of @xmath for all
states @xmath in our state space uniquely characterizes any element
@xmath of our algebra. The converse is also true: the value of @xmath
for all @xmath completely characterizes the state @xmath . To get a
better feeling for this, it is again helpful to think of an algebra
@xmath . Given a vector @xmath living in the Hilbert space @xmath , we
can construct a linear functional on @xmath by letting @xmath . The same
is true if we consider any abstract @xmath and its representation @xmath
on a Hilbert space, by letting @xmath given @xmath .

##### b.3.2 Representations

We now examine how an abstract @xmath -algebra can be represented by a
set of operators on a Hilbert space, via the famous construction by
Gelfand, Naimark and Segal. An account of this construction can be found
in any standard textbook on @xmath -algebra [ Tak79 , BR02 , Arv76 ] .
For completeness, we here give a heavily annotated, largely
self-contained, explanation of the GNS construction. As it turns out, by
the GNS construction, any @xmath -algebra is isomorphic to an algebra of
bounded operators, a result which we will merely state here. When trying
to find a representation of a @xmath -algebra @xmath , our goal is to
find a pair @xmath where @xmath is a Hilbert space and @xmath is a
@xmath -homomorphism which maps any element of our algebra to a bounded
operator in the chosen Hilbert space.

{theorem}

[GNS] Let @xmath be a unital @xmath -algebra, and let @xmath be a
positive linear functional on @xmath . Then there exists a
representation @xmath of @xmath with a Hilbert space @xmath , a @xmath
-homomorphism ³ ³ 3 A homomorphism that preserves the @xmath . @xmath
and a vector @xmath such that for all @xmath

  -- -------- --
     @xmath   
  -- -------- --

Proof. First, we construct the Hilbert space @xmath . Since @xmath is a
Banach space, we can turn it into a pre-Hilbert space ⁴ ⁴ 4 We take a
pre-Hilbert space to be a vector space with a positive semidefinite
sesquilinear form, and a strict pre-Hilbert space to be a vector space
with an inner product. by defining the positive semidefinite
sesquilinear form

  -- -------- --
     @xmath   
  -- -------- --

for all @xmath . Note that this form may be degenerate ⁵ ⁵ 5 Such a form
is nondegenerate if and only if: @xmath for all @xmath implies that
@xmath . . In order to eliminate this degeneracy, consider

  -- -------- --
     @xmath   
  -- -------- --

Note that @xmath is a linear subspace of @xmath since for all @xmath we
have @xmath , where we used the Cauchy-Schwarz inequality ⁶ ⁶ 6 In this
context the CS-inequality gives us that for all @xmath we have @xmath .

We now show that @xmath is a left ideal of @xmath : Let @xmath and
@xmath . We then need to show that @xmath . Indeed, from @xmath we have

  -- -------- --
     @xmath   
  -- -------- --

where the inequality follows from the Cauchy-Schwarz inequality.

The Hilbert space @xmath is then constructed by completing the quotient
space @xmath . This works as follows: Define the equivalence classes

  -- -------- --
     @xmath   
  -- -------- --

Note that these equivalence classes constitute a complex vector space on
their own, where addition and scalar multiplication are defined via the
following operations inherited from @xmath . We have @xmath and @xmath .
We can then define the inner product

  -- -------- --
     @xmath   
  -- -------- --

Note that @xmath and @xmath of course depend on @xmath . One can verify
that this a correct definition. Indeed, the inner product does not
depend on our choice of representative from each equivalence class: Let
@xmath , and let @xmath . Then

  -- -------- --
     @xmath   
  -- -------- --

where the last equality follows again from the Cauchy-Schwarz
inequality. We can now obtain @xmath by forming the completion of this
space. It is well-known in functional analysis that any strict
pre-Hilbert space can be embedded as a dense subspace of a Hilbert space
in such a way that the inner product is preserved.

Second, we must construct @xmath . We first define the action of @xmath
on the vectors constructed above as

  -- -------- --
     @xmath   
  -- -------- --

Note that this definition is again independent of our choice of
representative from each equivalence class since for all @xmath we have

  -- -------- --
     @xmath   
  -- -------- --

since @xmath is a left ideal of @xmath and we already saw that @xmath .
It remains to show that @xmath is a homomorphism and that @xmath is
indeed bounded. To see that @xmath is a homomorphism, note that

  -- -------- --
     @xmath   
  -- -------- --

and

  -- -------- --
     @xmath   
  -- -------- --

as desired. To see that @xmath is bounded, consider

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

where we used the fact that from @xmath we have @xmath (see for example
[ Tak79 ] ).

Finally, we need to construct the vector @xmath . Since @xmath is unital
we can take @xmath . This gives us @xmath . Note that @xmath , i.e.,
@xmath is cyclic for @xmath . @xmath

The resulting representation is irreducible if and only if @xmath is
pure [ BR02 , Theorem 2.3.19] . By considering a family of states @xmath
, and applying the GNS construction to all @xmath and taking the direct
sum of representations it is then possible to show that: {theorem} (GN)
Let @xmath be a unital @xmath -algebra. Then @xmath is isomorphic to an
algebra of bounded operators on a Hilbert space @xmath .

#### b.4 Commuting operators

@xmath is abelian if and only if the physical system corresponding to
this algebra is classical. Thus to distinguish the quantum from the
classical problems, commutation will be central to our discussion. In
fact, it leads to very nice structural properties which we already
exploited in Chapter 3 . First, however, we will need a bit more
terminology. The commutator of two operators @xmath and @xmath is given
by @xmath . For quantum applications, two observables @xmath and @xmath
are called compatible if they commute, i.e., @xmath . Conversely, @xmath
and @xmath are called complementary if @xmath . The center @xmath of an
algebra @xmath is the set of all elements in @xmath that commute with
all elements of @xmath , i.e.

  -- -------- --
     @xmath   
  -- -------- --

It is easy to see that if @xmath only has a trivial center, i.e. @xmath
, @xmath is simple [ Tak79 ] . If @xmath for some Hilbert space @xmath ,
then the commutant of @xmath in @xmath is

  -- -------- --
     @xmath   
  -- -------- --

We have @xmath .

##### b.4.1 Decompositions

In any of our problems, the interesting case is when the algebra @xmath
under consideration is in fact simple: that is, “fully quantum”. In all
problems we will consider, it will turn out that we can always break
down the problem into smaller components by decomposing any @xmath into
a sum of simple algebras. ⁷ ⁷ 7 Recall that we only consider the
finite-dimensional case. Luckily, such a decomposition always exists in
the finite-dimensional case: {lemma} Let @xmath be a finite-dimensional
@xmath -algebra. Then there exists a decomposition

  -- -------- --
     @xmath   
  -- -------- --

such that @xmath is simple. Proof. Let @xmath be the center of @xmath .
Clearly, since @xmath is finite-dimensional, @xmath is a
finite-dimensional abelian @xmath -algebra. Since @xmath is finite,
there exist a finite set of positive linear functionals @xmath , such
that @xmath and @xmath for all @xmath . ⁸ ⁸ 8 For a matrix algebra these
are just the eigenvectors with equal eigenvalue For all @xmath , choose
@xmath such that @xmath for all @xmath . Note that @xmath are projectors
and @xmath since for all @xmath we have @xmath since @xmath is abelian.
Now we have

  -- -------- --
     @xmath   
  -- -------- --

since for all @xmath we have @xmath since @xmath . Note that @xmath only
has a trivial center: its only elements that commute with any element of
@xmath are scalar multiples of @xmath . Hence, @xmath is simple. @xmath

In fact, it is possible to show that [ Tak79 ] : {corollary} Let @xmath
be a finite-dimensional @xmath -algebra Then there exists @xmath and a
decomposition

  -- -------- --
     @xmath   
  -- -------- --

such that

  -- -------- --
     @xmath   
  -- -------- --

Note that this means that any element @xmath can be written as @xmath
where @xmath is a projection onto @xmath .

##### b.4.2 Bipartite structure

As we saw in Chapter 3 , commutation relations induce a beautiful
structure captured by the Double Commutant theorem. We here sketch a
proof of the parts of this theorem which is interesting for
understanding non-local games: Consider a bipartite system @xmath , and
operators @xmath and @xmath with @xmath and @xmath . Clearly, @xmath
since @xmath and @xmath act on two different subsystems. Curiously,
however, we can essentially reverse the argument: A set of commutation
relations gives rise to a bipartite structure itself!

{lemma}

Let @xmath be a finite-dimensional Hilbert space, and let @xmath and
@xmath . Then the following two statements are equivalent:

1.  For all @xmath , @xmath , @xmath and @xmath it holds that @xmath .

2.  There exist Hilbert spaces @xmath such that @xmath and for all
    @xmath , @xmath we have @xmath and for all @xmath , @xmath we have
    @xmath .

This statement can easily be extended to more than two players. Here, we
will only address the finite-dimensional case.

First of all, recall that by Lemma 6.3.1 , we can greatly simplify our
problem for non-local games and restrict ourselves to @xmath -algebras
that are simple. As we saw earlier in Lemma B.4.1 , it is well known
that we can decompose any finite dimensional algebra into the sum of
simple algebras. We furthermore need that for any simple algebra, the
following holds: {lemma} [ Tak79 ] Let @xmath be a Hilbert space, and
let @xmath be simple. Then @xmath and @xmath .

We are now ready to prove Lemma B.4.2 . First, we examine the case where
we are given a simple algebra @xmath , for some Hilbert space @xmath .
We will need the following version of Schur’s lemma. {lemma} Let @xmath
be the center of @xmath . Then @xmath . Proof. Let @xmath and let @xmath
. Let @xmath be a basis for @xmath , where @xmath is the matrix of all
0’s and a 1 at position @xmath . Since @xmath and @xmath we have for all
@xmath

  -- -------- --
     @xmath   
  -- -------- --

Note that @xmath (or @xmath ) is the matrix of all 0’s but the @xmath th
column (or row) is determined by the elements of @xmath . Hence all off
diagonal elements of @xmath must be 0. Now consider

  -- -------- --
     @xmath   
  -- -------- --

Note that @xmath (or @xmath ) is the matrix in which the @xmath th and
@xmath th columns (rows) of @xmath have been swapped and the remaining
elements are 0. Hence all diagonal elements of @xmath must be equal.
Thus there exists some @xmath such that @xmath . @xmath

Using this Lemma, we can now show that {lemma} Let @xmath such that for
all @xmath we have

  -- -------- --
     @xmath   
  -- -------- --

Then there exists an @xmath such that @xmath . Proof. Let @xmath and
@xmath . Note that we can write any @xmath as

  -- -------- --
     @xmath   
  -- -------- --

for @xmath matrices @xmath . We have @xmath if and only if for all
@xmath @xmath , i.e. @xmath . Since this must hold for all @xmath , we
have by Lemma B.4.2 that there exists some @xmath such that @xmath .
Hence @xmath with @xmath . @xmath

For the case that the algebra generated by Alice and Bob’s measurement
operators is simple, Lemma B.4.2 now follows immediately:

Proof. [Proof of Lemma B.4.2 if @xmath is simple] Let @xmath be the
algebra generated by Alice’s measurement operators. If @xmath is simple,
it follows from Lemma B.4.2 that @xmath for @xmath . It then follows
from Lemma B.4.2 that for all @xmath and @xmath we must have @xmath .
@xmath

Thus, we obtain a tensor product structure! Recall that Lemma 6.3.1
states that for non-local games this is all we need.

In general, what happens if @xmath is not simple? We now sketch the
argument in the case the @xmath is semisimple, which by Lemma B.4.1 we
may always assume in the finite-dimensional case. Fortunately, we can
still assume that our commutation relations leave us with a bipartite
structure. We can essentially infer this from van Neumann’s famous
Double Commutant Theorem [ Tak79 , BR02 ] , partially stated here.
{theorem} Let @xmath be a finite-dimensional @xmath -algebra. Then there
exists @xmath and a decomposition

  -- -------- --
     @xmath   
  -- -------- --

such that

  -- -------- --
     @xmath   
  -- -------- --

and

  -- -------- -- -------
     @xmath      (B.1)
  -- -------- -- -------

Proof. (Sketch) We already now from Lemma B.4.1 that @xmath can be
decomposed into a sum of simple algebras. Clearly, the RHS of Eq. B.1 is
an element of @xmath . To see that the LHS is contained in the RHS,
consider the projection @xmath onto @xmath . Note that @xmath , and thus
for any @xmath we have @xmath . Hence, we can write @xmath , and thus we
can restrict ourselves to considering each factor individually. The
result then follows immediately from Lemma B.4.2 . @xmath

If we have more than two players, the argument is essentially analogous,
and we merely sketch it in the relevant case when the algebra generated
by the players’s measurements is simple, since Lemma 6.3.1 directly
extends to more than two players as well. Suppose we have @xmath players
@xmath and let @xmath denote their joint Hilbert space. Let @xmath be
the algebra generated by all measurement operators of players @xmath
respectively. Then it follows from Lemma B.4.2 and Lemma B.4.2 that
@xmath where @xmath and for all measurement operators @xmath of player
@xmath we have that @xmath . By applying Lemma B.4.2 recursively we
obtain that there exists a way to partition the Hilbert space into
subsystems @xmath such that the measurement operators of player @xmath
act on @xmath alone.

In quantum mechanics, we will always obtain such a tensor product
structure from commutation relations, even if the Hilbert space is
infinite dimensional [ Sum90 ] . Here, we start out with a type-I
algebra, the corresponding Hilbert space and operators can then be
obtained by the famous GNS construction [ Tak79 ] , an approach which is
rather beautiful in its abstraction. In quantum statistical mechanics
and quantum field theory, we will also encounter factors of type-II and
type-III. As it turns out, the above argument does not generally hold in
this case, however, there are a number of conditions that can lead to a
similar structure. Unfortunately, we cannot consider this case here and
merely refer to the survey article by Summers [ Sum90 ] .

##### b.4.3 Invariant observables and states

As we saw in Chapter 3 , expressing our problem in terms of commutation
relations enables us to exploit their structural consequences.
Particularly interesting is also the fact that we can characterize the
set of states which are invariant by a quantum channel by means of such
relations, repeated here for convenience sake: {lemma} (HKL) [ HKL03 ]
Let @xmath be a unital quantum channel with @xmath , and let @xmath be a
set of quantum states. Then

  -- -------- --
     @xmath   
  -- -------- --

Let’s see what this means for a specific unital channel @xmath and a
particular ensemble given by states @xmath . As in Chapter 3 , we now
consider the @xmath -algebra generated by @xmath . Let @xmath denote the
resulting algebra. By Theorem B.4.2 , we know that we can write

  -- -------- --
     @xmath   
  -- -------- --

and

  -- -------- --
     @xmath   
  -- -------- --

Clearly, we have from the above that if @xmath leaves our ensemble of
states untouched, we must have @xmath for all @xmath . Thus we know that
@xmath must be of the form @xmath on each factor. What does this mean
operationally? Suppose we can write @xmath such that @xmath for each
@xmath , where @xmath is a projector onto @xmath . That is, we can
simultaneously block-diagonalize all @xmath . Then we know that @xmath
must be equal to the identity on each factor @xmath , i.e. @xmath must
be of the form @xmath for some @xmath with @xmath . Another nice
application of this viewpoint is an algebraic no-cloning theorem, as put
forward by Lindblad [ Lin99 ] .

#### b.5 Conclusion

Even though the sheer number of new definitions may appear daunting, we
saw that the language of @xmath -algebras can help us get a grip on some
of the fundamental properties of quantum states quite easily. Of course,
the language of @xmath -algebras is not the most convenient one for all
problems. Yet, there are many cases for which the language of @xmath
-algebras is especially useful. As we saw earlier, one of these cases is
when we consider measurements performed by two parties on a bipartite
system. Another class of problems deals with questions of the following
forms: Which operations leave a given set of states invariant? How much
can we learn from a given state without disturbing it? What part of a
state is “truly” quantum and which parts can we consider to be
classical? How can we encode our states such that they are left
untouched by a set of operations?

For example, another application is the compression of quantum states.
Koashi and Imoto consider how a quantum state can be decomposed into a
quantum, a classical and a redundant part to aid compression. In their
paper, they provide an algorithm which in fact allows us to compute
(with a lot of pain) the decomposition of an algebra and its commutant
algebra [ KI02 ] . It is probably not so surprising by now that other
tasks involving invariance under operations are also closely related:
Choi and Kribs [ CK06 ] have phrased the principle of decoherence-free
subspaces in terms of what they call algebraic noise commutant
formalism. In this text, we have exploited @xmath -algebras to
investigate the use of post-measurement information in Chapter 3 . As we
saw in Chapter 8 , the question of how much post-measurement information
is needed is in fact closely related to how much entanglement we need to
succeed in non-local games. Whereas these two problem may appear
unrelated at first sight, their structural similarities show their close
connection. Likewise, these similarities also enabled us in Chapter 6 to
investigate how much we can really gain by receiving additional
post-measurement information. Finally, the close connection of @xmath
-algebras and Clifford algebras discussed in Appendix C was one of the
factors that led us to discover the uncertainty relations of Chapter 4 .
Hence, @xmath -algebras sometimes help us to understand the similarities
between problems, and aid our intuition.

### Appendix C Clifford Algebra

Similar to @xmath -algebra, Clifford algebra plays little role in
computer science even though it has recently found numerous applications
in the area of computer graphics. Here, we informally summarize the most
important facts we need in this text. Our aim is merely to provide the
reader with some intuition underlying our uncertainty relation in
Chapter 4 , and refer to [ Lou01 ] for an in-depth introduction.

#### c.1 Introduction

Clifford algebra is closely related to @xmath -algebra. Yet, it exhibits
many beautiful geometrical aspects which remain inaccessible to us
otherwise. In particular, we will see that commutation and
anti-commutation carries a geometric meaning within this algebra.

For any integer @xmath , the unital associative algebra generated by
@xmath , subject to the anti-commutation relations

  -- -------- --
     @xmath   
  -- -------- --

is called Clifford algebra . It has a unique representation by Hermitian
matrices on @xmath qubits (up to unitary equivalence) which we fix
henceforth. This representation can be obtained via the famous
Jordan-Wigner transformation [ JW28 ] :

  -- -------- -------- --
     @xmath   @xmath   
     @xmath   @xmath   
  -- -------- -------- --

for @xmath . A Clifford algebra of @xmath generators is isomorphic to a
@xmath -algebra of matrices of size @xmath for @xmath even and to the
direct sum of two @xmath -algebras of matrices of size @xmath for @xmath
odd [ Tsi87 ] .

#### c.2 Geometrical interpretation

The crucial advantage of the Clifford algebra is that we can view the
operators @xmath as @xmath orthogonal vectors forming a basis for a
@xmath -dimensional real vector space @xmath . Each vector @xmath can
then be written as linear combination of basis elements as @xmath . The
Clifford product of two vectors @xmath and @xmath is given by

  -- -------- --
     @xmath   
  -- -------- --

where @xmath is the inner product of two vectors and @xmath is the outer
product, as given below. We will write scalars as scalar multiples of
the identity element whose matrix representation is simply the identity
matrix. If we represent @xmath using the matrices from above, then the
Clifford product is simply the matrix product of the resulting matrices.
Hence, we will now adopt this viewpoint with the representation in mind.
Note that the Clifford product satisfies @xmath , where @xmath is the
@xmath -norm of the vector @xmath which we refer to as the length of a
vector.

##### c.2.1 Inner and outer product

We can see immediately from the definition of the Clifford product that
the inner product of two vectors @xmath as depicted in Figure C.1 is
given by @xmath , and can be expressed as:

  -- -------- --
     @xmath   
  -- -------- --

Hence, anti-commutation takes a geometric meaning within the algebra:
two vectors anti-commute if and only if they are orthogonal!

Similarly, we can write

  -- -------- --
     @xmath   
  -- -------- --

Geometrically, this means that two vectors are parallel if and only if
they commute.

To gain some intuition, let’s look at the simple example of @xmath :
Here, we have @xmath and @xmath . The Clifford product of @xmath and
@xmath is now given as

  -- -------- --
     @xmath   
  -- -------- --

The element @xmath represents the oriented plane segment of the
parallelogram determined by @xmath and @xmath in Figure C.3 below. The
area of this parallelogram is exactly @xmath . Note that we have @xmath
, as shown in Figure C.3 . Thus @xmath not only gives us the area but
also encodes a direction.

In higher dimensions, the elements generated by @xmath etc similarly
correspond to oriented plane or volume segments. Note that we have
@xmath for all basis vectors @xmath and @xmath . We will refer to
products of @xmath elements of the form @xmath as @xmath -vectors .

##### c.2.2 Reflections

The power of the Clifford algebra mainly lies in the fact that we can
express geometrical operations involving any @xmath -vector in an
extremely easy fashion using the Clifford product. Here, we will only be
concerned with performing operations on @xmath -vectors.

Consider the projection of a vector @xmath onto a vector @xmath as
depicted in Figure C.4 . Let @xmath be the part of @xmath that is
parallel to @xmath , and @xmath the part of @xmath that lies
perpendicular to @xmath . Clearly, we may write @xmath . Using the
definition of the Clifford product, we may write

  -- -------- --
     @xmath   
  -- -------- --

where we define @xmath to be the inverse of @xmath . Indeed, we have
@xmath . If @xmath is a unit vector, then in terms of the matrix
representation given above @xmath is the adjoint of the matrix @xmath .
For the product of two vectors we define @xmath . We can also write

  -- -------- --
     @xmath   
  -- -------- --

We can now easily determine the reflection of @xmath around the vector
@xmath , as depicted in Figure C.5 :

  -- -------- --
     @xmath   
  -- -------- --

Consider @xmath . Then the @xmath -dimensional real vector space is
given by basis vectors @xmath and @xmath . Indeed, this is the familiar
@xmath -plane of the Bloch sphere depicted in Figure 2.1 . Consider the
Hadamard transform @xmath . Figure C.7 demonstrates that @xmath plays
exactly this role: it reflects @xmath around the vector @xmath to obtain
@xmath . Given @xmath , we can also easily derive the vector obtained by
reflecting @xmath around the plane perpendicular to @xmath (in 0), as
shown in Figure C.6 .

  -- -------- --
     @xmath   
  -- -------- --

##### c.2.3 Rotations

From reflections we may now obtain rotations as successive reflections.
Suppose we are given vectors @xmath and @xmath as shown in Figure C.8 .
To rotate the vector @xmath by an angle that is twice the angle between
@xmath and @xmath , we now first reflect @xmath around @xmath to obtain
@xmath . We then reflect @xmath around @xmath to obtain

  -- -------- --
     @xmath   
  -- -------- --

where we let @xmath . As desired, @xmath rotates @xmath by an angle of
@xmath .

We can easily convince ourselves that @xmath does not affect any vector
@xmath that is orthogonal to both @xmath and @xmath .

  -- -------- --
     @xmath   
  -- -------- --

where we have used the fact that two vectors anti-commute if and only if
they are orthogonal. Note also that @xmath . It can be shown that if
@xmath is a @xmath -vector, then @xmath is also a @xmath -vector for any
rotation @xmath [ DL03 ] . Indeed, this is easy to see, for the @xmath
-vector formed by orthogonal basis vectors:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

where we have used the fact that rotations preserve the angles between
vectors. We will need this fact in our proof in Chapter 4 .

Clifford algebra offers a very convenient way to express rotations
around arbitrary angles in the plane @xmath [ Lou01 ] . In Chapter 4 ,
however, we will only need to understand how we can find the rotation
@xmath that takes us from a given vector @xmath with length @xmath to
the vector @xmath . Indeed, our strategy works for finding the rotation
of any vector @xmath to a target vector @xmath of the same length.
Consider Figure C.9 .

For convenience, we first normalize @xmath to obtain the vector

  -- -------- --
     @xmath   
  -- -------- --

We then compute the vector @xmath lying exactly half-way between @xmath
and our target vector @xmath and normalize it to obtain

  -- -------- --
     @xmath   
  -- -------- --

We now first reflect @xmath around the plane perpendicular to the vector
@xmath to obtain @xmath , followed by a reflection around the plane
perpendicular to the target vector @xmath :

  -- -------- --
     @xmath   
  -- -------- --

with @xmath , where we have used the fact that both @xmath and @xmath
have unit length and hence @xmath and @xmath . Evidently,

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

and hence

  -- -------- --
     @xmath   
  -- -------- --

We then also have that

  -- -------- --
     @xmath   
  -- -------- --

as desired. We will employ a similar rotation in Chapter 4 .

#### c.3 Application

Here, the primary benefit which we gain by considering a Clifford
algebra, is that we can parametrize matrices in terms of its generators,
and products thereof. Suppose we are given some matrix

  -- -------- --
     @xmath   
  -- -------- --

where @xmath form a basis for the @xmath complex matrices, such that for
all @xmath we have @xmath , @xmath , @xmath , and @xmath . We saw in
Chapter 4 how to construct such a basis for @xmath based on mutually
unbiased bases. In fact, this gives us the well-known Pauli basis, given
by the @xmath elements of the form @xmath with @xmath . When solving
optimization problems within quantum information, we are often faced
with the following problem: When is @xmath a quantum state? That is,
what are the necessary and sufficient conditions for the coefficients
@xmath such that @xmath ?

For @xmath , this is an easy problem: We can write @xmath where @xmath
is the Bloch vector we encountered in Chapter 2 . We have that @xmath if
and only if @xmath , i.e.

  -- -------- --
     @xmath   
  -- -------- --

Thus, we have @xmath if and only if @xmath . Geometrically, this means
that any point on or inside the Bloch sphere corresponds to a valid
quantum state as illustrated in Figure 2.1 . Sadly, when we consider
@xmath , our task becomes considerably more difficult. Clearly, since
@xmath for any quantum state, we can always say that

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

giving us @xmath . Unfortunately, this condition is too weak for almost
all practical applications. There exist many matrices which obey this
condition, but nevertheless do not correspond to valid quantum states.
Luckily, we can say something much stronger using the Clifford algebra.

Let’s consider the operators @xmath themselves. Evidently, each operator
@xmath has exactly two eigenvalues @xmath : Let @xmath be an eigenvector
of @xmath with eigenvalue @xmath . From @xmath we have that @xmath .
Furthermore, we have @xmath . Thus, if @xmath is an eigenvalue of @xmath
then so is @xmath . We can therefore express each @xmath as

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and @xmath are projectors onto the positive and negative
eigenspace of @xmath respectively. Furthermore, note that we have for
all @xmath with @xmath

  -- -------- --
     @xmath   
  -- -------- --

that is all such operators are orthogonal with respect to the
Hilbert-Schmidt inner product. We now use the fact that the collection
of operators

  -- -------- --
     @xmath   
  -- -------- --

forms an orthogonal basis for the @xmath matrices with @xmath [ Die06 ]
. By counting, the above operators form a complete operator basis with
respect to the Hilbert-Schmidt inner product. In fact, by working out
the individual basis elements with respect to the representation above,
we see that this basis is in fact equal to the Pauli basis. Notice that
the products with an odd number of factors are Hermitian, while the ones
with an even number of factors are skew-Hermitian, so in the definition
of the above operators we introduce a factor of @xmath to all with an
even number of indices to make the whole set a basis for the Hermitian
operators. Hence we can write every state @xmath as

  -- -------- --
     @xmath   
  -- -------- --

with real coefficients @xmath .

It is clear from the above that if we transform the generating set of
@xmath linearly,

  -- -------- --
     @xmath   
  -- -------- --

then the set @xmath satisfies the anti-commutation relations if and only
if @xmath is an orthogonal matrix: these are exactly the operations
which preserve the inner product. In that case there exists a matching
unitary @xmath which transforms the operator basis as

  -- -------- --
     @xmath   
  -- -------- --

As an importance consequence, it can be shown [ Die06 ] that any
operation @xmath transforms the state @xmath as

  -- -------- --
     @xmath   
  -- -------- --

where we write @xmath to indicate the transformation of the vector
@xmath by @xmath . For example, for the rotation @xmath constructed
earlier, we may immediately write

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

Thus, we can think of the 1-vector components of @xmath as vectors in a
generalized Bloch sphere. In Chapter 4 , we will extend this approach to
include the @xmath as an additional “vector”. There, we use these facts
to prove a useful statement which leads to our uncertainty relations:
{lemma} [Lemma 4.3.2 ] For any state @xmath , we have @xmath .

With respect to our discussion above, this is indeed a generalization of
what we observed for the Bloch sphere in @xmath . Note that we obtain a
whole range of such statements as we can find different sets of @xmath
anti-commuting matrices within the entire set of @xmath basis elements
above.

#### c.4 Conclusion

Luckily, we made some progress to give a characterization of quantum
states in terms of their basis coefficients that was sufficient to prove
our uncertainty relation from Chapter 4 . Parametrizing states using
Clifford algebra elements provides us with additional structure to
characterize quantum states that is not at all obvious when looking at
them from a linear algebra point of view alone. We hope that
parametrizing states in this fashion could enable us to make even
stronger statements in the future. It is also interesting to think about
standard quantum gates as geometrical operations within the Clifford
algebra. Indeed, this is possible to a large extent, but lies outside
the scope of this text.

Clearly, the subspace spanned by the elements @xmath plays a special
role. Note that when considering the state minimizing our uncertainty
relation, only its 1-vector coefficients played any role. The other
coefficients do not contribute at all to the minimization problem. It is
interesting to observe that we have in fact already seen a similar
effect in Chapter 6 . Recall that we used Tsirelson’s construction to
turn vectors @xmath back into observables by letting @xmath and @xmath .
The optimal strategy of Alice and Bob could then be implemented using
the maximally entangled state of local dimension @xmath

  -- -------- --
     @xmath   
  -- -------- --

where @xmath and we used the @xmath simply as a remainder term. Clearly,
the coefficients @xmath do not contribute to the term @xmath at all, and
only the coefficients @xmath matter. However, in dimension @xmath we
have only @xmath such terms. Curiously, the remaining terms are only
needed to ensure that @xmath . Numerical feasibility analysis using
semidefinite programming for @xmath and @xmath reveals that we do indeed
need to take the maximally entangled state, and cannot omit any of the
remaining terms.