##### Contents

-    List of Acronyms
-    List of Symbols
-    1 Introduction
    -    1.1 Link Scheduling in Wireless Networks
    -    1.2 Motivation for the Thesis
    -    1.3 Overview and Contributions of the Thesis
-    2 A Framework for Link Scheduling Algorithms for STDMA Wireless
    Networks
    -    2.1 System Model
    -    2.2 Link Scheduling based on Protocol Interference Model
        -    2.2.1 Equivalence of Link Scheduling and Graph Edge
            Coloring
        -    2.2.2 Review of Algorithms
    -    2.3 Limitations of Algorithms based on Protocol Interference
        Model
    -    2.4 Link Scheduling based on Communication Graph Model and SINR
        Conditions
    -    2.5 Link Scheduling based on SINR Graph Model
    -    2.6 Spatial Reuse as Performance Metric
-    3 Point to Point Link Scheduling based on Communication Graph Model
    -    3.1 ArboricalLinkSchedule Algorithm Revisited
        -    3.1.1 Performance Results
        -    3.1.2 Analytical Results
        -    3.1.3 Discussion
    -    3.2 A High Spatial Reuse Link Scheduling Algorithm
        -    3.2.1 Problem Formulation
        -    3.2.2 Motivation
        -    3.2.3 ConflictFreeLinkSchedule Algorithm
        -    3.2.4 Performance Results
        -    3.2.5 Analytical Results
        -    3.2.6 Discussion
-    4 Point to Point Link Scheduling based on SINR Graph Model
    -    4.1 Motivation
    -    4.2 SINRGraphLinkSchedule Algorithm
        -    4.2.1 Description
        -    4.2.2 Example
    -    4.3 Analytical Results
    -    4.4 Performance Results
    -    4.5 Discussion
-    5 Point to Multipoint Link Scheduling: A Hybrid Approach
    -    5.1 System Model
    -    5.2 Equivalence of Link Scheduling and Graph Vertex Coloring
    -    5.3 Limitations of Algorithms based on Protocol Interference
        Model
    -    5.4 Problem Formulation
    -    5.5 MaxAverageSINRSchedule Algorithm
    -    5.6 Performance Results
    -    5.7 Analytical Result
    -    5.8 Discussion
-    6 A Review of Random Access Algorithms for Wireless Networks
    -    6.1 Traditional Random Access Algorithms
    -    6.2 Signal Processing in Random Access
    -    6.3 Channel-Aware ALOHA Algorithms
    -    6.4 Splitting Algorithms
    -    6.5 Towards Power Controlled Random Access
-    7 Power Controlled FCFS Splitting Algorithm for Wireless Networks
    -    7.1 System Model
    -    7.2 Motivation and Problem Formulation
    -    7.3 PCFCFS Interval Splitting Algorithm
        -    7.3.1 Description
        -    7.3.2 Examples
    -    7.4 Throughput Analysis
    -    7.5 Numerical Results
    -    7.6 Conclusions
-    8 Flow Control: An Information Theory Viewpoint
    -    8.1 System Model
    -    8.2 Generalized Token Bucket Regulator
    -    8.3 Notion of Information Utility
    -    8.4 Problem Formulation
    -    8.5 Results
        -    8.5.1 Analytical Result
        -    8.5.2 Numerical Results
    -    8.6 Information-Theoretic Interpretation
    -    8.7 Discussion
-    9 Conclusions
-    A Proofs of Limiting Transition Probabilities
    -    A.1 Proof of ( 7.54 )
    -    A.2 Proof of ( 7.55 )
    -    A.3 Proof of ( 7.56 )
    -    A.4 Proof of ( 7.57 )

## List of Acronyms

## List of Symbols

###### List of Tables

-    List of Acronyms
-    List of Symbols
-    2.1 System parameters for STDMA networks shown in Figures 2.1(a) ,
    2.5 and 2.10 .
-    4.1 System parameters for the STDMA network shown in Figure 4.1 .
-    4.2 Interference and co-schedulability weight functions for edges
    of SINR graph shown in Figure 4.3 .
-    4.3 Normalized noise powers at vertices of SINR graph shown in
    Figure 4.3 .
-    4.4 Output of SGLS algorithm for STDMA network described by Figure
    4.1 and Table 4.1 .
-    5.1 System parameters for STDMA networks shown in Figures 5.1(a)
    and 5.4 .
-    6.1 Transmitting and waiting sets for basic tree algorithm shown in
    Figure 6.1 .
-    6.2 Transmitting and waiting sets for modified tree algorithm shown
    in Figure 6.3 .
-    7.1 System parameters for performance evaluation of PCFCFS and FCFS
    algorithms.
-    8.1 Entropy-maximizing GTBR for given data transmission time, token
    rate and bucket depth of a comparable STBR.
-    9.1 Link scheduling algorithms investigated in Chapters 3 , 4 and 5
    .

###### List of Figures

-    1.1 Wireless mesh network, adapted from [ 1 ] .
-    1.2 Potential applications of link scheduling and flow control in
    wireless networks.
-    2.1 Example of STDMA network and point to point link schedule.
-    2.2 Communication graph model of STDMA network described by Figure
    2.1(a) and Table 2.1 .
-    2.3 Two-tier graph model of STDMA network described by Figure
    2.1(a) and Table 2.1 .
-    2.4 Edge coloring of communication graph shown in Figure 2.2
    corresponding to the link schedule shown in Figure 2.1(b) .
-    2.5 An STDMA wireless network with six nodes.
-    2.6 Two-tier graph model of the STDMA wireless network described by
    Figure 2.5 and Table 2.1 .
-    2.7 Subgraph of two-tier graph shown in Figure 2.6 .
-    2.8 Coloring of subgraph shown in Figure 2.7 .
-    2.9 Point to point link scheduling algorithms based on protocol
    interference model can lead to high interference.
-    2.10 An STDMA wireless network with four nodes.
-    2.11 Two-tier graph model of STDMA wireless network described by
    Figure 2.10 and Table 2.1 .
-    2.12 Subgraph of two-tier graph shown in Figure 2.11 .
-    2.13 Coloring of subgraph shown in Figure 2.12 .
-    2.14 Point to point link scheduling algorithms based on protocol
    interference model can lead to higher number of colors.
-    2.15 Alternative coloring of subgraph shown in Figure 2.12 .
-    2.16 A point to point link schedule corresponding to Figure 2.15
    that yields lower number of colors.
-    3.1 Schedule length vs. number of nodes.
-    3.2 Potential conflicting edges when coloring edge @xmath .
-    3.3 Spatial reuse vs. number of nodes for Experiment 1.
-    3.4 Spatial reuse vs. number of nodes for Experiment 2.
-    3.5 Spatial reuse vs. number of nodes for Experiment 1 under
    multipath fading and shadowing channel conditions.
-    3.6 Spatial reuse vs. number of nodes for Experiment 2 under
    multipath fading and shadowing channel conditions.
-    3.7 Comparison of thickness and number of edges with number of
    vertices.
-    4.1 An STDMA wireless network with four nodes.
-    4.2 Communication graph model of STDMA network described by Figure
    4.1 and Table 4.1 .
-    4.3 SINR graph model of communication graph shown in Figure 4.2 .
-    4.4 Truncated SINR graph derived from SINR graph shown in Figure
    4.3 and weight values given in Tables 4.2 and 4.3 .
-    4.5 Coloring of vertices of truncated SINR graph after first
    iteration of SGLS algorithm.
-    4.6 Coloring of vertices of truncated SINR graph after second
    iteration of SGLS algorithm.
-    4.7 Coloring of vertices of truncated SINR graph after third
    iteration of SGLS algorithm.
-    4.8 Coloring of vertices of truncated SINR graph after complete
    execution of SGLS algorithm.
-    4.9 Output of SGLS algorithm for STDMA network described by Figure
    4.1 and Table 4.1 .
-    4.10 Spatial reuse vs. number of nodes for Experiment 1.
-    4.11 Spatial reuse vs. number of nodes for Experiment 2.
-    5.1 Example of STDMA network and point to multipoint link schedule.
-    5.2 Communication graph model of STDMA network described by Figure
    5.1(a) and Table 5.1 .
-    5.3 Vertex coloring of communication graph shown in Figure 5.2
    corresponding to the link schedule shown in Figure 5.1(b) .
-    5.4 An STDMA wireless network with six nodes.
-    5.5 Communication graph model of STDMA network described by Figure
    5.4 and Table 5.1 .
-    5.6 Coloring of vertices @xmath and @xmath of graph shown in Figure
    5.4 .
-    5.7 Point to multipoint link scheduling algorithms based on
    protocol interference model can lead to high interference.
-    5.8 Average spatial reuse vs. number of nodes for Experiment 1.
-    5.9 Average spatial reuse vs. number of nodes for Experiment 2.
-    6.1 Basic Tree Algorithm for three nodes @xmath , @xmath and @xmath
    .
-    6.2 Stack representation of transmitting and waiting nodes for
    basic tree algorithm shown in Figure 6.1 .
-    6.3 Modified Tree Algorithm for three nodes @xmath , @xmath and
    @xmath .
-    6.4 Stack representation of transmitting and waiting nodes for
    modified tree algorithm shown in Figure 6.3 .
-    7.1 PCFCFS splitting algorithm illustrating a collision followed by
    an idle.
-    7.2 FCFS splitting algorithm illustrating a collision followed by
    an idle.
-    7.3 PCFCFS splitting algorithm illustrating a collision followed by
    another collision.
-    7.4 FCFS splitting algorithm illustrating a collision followed by
    another collision.
-    7.5 Discrete Time Markov Chain representing a CRP of PCFCFS
    splitting algorithm.
-    7.6 Notation for number of packets in left and right subintervals
    of the original allocation interval.
-    7.7 Plot of @xmath versus @xmath .
-    7.8 Throughput versus arrival rate for PCFCFS and FCFS algorithms.
-    7.9 Average delay versus arrival rate for PCFCFS and FCFS
    algorithms.
-    7.10 Average power versus arrival rate for PCFCFS and FCFS
    algorithms.
-    8.1 Flow control of a source’s packets over a packet network.
-    8.2 Token bucket regulation of a source’s packets over a packet
    network.
-    8.3 Relative time instants of parameters defined in ( 8.4 ).
-    8.4 Information utility of GTBR vs. bucket depth of comparable
    STBR.
-    8.5 Information utility of GTBR vs. token increment rate of
    comparable STBR.

## Chapter 1 Introduction

### 1.1 Link Scheduling in Wireless Networks

Wireless and mobile communications have revolutionized the way we
communicate over the past decade. This impact has been felt both in
voice communications and wireless Internet access. The ever-increasing
need for applications like video and images have driven the need for
technologies like @xmath Generation Partnership Project Long Term
Evolution (3GPP LTE), @xmath Generation Partnership Project 2 (3GPP2),
IEEE 802.16 Worldwide Interoperability for Microwave Access (WiMAX)
networks and IEEE 802.11 Wireless Local Area Networks (WLANs) which
promise broadband data rates to wireless users. This revolution in
wireless communications has had a great impact in India, where the
number of cellular subscribers is 250 million (as of November 2008) and
is growing at a rate of approximately @xmath per month [ 2 ] .

Wireless networks can be broadly classified into cellular networks and
ad hoc networks. A wireless ad hoc network is a collection of wireless
nodes that can dynamically self-organize into an arbitrary topology to
form a network without necessarily using any pre-existing
infrastructure. Based on their application, ad hoc networks can be
further classified into Mobile Ad Hoc Networks (MANETs), wireless mesh
networks and wireless sensor networks. A wireless mesh network can be
considered to be an infrastructure-based ad hoc network with a mesh
backbone carrying most of the traffic.

Wireless Mesh Networks (WMNs) have been recently advocated to provide
connectivity and coverage, especially in sparsely populated and rural
areas. For example, several Wireless Community Networks (WCNs) are
operational in Europe, Australia and USA [ 3 ] . Peer to peer wireless
technology is also being developed by companies such as [ 4 ] . WMNs are
dynamically self-organized and self-configured, with nodes in the
network automatically establishing an ad hoc network and maintaining
mesh connectivity [ 1 ] . An example of a WMN is shown in Figure 1.1 .
Typically, a WMN comprises of two types of nodes: mesh routers and mesh
clients. A mesh router consists of gateway/bridge functions and the
capability to support mesh networking. Mesh routers have little or no
mobility and form a wireless backbone for mesh clients. The
gateway/bridge functionalities in mesh routers aid in the integration of
WMNs with heterogeneous networks such as Ethernet [ 5 ] , cellular
networks, WLANs [ 6 ] , WiMAX networks [ 7 ] and sensor networks. WMNs
are witnessing commercialization in various applications like broadband
home networks, enterprise networks, community networks and metropolitan
area networks. Moreover, WMNs diversify the functionalities of ad hoc
networks, instead of just being another type of ad hoc network. These
additional functionalities necessitate novel design principles and
efficient algorithms for the realization of WMNs.

Significant research efforts are required to realize the full potential
of WMNs. Among the many challenging issues in the design of WMNs, the
design of the physical as well as the Medium Access Control (MAC) layers
is important, especially from a perspective of achieving high network
throughput. At the physical layer, techniques like adaptive modulation
and coding, Orthogonal Frequency Division Multiplexing (OFDM) [ 8 ] , [
9 ] and Multiple Input Multiple Output (MIMO) techniques [ 10 ] can be
used to increase the capacity of a wireless channel and achieve high
data transmission rates. At the MAC layer, various solutions like
directional antenna based MAC [ 11 ] , MAC with power control [ 12 ] and
multi-channel MAC [ 13 ] have been proposed in the literature.

In this thesis, we primarily focus on the design of the MAC layer for
wireless mesh networks. We abstract out essential features of the MAC
and physical layers of a WMN and propose techniques that deliver high
network throughput. We take into account wireless channel effects such
as propagation path loss, fading and shadowing [ 14 ] . Towards the end
of the thesis, we provide an information-theoretic perspective on flow
control. The main body of this thesis, however, focuses on MAC layer
design for two types of networks: Spatial Time Division Multiple Access
(STDMA) networks and random access networks. We next describe these two
types of networks along with their potential applications in WMNs.

An STDMA network can be thought of as a mesh network in which multiple
transmitter receiver pairs can communicate at the same time. More
specifically, consider a WMN comprising of store-and-forward nodes
connected by “point to point” wireless communication channels (links). A
link is an ordered pair @xmath , where @xmath is a transmitter and
@xmath is a receiver. Time is divided into fixed-length intervals called
slots. In STDMA, we allow concurrent communications between collections
of nodes that are “reasonably far” from each other, i.e., we exploit
spatial reuse. An STDMA link schedule describes the transmission rights
for each time slot in such a way that communicating entities assigned to
the same slot do not “collide”. In this thesis, we design centralized
STDMA link scheduling algorithms that take into account physical layer
characteristics such as Signal to Interference and Noise Ratio (SINR) at
a receiver.

STDMA link scheduling algorithms can be implemented at the MAC layer of
wireless mesh networks, as shown in Figure 1.2 . A mesh network can be
constructed with mesh routers and mesh clients functioning as relay
nodes in addition to their sender and receiver roles. The link schedule
can be computed by a designated mesh router and then disseminated to all
other nodes. The mesh routers form the mesh backbone to provide
connectivity to (possibly mobile) mesh clients.

In a related problem involving link scheduling, we consider a multipoint
to point wireless network with random access. When random access
algorithms are directly translated from a wired network to a wireless
network, they yield equal or lower throughput. This is because they do
not consider the time variation of the wireless channel and interference
conditions at the receiver. In this thesis, we design a distributed
random access algorithm that takes into account wireless channel
attributes such as propagation path loss and physical layer
characteristics such as SINR at the receiver.

Random access algorithms can be applied to the MAC layer of wireless
networks, as shown in Figure 1.2 . The BS and SSs are organized into a
cell-like structure. Both uplink (from SS to BS) and downlink (from BS
to SS) channels are shared among the SSs. This mode requires all SSs to
be within the communication range and line of sight of the BS. A random
access algorithm can be implemented in the SSs to resolve contentions on
the uplink channel.

In a complementary problem, we consider a packet level flow from a
source to a destination over a data network. The packets transmitted by
the source are regulated at the ingress of the network, as shown in
Figure 1.2 . In this thesis, we investigate the maximum amount of
information that can be transmitted from the source to the destination
by utilizing the idea of covert information channels.

To summarize, this thesis deals with the design of MAC layer algorithms
(equivalently, link scheduling algorithms) for mesh networks. The
proposed link scheduling algorithms take into account physical layer
characteristics such as SINR at a receiver. Finally, we also consider
the problem of flow control.

Various solutions to the link scheduling problem have been proposed in
literature depending on the modeling of the wireless network and
interference conditions. In the next section, we motivate our work by
briefly outlining the essential differences between our approach and the
methodology of existing approaches.

### 1.2 Motivation for the Thesis

Consider the problem of determining a link schedule for an STDMA
wireless network. STDMA link schedules can be classified into point to
point and point to multipoint link schedules. In a point to point link
schedule, the transmission right in each slot is assigned to certain
links, while in a point to multipoint link schedule, the transmission
right in each slot is assigned to certain nodes. An STDMA scheduling
algorithm is a set of rules that is used to determine a link schedule so
as to satisfy certain objectives. An STDMA link schedule should be so
designed that, in every time slot, all packets transmitted by the
scheduled transmitters are received successfully at the corresponding
(intended) receivers.

Two models have been proposed in literature for specifying the criteria
for successful packet reception. According to the protocol interference
model [ 15 ] , a packet is received successfully at a receiver only if
its intended transmitter is within the communication range and other
unintended transmitters are outside the interference range of the
receiver. In essence, the protocol interference model mandates a
“silence zone” around every scheduled receiver in a time slot. On the
other hand, according to the physical interference model [ 15 ] , a
packet is received successfully at a receiver only if the SINR at the
receiver is no less than a certain threshold, called communication
threshold.

Throughout this thesis, we assume that a packet is received successfully
if the SINR at the receiver is greater than or equal to the
communication threshold, i.e., we employ the physical interference
model. Moreover, we assume that, as long as the SINR threshold condition
is satisfied at the receiver of a link, a constant rate of data transfer
occurs along that link. In other words, the existence of a channel
coding technique that guarantees a fixed data rate is assumed, when the
SINR threshold condition is satisfied.

To maximize the aggregate traffic transported by an STDMA wireless
network, most link scheduling algorithms employ the protocol
interference model and seek to minimize the schedule length. These
algorithms model the network by a communication graph and employ novel
techniques to color all the edges of the graph using minimum number of
colors [ 16 ] . Such approaches have three lacunae. First, they
transform the link scheduling problem to an edge coloring problem in a
graph, which is a simplification of the true system model. Second, they
do not incorporate wireless channel effects like propagation path loss,
fading and shadowing. Finally, they do not consider SINR threshold
conditions at a receiver.

In this thesis, we seek to address these issues by designing polynomial
time link scheduling algorithms that employ the physical interference
model, provide a reasonably accurate representation of the wireless
network and aim to maximize the number of successful packet
transmissions per time slot. These algorithms take into account wireless
channel effects like propagation path loss, fading and shadowing, as
well as SINR conditions at a receiver. We design and evaluate algorithms
for both point to point and point to multipoint link scheduling. Our
work falls under the realm of joint PHY-MAC design of wireless networks.

In a related scenario involving link scheduling, consider the problem of
designing a random access algorithm for a multipoint to point wireless
network. When traditional random access algorithms like ALOHA [ 17 ] and
tree-like algorithms [ 18 ] are employed in a wireless network, they
yield equal or lower throughput compared to the wired case. This is
because such algorithms are incognizant of wireless channel effects and
physical layer characteristics. Thus, it is important to design a random
access algorithm that incorporates wireless channel effects and exploits
flexibilities provided by the physical layer. Towards this step, we
assume a receiver that is capable of power-based capture [ 19 ] . Also,
we assume that users can vary their transmission powers to increase the
chances of successful packet reception under the physical interference
model. Consequently, we design and analyze a variable-power tree-like
algorithm for a random access wireless network.

In the final scenario, we formulate the problem of analyzing flow
control in packet networks from an information-theoretic perspective. We
focus on the problem of analyzing regulated flows in a point to point
network. It is well-known that information (in the Shannon sense) can be
transmitted from a source to a destination only by encoding it in the
contents, lengths and timings of data packets from the source to the
destination [ 20 ] , [ 21 ] . We investigate the maximum amount of
information that can be transmitted by a source whose flow is linearly
bounded. Specifically, we assume that covert information is conveyed by
randomness in packet lengths and investigate properties of the
regulating mechanism that leads to maximum information transfer.

### 1.3 Overview and Contributions of the Thesis

In the first part of the thesis (Chapters 2 to 5 ), we consider various
problems on centralized link scheduling in STDMA wireless networks; each
problem represents a different nuance of the overall link scheduling
problem. In the second part of the thesis (Chapters 6 and 7 ), we
consider a related link scheduling problem, namely, distributed medium
access control in a random access wireless network. In the third and
final part of the thesis (Chapter 8 ), we consider flow control in
networks from an information-theoretic perspective.

Chapter 2 presents a generic framework and system model for link
scheduling in STDMA wireless networks. We describe the system parameters
of an STDMA wireless network and explain two prevalent models used to
specify the criteria for successful packet reception, namely protocol
interference model and physical interference model [ 15 ] . We argue
that STDMA link scheduling algorithms can be classified into three
classes: algorithms based on modeling the network by a two-tier or
communication graph, “hybrid” algorithms based on modeling the network
by a communication graph and verifying SINR conditions and algorithms
based on modeling the network by an SINR graph. We review representative
research papers from each of these classes. We explain the relative
merits and demerits of each class of algorithms in terms of
computational complexity, performance and accuracy of the network model.
We discuss limitations of link scheduling algorithms based only on the
communication graph model by providing illustrative examples. Finally,
to compare the performance of various link scheduling algorithms, we
motivate and introduce spatial reuse as a performance metric. Various
“spinoffs” of the “parent” link scheduling problem constitute the
subproblems considered in Chapters 3 , 4 and 5 .

In Chapter 3 , we consider STDMA point to point link scheduling
algorithms which utilize a communication graph representation of the
network. Initially, we examine the ArboricalLinkSchedule (ALS) algorithm
[ 16 ] , which represents the network by a communication graph,
partitions the graph into minimum number of planar subgraphs and colors
each subgraph in a greedy manner. We suggest a modification to the ALS
algorithm based on reusing colors from previously colored subgraphs to
color the current subgraph. We compare the performance of the modified
algorithm with the ALS algorithm and derive its running time complexity.
Subsequently, we propose the ConflictFreeLinkSchedule algorithm, which
is a hybrid algorithm based on the communication graph and verifying
SINR conditions. Under various wireless channel conditions, we
demonstrate that ConflictFreeLinkSchedule achieves higher spatial reuse
than existing link scheduling algorithms based on the communication
graph. However, this improvement in performance is achieved at a cost of
slightly higher computational complexity.

In Chapter 4 , we consider the point to point link scheduling problem
under the physical interference model. The STDMA network is represented
by an SINR graph, in which weights of edges correspond to interferences
between pairs of nodes and weights of vertices correspond to normalized
noise powers at receiving nodes. We propose a link scheduling algorithm
based on the SINR graph representation of the network. We prove the
correctness of the algorithm and show that it has polynomial running
time complexity. Finally, we demonstrate that the proposed algorithm
achieves higher spatial reuse than ConflictFreeLinkSchedule.

In Chapter 5 , we consider point to multipoint link scheduling
(broadcast scheduling) under the physical interference model. The
problem addressed herein can be considered as the “dual” of the problem
considered in Chapters 3 and 4 . We generalize the definition of spatial
reuse to the point to multipoint link scheduling problem. We propose a
greedy scheduling algorithm which has demonstrably higher spatial reuse
than existing algorithms, without any increase in computational
complexity.

In Chapter 6 , we consider another flavor of the link scheduling
problem, namely random access algorithms for wireless networks. While
random access algorithms for satellite networks, packet radio networks,
multidrop telephone lines and multitap bus (“traditional random access
algorithms”) is a well-researched and mature subject, the study of
random access algorithms for wireless networks that take into account
physical layer characteristics such as SINR and channel variations has
yet to gain momentum. This chapter reviews representative research work
which investigate such random access algorithms, most of them being
generalizations of the ALOHA protocol (by adapting the retransmission
probability) or the tree algorithm (by adapting the set of contending
users). We motivate the use of variable transmission power to increase
the throughput in random access wireless networks.

We consider random access for wireless networks under the physical
interference model in Chapter 7 . We design an algorithm that adapts the
set of contending users and their corresponding transmission powers
based on quaternary (2 bit) channel feedback. We model the algorithm
dynamics by a Discrete Time Markov Chain and subsequently derive its
maximum stable throughput. Finally, we demonstrate that the proposed
algorithm achieves higher throughput and substantially lower delay than
the well-known First Come First Serve splitting algorithm [ 22 ] .

In Chapter 8 , we formulate the problem of analyzing flow control in
packet networks from a perspective of maximizing mutual information
between a source and a destination. We focus on the simpler, yet
insightful, problem of analyzing regulated flows in a point to point
network. More specifically, we consider a source whose flow is bounded
by a “generalized” Token Bucket Regulator (TBR) and analyze the maximum
amount of information (in the Shannon sense) that the source can convey
to its destination by encoding information in the randomness of packet
lengths. This chapter reveals two interesting results. First, under
certain “bandwidth” constraints on cumulative tokens and cumulative
bucket depth, we demonstrate that a generalized TBR can achieve higher
flow entropy than that of a standard TBR. Second, we provide
information-theoretic arguments for the observations that the optimal
generalized TBR has a decreasing token increment sequence and a
near-uniform bucket depth sequence.

In Chapter 9 , we summarize the thesis and provide possible directions
for future work. Specifically, we suggest generalizations of the
two-level power control algorithm proposed in Chapter 7 . We also
provide pointers for deriving the approximation factors of the
algorithms proposed in Chapters 3 and 4 .

## Chapter 2 A Framework for Link Scheduling Algorithms for STDMA
Wireless Networks

An STDMA wireless network consists of a finite set of nodes wherein
multiple pairs of nodes can communicate concurrently, as discussed in
Chapter 1 . In this chapter, we outline a framework for modeling STDMA
link scheduling algorithms. We consider a general representation of an
STDMA wireless network, i.e., this model is not specific to any
technology or protocol. This abstraction lends simplicity to the network
model and helps us focus on the design of scheduling algorithms for the
network. Since the problem of determining an optimal link schedule is
NP-hard [ 16 ] , researchers have proposed various heuristics to obtain
close-to-optimal solutions. In our view, such heuristics can be broadly
classified into three categories: algorithms based on modeling the
network by a two-tier or communication graph, “hybrid” algorithms based
on modeling the network by a communication graph and verifying SINR
conditions and algorithms based on modeling the network by an SINR
graph. We review representative research papers from each of these
classes. The relative merits and demerits of each class of algorithms
are also elucidated in the chapter. Our observations motivate us to
propose a performance metric that is proportional to aggregate network
throughput.

The rest of this chapter is structured as follows. In Section 2.1 , we
describe the system model of an STDMA wireless network and explain the
protocol and physical interference models. In Section 2.2 , we elucidate
the equivalence between a point to point link schedule for an STDMA
network and the colors of edges of the communication graph model of the
network. This is followed by a review of research work on point to point
link scheduling algorithms based on the protocol interference model. In
Section 2.3 , we describe the limitations of algorithms based on the
protocol interference model from a perspective of maximizing network
throughput in wireless networks. We review research work on link
scheduling algorithms based on the physical interference model in
Sections 2.4 and 2.5 . Specifically, Section 2.4 reviews algorithms
based on communication graph model of the network and SINR conditions,
while Section 2.5 reviews algorithms based on an SINR graph model of the
network. Finally, in Section 2.6 , we propose spatial reuse as a
performance metric and argue that it corresponds to network throughput
from a physical layer viewpoint.

### 2.1 System Model

We consider a general model of an STDMA wireless network with @xmath
static store-and-forward nodes in a two-dimensional plane, where @xmath
is a positive integer. Nodes are indexed as @xmath . In a wireless
network, a link is an ordered pair of nodes @xmath , where @xmath is a
transmitter and @xmath is a receiver. We assume equal length packets.
Time is divided into slots of equal duration. During a time slot, a node
can either transmit, receive or remain idle. The slot duration equals
the amount of time it takes to transmit one packet over the wireless
channel. We make the following additional assumptions:

-   Synchronized nodes: All nodes are synchronized to slot boundaries.

-   Homogeneous nodes: Every node has identical receiver sensitivity,
    transmission power and thermal noise characteristics.

-   Backlogged nodes: We assume a node to be continuously backlogged,
    i.e., a node always has a packet to transmit and cannot transmit
    more than one packet in a time slot.

Let:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

The received signal power at a distance @xmath from the transmitter is
given by @xmath , where @xmath is the path loss exponent ¹ ¹ 1 We do not
consider fading and shadowing effects. . An STDMA link schedule is a
mapping from the set of links to time slots. We only consider static
link schedules, i.e., link schedules that repeat periodically throughout
the operation of the network. Let @xmath denote the number of time slots
in a link schedule, i.e., the schedule length. For a given time slot
@xmath , @xmath communicating transmitter-receiver pair is denoted by
@xmath , where @xmath denotes the index of the node which transmits a
packet and @xmath denotes the index of the node which receives the
packet. Let @xmath denote the number of concurrent transmitter-receiver
pairs in time slot @xmath . A point to point link schedule for the STDMA
network is denoted by @xmath , where

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath            
                       @xmath   
  -- -------- -------- -------- --

Note that a link schedule repeats periodically throughout the operation
of the network. More specifically, transmitter-receiver pairs that
communicate concurrently in time slot @xmath also communicate
concurrently in time slots @xmath , @xmath and so on. Thus, @xmath .
Finally, note that all transmitters and receivers are stationary.

Every point to point link schedule must satisfy the following:

-   Operational constraint: During a time slot, a node can transmit to
    exactly one node, receive from exactly one node or remain idle,
    i.e.,

      -- -------- -- -------
         @xmath      (2.1)
      -- -------- -- -------

As an illustration, consider the STDMA wireless network shown in Figure
2.1(a) . It consists of six nodes whose coordinates (in meters) are
@xmath , @xmath , @xmath , @xmath , @xmath and @xmath . An example point
to point link schedule for this STDMA network is shown in Figure 2.1(b)
. Note that this schedule is only one of the several possible schedules
and is given here only for illustrative purposes. The schedule length is
@xmath time slots and the schedule is defined by @xmath , where

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

After 8 time slots, the schedule repeats periodically, as shown in
Figure 2.1(b) .

A scheduling algorithm is a set of rules that is used to determine a
link schedule @xmath . Usually, a scheduling algorithm needs to satisfy
certain objectives.

Consider @xmath receiver in time slot @xmath , i.e., receiver @xmath .
The power received at @xmath from its intended transmitter @xmath
(signal power) is @xmath . Similarly, the power received at @xmath from
its unintended transmitters (interference power) is @xmath . Thus, the
Signal to Interference and Noise Ratio (SINR) at receiver @xmath is
given by

  -- -------- -------- -- -- -------
     @xmath   @xmath         (2.2)
  -- -------- -------- -- -- -------

Without considering the interference power, the Signal to Noise Ratio
(SNR) at receiver @xmath is given by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (2.3)
  -- -------- -------- -------- -- -------

According to the protocol interference model [ 15 ] , transmission
@xmath is successful if:

1.  the SNR at receiver @xmath is no less than a certain threshold
    @xmath , termed as the communication threshold . From ( 2.3 ), this
    translates to

      -- -------- -------- -------- -- -------
         @xmath   @xmath   @xmath      (2.4)
      -- -------- -------- -------- -- -------

    where @xmath is termed as communication range, and

2.  the signal from any unintended transmitter @xmath is received at
    @xmath with an SNR less than a certain threshold @xmath , termed as
    the interference threshold . From ( 2.3 ), this translates to

      -- -------- -------- -------- -- -------
         @xmath   @xmath   @xmath      (2.5)
      -- -------- -------- -------- -- -------

    where @xmath is termed as interference range.

In essence, the transmission on a link is successful if the distance
between the nodes is less than or equal to the communication range and
no other node is transmitting within the interference range from the
receiver.

The STDMA network is denoted by @xmath . Note that @xmath , thus @xmath
. The relation @xmath is widely assumed in literature [ 23 ] , [ 24 ] ,
[ 25 ] , [ 26 ] .

According to the physical interference model [ 15 ] , the transmission
on a link is successful if the SINR at the receiver is greater than or
equal to the communication threshold @xmath . More specifically, the
physical interference model states that transmission @xmath is
successful if:

  -- -- -- -------
           (2.6)
  -- -- -- -------

Note that the physical interference model is less restrictive but more
complex. Usually, this representation has been employed to model mesh
networks with TDMA like access mechanisms [ 27 ] . We will discuss this
aspect later in the thesis.

A point to point link schedule @xmath is conflict-free if the SINR at
every intended receiver does not drop below the communication threshold,
i.e.,

  -- -------- -- -------
     @xmath      (2.7)
  -- -------- -- -------

### 2.2 Link Scheduling based on Protocol Interference Model

#### 2.2.1 Equivalence of Link Scheduling and Graph Edge Coloring

In this section, we describe the communication and two-tier graph
representations of an STDMA wireless network. We explain the equivalence
between a point to point link schedule for the STDMA network and the
colors of edges of the communication graph representation of the
network, and illustrate this equivalence with an example.

The STDMA network @xmath can be modeled by a directed graph @xmath ,
where @xmath is the set of vertices and @xmath is the set of edges. Let
@xmath , where vertex @xmath represents node @xmath in @xmath . In the
graph representation, if node @xmath is within node @xmath ’s
communication range, then there is an edge from @xmath to @xmath ,
denoted by @xmath and termed as communication edge. Similarly, if node
@xmath is outside node @xmath ’s communication range but within its
interference range, then there is an edge from @xmath to @xmath ,
denoted by @xmath and termed as interference edge. Thus, @xmath , where
@xmath and @xmath denote the set of communication and interference edges
respectively. The two-tier graph representation of the STDMA network
@xmath is defined as the graph @xmath comprising of all vertices and
both communication and interference edges. The communication graph
representation of the STDMA network @xmath is defined as the graph
@xmath comprising of all vertices and communication edges only. We will
illustrate these representations with an example.

Consider the STDMA wireless network @xmath whose deployment is shown in
Figure 2.1(a) . The system parameters for this network are given in
Table 2.1 . From ( 2.4 ) and ( 2.5 ), it can be easily shown that @xmath
m and @xmath m. The corresponding communication graph representation
@xmath is shown in Figure 2.2 . The communication graph comprises of 6
vertices and 14 directed communication edges. The vertex and
communication edge sets are given by

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (2.8)
     @xmath   @xmath   @xmath            (2.9)
                                @xmath   
  -- -------- -------- -------- -------- -------

The two-tier graph model @xmath of the STDMA network @xmath is shown in
Figure 2.3 . The two-tier graph comprises of 6 vertices, 14 directed
communication edges and 10 directed interference edges. The vertex and
communication edge sets are given by ( 2.8 ) and ( 2.9 ) respectively,
while the interference edge set is given by

  -- -------- -------- -------- -------- --------
     @xmath   @xmath   @xmath            (2.10)
                                @xmath   
  -- -------- -------- -------- -------- --------

Given the above representations, a point to point link schedule @xmath
for an STDMA wireless network @xmath can be considered as equivalent to
assigning a unique color to every edge in the communication graph, such
that transmitter-receiver pairs with the same color transmit
simultaneously in a particular time slot. For the example network
considered, the link schedule shown in Figure 2.1(b) corresponds to the
coloring of the edges of the communication graph shown in Figure 2.4 .
Time slots 1, 2, 3, 4, 5, 6, 7 and 8 in @xmath correspond to colors red,
blue, green, magenta, yellow, cyan, brown and gold in @xmath
respectively. Note that a coloring algorithm that uses the least number
of colors also minimizes the schedule length. This aspect is further
addressed in subsequent sections.

#### 2.2.2 Review of Algorithms

In this section, we provide an overview of past research in the field of
STDMA point to point link scheduling algorithms based on the protocol
interference model. The protocol interference model is widely studied in
literature because of its simplicity. It has been usually employed to
model networks such as Carrier Sense Multiple Access with Collision
Avoidance (CSMA/CA) based WLANs ² ² 2 Consider an IEEE 802.11 based WLAN
wherein CSMA with RTS/CTS/ACK is used to protect unicast transmissions.
Due to carrier sensing, a transmission between nodes @xmath and @xmath
may block all transmissions that are within a distance of @xmath from
either @xmath (due to sensing RTS and DATA) or @xmath (due to sensing
CTS and ACK). [ 27 ] , [ 25 ] . Centralized algorithms [ 16 ] , [ 28 ] ,
[ 29 ] , [ 30 ] , [ 25 ] as well as distributed algorithms [ 31 ] have
been proposed for generating link schedules based on the protocol
interference model.

A link scheduling algorithm based on the protocol interference model
utilizes a communication or two-tier graph model of the STDMA network to
determine a point to point link schedule [ 32 ] , [ 33 ] . Algorithms
based on the protocol interference model for assigning links to time
slots (equivalently, colors) require that two communication edges @xmath
and @xmath can be colored the same if and only if:

1.  vertices @xmath , @xmath , @xmath , @xmath are all mutually
    distinct, i.e., there is no primary edge conflict, and

2.  @xmath and @xmath , i.e, there is no secondary edge conflict .

The first criterion is based on the operational constraint ( 2.1 ). The
second criterion states that a node cannot receive a packet if it lies
within the interference range of any other transmitting node. A
scheduling algorithm utilizes various graph coloring methodologies to
obtain a non-conflicting link schedule, i.e., a link schedule devoid of
primary and secondary edge conflicts.

To maximize the throughput of an STDMA network, algorithms based on the
protocol interference model ³ ³ 3 Link scheduling algorithms based on
the protocol interference model are sometimes referred to as “graph
based algorithms” in literature [ 32 ] , [ 33 ] . This term is slightly
confusing since scheduling algorithms based on the physical interference
model also construct graphs prior to determining a link schedule. seek
to minimize the total number of colors used to color all the
communication edges of @xmath . This will in turn minimize the schedule
length. It is well known that for an arbitrary communication graph, the
problem of determining a minimum length schedule (optimal schedule) is
NP-hard [ 16 ] , [ 29 ] . Hence, the approach followed in the literature
is to devise algorithms that produce close to optimal (sub-optimal)
solutions. The efficiency of a sub-optimal algorithm is typically
measured in terms of its computational (run time) complexity and
performance guarantee (approximation factor).

The concept of STDMA for wireless networks was formalized in [ 28 ] .
The authors assume a multihop packet radio network with fixed node
locations and consider the problem of assigning an integral number of
slots to every link in an STDMA cycle (frame). To solve this problem,
they model the network by a communication graph, determine a set of
maximal cliques and then assign a certain number of slots to all the
links in each maximal clique. Finally, the authors develop a fluid
approximation for the mean system delay and validate it using
simulations.

In [ 29 ] , the authors consider pre-specified link demands in a spread
spectrum packet radio network. They formulate the problem as a linear
optimization problem and use the ellipsoid algorithm [ 34 ] to solve the
problem. They assume that the desired link data rates are rational
numbers and develop a strongly polynomial algorithm ⁴ ⁴ 4 An algorithm
is strongly polynomial if (a) the number of arithmetic operations
(addition, multiplication, division or comparison) is polynomially
bounded by the dimension of the input, and (b) the precision of numbers
appearing in the algorithm is bounded by a polynomial in the dimension
and precision of the input. that computes a minimum length schedule.
Finally, they consider the problem of link scheduling to satisfy
pre-specified end-to-end demands in the network. They formulate this
problem as a multicommodity flow problem and describe a polynomial time
algorithm that computes a minimum length schedule. As pointed out by the
authors, their algorithm is not practical due to its high computational
complexity.

A significant work in link scheduling under protocol interference model
is reported in [ 16 ] , in which the authors show that tree networks can
be scheduled optimally, oriented graphs ⁵ ⁵ 5 An in-oriented graph is a
directed graph in which every vertex has at most one outgoing edge. An
out-oriented graph is a directed graph in which every vertex has at most
one incoming edge. can be scheduled near-optimally and arbitrary
networks can be scheduled such that the schedule is bounded by a length
proportional to the graph thickness ⁶ ⁶ 6 The thickness of a graph
@xmath is the minimum number of planar graphs into which @xmath can be
partitioned. times the optimum number of colors.

In [ 16 ] , the authors seem to have missed a subtle point that colors
from previously colored oriented graphs can be used to color the current
oriented graph. Instead, they use a fresh set of colors to color each
successive oriented graph. Consequently, their algorithm leads to a
higher numbers of colors, especially if the number of oriented graphs is
large. The authors employ such a heuristic primarily to upper bound the
number of colors used by the algorithm ( [ 16 ] , Lemma 3.4) and
consequently obtain bounds on the running time complexity and
performance guarantee of the algorithm ( [ 16 ] , Theorem 3.3). Though
the ArboricalLinkSchedule algorithm has nice theoretical properties such
as low computational complexity, it can be shown that it may yield a
higher number of colors in practice . This leads to lower network
throughput.

We should point out here that, if we modify the ArboricalLinkSchedule
algorithm to reuse colors from previously colored oriented graphs to
color the current oriented graph, then the schedule length will always
be lower than the schedule length obtained by the ArboricalLinkSchedule
algorithm. This can lead to higher network throughput. We develop this
idea further in Chapter 3 . Furthermore, we show that this can be
achieved with only a slight increase in computational complexity.

In [ 26 ] , the authors investigate throughput bounds for a given
wireless network and traffic workload under the protocol interference
model. They use a conflict graph ⁷ ⁷ 7 Under the protocol interference
model, the conflict graph @xmath is constructed from the communication
graph @xmath as follows. Let @xmath denote the communication edge @xmath
. Vertices of @xmath correspond to directed edges @xmath in @xmath . In
@xmath , there exists an edge from vertex @xmath to vertex @xmath if any
of the following is true: (a) @xmath or (b) @xmath . to represent
interference constraints. The problem of finding maximum throughput for
a given source-destination pair under the flexibility of multipath
routing is formulated as a linear program with flow constraints and
conflict graph constraints. They show that this problem is NP-hard and
describe techniques to compute lower and upper bounds on throughput.
Finally, the authors numerically evaluate throughput bounds and
computation time of their heuristics for simple network scenarios and
IEEE 802.11 MAC (bidirectional MAC). Though the authors provide a
general framework for joint routing and scheduling, they neither derive
the computational complexity of their heuristics nor describe their link
scheduling algorithm explicitly.

Recently, in [ 25 ] , the authors investigate joint link scheduling and
routing under the protocol interference model for a wireless mesh
network consisting of static mesh routers and mobile client devices.
Assuming that @xmath denotes the aggregate traffic demand on node @xmath
, they consider the problem of maximizing @xmath , such that at least
@xmath amount of traffic can be routed from each node @xmath to a fixed
gateway node. Since this problem is NP-hard, the authors propose
heuristics based on linear programming and re-routing flows on the
communication graph. They derive the worst case bound of their algorithm
and evaluate its performance via simulations. Though the authors make a
reasonable attempt to solve the joint routing and scheduling problem,
their algorithm is extremely complex ⁸ ⁸ 8 The algorithm in [ 25 ]
consists of five steps: solve linear program, channel assignment, post
processing, flow scaling and interference free link scheduling.
Moreover, the channel assignment step consists of three algorithms. and
brute force in nature. Furthermore, the authors have not provided
intuitive arguments for their algorithm.

Another recent work which jointly investigates link scheduling and
routing under protocol interference model is reported in [ 30 ] . The
authors consider wireless mesh networks with half duplex and full duplex
orthogonal channels, wherein each node can transmit to at most one node
and/or receive from at most @xmath nodes ( @xmath ) during any time
slot. They investigate the joint problem of routing and scheduling to
analyze the achievability of a given rate vector between multiple
source-destination pairs. The scheduling algorithm is equivalent to an
edge-coloring on a multi-graph representation ⁹ ⁹ 9 A multi-graph is a
directed graph in which multiple edges can emanate from a vertex @xmath
and terminate at another vertex @xmath @xmath . and the corresponding
necessary conditions lead the routing problem to be formulated as a
linear optimization problem. The authors describe a polynomial time
approximation algorithm to obtain an @xmath -optimal solution of the
routing problem using the primal dual approach. Finally, they evaluate
the performance of their algorithms via simulations.

It has been observed that high data rates are achievable in a wireless
mesh network by allowing a node to transmit to only one neighboring node
at fixed peak power in any time slot [ 30 ] . We point out here that a
similar assumption of uniform transmission power has been made in our
system model in subsequent chapters of the thesis.

Algorithms based on the protocol interference model represent the
network by a communication or two-tier graph and employ a plethora of
techniques from graph theory [ 35 ] and approximation algorithms [ 36 ]
, [ 37 ] to devise heuristics which yield a minimum length schedule.
Consequently, such algorithms have the advantage of low computational
complexity (in general). However, recent research suggests that these
algorithms result in low network throughput. This aspect is further
illustrated in the following section.

### 2.3 Limitations of Algorithms based on Protocol Interference Model

Due to its inherent simplicity, the protocol interference model has been
traditionally employed to represent a wide variety of wireless networks.
However, it leads to low network throughput in wireless mesh networks.
To emphasize this point, we provide examples to demonstrate that
algorithms based on the protocol interference model can result in
schedules that yield low network throughput.

Intuitively, the protocol interference model divides the deployment
region of the STDMA wireless network into “communication zones” and
“interference zones”. This transforms the scheduling problem to an edge
coloring problem for the communication graph representation of the
network. However, this simplification can result in schedules that do
not satisfy the SINR threshold condition ( 2.7 ).

Specifically, algorithms based on the protocol interference model do not
necessarily maximize the throughput of an STDMA wireless network
because:

1.  They can lead to high cumulative interference at a receiver, due to
    hard-thresholding based on communication and interference radii [ 32
    ] , [ 33 ] . This is because the SINR at receiver @xmath decreases
    with an increase in the number of concurrent transmissions @xmath ,
    while the communication radius @xmath and the interference radius
    @xmath have been defined for a single transmission only.

    For example, consider the STDMA wireless network whose deployment is
    shown in Figure 2.5 . The network consists of six labeled nodes
    whose coordinates (in meters) are @xmath , @xmath , @xmath , @xmath
    , @xmath and @xmath . The system parameters are shown in Table 2.1 ,
    which yield @xmath m and @xmath m. The two-tier graph model of the
    STDMA network is shown in Figure 2.6 ; note that interference edges
    are absent. Consider the transmission requests @xmath , @xmath and
    @xmath , which correspond to communication edges of the subgraph
    shown in Figure 2.7 . The communication edges @xmath , @xmath and
    @xmath shown in Figure 2.7 do not have primary or secondary edge
    conflicts. To minimize the number of colors, such an algorithm will
    color these edges with the same color, as shown in Figure 2.8 .
    Equivalently, transmissions @xmath , @xmath and @xmath will be
    scheduled in the same time slot, say time slot @xmath . However, our
    computations show that the SINRs at receivers @xmath , @xmath and
    @xmath are @xmath dB, @xmath dB and @xmath dB respectively. Figure
    2.9 shows the nodes of the network along with the labeled
    transmitter-receiver pairs, receiver-centric communication and
    interference zones and the SINRs at the receivers. From the SINR
    threshold condition ( 2.6 ), transmission @xmath is successful,
    while transmissions @xmath and @xmath are unsuccessful. This leads
    to low network throughput.

2.  Moreover, these algorithms can be extremely conservative and result
    in higher number of colors.

    For example, consider the STDMA wireless network whose deployment is
    shown in Figure 2.10 . The network consists of four labeled nodes
    whose coordinates (in meters) are @xmath , @xmath , @xmath and
    @xmath . The system parameters are shown in Table 2.1 , which lead
    to @xmath m and @xmath m. The two-tier graph model of the STDMA
    network is shown in Figure 2.11 . Consider the transmission requests
    @xmath and @xmath , which correspond to communication edges of the
    subgraph shown in Figure 2.12 . The communication edges @xmath and
    @xmath shown in Figure 2.12 have secondary edge conflicts. Hence,
    such an algorithm will typically color these edges with different
    colors, as shown in Figure 2.13 . Equivalently, a link scheduling
    algorithm based on the protocol interference model will schedule
    transmissions @xmath and @xmath in different time slots, say time
    slots @xmath and @xmath respectively, where @xmath . Our
    computations show that the resulting SINRs at receivers @xmath and
    @xmath are both equal to @xmath dB. Figure 2.14 shows the nodes of
    the network along with the labeled transmitter-receiver pairs,
    receiver-centric communication and interference zones and SINRs at
    the receivers. Observe that, with an algorithm based on the protocol
    interference model, the SINRs at both receivers are well above the
    communication threshold of @xmath dB. Alternatively, consider an
    algorithm (perhaps based on the physical interference model) that
    schedules transmissions @xmath and @xmath in the same time slot, say
    time slot @xmath . The corresponding edge coloring is shown in
    Figure 2.15 . Our computations show that the resulting SINRs at
    receivers @xmath and @xmath are both equal to @xmath dB, which are
    also above the communication threshold. Figure 2.16 shows the nodes
    of the network along with the labeled transmitter-receiver pairs and
    SINRs at the receivers. In essence, with the alternate algorithm,
    both transmissions @xmath and @xmath are successful, since signals
    levels are so high at the receivers that strong interferences can be
    tolerated. In summary, a point to point link scheduling algorithm
    based on the protocol interference model will typically schedule the
    above transmissions in different slots and yield lower network
    throughput compared to the alternate algorithm.

3.  Lastly, these algorithms are not aware of the topology of the
    network, i.e., they determine a link schedule without being
    cognizant of the exact positions of the transmitters and receivers.

The above examples demonstrate that scheduling algorithms based on the
protocol interference model can result in low network throughput.
Observe that algorithms that construct an approximate model of the STDMA
network (two tier graph or communication graph) and focus on minimizing
the schedule length do not necessarily maximize network throughput. This
observation is developed into a proposal for an appropriate performance
metric in Section 2.6 .

Since link scheduling algorithms based on the protocol interference
model yield low throughput, researchers have propounded algorithms based
on the physical interference model to improve the throughput of STDMA
wireless networks. To achieve higher throughput, one possible technique
is to model the STDMA network by a communication graph and check SINR
threshold conditions during assignment of links to time slots; this is
the approach most commonly employed, for example in [ 27 ] , [ 32 ] , [
38 ] . The other technique is to incorporate SINR threshold conditions
into a special graph model of the network; this approach is more
challenging and (to the best of our knowledge) is considered only in
research work such as [ 39 ] , [ 40 ] , [ 41 ] . Research papers which
employ the former approach are reviewed in Section 2.4 , while research
papers which employ the latter approach are reviewed in Section 2.5 .

### 2.4 Link Scheduling based on Communication Graph Model and SINR
Conditions

In this section, we examine recent research in link scheduling based on
modeling the STDMA network by a communication graph and verifying SINR
conditions at the receivers. Though algorithms based on this model [ 24
] , [ 42 ] , yield higher throughput, they usually result in higher
computational complexity than algorithms based on the protocol
interference model.

In [ 27 ] , the authors investigate throughput improvement in an IEEE
802.11 like wireless mesh network with CSMA/CA channel access scheme
replaced by STDMA. For a successful packet transmission, they mandate
that two-way communication be successful, i.e., a packet transmission is
defined to be successful if and only if both data and acknowledgement
packets are received successfully. Under this “extended physical
interference model”, they present a greedy algorithm which computes a
point to point link transmission schedule in a centralized manner.
Assuming uniform random node distribution and using results from
occupancy theory [ 43 ] , they derive an approximation factor for the
length of this schedule relative to the shortest schedule. Though the
analysis presented in [ 27 ] is novel, their model is restrictive
because it is only applicable to wireless networks using link-layer
reliability protocols.

The throughput performance of link scheduling algorithms based on
two-tier graph model @xmath has been analyzed under physical
interference conditions in [ 32 ] . The authors determine the optimal
number of simultaneous transmissions by maximizing a lower bound on the
throughput and subsequently propose Truncated Graph-Based Scheduling
Algorithm (TGSA), an algorithm that provides probabilistic guarantees
for network throughput. Though the analysis presented in [ 32 ] is
mathematically elegant and based on the Edmundson-Madansky bound [ 44 ]
, [ 45 ] , their algorithm does not yield high network throughput. This
is because the partitioning of a maximal independent set of
communication edges into multiple subsets (time slots) is arbitrary and
not based on network topology, which can lead to significant
interference in certain regions of the network. This is further
elucidated by the simulation results in Chapter 3 .

The performance of algorithms based on the protocol interference model
versus those based on communication graph model and SINR conditions is
evaluated and compared in [ 33 ] . To generate a non-conflicting link
schedule based on the protocol interference model, the authors use a
two-tier graph model with certain SINR threshold values chosen based on
heuristics and examples. To generate a conflict-free point to point link
schedule based on the physical interference model, the authors employ a
method suggested in [ 46 ] which describes heuristics based on two path
loss models, namely terrain-data based ground wave propagation model and
Vogler’s five knife-edge model. Their simulations results indicate that,
under a Poisson arrival process, algorithms based on the protocol
interference model result in higher average packet delay than algorithms
based on communication graph model and SINR conditions.

In [ 42 ] , the authors investigate the tradeoff between the average
number of concurrent transmissions (spatial reuse) and sustained data
rate per node for an IEEE 802.11 wireless network. They show that
spatial reuse depends only on the ratio of transmit power to carrier
sense threshold [ 6 ] . Keeping the carrier sense threshold fixed, they
propose a distributed power and rate control algorithm based on
interference measurement and evaluate its performance via simulations.

In [ 24 ] , the authors investigate mitigation of inter-flow
interference in an IEEE 802.11e wireless mesh network from a
temporal-spatial diversity perspective. Measurements of received signal
strengths are used to construct a virtual coordinate system to identify
concurrent transmissions with minimum inter-flow interference. Based on
this new coordinate system, one of the nodes, designated as gateway
node, determines the scheduling order for downlink frames of different
connections. Through extensive simulations with real-life measurement
traces, the authors demonstrate throughput improvement with their
algorithm.

Algorithms based on representing the network by a communication graph
and verifying SINR threshold conditions yield higher network throughput
than algorithms based on the protocol interference model. However, this
is achieved at the cost of higher computational complexity. Furthermore,
the gains in throughput may not be significant enough to justify the
increase in computational complexity. This has prompted few researchers
to solve the link scheduling problem in a more fundamental manner. These
researchers have proposed an altogether different model of the network,
termed as SINR graph model, and developed heuristics. Such algorithms
are reviewed in the following section.

### 2.5 Link Scheduling based on SINR Graph Model

In literature, many authors refer to algorithms based on communication
graph model and checking SINR conditions as “algorithms based on
physical interference model”. In this thesis, only algorithms that embed
SINR threshold conditions into an appropriate graph model of the network
are referred to as “algorithms based on the physical interference
model”. Though the physical interference model is more realistic,
algorithms based on this model [ 39 ] , [ 40 ] , [ 41 ] have, in
general, higher computational complexity than algorithms based on the
protocol interference model.

Point to point link scheduling for power-controlled STDMA networks under
the physical interference model is analyzed in [ 39 ] . The authors
define scheduling complexity as the minimum number of time slots
required for strong connectivity of the graph ¹⁰ ¹⁰ 10 A directed graph
@xmath is strongly connected if there exists a directed path from every
vertex to every other vertex. constructed from the point to point link
schedule. They develop an algorithm employing non-linear power
assignment ¹¹ ¹¹ 11 In uniform power assignment, all nodes transmit with
the same transmission power. In linear power assignment [ 39 ] , a node
transmits with minimum power required to satisfy the SINR threshold
condition at the receiver, i.e., transmission power equals @xmath .
Non-linear power assignment refers to a power assignment scheme that is
neither uniform nor linear. and show that its scheduling complexity is
polylogarithmic in the number of nodes. In a related work [ 40 ] , the
authors investigate the time complexity of scheduling a set of
communication requests in an arbitrary network. They consider a
“generalized physical model” wherein the actual received power of a
signal can deviate from the theoretically received power by a
multiplicative factor. Their algorithm successfully schedules all links
in time proportional to the squared logarithm of the number of nodes
times the static interference measure [ 47 ] . Though the authors of [
39 ] , [ 40 ] allow non-uniform transmission power at all nodes and
develop novel algorithms, their algorithms are impractical. This is
because wireless devices have constraints on maximum transmission power,
while the algorithms in [ 39 ] , [ 40 ] can result in arbitrarily high
transmission power at some nodes.

In [ 26 ] , the authors provide a general framework for computation of
throughput bounds for a given wireless network and traffic workload.
Though their work primarily focuses on the protocol interference model,
they briefly allude to the physical interference model too.
Specifically, they describe a technique to construct a weighted conflict
graph to represent interference constraints. They briefly describe
methods to compute lower and upper bounds on throughput and the issues
involved therein. However, the authors do not describe simulation
results under the physical interference model, perhaps due to the
tremendous complexity incurred in solving linear programs for
representative network scenarios.

###### Remark 2.5.1.

Under physical interference model, the weighted conflict graph @xmath [
26 ] is constructed from the network as follows. Let @xmath denote the
received signal power at node @xmath due to the transmission from node
@xmath . In @xmath , a vertex corresponds to a directed link @xmath
(equivalently, node pair @xmath ) provided @xmath . @xmath is a perfect
graph wherein the weight @xmath of the directed edge from vertex @xmath
to vertex @xmath is given by @xmath .

We should point out here that, analogous to a conflict graph, an SINR
graph representation of an STDMA wireless network has been proposed by
us in Chapter 4 . Furthermore, the authors of [ 26 ] do not propose any
specific link scheduling algorithm and use the weighted conflict graph
only to compute bounds on network throughput. On the other hand, we use
an SINR graph representation of the network under the physical
interference model and develop a link scheduling algorithm with lower
time complexity and demonstrably superior performance.

More specifically, in Chapter 4 , we investigate link scheduling for
STDMA wireless networks under the physical interference model. Unlike [
39 ] , [ 40 ] , we assume that a node transmits at fixed power, i.e., we
assume uniform power assignment. Moreover, unlike [ 39 ] , [ 40 ] , we
do not assume a minimum distance of unity between any two nodes.
Consequently, our system model is more practical than those of [ 39 ] ,
[ 40 ] . Under these realistic assumptions, we propose a link scheduling
algorithm based on an SINR graph representation of the network. In the
SINR graph ¹² ¹² 12 The SINR graph is analogous to a line graph [ 35 ]
constructed from the communication graph representation of the network.
, weights of the edges correspond to interferences between pairs of
nodes. We prove the correctness of the algorithm and derive its
computational complexity. We demonstrate that the proposed algorithm
achieves higher throughput than existing algorithms, without any
increase in computational complexity.

So far, we have provided a brief glimpse into three classes of link
scheduling algorithms, each with its relative merits and demerits. For
example, algorithms based on the protocol interference model have low
computational complexity and are simple to implement, but yield low
network throughput. On the other hand, algorithms based on SINR graph
representation have higher computational complexity and are more
cumbersome to implement, but achieve higher network throughput. Also,
there exist algorithms based on communication graph and SINR conditions
whose performance characteristics lie between these two classes. Hence,
in general, these three classes of algorithms exhibit a tradeoff between
complexity and performance. Finally, algorithms based on the protocol
interference model are better suited to model WLANs, while the latter
two classes of algorithms are better suited to model wireless mesh
networks. For these reasons, we investigate and develop algorithms from
each of these classes in this thesis.

Prior to proposing efficient algorithms in each of these classes, we
seek to address the following question: Is schedule length an
appropriate performance metric for an algorithm that considers the SINR
threshold condition ( 2.6 ) as the criterion for successful packet
reception? In other words, should algorithms based on communication
graph and SINR conditions and algorithms based on SINR graph
representation focus on minimizing the schedule length? We answer this
important question in detail in the following section.

### 2.6 Spatial Reuse as Performance Metric

In literature, link scheduling algorithms have only focused on
minimizing the schedule length. However, algorithms that minimize the
schedule length do not necessarily maximize network throughput, as
explained in Section 2.3 . Thus, from a perspective of maximizing
network throughput observed by the physical layer, it is imperative to
consider a performance metric that takes into account SINR threshold
condition ( 2.6 ) as the criterion for successful packet reception,
i.e., a metric also suitable for the physical interference model. We
propose such a performance metric, spatial reuse, in this section. We
show that maximizing spatial reuse directly translates to maximizing
network throughput.

Consider an STDMA wireless network that operates over @xmath time slots
@xmath . The total number of successfully scheduled links from slot
@xmath to slot @xmath is

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (2.11)
  -- -------- -------- -------- -- --------

So, the number of successfully scheduled links per time slot from slot
@xmath to slot @xmath is

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (2.12)
  -- -------- -------- -------- -- --------

We define spatial reuse @xmath as the limiting value of @xmath (assuming
that the limit exists). In other words, spatial reuse is the limiting
value of @xmath as the duration of the time interval becomes very large.
Mathematically,

  -- -------- -------- -------- -- --------
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (2.13)
  -- -------- -------- -------- -- --------

Assuming a constant data rate of @xmath bits per second on each
successful link and a slot duration of @xmath seconds, the (aggregate)
network throughput is given by @xmath bits per second. Thus, spatial
reuse is directly proportional to network throughput. Note that spatial
reuse is cognizant of the physical interference model, thereby making it
an appropriate performance metric for the comparison of various link
scheduling algorithms.

The fact that the interference at a receiver is an increasing function
of the number of concurrent transmissions in a time slot limits the
value of spatial reuse (for a given STDMA network). More specifically,
if too many transmissions are scheduled in a single time slot, the
interference at some receivers will be high enough to drive the SINRs
below the communication threshold, leading to lower spatial reuse.
Therefore, for a given STDMA network, there are certain fundamental
limits (upper bounds) on the spatial reuse.

In our system model, we only consider static link schedules, i.e., the
same fixed pattern of slots repeats cyclically. Hence, for our system
model, the equation for spatial reuse, ( 2.13 ), can be simplified to

  -- -- -------- -------- -- --------
        @xmath   @xmath      (2.14)
  -- -- -------- -------- -- --------

The essence of STDMA is to have a reasonably large number of concurrent
and successful transmissions. For a network which is operational for a
long period of time, say @xmath time slots, the total number of
successfully received packets is @xmath . Thus, a high value of spatial
reuse directly translates to higher network throughput and the number of
colors @xmath is relatively unimportant. Hence, spatial reuse ¹³ ¹³ 13
Note that spatial reuse in our network model is analogous to spectral
efficiency in digital communication systems. Both performance metrics
correspond to the “rate of data transfer” and are upper bounded by their
respective system parameters.

turns out to be a crucial metric for the comparison of different STDMA
algorithms in Chapters 3 , 4 and 5 .

## Chapter 3 Point to Point Link Scheduling based on Communication Graph
Model

We begin our investigation in link scheduling by critically examining
the ArboricalLinkSchedule algorithm proposed in [ 16 ] . The algorithm
is based only on the communication graph (protocol interference model)
and seeks to minimize the schedule length. Though ArboricalLinkSchedule
has good properties such as low computational complexity, it can yield
higher schedule length in practice. Towards this end, we propose a novel
modification to ArboricalLinkSchedule that results in lower schedule
length. We compare the performance of the modified algorithm with the
ArboricalLinkSchedule algorithm and derive its run time (computational)
complexity in Section 3.1 . We then propose the ConflictFreeLinkSchedule
point to point link scheduling algorithm, which is based on
communication graph model and SINR conditions, in Section 3.2 . The
performance of the proposed algorithm is compared with existing link
scheduling algorithms under various wireless channel conditions. We show
that the proposed algorithm has polynomial run time complexity. Finally,
we summarize the implications of our work.

### 3.1 ArboricalLinkSchedule Algorithm Revisited

In this section, we propose a modification to the ArboricalLinkSchedule
point to point link scheduling algorithm. Since both the original
algorithm and the proposed modification are based on the protocol
interference model, we compare their performance in terms of average
schedule length. Finally, we also derive the run time complexity of the
modified algorithm.

Our system model and notation are same as described in Section 2.2 . We
seek an algorithm that determines a minimum length point to point link
schedule for an STDMA wireless network under the protocol interference
model. For consistency with the graph model described in [ 16 ] , we
assume that the STDMA wireless network @xmath is modeled by the
communication graph @xmath only, i.e., interference edges are absent
@xmath .

It is well known that, under the protocol interference model, the
problem of determining an optimal schedule, i.e., a minimum length
schedule, is NP-hard [ 48 ] . As pointed out in Section 2.2.1 , this is
closely related to the problem of coloring all edges of the
communication graph with minimum number of colors, which is also known
to be NP-hard [ 16 ] . Consequently, the only recourse is to devise
approximation algorithms (heuristics) and show their efficiency
theoretically and experimentally.

One such algorithm, ArboricalLinkSchedule, has been described in [ 16 ]
. First, the algorithm uses the labeler function to label all the
vertices of the communication graph. Next, it partitions the
communication graph into edge-disjoint subgraphs, which are termed as
“oriented graphs”. Finally, the oriented graphs are colored in sequence.
Specifically, the vertices in each oriented graph are scanned in
increasing order of label and the unique edge associated with each
vertex is colored using the NonConflictingEdge function [ 16 ] . The
labeler function and the partitioning technique are described later in
the section.

In [ 16 ] , the authors appear to have missed a delicate point that
colors from previously colored oriented graphs can be used to color the
present oriented graph. Specifically, they use a fresh set of colors to
color each successive oriented graph. In our opinion, the authors employ
this method to upper bound the number of colors used by the algorithm (
[ 16 ] , Lemma 3.4) and thus derive the running time complexity of the
algorithm ( [ 16 ] , Theorem 3.3). However, such a heuristic can
potentially lead to a higher number of colors (and higher schedule
length) in practice.

Therefore, we propound a modification to the ArboricalLinkSchedule
algorithm that reuses colors from previously colored oriented graphs to
colors the current oriented graph. The resulting schedule length will
always be lower than that of ArboricalLinkSchedule, leading to
potentially higher throughput. Our proposed link scheduling algorithm is
ALSReuseColors, which considers the communication graph @xmath and is
described in Algorithm 1 .

In Phase 1, we label all the vertices using the labeler function [ 16 ]
. The labeler function is reproduced in Algorithm 2 for convenience. It
is a recursive function that assigns a unique label (from @xmath to
@xmath ) to every vertex of the communication graph. Let @xmath denote
the label assigned to vertex @xmath . The notation @xmath denotes the
graph that results when vertex @xmath and all its incident edges are
removed from graph @xmath . At every step in the recursion, it chooses
the minimum degree vertex @xmath in the residual graph @xmath and
assigns it the highest label that has not been assigned so far. Note
that vertices with lower degree tend to be assigned higher labels. The
labeler function ensures that, for any given node, the number of
neighbors with lower labels is much lower than the number of vertices in
@xmath .

In Phase 2, the communication graph @xmath is decomposed into what are
called as out-oriented and in-oriented graphs @xmath , similar to the
technique employed in [ 16 ] . Recall that an in-oriented graph is a
directed graph in which every vertex has at most one outgoing edge,
while an out-oriented graph is a directed graph in which every vertex
has at most one incoming edge. Each @xmath is a forest ¹ ¹ 1 A graph
that is a collection of trees is termed as a forest. and every edge of
@xmath is in exactly one of the @xmath ’s. This decomposition is
achieved by partitioning graph @xmath , the undirected equivalent of
@xmath , into undirected forests. The number of forests can be minimized
by using techniques from Matroid theory ( [ 49 ] , @xmath -forest
problem). However, this optimal decomposition requires extensive
computation. Hence, we adopt a faster albeit non-optimal approach of
using successive breadth first searches [ 50 ] to decompose @xmath into
undirected forests. Each undirected forest is further mapped to two
directed forests. In one forest, the edges in every connected graph
point away from the root and every vertex has at most one incoming edge,
thus producing an out-oriented graph. In the other forest, the edges in
every connected graph point toward the root and every vertex has at most
one outgoing edge, thus producing an in-oriented graph.

In Phase 3, the oriented graphs are considered sequentially. For each
oriented graph, the vertices are considered in increasing order of label
and the unique edge associated with each vertex is colored using the
NCEReuseColors function. The NCEReuseColors function is explained in
Algorithm 3 . For the edge @xmath under consideration, it discards any
color from any oriented graph that has an edge with a primary or
secondary conflict with @xmath . It returns the least color among the
residual set of non-conflicting colors from all oriented graphs colored
so far. If no non-conflicting color from any oriented graph is found, it
returns a new color.

1: input: Directed communication graph @xmath

2: output: A coloring @xmath

3: @xmath {Phase 1}

4: use successive breadth first searches to partition @xmath into
oriented graphs @xmath , @xmath {Phase 2}

5: for @xmath do {Phase 3 begins}

6: for @xmath do

7: if @xmath is out-oriented then

8: let @xmath be such that @xmath

9: else

10: let @xmath be such that @xmath

11: end if

12: @xmath

13: end for

14: end for {Phase 3 ends}

Algorithm 1 ALSReuseColors

1: if @xmath is not empty then

2: let @xmath be a vertex of @xmath of minimum degree

3: @xmath

4: else

5: return @xmath

6: end if

Algorithm 2 integer labeler( @xmath )

1: input: Directed communication graph @xmath

2: output: A non-conflicting color

3: @xmath

4: @xmath @xmath is colored and @xmath and @xmath have a primary edge
conflict @xmath

5: @xmath @xmath is colored and @xmath and @xmath have a secondary edge
conflict @xmath

6: @xmath

7: if @xmath then

8: return the least color @xmath @xmath

9: else

10: return @xmath

11: end if

Algorithm 3 integer NCEReuseColors( @xmath )

#### 3.1.1 Performance Results

In the simulation experiment, every node location is generated randomly,
using a uniform distribution for its @xmath and @xmath coordinates in
the deployment area. We assume that the deployment region is a square of
length @xmath . Thus, if @xmath are the Cartesian coordinates of @xmath
node, then @xmath and @xmath . The values chosen for system parameters
@xmath , @xmath , @xmath and @xmath , are prototypical values of system
parameters in wireless networks [ 42 ] . After generating random
positions for @xmath nodes, we have complete information of @xmath .
Using ( 2.4 ), we compute the communication range, and then map the
STDMA network @xmath to the communication graph @xmath . Once the
schedule @xmath is computed by every algorithm, we know its schedule
length @xmath . For a given set of parameters @xmath , we calculate the
average schedule length by averaging @xmath over 1000 randomly generated
networks. Keeping all other parameters fixed, we observe the effect of
increasing the number of nodes on the average schedule length. In our
experiments, we compare the performance of the following algorithms:

-   ArboricalLinkSchedule [ 16 ] ,

-   Proposed ALSReuseColors.

We assume that @xmath mW, @xmath , @xmath dBm and @xmath dB. From ( 2.4
), we obtain @xmath m. We assume that @xmath m, and vary the number of
nodes from 100 to 200 in steps of 10. Figure 3.1 plots the average
schedule length vs. number of nodes for both the algorithms.

For both the algorithms, we observe that average schedule length
increases almost linearly with the number of nodes. The average schedule
length of ALSReuseColors is about @xmath lower than that of
ArboricalLinkSchedule.

Note that an increase in the number of nodes in a given geographical
area leads to an increase in the number of edges incident on a vertex
and a subsequent increase in the number of oriented graphs.
ArboricalLinkSchedule, which is based on using a fresh set of colors for
each oriented graph, requires increasingly higher number of colors to
color the communication graph compared to ALSReuseColors. Consequently,
the gap between the average schedule lengths increases with number of
nodes in Figure 3.1 .

#### 3.1.2 Analytical Results

We now derive upper bounds on the running time (computational)
complexity of the ALSReuseColors algorithm. With respect to the
communication graph @xmath , let:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath            
              @xmath            
                       @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Recall that the modified algorithm partitions the communication graph
@xmath into oriented graphs @xmath , and colors the oriented graphs in
that order. @xmath is termed as the first oriented graph , while any
oriented graph @xmath , where @xmath , is termed as a subsequent
oriented graph .

###### Lemma 3.1.1.

Suppose that each vertex of the first oriented graph @xmath has at most
@xmath neighbors with lower labels. Then, @xmath may be colored using no
more than @xmath colors.

###### Proof.

This is similar to the proof of Lemma 3.1 in [ 16 ] . ∎

###### Lemma 3.1.2.

Any subsequent oriented graph @xmath , where @xmath , can be colored
using no more than @xmath colors.

###### Proof.

We prove the lemma for an out-oriented graph. A similar proof holds for
an in-oriented graph. Let @xmath be partitioned into edge-disjoint
oriented graphs @xmath . Consider the coloring of edge @xmath in @xmath
oriented graph @xmath , where @xmath , as shown in Figure 3.2 . Now,
edges of previously colored oriented graphs @xmath must also be
considered for potential edge conflicts with edge @xmath of @xmath .
Define

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Any edge which can cause a primary edge conflict with @xmath must belong
to @xmath or @xmath . Also, any edge which can cause a secondary edge
conflict with @xmath must belong to @xmath or @xmath . Let @xmath for
@xmath . The lemma reduces to proving that @xmath is @xmath .

By definition of maximum vertex degree, @xmath and @xmath . Thus, @xmath
is @xmath . For the computation of @xmath , we must also consider
secondary edge conflicts with edges of previously colored oriented
graphs, as shown in Figure 3.2 . The worst-case value of @xmath is
@xmath . Thus, @xmath is @xmath . Similarly, by considering secondary
edge conflicts with edges of previously colored oriented graphs, it
follows that @xmath is @xmath . Finally, @xmath is @xmath . ∎

###### Lemma 3.1.3.

For the first oriented graph @xmath , the running time of Phase 3 of
ALSReuseColors is @xmath .

###### Proof.

This is similar to the proof of Lemma 3.2 in [ 16 ] . ∎

###### Lemma 3.1.4.

For any subsequent oriented graph @xmath , where @xmath , the running
time of Phase 3 of ALSReuseColors is @xmath .

###### Proof.

From Lemma 3.1.2 , for any subsequent oriented graph @xmath , the size
of the set of conflicting colors @xmath of function NCEReuseColors is
@xmath . Thus, determining a new color for an edge in Phase 3 of
ALSReuseColors takes @xmath steps. Since this is done for every label
and hence for every vertex, it follows that the overall running time of
Phase 3 of ALSReuseColors is @xmath . ∎

###### Theorem 3.1.5.

For an arbitrary graph of thickness @xmath and maximum degree @xmath ,
ALSReuseColors has a running time of @xmath .

###### Proof.

The running time of the labeler function is @xmath using a Fibonacci
Heap [ 51 ] . The partitioning method of [ 49 ] results in a
decomposition of a graph of thickness @xmath into at most @xmath
oriented graphs in time @xmath . Thus, @xmath . From Lemma 3.2 in [ 16 ]
, the first oriented graph @xmath can be colored in time @xmath .
However, consider the coloring of @xmath oriented graph @xmath , where
@xmath . From Lemma 3.1.4 , @xmath can be colored in time @xmath .
Hence, the for loop of ALSReuseColors runs in time @xmath . Therefore,
the overall running time of ALSReuseColors is @xmath . Since @xmath
holds for any directed graph @xmath that models a wireless mesh network,
the overall running time of ALSReuseColors simplifies to @xmath . ∎

#### 3.1.3 Discussion

In this section, we have considered an STDMA wireless network with
uniform transmission power at all nodes and presented an algorithm for
point to point link scheduling under the protocol interference model.
The proposed algorithm, which is a modification of the
ArboricalLinkSchedule algorithm in [ 16 ] , models the network by a
communication graph, partitions the communication graph into
edge-disjoint oriented graphs and colors each oriented graph
successively. However, unlike [ 16 ] , we reuse colors from previously
colored oriented graphs to color the current oriented graph. The
proposed algorithm results in around @xmath lower schedule length than
that of [ 16 ] , albeit at the cost of slightly higher computational
complexity ² ² 2 The computational complexity of ArboricalLinkSchedule
is @xmath [ 16 ] . . Since schedules are constructed only once offline
and then used by the network for a long period of time, our approach has
the potential of providing higher long-term network throughput.

For the rest of this chapter, we consider point to point link scheduling
under the physical interference model. The algorithm developed in this
section will be further refined to design a link scheduling algorithm in
the next section.

### 3.2 A High Spatial Reuse Link Scheduling Algorithm

In this section, we propose a point to point link scheduling algorithm
based on the communication graph model of an STDMA wireless network as
well as SINR computations. We adopt spatial reuse as the performance
metric, which has been motivated in Section 2.6 . We compare the
performance of the proposed algorithm with link scheduling algorithms
which utilize a communication graph model of the network. We show that
the proposed algorithm achieves higher spatial reuse compared to
existing algorithms, without any increase in computational complexity.

#### 3.2.1 Problem Formulation

Our system model and notation are exactly as described in Section 2.2 .
A link schedule is feasible if it satisfies the following conditions:

1.  Operational constraint ( 2.1 ).

2.  Range constraint: Every receiver is within the communication range
    of its intended transmitter, i.e.,

      -- -------- -- -------
         @xmath      (3.1)
      -- -------- -- -------

A link schedule @xmath is exhaustive if every pair of nodes which are
within communication range occur exactly twice in the link schedule,
once with one node being the transmitter and the other node being the
receiver, and during another time slot with the transmitter-receiver
roles interchanged. Mathematically,

  -- -------- -- -------
     @xmath      (3.2)
  -- -------- -- -------

Our aim is to design a low complexity conflict-free STDMA point to point
link scheduling algorithm that achieves high spatial reuse, where
spatial reuse is given by ( 2.14 ). We only consider STDMA link
schedules which are feasible and exhaustive ³ ³ 3 The set of edges in
@xmath to be scheduled is determined by a routing algorithm. For
simplicity, we only consider exhaustive schedules, i.e., schedules which
assign exactly one time slot to every directed edge in @xmath . . Thus,
our schedules satisfy ( 2.1 ), ( 2.7 ), ( 3.1 ) and ( 3.2 ).

#### 3.2.2 Motivation

We briefly describe the essential features of STDMA link scheduling
algorithms. An STDMA link scheduling algorithm is equivalent to
assigning a unique color to every edge in the communication graph, such
that transmitter-receiver pairs corresponding to communication edges
with the same color are simultaneously active in a particular time slot,
as described in Section 2.2.1 . The core of a typical link scheduling
algorithm consists of the following functions:

1.  An order in which communication edges are considered for coloring.

2.  A function which determines the set of all existing colors which can
    be assigned to the edge under consideration without violating the
    problem constraints.

3.  A BestColor rule to determine which color to assign to the edge
    under consideration.

The second function considers only operational and range constraints in
link scheduling algorithms based on the protocol interference model
(equivalently, based on the communication graph). However, in the link
scheduling algorithm that we propose, SINR constraints are also taken
into account.

Algorithms based on the protocol interference model are inadequate to
design efficient link schedules. This is because the communication graph
@xmath is a crude approximation of @xmath . Even the two-tier graph
@xmath , which is a better approximation of @xmath , leads to low
network throughput, as argued in Section 2.3 . On the other hand, from
@xmath and @xmath , one can exhaustively determine the STDMA schedule
which yields the highest spatial reuse. However, this is a combinatorial
optimization problem of prohibitive complexity @xmath and is thus
computationally infeasible.

To overcome these problems, we propose a new algorithm for STDMA link
scheduling under the realistic physical interference model. Our
algorithm is based on the communication graph model @xmath as well as
SINR computations. Motivated by techniques from matroid theory [ 52 ] ,
we develop a computationally feasible algorithm with demonstrably high
spatial reuse. The essence of our algorithm is to partition the set of
communication edges into subsets (forests) and color the edges in each
subset sequentially. The edges in each forest are considered in a random
order for coloring, since randomized algorithms are known to outperform
deterministic algorithms, especially when the characteristics of the
input are not known a priori [ 53 ] .

A similar matroid-based network partitioning technique is used in [ 54 ]
to generate high capacity subnetworks for a distributed throughput
maximization problem in wireless mesh networks. Techniques from matroid
theory have also been employed to develop efficient heuristics for
NP-hard combinatorial optimization problems in fields such as
distributed computer systems [ 55 ] and linear network theory [ 56 ] .

#### 3.2.3 ConflictFreeLinkSchedule Algorithm

We call the proposed point to point link scheduling algorithm as
ConflictFreeLinkSchedule (CFLS). The algorithm considers the
communication graph @xmath and SINR conditions and is explained in
Algorithm 4 .

In Phase 1, we label all the vertices randomly. Specifically, if @xmath
has @xmath vertices, we perform a random permutation of the sequence
@xmath and assign these labels to vertices with indices @xmath
respectively. @xmath denotes the label assigned to vertex @xmath .

In Phase 2, the communication graph @xmath is decomposed into what are
called out-oriented and in-oriented graphs @xmath [ 16 ] . Each @xmath
is a forest and every edge of @xmath is in exactly one of the @xmath ’s.
This decomposition is achieved by partitioning graph @xmath , the
undirected equivalent of @xmath , into undirected forests. The number of
forests can be minimized by using techniques from Matroid theory ( [ 49
] , @xmath -forest problem). However, this optimal decomposition
requires extensive computation. Hence, we adopt the faster albeit
non-optimal approach of using successive breadth first searches [ 50 ]
to decompose @xmath into undirected forests. Each undirected forest is
further mapped to two directed forests. In one forest, the edges in
every connected component point away from the root and every vertex has
at most one incoming edge, thus producing an out-oriented graph. In the
other forest, the edges in every connected component point toward the
root and every vertex has at most one outgoing edge, thus producing an
in-oriented graph.

In Phase 3, the oriented graphs are considered sequentially. For each
oriented graph, vertices are considered in increasing order by label and
the unique edge associated with each vertex is colored using the
FirstConflictFreeColor (FCFC) function.

The FCFC function is explained in Algorithm 5 . For the edge under
consideration @xmath , it discards any color that has an edge with a
primary conflict with @xmath . Among the residual set of colors, we
choose the first color such that the resulting SINRs at the receiver of
@xmath and the receivers of all co-colored edges are no less than the
communication threshold @xmath . If no such color is found, we assign a
new color to @xmath . Hence, this function guarantees that the ensuing
schedule is conflict-free.

1: input: STDMA network @xmath , communication graph @xmath

2: output: A coloring @xmath

3: label the vertices of @xmath randomly {Phase 1}

4: use successive breadth first searches to partition @xmath into
oriented graphs @xmath , @xmath {Phase 2}

5: for @xmath do {Phase 3 begins}

6: for @xmath do

7: if @xmath is out-oriented then

8: let @xmath be such that @xmath

9: else

10: let @xmath be such that @xmath

11: end if

12: @xmath

13: end for

14: end for {Phase 3 ends}

Algorithm 4 ConflictFreeLinkSchedule (CFLS)

1: input: STDMA network @xmath , communication graph @xmath

2: output: A conflict-free color

3: @xmath

4: @xmath , @xmath is colored, @xmath and @xmath have a primary edge
conflict @xmath

5: @xmath

6: for @xmath do

7: @xmath

8: @xmath

9: @xmath

10: if SINR at all receivers of @xmath exceed @xmath then

11: return @xmath

12: end if

13: end for

14: return @xmath

Algorithm 5 integer FirstConflictFreeColor( @xmath )

#### 3.2.4 Performance Results

##### Simulation Model

In the simulation experiments, the location of every node is generated
randomly, using a uniform distribution for its @xmath and @xmath
coordinates, in the deployment area. For a fair comparison of our
algorithm with the Truncated Graph-Based Scheduling Algorithm (TGSA) [
32 ] , we assume that the deployment region is a circular region of
radius @xmath . Thus, if @xmath are the Cartesian coordinates of @xmath
node, @xmath , then @xmath and @xmath subject to @xmath . Equivalently,
if @xmath are the polar coordinates of @xmath node, then @xmath and
@xmath . After generating random positions for @xmath nodes, we have
complete information of @xmath . Using ( 2.4 ) and ( 2.5 ), we compute
the communication and interference radii, and then map the network
@xmath to the two-tier graph @xmath . Once the link schedule is computed
by an algorithm, @xmath is computed using ( 2.14 ). System parameters
are chosen based on their prototypical values in wireless mesh networks
[ 42 ] . For a given set of system parameters, we calculate the average
spatial reuse by averaging @xmath over 1000 randomly generated networks.
Keeping all other parameters fixed, we observe the effect of increasing
the number of nodes @xmath on the average spatial reuse.

In our experiments, we compare the performance of the following
algorithms:

-   ArboricalLinkSchedule (ALS) [ 16 ] ,

-   Truncated Graph-Based Scheduling Algorithm ⁴ ⁴ 4 In Truncated
    Graph-Based Scheduling Algorithm, for the computation of optimal
    number of transmissions @xmath , we follow the method described in [
    32 ] . Since @xmath , we assume that @xmath and compute successive
    Edmundson-Madansky (EM) upper bounds [ 44 ] , [ 45 ] , till the
    difference between successive EM bounds is less than @xmath . We
    have experimentally verified that only high values of @xmath lead to
    reasonable values for @xmath , whereas low values of @xmath , say
    @xmath , lead to the extremely conservative value of @xmath in most
    cases. (TGSA) [ 32 ] ,

-   GreedyPhysical (GP) [ 27 ] ,

-   Proposed ConflictFreeLinkSchedule (CFLS).

##### Performance Comparison under Path Loss Model

In the first set of experiments (Experiment 1), we assume that @xmath m,
@xmath mW, @xmath , @xmath dBm, @xmath dB and @xmath dB [ 42 ] . Thus,
@xmath m and @xmath m. We vary the number of nodes from 30 to 110 in
steps of 5. Figure 3.3 plots the average spatial reuse vs. number of
nodes for all the algorithms.

In the second set of experiments (Experiment 2), we assume that @xmath
m, @xmath mW, @xmath , @xmath dBm, @xmath dB and @xmath dB. Thus, @xmath
m and @xmath m. We vary the number of nodes from 70 to 150 in steps of
5. Figure 3.4 plots the average spatial reuse vs. number of nodes for
all the algorithms.

For the ALS algorithm, we observe that spatial reuse increases very
slowly with increasing number of nodes.

For the TGSA algorithm, we observe that spatial reuse is @xmath - @xmath
lower than that of ALS and @xmath - @xmath lower than that of GP. A
plausible explanation for this behavior is as follows. The basis for
TGSA is the computation of @xmath , the optimal number of transmissions
in every slot [ 32 ] . @xmath is determined by maximizing a lower bound
on the expected number of successful transmissions in a time slot. Since
the partitioning of a maximal independent set of communication arcs into
subsets of cardinality at most @xmath is arbitrary and not
geography-based, there could be scenarios where the transmissions
scheduled in a subset are in the vicinity of each other, resulting in
moderate to high interference. In essence, maximizing this lower bound
does not necessarily translate to maximizing the number of successful
transmissions in a time slot. Also, due to its design, the TGSA
algorithm yields higher number of colors compared to ALS and GP.

Though the GP algorithm is based on communication graph and SINR
conditions, it yields slightly lower spatial reuse than CFLS. A possible
reason for this observation is as follows. The GP algorithm colors edges
of the communication graph in the decreasing order of interference
number. The interference number of edge @xmath is the number of edges
@xmath such that, if @xmath are scheduled simultaneously, then the SINR
threshold condition ( 2.7 ) is violated along one or both links. Edges
with higher interference number tend to be located towards the center of
the deployment region. Since these edges are colored first, a large
number of colors are utilized in the initial stages of the algorithm,
lead to potentially higher schedule length and lower spatial reuse. A
better technique would be successively examine edges at the centre and
the periphery, which is achieved by the partition technique employed by
CFLS.

For the proposed CFLS algorithm, we observe that spatial reuse increases
steadily with increasing number of nodes and is about @xmath higher than
the spatial reuse of ALS, TGSA and GP.

##### Performance Comparison under Realistic Conditions

In a realistic wireless environment, channel impairments like multipath
fading and shadowing affect the received SINR at a receiver [ 14 ] . In
this section, we compare the performance of the ALS, TGSA, GP and CFLS
algorithms in a wireless channel which experiences Rayleigh fading and
lognormal shadowing.

In the absence of fading and shadowing, the SINR at receiver @xmath is
given by ( 2.2 ). We assume that every algorithm (ALS, TGSA, GP and
CFLS) considers only path loss in the channel prior to constructing the
two-tier graph @xmath and computing the link schedule.

However, for computing the average spatial reuse of each algorithm, we
take into account fading and shadowing channel gains between each pair
of nodes. More specifically, for computing the spatial reuse using (
2.14 ), the (actual) SINR at receiver @xmath is given by

  -- -------- -- -------
     @xmath      (3.3)
  -- -------- -- -------

where random variables @xmath and @xmath correspond to channel gains due
to Rayleigh fading and lognormal shadowing respectively. We assume that
@xmath are independent and identically distributed (i.i.d.) random
variables with probability density function (pdf) [ 10 ]

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (3.4)
  -- -------- -------- -------- -- -------

where @xmath is the unit step function. Also, @xmath are assumed to be
i.i.d. zero mean Gaussian random variables with pdf [ 57 ]

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (3.5)
  -- -------- -------- -------- -- -------

Random variables @xmath and @xmath are independent of each other and
also independent of the node locations.

The simulation model and experiments are exactly as described before. In
the simulations, we assume @xmath . For Experiment 1, Figure 3.5 plots
the average spatial reuse vs. number of nodes for all the algorithms.
For Experiment 2, Figure 3.6 plots the average spatial reuse vs. number
of nodes for all the algorithms.

From Figures 3.3 , 3.4 , 3.5 and 3.6 , we observe that spatial reuse
decreases by @xmath - @xmath in a channel experiencing multipath fading
and shadowing effects. A plausible explanation for this observation is
as follows. Since the channel gains between every pair of nodes are
independent of each other, it is reasonable to assume that the
interference power at a typical receiver remains almost the same as in
the non-fading case. This is because, even if the power received from
few unintended transmitters is low, the power received from other
unintended transmitters will be high (on average); thus the interference
power remains constant. Consequently, the change in SINR is determined
by the change in received signal power only. If the received signal
power is higher compared to the non-fading case, the transmission is
anyway successful and spatial reuse remains unchanged (see ( 2.14 )).
However, if the received signal power is lower, the transmission is now
unsuccessful and spatial reuse decreases. Hence, on average, the spatial
reuse decreases.

Finally, from Figures 3.5 and 3.6 , we observe that the proposed CFLS
algorithm achieves @xmath - @xmath higher spatial reuse than the ALS and
GP algorithms and @xmath - @xmath higher spatial reuse than the TGSA
algorithm, under realistic wireless channel conditions.

#### 3.2.5 Analytical Results

In this section, we derive upper bounds on the running time
(computational) complexity of ConflictFreeLinkSchedule algorithm. We use
the following notation with respect to the communication graph @xmath :

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath            
              @xmath            
                       @xmath   
  -- -------- -------- -------- --

Before we prove our results, it is instructive to observe Figure 3.7 ,
which shows the variation of @xmath and @xmath with @xmath for the two
experiments described in Section 3.2.4 . Since determining the thickness
of a graph is NP-hard [ 58 ] , each value of @xmath in Figure 3.7 is an
upper bound on the actual thickness based on the number of forests into
which the undirected equivalent of the communication graph has been
decomposed using successive breadth first searches. We observe that the
graph thickness increases very slowly with the number of vertices @xmath
, while the number of edges increases super-linearly with the number of
vertices.

###### Lemma 3.2.1.

An oriented graph @xmath can be colored using no more than @xmath colors
using ConflictFreeLinkSchedule.

###### Proof.

Since an oriented graph with @xmath vertices has at most @xmath edges,
the edges of @xmath can be colored with at most @xmath colors. ∎

###### Lemma 3.2.2.

For an oriented graph @xmath , the running time of
ConflictFreeLinkSchedule is @xmath .

###### Proof.

Assuming that an element can be chosen randomly and uniformly from a
finite set in unit time ( [ 53 ] , Chapter 1), the running time of Phase
1 can be shown to be @xmath . Since there is only one oriented graph,
Phase 2 runs in time @xmath . In Phase 3, the unique edge associated
with the vertex under consideration is assigned a color using
FirstConflictFreeColor. From Lemma 3.2.1 , the size of the set of colors
to be examined @xmath is @xmath . In FirstConflictFreeColor, the SINR is
checked only once for every colored edge in the set @xmath and at most
@xmath times for the edge under consideration @xmath . With a careful
implementation, FirstConflictFreeColor runs in time @xmath . So, the
running time of Phase 3 is @xmath . Thus, the total running time is
@xmath . ∎

###### Theorem 3.2.3.

For an arbitrary graph @xmath , the running time of
ConflictFreeLinkSchedule is @xmath .

###### Proof.

Assuming that an element can be chosen randomly and uniformly from a
finite set in unit time [ 53 ] , the running time of Phase 1 can be
shown to be @xmath . For Phase 2, the optimal partitioning technique of
[ 49 ] based on Matroids can be used to partition the communication
graph @xmath into at most @xmath oriented graphs in time @xmath . Thus,
@xmath holds for Phase 3. From Lemma 3.2.2 , it follows that the first
oriented graph @xmath can be colored in time @xmath . However, consider
the coloring of @xmath oriented graph @xmath , where @xmath . When
coloring edge @xmath from @xmath using FirstConflictFreeColor, conflicts
can occur not only with the colored edges of @xmath , but also with the
edges of the previously colored oriented graphs @xmath . Hence, the
worst-case size of the set of colors to be examined @xmath is @xmath .
Note that in FirstConflictFreeColor, the SINR is checked only once for
every colored edge in the set @xmath and at most @xmath times for the
edge under consideration @xmath . With a careful implementation,
FirstConflictFreeColor runs in time @xmath . Hence, any subsequent
oriented graph @xmath can be colored in time @xmath . Thus, the running
time of Phase 3 is @xmath . Therefore, the overall running time of
ConflictFreeLinkSchedule is @xmath . ∎

#### 3.2.6 Discussion

In this section, we have developed ConflictFreeLinkSchedule, a point to
point link scheduling algorithm for an STDMA wireless mesh network under
the physical interference model. The performance of the proposed
algorithm is superior to those of existing link scheduling algorithms
for STDMA wireless networks with uniform power assignment. A practical
experimental modeling shows that, on average, the proposed algorithm
achieves @xmath higher spatial reuse than the ArboricalLinkSchedule [ 16
] , GreedyPhysical [ 27 ] and Truncated Graph-Based Scheduling [ 32 ]
algorithms. Since link schedules are constructed offline only once and
then used by the network for a long period of time, these improvements
in performance directly translate to higher long-term network
throughput.

The computational complexity of ConflictFreeLinkSchedule is comparable
to the computational complexity of ArboricalLinkSchedule and is much
lower than the computational complexity of GreedyPhysical and Truncated
Graph-Based Scheduling algorithms. Thus, in cognizance of spatial reuse
as well as computational complexity, ConflictFreeLinkSchedule appears to
be a good candidate for efficient STDMA link scheduling algorithms.

## Chapter 4 Point to Point Link Scheduling based on SINR Graph Model

In this chapter, we propound a somewhat different approach for point to
point link scheduling in an STDMA wireless network under the physical
interference model. This approach is based on SINR graph representation
of the network wherein weights of edges correspond to interferences
between pairs of nodes and weights of vertices correspond to normalized
noise powers at receiving nodes. We develop a novel link scheduling
algorithm with polynomial time complexity and improved performance in
terms of spatial reuse.

The rest of the chapter is organized as follows. We motivate our SINR
graph approach in Section 4.1 . We describe the proposed link scheduling
algorithm and provide an illustrative example in Section 4.2 . We prove
the correctness of the algorithm and derive its computational complexity
in Section 4.3 . The performance of the proposed algorithm is compared
with existing link scheduling algorithms in Section 4.4 . We discuss the
implications of our work in Section 4.5 .

### 4.1 Motivation

The system model, notation and problem formulation are exactly as
described in Section 3.2.1 . Specifically, we seek a low complexity
conflict-free point to point link scheduling algorithm that achieves
high spatial reuse.

In general, for the STDMA wireless network @xmath , the set of links to
be scheduled is determined by a routing algorithm. For simplicity, we
only consider exhaustive link schedules, i.e., we consider uniform load
on all links.

Note that for point to point link schedules that are conflict-free,
i.e., for link schedules that satisfy ( 2.7 ), the equation for spatial
reuse ( 2.14 ) reduces to

  -- -- -------- -------- -- -------
        @xmath   @xmath      (4.1)
  -- -- -------- -------- -- -------

where @xmath denotes the number of directed edges in the communication
graph @xmath and @xmath denotes the number of slots in the link
schedule. Therefore, for conflict-free link schedules, maximizing
spatial reuse is equivalent to minimizing the number of colors, i.e.,
minimizing the schedule length.

To the best of our knowledge, there is no known polynomial time
algorithm that determines a provably optimal schedule (minimum length
schedule) for an STDMA wireless network with constrained transmission
power. Hence, the only recourse is to devise heuristics and show their
efficiency theoretically and experimentally. Towards this end, we
propose a heuristic based on an SINR graph representation of the
network.

Consider any directed graph @xmath , where @xmath is the set of vertices
and @xmath is the set of edges. The line graph of @xmath is the graph
@xmath whose vertices are the edges of @xmath , i.e., @xmath [ 35 ] .
The SINR graph that we consider in this chapter is analogous to the
concept of line graph in [ 35 ] . However, unlike the line graph, we
assume that the SINR graph is a complete graph, i.e., for any two
distinct vertices @xmath , @xmath @xmath , there is a directed edge from
@xmath to @xmath in @xmath .

The crux of the proposed link scheduling algorithm can be understood by
revisiting the condition for successful packet reception under the
physical interference model (Equation 2.6 ), i.e.,

  -- -- -- -------
           (4.2)
  -- -- -- -------

Rearranging the terms in ( 4.2 ), we obtain

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (4.3)
  -- -------- -------- -------- -- -------

Dropping time slot index @xmath for clarity, we obtain the “equivalent”
SINR threshold condition

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (4.4)
  -- -------- -------- -------- -- -------

where @xmath , @xmath and @xmath can be interpreted as @xmath
transmitter, @xmath receiver and number of concurrent transmissions,
respectively, in a given time slot. The terms appearing in ( 4.4 )
correspond to vertex and edge weights in a special graph representation
of the STDMA network, termed as SINR graph. This idea will be elucidated
further in Section 4.2.1 .

### 4.2 SINRGraphLinkSchedule Algorithm

In this section, we explain the proposed link scheduling algorithm based
on SINR graph representation of the STDMA network. We provide an
illustrative example to elucidate the intricacies of the proposed
algorithm.

#### 4.2.1 Description

1: Input: Communication graph @xmath ( @xmath , @xmath ), @xmath ,
@xmath , @xmath

2: Output: A coloring @xmath : @xmath

3: @xmath

4: Construct the directed complete graph @xmath

5: for all @xmath do

6: if edges @xmath and @xmath have a common vertex in @xmath then

7: @xmath

8: else

9: @xmath

10: end if

11: end for

12: for all @xmath do

13: @xmath

14: end for

15: for all @xmath do

16: @xmath

17: end for

18: @xmath ; @xmath

19: while @xmath do

20: @xmath ; choose @xmath randomly

21: @xmath ; @xmath ; @xmath ; @xmath

22: while @xmath and @xmath and @xmath do

23: for all @xmath such that @xmath do

24: @xmath

25: for all @xmath do

26: if @xmath then

27: @xmath

28: end if

29: end for

30: if @xmath and @xmath then

31: @xmath ; @xmath ; @xmath

32: else

33: @xmath

34: end if

35: end for

36: if @xmath then

37: @xmath

38: end if

39: end while

40: end while

Algorithm 6 SINRGraphLinkSchedule (SGLS)

The proposed link scheduling algorithm under the physical interference
model is SINRGraphLinkSchedule (SGLS), which considers the communication
graph @xmath .

First, we construct a directed complete SINR graph @xmath that has the
edges of @xmath as its vertices, i.e., @xmath . Let the edges of @xmath
and the corresponding vertices of @xmath be labeled @xmath . Let @xmath
and @xmath denote the transmitter and receiver respectively of edge
@xmath in @xmath . For any two edges @xmath and @xmath in graph @xmath ,
the interference weight function @xmath is defined as:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

The interference weight function @xmath indicates the interference
energy at @xmath due to transmission from @xmath to @xmath scaled with
respect to the signal energy of @xmath at @xmath . Note that the
interference weight function appears as a summand in the equivalent SINR
threshold condition ( 4.4 ).

We then compute the co-schedulability weight function @xmath . For any
two edges @xmath and @xmath in @xmath , the weight of edge @xmath in
@xmath is given by @xmath . Since @xmath and @xmath represent
interferences among links @xmath and @xmath in the STDMA network @xmath
, @xmath and @xmath intuitively represent the co-schedulability of links
@xmath and @xmath in @xmath (equivalently, co-schedulability of vertices
@xmath and @xmath in @xmath ). For example, if @xmath is greater than or
equal to @xmath , then the interference at the receiver of link @xmath
from the transmitter of link @xmath is very high and these links cannot
be scheduled simultaneously. This will result in @xmath being equal to
@xmath indicating that vertices @xmath and @xmath in @xmath are not
co-schedulable. On the other hand, if @xmath is slightly greater than
@xmath @xmath , @xmath will be slightly less than @xmath indicating that
the vertices @xmath and @xmath in @xmath are co-schedulable. Note that
for the SINR graph @xmath , the weight of an edge refers to the value of
co-schedulability function for that edge.

Next, we determine the normalized noise power at the receiver of each
link of @xmath . This is tantamount to computing the normalized noise
power for each edge of @xmath , i.e., at each vertex of @xmath . Note
that the normalized noise power function appears as a term in the
equivalent SINR threshold condition ( 4.4 ).

Our objective is to color the vertices of @xmath (equivalently, edges of
@xmath ) using minimum number of colors under the physical interference
model, i.e., subject to the condition that the SINR at the receiver of
every link in @xmath is no less than the communication threshold @xmath
. Equivalently, for any @xmath , the coloring of all vertices @xmath
with the same color is defined to be feasible if

  -- -------- -- -------
     @xmath      (4.5)
  -- -------- -- -------

In the SINR graph @xmath , this condition translates to the sum of
weights of edges incoming to a vertex from all co-colored vertices being
greater than the sum of the number of remaining co-colored vertices and
the normalized noise power minus a constant factor (unity); this will be
proved in Theorem 4.3.1 .

Finally, we color vertices of @xmath , i.e., edges of @xmath , according
to the following procedure. Let @xmath denote the set of uncolored
vertices of @xmath . Initially, @xmath includes all vertices of @xmath .
First, we choose a vertex randomly from @xmath . This is assigned a new
color, say @xmath . Then, we consider every vertex @xmath from @xmath
such that the sum of weights of all the edges between @xmath and the
vertices colored with @xmath is positive. Next, for each vertex colored
with @xmath , we check if the sum of weights of all incoming edges is
greater than the sum of the number of vertices colored with @xmath and
the normalized noise power at that vertex minus a constant factor
(unity). If this inequality is satisfied, we further check if the sum of
weights of all edges incoming to @xmath is greater than the sum of the
number of vertices colored with @xmath and the normalized noise power at
@xmath minus unity. If this inequality is also satisfied, then vertex
@xmath is colored with @xmath . If any of these inequalities are not
satisfied, vertex @xmath is colored with a new color. The algorithm
exits when all the vertices are colored. The pseudocode of the algorithm
is provided in Algorithm 6 .

#### 4.2.2 Example

Consider the STDMA wireless network @xmath whose deployment is shown in
Figure 4.1 . It consists of four labeled nodes whose coordinates (in
meters) are @xmath , @xmath , @xmath and @xmath . We use typical values
of system parameters in wireless networks [ 42 ] . These values are
shown in Table 4.1 , which lead to @xmath m.

The communication graph model of the STDMA network is shown in Figure
4.2 . The communication graph @xmath consists of four vertices and six
directed edges. The vertex and edge sets are given by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (4.6)
     @xmath   @xmath   @xmath      (4.7)
  -- -------- -------- -------- -- -------

The SINR graph model of the communication graph @xmath is shown in
Figure 4.3 . The SINR graph @xmath is a complete graph and consists of
six vertices and thirty directed edges. The vertex set of the SINR graph
is given by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (4.8)
  -- -------- -------- -------- -- -------

The edge set @xmath of the SINR graph is enumerated in Table 4.2 , along
with the interference weight function @xmath and co-schedulability
weight function @xmath for each edge @xmath . The normalized noise
powers at vertices of the SINR graph are enumerated in Table 4.3 .

The truncated SINR graph @xmath is shown in Figure 4.4 . The truncated
SINR graph consists of all vertices of the SINR graph and only those
edges whose co-schedulability weight function is positive, i.e., @xmath
. The values of the co-schedulability weight functions for all edges and
the normalized noise powers at all vertices are also shown in the
figure. We use the truncated SINR graph to explain the SGLS algorithm,
since edges having zero weight in the SINR graph do not play any role in
the SGLS algorithm. Note that, in the truncated SINR graph, the weight
of an edge refers to the value of the co-schedulability weight function
for that edge.

Initially, the set of uncolored vertices is @xmath . In the first
iteration, we randomly choose @xmath and assign it Color @xmath (say,
red). So, @xmath . The set of uncolored vertices is @xmath and the set
of vertices colored 1 is @xmath . From the set of uncolored vertices
@xmath , we consider every vertex @xmath such that the sum of weights of
edges from the presently colored vertex @xmath to @xmath and from @xmath
to the presently colored vertex is positive. From Figure 4.4 , we obtain
two candidates: @xmath and @xmath . We first examine the candidate
vertex @xmath . We check if the weight of the edge from @xmath to the
presently colored vertex @xmath is no greater than the number of
vertices colored with the present color (red) plus the normalized noise
power at the colored vertex minus unity. Our calculations show that
inequality holds @xmath and candidate vertex @xmath cannot be assigned
Color 1. We next examine the candidate vertex @xmath . We check if the
weight of the edge from the candidate vertex to @xmath is no greater
than the number of vertices colored with the present color plus the
normalized noise power at @xmath minus unity. Our calculations show that
inequality does not hold @xmath . Furthermore, we check if the weight of
the edge from the presently colored vertex @xmath to the candidate
vertex @xmath is greater than the number of vertices colored red plus
the normalized noise power at @xmath minus unity. The inequality holds
and hence the candidate vertex @xmath is assigned Color 1 (red). So,
@xmath . The set of uncolored vertices is @xmath and the set of vertices
colored 1 is @xmath . Again, from the set of uncolored vertices @xmath ,
we consider every vertex @xmath such that the sum of weights of edges
from the presently colored vertices @xmath to @xmath and from @xmath to
the presently colored vertices is positive. From Figure 4.4 , the
candidate vertices are @xmath and @xmath . Consider the candidate vertex
@xmath . For every vertex @xmath colored 1, we check if the sum of
weights of edges from remaining co-colored vertices and the candidate
vertex to the colored vertex is no greater than the number of co-colored
vertices and the normalized noise power at the colored vertex minus
unity. For the colored vertex @xmath , our calculations show that
inequality holds @xmath . So, we discard @xmath , consider the next
candidate vertex @xmath and perform an analogous comparison with @xmath
. Since inequality holds in this case too @xmath , we discard @xmath and
proceed to the next iteration. The set of vertices colored so far is
shown in Figure 4.5 .

In the second iteration, we randomly choose @xmath and assign it Color 2
(say, blue). So, @xmath . The set of uncolored vertices is @xmath and
the set of vertices colored 2 is @xmath . From the set of uncolored
vertices @xmath , we consider every vertex @xmath such that the sum of
weights of edges from the presently colored vertex @xmath to @xmath and
from @xmath to the presently colored vertex is positive. From Figure 4.5
, no such vertex exists. So, we proceed to the next iteration. The
vertices colored so far are shown in Figure 4.6 .

In the third iteration, we randomly choose @xmath and assign it Color 3
(say, green). So, @xmath . The set of uncolored vertices is @xmath and
the set of vertices colored 3 is @xmath . From the set of uncolored
vertices @xmath , we consider every vertex @xmath such that the sum of
weights of edges from the presently colored vertex @xmath to @xmath and
from @xmath to the presently colored vertex is positive. From Figure 4.4
, we obtain @xmath as the only candidate vertex. Next, we check if the
weight of the edge from the candidate vertex @xmath to the presently
colored vertex @xmath is no greater than the number of vertices colored
with the present color (green) plus the normalized noise power at the
colored vertex minus unity. Our calculations show that inequality does
not hold @xmath . So, we further check if the weight of the edge from
the presently colored vertex @xmath to the candidate vertex @xmath
exceeds the number of vertices colored with the present color plus the
normalized noise power at the candidate vertex minus unity. Since the
inequality holds @xmath , the candidate vertex @xmath is assigned Color
3 (green). So, @xmath . The set of uncolored vertices is @xmath and the
set of vertices colored green is @xmath . Next, from the set of
uncolored vertices @xmath , we choose that uncolored vertex @xmath such
that the sum of weights of edges from @xmath to the set of presently
colored vertices @xmath and from @xmath to @xmath is positive. From
Figure 4.6 , no such vertex @xmath exists. So, we proceed to the next
iteration. Figure 4.7 shows the set of vertices colored so far.

In the fourth iteration, @xmath is the only uncolored vertex. So, we
choose @xmath and assign it Color 4 (say, pink). The set of vertices
colored 4 is @xmath and the set of uncolored vertices is @xmath . So,
the algorithm ends. The final coloring of vertices of the truncated SINR
graph by SGLS algorithm is shown in Figure 4.8 .

The output of the SGLS algorithm is enumerated in Table 4.4 and is also
shown pictorially in Figure 4.9 . The resulting link schedule is denoted
by @xmath , where

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Finally, we check if the link schedule enumerated in Table 4.4 is
conflict-free, i.e., if the SINR threshold condition ( 2.7 ) is
satisfied at every receiver for the STDMA network described by Figure
4.1 and Table 4.1 . Only one transmitter-receiver pair is active during
time slots 2 and 4. Since the receiver is within the communication range
of its corresponding transmitter for each of these time slots, the SINR
threshold condition is satisfied trivially for time slots 2 and 4. Two
transmitter-receiver pairs are active during time slots 1 and 3. In time
slot 1, the active transmitter-receiver pairs are @xmath and @xmath .
Our computations show that the SINRs at Receivers 2 and 3 are @xmath dB
and @xmath dB, both of which exceed the communication threshold of
@xmath dB. In time slot 3, the active transmitter-receiver pairs are
@xmath and @xmath . Our computations show that the SINRs at Receivers 1
and 4 are @xmath dB and @xmath dB respectively, both of which exceed the
communication threshold. This verifies that the SGLS algorithm yields a
conflict-free link schedule for the network described by Figure 4.1 and
Table 4.1 . Note that, from ( 4.1 ), the spatial reuse of SGLS algorithm
for this network is @xmath .

### 4.3 Analytical Results

In this section, we prove the correctness of the SGLS algorithm and
derive its running time (computational) complexity. We follow the
notation of Algorithm 6 .

###### Theorem 4.3.1.

For any @xmath , if

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (4.9)
  -- -------- -------- -------- -- -------

then the coloring of all vertices of @xmath with the same color is
feasible.

###### Proof.

Recall that @xmath or @xmath and that @xmath . Suppose @xmath for some
@xmath , @xmath , then

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

which contradicts the hypothesis since @xmath . So, an edge connecting
any two vertices in @xmath must have positive weight. Thus, @xmath
@xmath @xmath , @xmath . Equivalently, @xmath @xmath @xmath , @xmath .
If two vertices @xmath (equivalently, edges @xmath ) have a common
vertex in @xmath , then @xmath , which is a contradiction. So, no two
vertices in @xmath have a common vertex in @xmath . From the hypothesis,

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Therefore, the SINR threshold condition ( 4.5 ) is satisfied at the
receivers of all vertices of @xmath . ∎

With respect to (w.r.t.) the communication graph @xmath , let:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

###### Theorem 4.3.2.

The running time complexity of SGLS algorithm is @xmath .

###### Proof.

@xmath . Since @xmath is a directed complete graph, @xmath . Since the
computation of @xmath for given edges @xmath and @xmath of @xmath takes
unit time, the computation of interference weight functions for all
edges of @xmath takes @xmath time. Similarly, the computation of
co-schedulability weight functions for all edges of @xmath requires
@xmath time. The computation of normalized noise powers at all vertices
of @xmath takes @xmath time.

In @xmath , let @xmath denote the total number of colors used to color
all vertices and let @xmath denote the number of vertices assigned color
@xmath , i.e., @xmath . Since @xmath can never exceed the number of
vertices in @xmath , i.e., the number of edges in @xmath , @xmath is
@xmath . The time required by Lines 20-21 is @xmath , let it be @xmath ,
where @xmath is a constant.

With a careful implementation of storing @xmath @xmath @xmath , Lines
26-28 take @xmath time. Thus, Lines 25-29 take @xmath time, let it be
equal to @xmath , where @xmath is a constant. Along similar arguments,
Lines 30-34 take @xmath time, let it be equal to @xmath , where @xmath
is a constant. The time required by Lines 36-38 is @xmath , where @xmath
is a constant. Thus, the total running time of the coloring phase is

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Since @xmath , it follows that @xmath . Furthermore, for any color
@xmath , @xmath . Thus, @xmath . Therefore

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

Hence, the total running time complexity of SGLS algorithm is @xmath . ∎

### 4.4 Performance Results

In this section, we demonstrate the efficacy of SGLS algorithm via
simulations. To the best of our knowledge, for an STDMA network with
constrained transmission power, there is no existing work on link
scheduling that utilizes an SINR graph representation of the network.
However, for completeness, we compare the performance of SGLS algorithm
with the CFLS algorithm proposed in Chapter 3 . Note that SGLS is based
on SINR graph while CFLS is based on communication graph and verifying
SINR conditions.

In the simulation experiments, the location of every node is generated
randomly using a uniform distribution for its @xmath and @xmath
coordinates. We assume that the deployment area is a circular region of
radius @xmath . The values chosen for system parameters @xmath , @xmath
, @xmath and @xmath are prototypical values of system parameters in
wireless networks [ 42 ] . After generating random positions for @xmath
nodes, we have complete information of @xmath . Once the link schedule
@xmath is computed by every algorithm, @xmath is computed using ( 4.1 ).
For a given set of system parameters, we calculate the average spatial
reuse by averaging @xmath over 1000 randomly generated networks. Keeping
all other parameters fixed, we observe the effect of increasing the
number of nodes @xmath on the average spatial reuse.

In the first experiment (Experiment 1), we assume that @xmath m, @xmath
mW, @xmath , @xmath dBm and @xmath dB. Thus, @xmath m. We vary the
number of nodes from 30 to 110 in steps of 5. Figure 4.10 plots the
average spatial reuse vs. number of nodes for both the algorithms.

In the second experiment (Experiment 2), we assume that @xmath m, @xmath
mW, @xmath , @xmath dBm and @xmath dB. Thus, @xmath m. We vary the
number of nodes from 70 to 150 in steps of 10. Figure 4.11 plots the
average spatial reuse vs. number of nodes for both the algorithms.

From the figures, we observe that SGLS achieves 5-10% higher spatial
reuse than CFLS. However, this improvement in performance is obtained at
the cost of higher computational complexity.

### 4.5 Discussion

In this chapter, we have proposed a novel point to point link scheduling
algorithm based on an SINR graph representation of an STDMA wireless
network under the physical interference model. Our results demonstrate
that the spatial reuse for the proposed algorithm is higher than that of
the ConflictFreeLinkSchedule algorithm. This is due to the fact that we
have embedded interference conditions between pairs of nodes into the
edge weights and normalized noise powers at receiver nodes into vertex
weights of the SINR graph and consequently determined a conflict-free
schedule. Our approach has the potential to scale with the number of
nodes in the network.

## Chapter 5 Point to Multipoint Link Scheduling: A Hybrid Approach

In this chapter, we investigate point to multipoint link scheduling in
STDMA wireless networks. We generalize the definition of spatial reuse
introduced in Chapter 2 for point to multipoint link scheduling. We
propose a “hybrid” link scheduling algorithm based on a communication
graph representation of the network and SINR conditions. We demonstrate
that the proposed algorithm achieves higher spatial reuse than existing
algorithms, without any increase in running time complexity.

The rest of this chapter is organized as follows. In Section 5.1 , we
describe our system model. We describe point to multipoint link
scheduling based on the protocol interference model in Section 5.2 and
describe its limitations in Section 5.3 . In Section 5.4 , we introduce
spatial reuse as our performance metric and formulate the problem. In
Section 5.5 , we describe the proposed link scheduling algorithm. We
evaluate its performance in Section 5.6 and derive its computational
complexity in Section 5.7 . We discuss the implications of our work in
Section 5.8 .

### 5.1 System Model

Our system model and notations are exactly as described in Section 2.1 .
However, we redefine and introduce terms that are applicable to point to
multipoint link scheduling.

If node @xmath is within node @xmath ’s communication range, then @xmath
is defined as a neighbor of @xmath , since @xmath can decode @xmath ’s
packet correctly (subject to Equation 2.6 ). Note that if node @xmath is
outside node @xmath ’s communication range, then it can never decode
@xmath ’s packet correctly (from Equation 2.6 ). The number of neighbors
of node @xmath is denoted by @xmath .

A point to multipoint link schedule for an STDMA wireless network @xmath
is a mapping from the set of nodes to time slots. Let @xmath denote the
number of time slots in a point to multipoint link schedule. For a given
time slot @xmath , @xmath point to multipoint transmission is denoted by
@xmath , where @xmath denotes the index of the node which transmits a
packet and @xmath denote the indices of neighboring nodes (neighbors of
@xmath ) that receive the packet. Note that @xmath denotes @xmath
receiver of @xmath transmission in time slot @xmath . Let @xmath denote
the number of concurrent point to multipoint transmissions in time slot
@xmath . A point to multipoint link schedule for an STDMA network @xmath
is denoted by @xmath , where

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

Every point to multipoint schedule @xmath must satisfy the following:

1.  Operational constraints:

    1.  A node cannot transmit and receive in the same time slot, i.e.,

          -- -------- -------- -------- -- -------
             @xmath   @xmath   @xmath      (5.1)
          -- -------- -------- -------- -- -------

    2.  A node cannot receive from multiple transmitters in the same
        time slot, i.e.,

          -- -------- -- -------
             @xmath      (5.2)
          -- -------- -- -------

2.  Range constraint: Every receiver is within the communication range
    of its intended transmitter, i.e.,

      -- -------- -- -------
         @xmath      (5.3)
      -- -------- -- -------

For an example, consider the STDMA wireless network @xmath shown in
Figure 5.1(a) . It consists of six nodes whose coordinates (in meters)
are @xmath , @xmath , @xmath , @xmath , @xmath and @xmath . One of the
possible point to multipoint link schedules for this STDMA network is
shown in Figure 5.1(b) . The schedule length is @xmath time slots and
the schedule is defined by @xmath , where

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

After 5 time slots, the schedule repeats periodically, as shown in
Figure 5.1(b) .

A point to multipoint link scheduling algorithm is a set of rules that
is used to determine a schedule @xmath . Typically, a scheduling
algorithm is required to satisfy certain objectives.

Consider @xmath receiver of @xmath transmission in time slot @xmath ,
i.e., receiver @xmath . The power received at @xmath from its intended
transmitter @xmath (signal power) is @xmath . The power received at
@xmath from its unintended transmitters (interference power) is @xmath .
Thus, the SINR at receiver @xmath is given by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (5.4)
  -- -------- -------- -------- -- -------

According to the physical interference model [ 15 ] , receiver @xmath
can successfully decode the packet transmitted by @xmath if the SINR at
@xmath is no less than the communication threshold @xmath , i.e.,

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (5.5)
  -- -------- -------- -------- -- -------

A link schedule @xmath is exhaustive if every two nodes @xmath , @xmath
who are neighbors of each other are included in the schedule exactly
twice, once with @xmath being a transmitter and @xmath being one of its
receivers, and during another time slot with @xmath being a transmitter
and @xmath being one of its receivers.

### 5.2 Equivalence of Link Scheduling and Graph Vertex Coloring

In this section, we describe the equivalence between a point to
multipoint link schedule for an STDMA wireless network and the coloring
of vertices of the communication graph representation (see Section 2.2.1
) of the network.

Consider the STDMA wireless network @xmath whose deployment is shown in
Figure 5.1(a) . The system parameters for this network are given in
Table 5.1 . From ( 2.4 ), we obtain @xmath m. The corresponding
communication graph representation @xmath is shown in Figure 5.2 . The
communication graph comprises of 6 vertices and 14 directed
communication edges. The vertex and communication edge sets are given by

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (5.6)
     @xmath   @xmath   @xmath            (5.7)
                                @xmath   
  -- -------- -------- -------- -------- -------

Given the above representation of an STDMA network, a point to
multipoint link schedule @xmath can be considered as equivalent to
assigning a unique color to every vertex in the communication graph,
such that nodes with the same color transmit simultaneously in a
particular time slot. For the example network considered, the link
schedule shown in Figure 5.1(b) corresponds to the coloring of the
vertices of the communication graph shown in Figure 5.3 . Time slots 1,
2, 3, 4 and 5 in @xmath correspond to colors red, blue, green, magenta
and yellow in @xmath respectively. Note that a coloring algorithm that
uses the least number of colors also minimizes the schedule length.

Algorithms for assigning nodes to time slots (equivalently, colors)
require that two vertices @xmath , @xmath can be colored the same if and
only if:

1.  edge @xmath and edge @xmath , i.e., there is no primary vertex
    conflict, and

2.  there is no vertex @xmath such that @xmath and @xmath , i.e., there
    is no secondary vertex conflict .

These criteria are based on the operational constraints ( 5.1 ) and (
5.2 ).

Algorithms based on the protocol interference model represent the
network by a communication graph and utilize various graph coloring
methodologies to devise heuristics which yield a minimum length
schedule. Hence, such algorithms have the merit of low computational
complexity. However, recent research suggests that these algorithms
yield low network throughput. This aspect is elaborated in the following
section.

### 5.3 Limitations of Algorithms based on Protocol Interference Model

In this section, we illustrate that algorithms based on the protocol
interference model can result in schedules that yield low network
throughput. Note that the limitations of point to multipoint link
scheduling algorithm are similar to those of point to point link
scheduling algorithms described in Section 2.3 .

With the intent of maximizing the throughput of an STDMA network,
algorithms based on the protocol interference model transform the
scheduling problem to a vertex coloring problem for the communication
graph representation of the network. For example, the BroadcastSchedule
algorithm [ 16 ] works in two phases. In Phase 1, the vertices of the
communication graph are labeled using the labeler function (Algorithm 2
, Section 3.1 ). In Phase 2, vertices are considered in increasing order
of label. For the vertex @xmath under consideration, it discards any
color that leads to primary or secondary vertex conflicts with @xmath .
The least color among the residual set of non-conflicting colors is used
to color vertex @xmath . If no non-conflicting color exists, vertex
@xmath is colored with a new color.

The simplification of the link scheduling problem in a wireless network
as a vertex coloring problem on the communication graph can result in
schedules that violate the SINR threshold condition ( 5.5 ).
Specifically, algorithms based on the protocol interference model do not
necessarily maximize the throughput of an STDMA network because:

1.  They can result in high cumulative interference at a receiver, due
    to hard-thresholding based on communication radius. This is because
    the SINR at receiver @xmath decreases with an increase in the number
    of concurrent transmissions @xmath , while @xmath has been defined
    for a single transmission only.

    For example, consider the STDMA wireless network whose deployment is
    shown in Figure 5.4 . The network consists of six nodes whose
    coordinates (in meters) are @xmath , @xmath , @xmath , @xmath ,
    @xmath and @xmath . The system parameters are shown in Table 5.1 ,
    which yields @xmath m. The communication graph model of the STDMA
    network is shown in Figure 5.5 . Consider the transmission requests
    @xmath and @xmath , which correspond to vertices @xmath and @xmath
    of the graph shown in Figure 5.5 . Note that vertices @xmath and
    @xmath do not have primary or secondary vertex conflicts. So, to
    minimize the number of colors, such an algorithm will color these
    vertices with the same color, as shown in Figure 5.6 . Equivalently,
    transmissions @xmath and @xmath will be scheduled in the same time
    slot, say time slot @xmath . However, our computations show that the
    SINRs at receivers @xmath , @xmath , @xmath and @xmath are @xmath
    dB, @xmath dB, @xmath dB and @xmath dB respectively. Figure 5.7
    shows the nodes of the network along with the labeled
    transmitter-receivers sets, receiver-centric communication zones and
    SINRs at the receivers. From the SINR threshold condition ( 5.5 ),
    transmission @xmath is successful, while transmissions @xmath ,
    @xmath and @xmath are unsuccessful. This leads to low network
    throughput.

2.  Moreover, these algorithms are not aware of the topology of the
    network, i.e., they determine a link schedule without being
    cognizant of the exact positions of the transmitters and receivers.

As argued above, point to multipoint link scheduling algorithms based on
the protocol interference model can result in low network throughput. In
essence, algorithms that construct an approximate model of an STDMA
network (communication graph) and concentrate on minimizing the schedule
length do not necessarily maximize network throughput. This observation
is developed into a proposal for an appropriate performance metric in
Section 5.4 .

### 5.4 Problem Formulation

In this section, we motivate the need for a performance metric that
takes into account the SINR threshold condition ( 5.5 ) as the criterion
for successful packet reception. Analogous to the notion of spatial
reuse, we propose a performance metric for point to multipoint link
scheduling, which is also termed as spatial reuse. We argue that spatial
reuse is directly proportional to the number of successful point to
multipoint transmissions. Finally, we formulate the scheduling problem
from a perspective of maximizing spatial reuse.

Algorithms based on the protocol interference model are inadequate to
design efficient point to multipoint link schedules. This is because
these algorithms are entirely based on the communication graph @xmath ,
which is a crude approximation of @xmath , and can lead to low network
throughput, as argued in Section 5.3 . On the other hand, from @xmath
and @xmath , one can exhaustively determine the link schedule @xmath
which yields highest network throughput according to the physical
interference model. However, this is a combinatorial optimization
problem of prohibitive complexity @xmath and is thus computationally
infeasible.

To overcome these problems, we propose a point to multipoint link
scheduling algorithm for STDMA wireless networks under the physical
interference model. Our algorithm is based on the communication graph
model @xmath as well as SINR computations.

To evaluate the performance of our algorithm and compare it with
existing link scheduling algorithms, we define the notion of spatial
reuse. Consider the point to multipoint link schedule @xmath for the
STDMA network @xmath . Under the physical interference model,
transmission @xmath is successful if and only if ( 5.5 ) is satisfied.
The spatial reuse of the link schedule @xmath is defined as the average
number of successful point to multipoint transmissions per time slot.
Thus

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (5.8)
  -- -------- -------- -------- -- -------

where @xmath denote the indicator function for event @xmath , i.e.,
@xmath if event @xmath occurs, @xmath if event @xmath does not occur.
Note that in ( 5.8 ), the number of nodes that successfully receive a
transmitted packet is normalized by the number of neighbors of the
transmitting node. A high value of spatial reuse corresponds to high
network throughput.

The essence of STDMA is to have a reasonably large number of
simultaneous and successful transmissions. For an STDMA wireless network
which is operational for a long period of time, say @xmath time slots,
the total number of successful point to multipoint transmissions is
@xmath . Thus, a high value of spatial reuse directly translates to
higher network throughput and the number of colors @xmath is relatively
unimportant. Hence, spatial reuse turns out to be a crucial metric for
the comparison of various STDMA link scheduling algorithms.

Our goal is to design a low complexity point to multipoint link
scheduling algorithm that achieves high spatial reuse, where spatial
reuse is given by ( 5.8 ). We only consider link schedules that are
feasible and exhaustive.

### 5.5 MaxAverageSINRSchedule Algorithm

Our proposed point to multipoint link scheduling scheduling algorithm
under the physical interference model is MaxAverageSINRSchedule (MASS),
which considers the communication graph @xmath and is described in
Algorithm 7 .

1: input: STDMA wireless network @xmath , communication graph @xmath

2: output: A coloring @xmath

3: label the vertices of @xmath randomly {Phase 1}

4: for @xmath do {Phase 2 begins}

5: let @xmath be such that @xmath

6: @xmath

7: end for {Phase 2 ends}

Algorithm 7 MaxAverageSINRSchedule (MASS)

In Phase 1, we label all the vertices randomly ¹ ¹ 1 Randomized
algorithms are known to outperform deterministic algorithms, especially
when the characteristics of the input are not known a priori [ 53 ] . .
Specifically, if @xmath has @xmath vertices, we perform a random
permutation of the sequence @xmath and assign these labels to vertices
with indices @xmath respectively. Let @xmath denote the label assigned
to vertex @xmath .

1: input: STDMA wireless network @xmath , communication graph @xmath

2: output: A non-conflicting color

3: @xmath

4: @xmath

5: @xmath

6: @xmath

7: if @xmath then

8: @xmath

9: if @xmath then

10: return @xmath

11: end if

12: end if

13: return @xmath

Algorithm 8 integer MaxAverageSINRColor( @xmath )

In Phase 2, the vertices are examined in increasing order of label ² ² 2
In essence, the vertices are scanned in a random order, since labeling
is random. and the MaxAverageSINRColor (MASC) function is used to assign
a color to the vertex under consideration. The MASC function is
explained in Algorithm 8 . It begins by discarding all colors that have
a primary or secondary vertex conflict with @xmath , the vertex under
consideration. Among the set of non-conflicting colors @xmath , it
chooses that color for @xmath which results in the maximum value of
average SINR at the neighbors of @xmath , provided this value exceeds
the communication threshold. Intuitively, the average SINR is also a
measure of the average distance of every neighbor of @xmath from all
co-colored transmitters. The higher the average SINR, the higher is this
average distance. We choose that color which results in the maximum
average SINR at the neighbors of @xmath , so that the additional
interference at the neighbors of all co-colored transmitters is kept
low. If no such color is found, it assigns a new color to @xmath .

### 5.6 Performance Results

In this section, we describe our simulation model. We compare the
performance of the proposed algorithm with existing point to multipoint
link scheduling algorithms.

In our simulation experiments, the location of every node is generated
randomly in a circular region of radius @xmath . If @xmath are the
Cartesian coordinates of node @xmath , then @xmath and @xmath subject to
@xmath . Equivalently, if @xmath are the polar coordinates of node
@xmath , then @xmath and @xmath . Using ( 2.4 ) and ( 2.5 ), we compute
@xmath and @xmath , and then map the STDMA network @xmath to the
communication graph @xmath . Once the link schedule @xmath is computed
by every algorithm, the spatial reuse @xmath is computed using ( 5.8 ).
We use two sets of prototypical values of system parameters in wireless
networks [ 42 ] . For a given set of system parameters, we calculate the
average spatial reuse by averaging @xmath over 1000 randomly generated
networks. Keeping all other parameters fixed, we observe the effect of
increasing the number of nodes on the average spatial reuse.

In our experiments, we compare the performance of the following
algorithms:

1.  BroadcastSchedule (BS) [ 16 ]

2.  MaxAverageSINRSchedule (MASS)

In our first set of experiments (Experiment 1), we assume that @xmath m,
@xmath mW, @xmath , @xmath dBm, @xmath dB and @xmath dB. Thus, @xmath m
and @xmath m. We vary the number of nodes from 30 to 110 in steps of 5.
Figure 5.8 plots the average spatial reuse vs. number of nodes for both
the algorithms.

In our second set of experiments (Experiment 2), we assume that @xmath
m, @xmath mW, @xmath , @xmath dBm, @xmath dB and @xmath dB. Thus, @xmath
m and @xmath m. We vary the number of nodes from 70 to 150 in steps of
5. Figure 5.9 plots the average spatial reuse vs. number of nodes for
both the algorithms.

From Figures 5.8 and 5.9 , we observe that average spatial reuse
increases with the number of nodes for both the algorithms. The MASS
algorithm consistently yields higher average spatial reuse compared to
BS. The spatial reuse of MASS is about @xmath higher than BS in
Experiment 1 and @xmath higher in Experiment 2. This improvement in
performance translates to substantially higher network throughput.

Also, an increase in the number of nodes in a given geographical area
leads to an increase in the number of vertices having a primary or
secondary vertex conflict with a given vertex. Hence, the number of
non-conflicting colors for a given vertex also decreases. From this
reduced set of non-conflicting colors, BroadcastSchedule chooses a color
randomly, while MaxAverageSINRSchedule chooses a color based on SINR
conditions. Since spatial reuse takes SINR threshold conditions into
account, the gap between average spatial reuse values increases with
number of nodes in Figures 5.8 and 5.9 .

### 5.7 Analytical Result

In this section, we derive an upper bound on the running time
(computational) complexity of the MaxAverageSINRSchedule algorithm. Let
@xmath denote the number of vertices of the communication graph @xmath .

###### Theorem 5.7.1.

The running time of MaxAverageSINRSchedule is @xmath .

###### Proof.

Assuming that an element can be chosen randomly and uniformly from a
finite set in unit time ( [ 53 ] , Chapter 1), the running time of Phase
1 can be shown to be @xmath . In Phase 2, the vertex under consideration
is assigned a color using MaxAverageSINRColor. The worst-case size of
the set of colors to be examined @xmath is @xmath . With a careful
implementation, MaxAverageSINRColor runs in time proportional to @xmath
, i.e., @xmath . Thus, the running time of Phase 2 is @xmath . Finally,
the overall running time of MaxAverageSINRSchedule is @xmath . ∎

### 5.8 Discussion

In this chapter, we have developed a point to multipoint link scheduling
algorithm for STDMA wireless networks under the physical interference
model, namely MaxAverageSINRSchedule. The performance of our algorithm
is superior to existing algorithms. A practical experimental modeling
shows that, on an average, our algorithm achieves @xmath higher spatial
reuse than the BroadcastSchedule algorithm [ 16 ] . Since link schedules
are constructed offline only once and then used by the network for a
long period of time, this improvement in performance directly translates
to higher network throughput. The computational complexity of
MaxAverageSINRSchedule is also comparable to the computational
complexity of BroadcastSchedule. Therefore, MaxAverageSINRSchedule is a
good candidate for efficient STDMA point to multipoint link scheduling
algorithms.

## Chapter 6 A Review of Random Access Algorithms for Wireless Networks

The MAC problem or multipoint to point problem is present in all
communication networks, both wired and wireless. Multiple nodes (users)
can access a single channel simultaneously to communicate with each
other or a common receiver – the challenge is to design efficient
channel access algorithms to achieve the desired performance in terms of
throughput and delay. Several solutions to the MAC problem have been
proposed depending on source traffic characteristics, channel models and
Quality of Service (QoS) requirements of the users.

MAC protocols can be broadly classified into two types: fixed resource
allocation protocols and random access protocols. Fixed resource
allocation protocols such as Time Division Multiple Access (TDMA),
Frequency Division Multiple Access (FDMA) and Code Division Multiple
Access (CDMA) assign orthogonal or near-orthogonal channels to every
user and are mostly implemented in voice-dominant wireless cellular
networks. These protocols typically require the presence of a central
entity (base station) to perform channel allocation and admission
control, i.e., they are highly centralized. Though fixed resource
allocation protocols are contention-free and can multiplex users with
similar traffic characteristics easily, they suffer from low throughput
and high channel access delay when the traffic is bursty and there are
large number of users. On the other hand, in random access protocols,
users vary their transmission probabilities or transmission times based
on limited channel feedback, i.e., random access protocols are highly
distributed. Random access protocols are more suitable for scenarios
wherein many users with varied traffic requirements have to be
multiplexed, i.e., the traffic is bursty.

Random access algorithms for satellite communications, multidrop
telephone lines and multitap bus (“traditional random access
algorithms”) have been well studied for the past four decades. These
algorithms can be broadly classified into three categories: ALOHA [ 17 ]
, [ 59 ] , Carrier Sense Multiple Access [ 60 ] and tree (or stack or
splitting) algorithms [ 18 ] . Traditional random access algorithms have
been implemented in practical systems. For example, ALOHA is used in
most cellular networks to request channel access and also in satellite
communication networks. Carrier Sense Multiple Access with Collision
Detection (CSMA/CD) is used to resolve contentions in Local Area
Networks (LANs).

On the other hand, random access algorithms that incorporate physical
layer characteristics such as SINR and channel variations have only been
studied recently. These algorithms, which have been primarily proposed
for wireless networks, can be broadly classified into three categories:
algorithms based on signal processing and diversity techniques,
channel-aware ALOHA algorithms based on adapting the retransmission
probabilities of contending users and “tree-like” algorithms based on
adapting the set of contending users. Existing random access algorithms,
such as Carrier Sense Multiple Access with Collision Avoidance (CSMA/CA
), are not channel-aware and can lead to low throughput. Thus, the
design of physical layer aware random access algorithms can be a
potential step towards achieving higher data rates in future wireless
networks.

The organization of this chapter is as follows. Section 6.1 provides a
summary of traditional random access algorithms along with the canonical
system model, performance metrics and well-known random access
techniques such as ALOHA and tree algorithms. This helps us understand
channel-aware generalizations of these algorithms. In Section 6.2 , we
review research papers which employ signal processing and diversity
techniques to correctly decode packets in random access wireless
networks. We critically review some of the research which focus on
channel-aware ALOHA and tree-like algorithms for wireless networks in
Sections 6.3 and 6.4 respectively. Finally, we motivate the use of
variable transmission power to increase the throughput of random access
wireless networks in Section 6.5 .

### 6.1 Traditional Random Access Algorithms

In this section, we describe the idealized slotted multiaccess model,
which can be used to represent various multiaccess media such as
satellite channels, multidrop telephone lines and multitap bus. We
explain traditional random access algorithms such as ALOHA and tree
algorithms. We also describe the performance metrics used to analyze and
evaluate random access algorithms, namely, throughput, delay and
stability.

Consider an idealized slotted multiaccess system with @xmath
transmitting nodes and one receiver. The assumptions of the model are [
22 ] :

1.  Slotted system: All transmitted packets have the same length and
    each packet requires one time unit, called a slot, for transmission.

2.  One of the following is usually assumed:

    1.  Poisson arrivals: Packets arrive at each of the @xmath nodes
        according to an independent Poisson process. Let @xmath be the
        overall arrival rate to the system and let @xmath be the arrival
        rate at each transmitting node.

    2.  Backlogged model: Every node always has a packet to transmit.
        Once a node transmits a packet successfully, a new packet is
        generated and awaits transmission.

3.  Collision or perfect reception: If two or more nodes transmit a
    packet in a given slot, then there is a collision and the receiver
    obtains no information about the contents or the sources of
    transmitted packets. If only one node transmits a packet in a given
    slot, the packet is correctly received.

4.  @xmath immediate feedback: At the end of each slot, every node
    obtains feedback from the receiver specifying whether 0 packet, 1
    packet or more than one packet ( @xmath denotes error) were
    transmitted in that slot.

5.  Retransmission of collisions: Each packet involved in a collision
    must be retransmitted in some later slot, with further such
    retransmissions until the packet is successfully received. A node
    with a packet that must be retransmitted is said to be backlogged.

6.  Only one of the following is assumed:

    1.  No buffering: If one packet at a node is currently waiting for
        transmission or colliding with another packet during
        transmission, new arrivals at that node are discarded and never
        transmitted.

    2.  Infinite set of nodes: The system has an infinite set of nodes
        and each new packet arrives at a new node.

For the analysis and performance evaluation of random access algorithms,
the metrics of interest are:

1.  Delay: Index packets as @xmath according to their arrival instants.
    Let @xmath denote the delay experienced by @xmath packet. Then the
    average packet delay is defined as

      -- -------- -------- -------- -- -------
         @xmath   @xmath   @xmath      (6.1)
      -- -------- -------- -------- -- -------

2.  Throughput: The following are the two most common definitions of
    throughput:

    1.  Throughput is the supremum of input packet arrival rates @xmath
        such that the packet delay remains bounded, i.e.,

          -- -------- -------- -------- -- -------
             @xmath   @xmath   @xmath      (6.2)
          -- -------- -------- -------- -- -------

    2.  Let @xmath denote the number of packets successfully transmitted
        in @xmath . Define

          -- -------- -------- -------- --
             @xmath   @xmath   @xmath   
          -- -------- -------- -------- --

        Throughput is then defined as

          -- -------- -------- -------- -- -------
             @xmath   @xmath   @xmath      (6.3)
          -- -------- -------- -------- -- -------

3.  Stability: A random access algorithm is stable if the throughput
    @xmath and unstable if @xmath .

The research of random access algorithms began with the unslotted ALOHA
(pure ALOHA) algorithm proposed by Abramson [ 17 ] . Each node, upon
receiving a packet, transmits it immediately rather than waiting for a
slot boundary. If a packet is involved in a collision, it is
retransmitted after a random delay. It can be shown that unslotted ALOHA
achieves a maximum throughput of @xmath [ 22 ] . An advantage of
unslotted ALOHA is that it can be used with variable-length packets.

Slotted ALOHA is a variation by Roberts [ 59 ] of the original unslotted
ALOHA protocol proposed by Abramson. Each node simply transmits a newly
arriving packet in the first slot after the packet arrival. When a
collision occurs, every node sending a colliding packet discovers the
collision at the end of the slot and becomes backlogged. Backlogged
nodes wait for a random number of slots before retransmitting. The
maximum throughput of slotted ALOHA can be shown to be @xmath [ 22 ] .
Drift-analytic ¹ ¹ 1 Drift in state @xmath is defined as the expected
change in backlog over one time-slot, starting in state @xmath . methods
reveal that slotted ALOHA is unstable. To stabilize ALOHA, some
techniques estimate @xmath or @xmath , so as to maintain the attempt
rate @xmath at 1, resulting in a maximum stable throughput of @xmath [
61 ] , [ 62 ] . Unlike unslotted ALOHA, slotted ALOHA cannot be easily
used with variable-sized packets. In slotted ALOHA, long packets must be
broken up to fit into slots and short packets must be padded out to fill
up slots.

Keeping the random access spirit of the ALOHA protocol, researchers
attempted to design more efficient protocols. A highly successful
approach consists of improving the control of the channel by carrier
sensing, i.e., the Carrier Sense Multiple Access (CSMA) technique. In [
22 ] , the authors show that CSMA outperforms ALOHA. Research has shown
that CSMA based protocols can achieve a throughput close to 0.9 [ 63 ] .
The Ethernet protocol, which is used to connect computers on a wired
LAN, utilizes Carrier Sense Multiple Access with Collision Detection
(CSMA/CD).

In splitting algorithms, the set of colliding nodes splits into subsets,
one of which transmits in the next slot. For a given colliding node, the
choice of its subset depends on a pre-determined rule such as, the
outcome of tossing an unbiased coin, a function of its arrival time or a
function of its node identifier. If the collision is not resolved, a
further splitting into subsets takes place. The algorithm proceeds
recursively until all collisions are resolved.

In the Basic Tree Algorithm (BTA) [ 18 ] , when a collision occurs, say
in @xmath slot, all nodes not involved in the collision go into a
waiting mode, and all those involved in the collision split into two
subsets, according to the pre-determined rule. The first subset (“left”
subset) transmits in slot @xmath , and if that slot is idle or
successful, the second subset (“right” subset) transmits in slot @xmath
. Alternatively, if another collision occurs in slot @xmath , the first
of the two subsets splits again, and the second subset waits for the
resolution of that collision. Figure 6.1 exemplifies the operation of
BTA for three nodes @xmath , @xmath and @xmath . Observe the binary tree
structure of the sets of transmitting and waiting nodes in the figure.
The transmitting and waiting sets in terms of subtrees of this binary
tree are shown in Table 6.1 , where @xmath denotes the set of all nodes
that were involved in the initial collision. The labeling of the
subtrees is recursive; for example, @xmath denotes the right subtree of
the left subtree of the original binary tree. The transmission order
corresponds to that of a stack, as shown in Figure 6.2 . In each slot,
the stack is popped and all the nodes that were at the top of the stack
transmit their packets. In case of a collision, the stack is pushed with
nodes that join the right subset and then pushed again with nodes that
join the left subset. In case of a success or idle, no push operations
are performed on the stack. A Collision Resolution Period (CRP) is
defined to be completed when a success or idle occurs and there are no
remaining elements on the stack. In Figure 6.1 , the length of the CRP
is 9 slots.

During the operation of BTA, many new packets might arrive while a
collision is being resolved. To solve this problem, at the end of a CRP,
the set of nodes with new arrivals is immediately split into @xmath
subsets, where @xmath is chosen so that the expected number of packets
per subset is slightly greater than 1. The maximum throughput, optimized
over the choice of @xmath as a function of expected number of waiting
packets, is 0.43 packets per slot [ 18 ] .

There exist variants of BTA that yield higher throughput. For example,
in Modified Tree Algorithm (MTA), if a collision in slot @xmath is
followed by an idle in slot @xmath , then nodes which collided in slot
@xmath refrain from transmitting in slot @xmath . Instead, they further
split into two subsets, one of which transmits in slot @xmath . As an
example, the operation of MTA for three nodes @xmath , @xmath and @xmath
is shown in Figure 6.3 . Observe that the length of the CRP is 8 slots.
For this example, the transmitting and waiting sets of subtrees are
shown in Table 6.2 , while the corresponding stack representation is
shown in Figure 6.4 . If an idle occurs in the current slot and a
collision occurred in the previous slot (see Slot 5 in Figure 6.4 ),
then the stack is popped a second time but the nodes at the top of the
stack are not transmitted. Instead, these nodes split into right and
left subsets and these subsets are pushed on the stack. This leads to
fewer collisions and higher throughput compared to BTA. The maximum
stable throughput of MTA is 0.46 packets per slot [ 64 ] .

In First Come First Serve (FCFS) splitting algorithm [ 22 ] , nodes
involved in a collision split into two subsets based on the arrival
times of collided packets. Using this approach, each subset consists of
all packets that arrived in some given interval, and when a collision
occurs, that interval will be split into two smaller intervals. By
always transmitting packets that arrived in the earlier interval first,
the algorithm transmits successful packets in the order of their
arrival. The FCFS algorithm is stable for @xmath [ 22 ] . Conflict
resolution protocols based on tree algorithms have provable stability
properties [ 65 ] .

We should point out that the random access algorithm proposed in Chapter
7 has a “tree structure” analogous to that of MTA. The detailed
explanations of BTA and MTA provide a basic background to understand the
dynamics of the proposed algorithm.

So far, we have summarized the methodology of traditional random access
algorithms. In subsequent sections, we will focus on random access
algorithms that are better suited for wireless networks such as WLANs
and Wireless Metropolitan Area Networks (WMANs).

### 6.2 Signal Processing in Random Access

The collision model (Section 6.1 , Assumption 4 ) is simple in that the
onus of scheduling packets is left entirely to the MAC layer. On the
contrary, physical layer techniques like multipacket reception, capture
and network-assisted diversity are able to correctly decode packets from
collisions by means such as coding and signal processing. These
techniques are potential steps towards alleviating the burden of
decoding packets from the MAC layer to the physical layer [ 66 ] . In
this section, we review representative research work which exploits
signal processing and diversity techniques to correctly decode the
received packets in random access wireless networks.

With the advent of multiaccess techniques such as CDMA and Multiuser
Detection [ 67 ] , the first fundamental change in the collision model
has been propounded in [ 68 ] . The authors offer the generalization
that, in the presence of simultaneous transmissions, the reception can
be described by conditional probabilities instead of deterministic
failure. They propose the MultiPacket Reception (MPR) model defined by
the matrix

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (6.4)
  -- -------- -------- -------- -- -------

where @xmath is the conditional probability that, given @xmath users
transmit, @xmath out of @xmath transmissions are successful. Given
@xmath users transmit at the same time, the average number of
successfully received packets is given by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (6.5)
  -- -------- -------- -------- -- -------

They show that ALOHA under MPR achieves stable throughput @xmath
assuming that the limit exists. The stability and delay of finite-user
slotted ALOHA with multipacket reception has been analyzed in [ 69 ] .

In [ 70 ] , the authors analyze the probability of capture in a
multipoint to point wireless network. Analogous to the physical
interference model, the capture model assumes that if a user’s SINR
exceeds a threshold @xmath , then that user’s packet will be
successfully received. They consider a realistic multiplicative
propagation model in which the received power is obtained by multiplying
the transmitted power by independent random variables representing
fading, shadowing and path loss effects. To model the near-far effect,
they assume that the distance @xmath of a mobile station from the base
station is a random variable with distribution function @xmath . They
show that, under broad conditions, the roll-off parameter @xmath of the
distribution of power received from a mobile station is determined by
the path loss exponent and @xmath . Additionally, @xmath is insensitive
to other effects such as Rayleigh or Rician fading and log-normal
shadowing. Finally, they show that in the limit of a large number of
transmitters, the probability of capture is determined by the power
capture threshold @xmath and @xmath . Though the analysis provided in [
70 ] is mathematically robust, the authors do not describe any multiple
access algorithm which achieves high throughput in wireless networks
under the capture model, i.e., their result is more existential than
constructive.

In [ 71 ] , the authors propose Network-Assisted Diversity Multiple
Access (NDMA), a technique for resolving collisions in wireless
networks. They consider a wireless slotted random access network with
Rayleigh fading and Additive White Gaussian Noise (AWGN). In NDMA, if
@xmath users collide in a given slot, they repeat their transmissions
@xmath times so that @xmath copies of the collided packets are received.
Using signal separation principles, the receiver resolves a @xmath
source mixing problem to extract the signals of individual users,
without incurring any penalty in throughput. The protocol has been
extended to blind user detection [ 72 ] and has provable stability [ 73
] . A good review of NDMA protocols is given in [ 74 ] .

An alternative to employing signal processing techniques in random
access wireless networks is to appropriately model the wireless channel
and modify the well-researched ALOHA protocol. We review such research
work in the next section.

### 6.3 Channel-Aware ALOHA Algorithms

In this section, we review representative research work whose central
theme is to adapt the retransmission probabilities of users in random
access wireless networks. In other words, we review research work which
develops channel-aware ALOHA algorithms for wireless networks.

In [ 75 ] , the authors develop a channel-aware ALOHA protocol for
wireless networks. They assume a slotted system, block fading, @xmath
feedback and a backlogged model (Section 6.1 , Assumption 2b ). They
develop a distributed random access protocol in which each node only has
knowledge of its own channel gain and nodes have long-term power
constraints. A node transmits only if its channel gain exceeds @xmath .
For a system with @xmath nodes, the authors show that the optimum
transmission probability is @xmath , where @xmath and @xmath as @xmath .
Asymptotically, the ratio of the throughput of channel-aware ALOHA to
the throughput of a centralized scheduler (which has knowledge of
channel gains of all nodes) is shown to be @xmath .

Opportunistic ALOHA algorithms for wireless networks have been studied
in [ 76 ] . The authors consider a general reception model which
encompasses @xmath feedback, capture as well as multipacket reception.
Under the assumption that the Channel State Information (CSI) is known
to each user, they propose a variant of slotted ALOHA, where the
transmission probability is allowed to be a function of the CSI. The
maximum throughput for the finite-user infinite-buffer model is derived.
Finally, the theory is applied to CDMA networks with Linear Minimum Mean
Square Error (LMMSE) receiver and matched filters.

The performance of slotted ALOHA in a wireless network with multiple
destinations under the physical interference model is evaluated in [ 19
] . A packet is successful only if it is captured at the receiver of its
intended destination. The authors assume Poisson packet generation,
@xmath feedback and circularly symmetric Gaussian distribution of users
around each destination. They use a modified version of Rivest’s
pseudo-Bayesian estimator [ 22 ] to estimate the backlog. Their
simulation results demonstrate the effect of arrival rate, capture
threshold, variance of user distribution and number of destinations on
the throughput and energy efficiency per destination.

In [ 77 ] , the author analyzes the throughput of slotted ALOHA in a
multipoint to point wireless ad hoc network under the physical
interference model. The cluster head employs reverse link power control,
similar to IS-95 CDMA systems [ 78 ] , to ensure that equal power is
received from all nodes who attempt transmission in a time slot. The
wireless channel is modeled as a multipacket reception channel. Assuming
that one new packet arrives at each node in every time slot, the state
of the system is characterized by a discrete time Markov chain with a
steady state distribution. Finally, the author describes a technique to
compute the network throughput.

In [ 79 ] , the authors introduce spatial reuse slotted ALOHA, a random
access protocol for random homogeneous mobile wireless networks. The
occurrence of a collision is determined by the SINR at a receiver, i.e.,
the authors employ the physical interference model. They assume that
nodes are randomly placed in a two-dimensional plane according to a
Poisson point process and each node chooses a random destination at some
finite distance. The powers at which stations can transmit are assumed
to be independent and identically distributed (i.i.d.) and the wireless
channel is characterized by its propagation path loss. Nodes move
according to the random waypoint mobility model [ 80 ] . The authors
characterize the interference process using tools from stochastic
geometry. Subsequently, they determine the probability of channel access
that maximizes the expected projected distance traversed per hop towards
a destination, termed as “spatial density of progress”. Under the
assumption that there is some non-degenerate node mobility, the authors
show that the spatial density of progress is proportional to the
square-root of the density of the nodes. Though the authors present a
distributed ALOHA protocol and address certain implementation issues,
their model does not represent real-world scenarios. Practical
deployments of wireless nodes are better modeled by a uniform
distribution in a finite plane rather than a Poisson point process in an
infinite plane. Also, most of their results do not hold for static
wireless networks (say, wireless mesh networks) since ergodicity
assumptions no longer hold. Finally, their proposed routing protocol
requires every node to have knowledge of locations and MAC states
(receiver or transmitter) of all other nodes, which requires a lot of
message passing between nodes (especially with mobile nodes) and is thus
not scalable.

Instead of adapting the transmission probabilities of users in random
access wireless networks, one can also adapt the transmission times of
users based on the channel state and feedback from the receiver. Such
techniques, which can be broadly termed as splitting algorithms or
tree-like algorithms for wireless networks, are reviewed in the next
section.

### 6.4 Splitting Algorithms

In this section, we review representative research work on random access
algorithms whose main idea is to adapt the set of contending users based
on feedback from the channel or the common receiver. In such work, the
authors develop and analyze splitting (or tree or stack) algorithms for
various models of the wireless channel and evaluate the performance of
their algorithms via simulations.

In [ 81 ] , the authors propose an opportunistic splitting algorithm for
a multipoint to point wireless network. They assume a slotted system,
block fading channel and @xmath feedback. Assuming that each user only
knows its own channel gain and the number of backlogged users, the
authors propose a distributed splitting algorithm to determine the user
with the best channel gain over a sequence of mini-slots. The algorithm
determines a lower threshold @xmath and a higher threshold @xmath for
each mini-slot, such that only users whose channel gains lie between
between @xmath and @xmath are allowed to transmit their packets. Based
on results from “partitioning a sample with binary type questions” [ 82
] , they show that the average number of mini-slots required to
determine the user with the best channel is 2.5, independent of the
number of users and the fading distribution. However, their algorithm is
impractical because it assumes that every user can accurately estimate
the number of backlogged users.

In [ 83 ] , the authors consider a random access network with infinite
users, Poisson arrivals and @xmath immediate feedback, where @xmath is
any positive integer. In contrast to standard tree algorithms (BTA, MTA,
FCFS) that discard collided packets (Section 6.1 , Assumption 4 ), they
propose an algorithm that stores collided packets. The receiver extracts
information from the collided packets by relying on successive
interference cancellation techniques ( [ 67 ] , Chapter 7) and the tree
structure of a collision resolution algorithm. Though their algorithm
achieves a stable throughput of 0.693, it requires infinite storage and
increased input voltage range at the receiver, which are not feasible in
practical systems.

In [ 84 ] , the author considers a multipoint to point wireless channel
with and without capture and MPR. The channel provides
Empty(E)/Non-Empty(NE) feedback to all active users and ‘success’
feedback to successful users only. The users do not need to know the
starting times and ending times of collision resolution periods. For
such a channel with E/NE binary feedback, the author proposes and
analyzes a stack multiple access algorithm that is limited sensing and
does not require any frame synchronization. The author considers two
models for capture, namely Rayleigh fading with incoherent and coherent
combining of joint interference power. For MPR, the author assumes a
maximum of two successes during a collision. The maximum throughput of
the algorithm is numerically evaluated be to 0.6548 when capture and MPR
are present, and 0.2891 when both effects are absent. Though a novel
splitting algorithm is proposed in [ 84 ] , the author does not take
into account throughput gains possible by varying transmission powers of
users.

So far, we have reviewed research papers that either utilize signal
processing techniques or adapt transmission probabilities or
transmission times to increase the throughput in random access wireless
networks. The throughput can be further increased by allowing users to
use variable transmission powers. We review research papers which employ
this idea in the next section.

### 6.5 Towards Power Controlled Random Access

In this section, we review representative research papers which focus on
power control techniques in random access wireless networks. We then
motivate the use of variable transmission power to increase the
throughput in random access wireless networks.

In [ 85 ] , the author considers a time-slotted CDMA-based wireless
network wherein a finite number of nodes communicate with a common
receiver. The author formulates the problem of determining the set of
nodes that can transmit in each slot along with their corresponding
transmission powers, subject to constraints on maximum transmission
power and the SINRs of all transmissions exceeding the communication
threshold. Due to its NP-hard nature, the problem is relaxed to a case
wherein a node transmits with a certain probability in each slot.
Equivalently, the problem of joint power control and link scheduling is
transformed to a problem of power controlled random access, wherein the
objective is to determine the probability of transmission @xmath and
transmission power @xmath for each node @xmath , subject to constraints
on maximum transmission power and the “expected SINR” exceeding the
communication threshold. The author seeks to minimize a weighted sum of
the maximum transmission power and maximum reciprocal probability, i.e.,
minimize @xmath . This convex optimization problem is solved using
techniques from geometric programming [ 86 ] . Finally, the author
derives the probability of outage ² ² 2 An outage occurs on a link if
the received (actual) SINR on the link is less than the communication
threshold. and delay distribution of buffered packets and demonstrates
the efficacy of the schemes via simulations.

In [ 87 ] , the authors investigate transmission power control and rate
adaptation in random access wireless networks using game theoretic
techniques. They consider multiple transmitters sharing a time-slotted
channel to communicate equal-length packets with a common receiver. A
user’s packet is successfully received if the SINR at the receiver is no
less than the communication threshold, i.e., the authors employ the
physical interference model. The random access problem is formulated as
a game wherein each user selects its strategy (transmit or wait) at each
stage of the game in a non-cooperative (independent) or cooperative
manner. The authors evaluate equilibrium strategies for non-cooperative
and cooperative symmetric random access games. Finally, the authors
describe distributed power control and rate adaptation games for
non-cooperative users for a collision channel with power-based capture.
Their numerical results demonstrate improved expected user utilities
when power control and rate adaptation are incorporated, at the expense
of increased computational complexity. Though the authors propose a
distributed random access algorithm based on game theoretic techniques,
their algorithm is impractical because it assumes that every user knows
@xmath , the number of backlogged users, in each slot. However, in
practice, @xmath can only be estimated using techniques such as Rivest’s
pseudo-Bayesian algorithm [ 62 ] .

Though researchers have addressed the problem of random access in
wireless networks by considering various channel models, different types
of feedback and realistic criteria for successful packet reception, only
few of them exploit the idea that throughput gains are achievable in a
random access wireless network by varying transmission powers of users.
In general, varying the transmission powers of users leads to higher
long-term average power. However, there exist wireless networks whose
users do not have stringent energy requirements. For such scenarios, it
would be useful to investigate the throughput gains achievable in the
network by varying the transmission powers of users.

We envisage developing a power controlled random access algorithm for
wireless networks under the physical interference model. We seek an
algorithm that yields higher throughput than traditional random access
algorithms. In cognizance of these requirements, we propose a power
controlled splitting algorithm for wireless networks in Chapter 7 . The
algorithm is so designed that successful packets are transmitted in the
order of their arrivals, i.e., in an FCFS manner.

In the system model considered in Chapter 7 , if multiple transmissions
occur, the receiver can decode a certain user’s packet correctly only if
the received SINR exceeds a threshold, i.e., we consider a channel with
power-based capture. The notion of capture has been addressed
previously, though in different contexts [ 19 ] , [ 84 ] , [ 88 ] .
However, in Chapter 7 , we motivate the idea that a user can transmit at
variable power levels to increase the chances of capture. Moreover,
unlike [ 19 ] , [ 84 ] , [ 88 ] , we assume @xmath feedback, where
@xmath , @xmath and @xmath denote idle, success and error respectively
(Section 6.1 , Assumption 4 ), and @xmath denotes capture in the
presence of multiple transmissions. Note that the system model
considered in Chapter 7 is different from those considered in existing
works on splitting algorithms for wireless networks. For example, in [
84 ] , the author proposes a novel splitting algorithm, but does not
take into account throughput gains possible by varying the transmission
power. Though the authors of [ 81 ] propose a splitting algorithm to
determine the user with the best channel gain, their algorithm is
impractical because it assumes that every user can accurately estimate
the number of backlogged users.

To the best of our knowledge, there is no existing work on variable
power splitting algorithms for a wireless network under the physical
interference model. The specification of the proposed algorithm along
with its performance analysis and evaluation constitute the subject
matter of the next chapter.

## Chapter 7 Power Controlled FCFS Splitting Algorithm for Wireless
Networks

In this chapter, we propound a random access algorithm that incorporates
variable transmission powers in a multipoint to point wireless network.
Specifically, we investigate random access in wireless networks under
the physical interference model wherein the receiver is capable of
power-based capture, i.e., a packet can be decoded correctly in the
presence of multiple transmissions if the received SINR exceeds the
communication threshold. We propose an interval splitting algorithm that
varies the transmission powers of users based on channel feedback. We
derive the maximum stable throughput of the proposed algorithm and
demonstrate that it achieves better performance than the FCFS splitting
algorithm [ 22 ] with uniform transmission power.

The rest of the chapter is organized as follows. We describe our system
model in Section 7.1 and motivate variable control of transmission
powers of contending users in Section 7.2 . We describe the proposed
random access algorithm and provide two illustrative examples in Section
7.3 . We model the algorithm dynamics by a Markov chain and derive its
maximum stable throughput in Section 7.4 . The performance of the
proposed algorithm is evaluated in Section 7.5 . We conclude in Section
7.6 .

### 7.1 System Model

Consider a multipoint to point wireless network. We assume the
following:

1.  Slotted system: Users (nodes) transmit fixed-length packets to a
    common receiver over a time-slotted channel. All users are
    synchronized such that the reception of a packet starts at an
    integer time and ends before the next integer time.

2.  Poisson arrivals: The packet arrival process is Poisson distributed
    with overall rate @xmath , and each packet arrives to a new user
    that has never been assigned a packet before. After a user
    successfully transmits its packet, that user ceases to exist and
    does not contend for channel access in future time slots.

3.  Channel model: The wireless channel is modeled by the path loss
    propagation model. The received signal power at a distance @xmath
    from the transmitter is given by @xmath , where @xmath is the
    transmission power and @xmath is the path loss factor. We do not
    consider fading and shadowing effects.

4.  Power-based capture: According to the physical interference model [
    15 ] , a packet transmission from transmitter @xmath to receiver
    @xmath in @xmath time slot is successful if and only if the SINR at
    receiver @xmath is greater than or equal to the communication
    threshold @xmath ¹ ¹ 1 In literature, @xmath is also referred to as
    capture ratio [ 84 ] , capture threshold [ 19 ] and power ratio
    threshold [ 70 ] . , i.e.,

      -- -- -- -------
               (7.1)
      -- -- -- -------

    where

      -- -------- -------- -------- --
         @xmath   @xmath   @xmath   
         @xmath   @xmath   @xmath   
         @xmath   @xmath   @xmath   
         @xmath   @xmath   @xmath   
         @xmath   @xmath   @xmath   
      -- -------- -------- -------- --

5.  @xmath immediate feedback: By the end of each slot, users are
    informed of the feedback from the receiver immediately and without
    any error. The feedback is one of:

    1.  idle @xmath : when no packet transmission occurs,

    2.  perfect reception @xmath : when one packet transmission occurs
        and is received successfully,

    3.  capture @xmath : when multiple packet transmissions occur and
        only one packet is received successfully, or

    4.  collision @xmath : when multiple packet transmissions occur and
        no packet reception is successful.

    The receiver can distinguish between @xmath and @xmath by using
    energy detectors [ 83 ] , [ 89 ] . Thus, by the end of every slot,
    only two bits are required to provide feedback from the receiver to
    all users. Note that two bits are required to provide feedback even
    for the classical @xmath feedback model. Thus, our @xmath immediate
    feedback assumption does not increase the number of bits required
    for feedback..

6.  Gated Channel Access Algorithm (CAA): New packets are transmitted in
    the first available slot after previous conflicts are resolved. The
    time interval from the slot where an initial collision occurs up to
    and including the slot in which all users recognize that all packets
    involved in the collision have been successfully received, is called
    a Collision Resolution Period (CRP). Thus, new arrivals are
    inhibited from transmission during the CRP.

7.  Equal distances: We assume that each user is at the same distance
    @xmath from the common receiver.

### 7.2 Motivation and Problem Formulation

The maximum stable throughput of the well-known FCFS splitting algorithm
is 0.4871 [ 22 ] , which is the highest throughput amongst a wide class
of random access algorithms for wired networks. However, in a wireless
network, transmission power of a node provides an extra degree of
freedom, and higher throughputs are achievable.

Consider a scenario wherein all contending nodes transmit with equal
power @xmath in a given time slot. When only one node transmits, its
packet is successfully received if the SINR threshold condition ( 7.1 )
is satisfied, i.e.,

  -- -------- -- -------
     @xmath      (7.2)
  -- -------- -- -------

When @xmath nodes transmit concurrently with equal power @xmath , where
@xmath , the SINR corresponding to @xmath transmission is given by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (7.3)
  -- -------- -------- -------- -- -------

a quantity which is always less than 1. Since @xmath for all practical
narrowband communication receivers [ 70 ] , @xmath @xmath @xmath and all
@xmath transmissions are unsuccessful ² ² 2 For a spread spectrum CDMA
system with processing gain @xmath , ( 7.3 ) gets modified to @xmath [
87 ] . For such a wideband system, @xmath , and more than one packet can
be decoded correctly in the presence of multiple transmissions. However,
in this thesis, we consider narrowband systems only. . Thus, when
multiple nodes transmit with equal power, a collision occurs
irrespective of the transmission power @xmath .

However, the above situation can be circumvented by varying transmission
powers of users in some special cases. With relatively small attempt
rates, when a collision occurs, it is most likely between only two
packets [ 22 ] . In this case, if the receiver is capable of power-based
capture, a collision between two nodes can be avoided by using different
transmission powers. Specifically, one of the nodes, say @xmath ,
transmits with minimum power @xmath such that, if it were the only node
transmitting in that time slot, then its packet transmission will be
successful. From ( 7.1 ), the required nominal power is

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (7.4)
  -- -------- -------- -------- -- -------

The other node, say @xmath , transmits with minimum power @xmath such
that if there is exactly one other node transmitting at nominal power
@xmath , then the packet transmitted by @xmath will be successful. From
( 7.1 ) and ( 7.4 ), we obtain

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.5)
  -- -------- -------- -------- -- -------

Note that @xmath . We do not consider more than two power levels for the
following reasons:

1.  it complicates the power-control algorithm, and

2.  most mobile wireless devices have constraints on peak transmission
    power.

Note that the above power control technique converts some collisions
into “captures”. Thus, it has the potential of increasing the throughput
of random access algorithms employing uniform transmission power.

We seek to design a distributed algorithm incorporating this power
control technique, while still ensuring that the algorithm transmits
successful packets in the order of their arrival, i.e., in an FCFS
manner ³ ³ 3 Since successful packets are transmitted in an FCFS manner,
the delay experienced by a packet will not be significantly higher than
the average packet delay. Thus, from a QoS perspective, FCFS
transmission of packets not only guarantees average delay bounds, but
also ensures fairness of user packets. .

### 7.3 PCFCFS Interval Splitting Algorithm

In this section, we present an algorithmic description of the proposed
Power Controlled First Come First Serve (PCFCFS) splitting algorithm. We
also explain the behavior of the proposed algorithm by providing two
illustrative examples.

#### 7.3.1 Description

We first describe the notation. Slot @xmath is defined to be the time
interval @xmath . At each integer time @xmath ( @xmath ), the algorithm
specifies the packets to be transmitted in slot @xmath to be the set of
all packets that arrived in an earlier interval @xmath , which is
defined as the allocation interval for slot @xmath . The maximum size of
the allocation interval is denoted by @xmath , a parameter which will be
optimized for maximum throughput in Section 7.4 . Packets are indexed as
@xmath in the order of their arrival. Since the arrival times are
Poisson distributed with rate @xmath , the inter-arrival times are
exponentially distributed with mean @xmath . Let @xmath denote the
arrival time of @xmath packet. Using the memoryless property of the
exponential distribution (and without loss of generality), we assume
that @xmath . The transmission power of @xmath packet in slot @xmath is
denoted by @xmath , where @xmath . Note that, if @xmath , then @xmath
packet is not transmitted in slot @xmath .

Algorithm 9 describes the proposed Power Controlled First Come First
Serve (PCFCFS) splitting algorithm, which is the set of rules by which
the users compute allocation interval parameters @xmath and transmission
power @xmath for slot @xmath in terms of the feedback and allocation
interval parameters for slot @xmath . In our algorithm, every allocation
interval is tagged as a “left” @xmath or “right” @xmath interval. @xmath
denotes the tag ( @xmath or @xmath ) of allocation interval @xmath in
slot @xmath . Moreover, whenever an allocation interval is split, it is
always split into two equal-sized subintervals, and these subintervals
@xmath are said to correspond to each other.

1: input: @xmath , @xmath , @xmath , arrivals @xmath in @xmath {Phase 1
begins}

2: @xmath

3: @xmath

4: @xmath

5: @xmath {Phase 1 ends}

6: for @xmath do {Phase 2 begins}

7: if @xmath then {Phase 2a begins}

8: for all @xmath such that @xmath do

9: @xmath

10: end for

11: for all @xmath such that @xmath do

12: @xmath

13: end for

14: end if {Phase 2a ends}

15: transmit packets whose arrivals times lie in @xmath and obtain
channel feedback {Phase 2b begins}

16: if @xmath then

17: @xmath

18: @xmath

19: @xmath

20: else if @xmath then

21: @xmath

22: @xmath

23: @xmath

24: else if @xmath and @xmath then

25: @xmath

26: @xmath

27: @xmath

28: else if @xmath and @xmath then

29: @xmath

30: @xmath

31: @xmath

32: else

33: @xmath

34: @xmath

35: @xmath

36: end if {Phase 2b ends}

37: end for {Phase 2 ends}

Algorithm 9 PCFCFS splitting algorithm

In Phase 1 of the algorithm, we initialize various quantities. @xmath
denotes the number of slots for which the algorithm operates; ideally
@xmath . By convention, the initial allocation interval is @xmath ,
which is a right interval ( @xmath ). The initial channel feedback is
assumed to be idle (0).

In Phase 2 of the algorithm, we determine power levels, obtain channel
feedback and compute allocation interval parameters for each successive
slot @xmath . In Phase 2a, all users whose arrival times lie in the left
half of the current allocation interval transmit with higher power
@xmath , while all users whose arrival times lie in the right half of
the current allocation interval transmit with nominal power @xmath .
However, if a capture occurred in the previous slot @xmath , all users
in the current allocation interval transmit with nominal power @xmath .
Therefore, our algorithm always transmits successful packets in an FCFS
manner. In Phase 2b, the allocation interval parameters are modulated
based on the channel feedback. More specifically, if a collision occurs,
then the left half of the current allocation interval becomes the new
allocation interval. If a capture occurs, then the right half of the
current allocation interval becomes the new allocation interval. If a
success occurs and the current allocation interval is tagged as a left
interval, then the corresponding right interval becomes the new
allocation interval. If an idle occurs and the current allocation
interval is tagged as a left interval, then the left half of the
corresponding right interval becomes the new allocation interval.
Otherwise, if a success or an idle occurs and the current allocation
interval is tagged as a right interval, the waiting interval truncated
to length @xmath becomes the new allocation interval, and a new
Collision Resolution Period (CRP) begins in the next time slot @xmath .
Note that the transmit power levels in PCFCFS are variable and based on
channel feedback, i.e., they are adaptive.

#### 7.3.2 Examples

To illustrate the rules of the PCFCFS splitting algorithm for a single
CRP, consider the example shown in Figure 7.1 . In slot @xmath , the
allocation interval has no node in its left half and two nodes in its
right half. Both these nodes transmit with nominal power @xmath and a
collision occurs. So, the allocation interval is split, with the left
interval @xmath being the allocation interval for slot @xmath . An idle
occurs in slot @xmath . Next, the right subinterval @xmath is further
split, with @xmath being the allocation interval for slot @xmath . The
left node in @xmath transmits with higher power @xmath , while the right
node in @xmath transmits with nominal power @xmath , resulting in a
capture of the packet transmitted by the left node. The allocation
interval is further split, with @xmath forming the allocation interval
for slot @xmath . Since a capture occurred in @xmath in slot @xmath ,
the corresponding right subinterval @xmath is returned to the waiting
interval in slot @xmath . Post-capture, the lone node in @xmath
transmits with nominal power @xmath , resulting in a success and
completing the CRP. For the same sequence of arrival times, the behavior
of the FCFS algorithm with uniform transmission power @xmath is shown in
Figure 7.2 , where @xmath denotes the length of the allocation interval
in slot @xmath . Note that the FCFS algorithm requires 5 slots to
resolve the collisions, while the proposed PCFCFS algorithm requires
only 4 slots.

To further illustrate the rules of the PCFCFS splitting algorithm for a
single CRP, consider the example shown in Figure 7.3 . In slot @xmath ,
the allocation interval has three nodes in its left half and one node in
its right half. All ‘left half’ nodes transmit with higher power @xmath
, while the ‘right half’ node transmits with nominal power @xmath ,
leading to a collision. So, the allocation interval is split, with the
left interval @xmath being the allocation interval for slot @xmath . In
slot @xmath , the allocation interval has one node in its left half,
which transmits with higher power @xmath , and two nodes in its right
half, which transmit with nominal power @xmath . Hence, a collision
occurs, and the allocation interval @xmath is split into two equal sized
subintervals @xmath and @xmath , with @xmath being the allocation
interval for slot @xmath . Since a collision is followed by another
collision, the right interval @xmath is returned to the waiting interval
in slot @xmath . In slot @xmath , there is only one node in the
allocation interval. Since this lone node lies in the right half of the
allocation interval, it transmits with nominal power @xmath , leading to
a success. Thus, @xmath becomes the allocation interval for slot @xmath
. For this allocation interval, the node in the left half transmits with
higher power @xmath and the node in the right half transmits with
nominal power @xmath , resulting in a capture of the packet transmitted
by the former node. Consequently, @xmath becomes the new allocation
interval for slot @xmath . Finally, in slot @xmath , the lone node
transmits with nominal power @xmath , leading to a deterministic success
and completing the CRP. For the same sequence of arrival times, the
behavior of the FCFS algorithm with uniform transmission power @xmath is
shown in Figure 7.4 . Note that the FCFS algorithm requires 6 slots to
resolve the collisions, while the proposed PCFCFS algorithm requires
only 5 slots.

### 7.4 Throughput Analysis

The evolution of a CRP can be represented by the Discrete Time Markov
Chain (DTMC) shown in Figure 7.5 . Every state in the DTMC is a pair
@xmath , where @xmath is the status @xmath and @xmath is the number of
times the original allocation interval (of length @xmath ) has been
split. State @xmath corresponds to the initial slot of a CRP. If an idle
or a success occurs, the CRP ends immediately and a new CRP begins in
the next slot. If a capture occurs, a transition occurs to state @xmath
, where @xmath indicates that capture has occurred in the allocation
interval. If a collision occurs in @xmath , a transition occurs to state
@xmath . Each subsequent idle in a left allocation interval generates
one additional split with a smaller left allocation interval,
corresponding to a transition to @xmath , where @xmath indicates that
the current left allocation interval has been reached after a collision
(in some time slot) followed by one or more idles. A collision in an
allocation interval generates one additional split with a smaller left
allocation interval, corresponding to a transition to @xmath , where
@xmath indicates that the current left allocation interval has been
reached just after a collision. A capture in an allocation interval
generates an additional split with a smaller right allocation interval
and corresponds to a transition to @xmath . This is followed by a
success from @xmath to @xmath , thus ending the CRP. A success in a left
allocation interval leads to the corresponding right allocation interval
with no additional split, which causes a transition from @xmath to
@xmath , or @xmath to @xmath . A success in @xmath causes a transition
to @xmath , thus ending the CRP. It can be easily verified that the
states and transitions in Figure 7.5 constitute a Markov chain, i.e.,
each transition from every state is independent of the path used to
reach the given state.

We now analyze a single CRP. Assume that the size of the initial
allocation interval is @xmath (corresponding to state @xmath ). Each
splitting of the allocation interval halves this, so that states @xmath
, @xmath , @xmath , @xmath and @xmath in Figure 7.5 correspond to
allocation intervals of size @xmath . Since the arrival process is
Poisson with rate @xmath , the number of packets in the original
allocation interval is a Poisson random variable (r.v.) with mean @xmath
. Consequently, the a priori distributions on the number of packets in
disjoint subintervals are independent and Poisson. Define @xmath as the
expected number of packets in an interval that has been split @xmath
times. Thus

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (7.6)
     @xmath   @xmath   @xmath      (7.7)
  -- -------- -------- -------- -- -------

We view @xmath as the starting state as well as the final state. For
brevity in notation, the transition probability from state @xmath to
state @xmath is denoted by @xmath , where @xmath and @xmath (see Figure
7.5 ). For example, the transition probability from @xmath to @xmath is
denoted by @xmath .

@xmath is the probability of an idle or success in the first slot of the
CRP. Since the number of packets in the initial allocation interval is
Poisson with mean @xmath , the probability of 0 or 1 packet is

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (7.8)
  -- -------- -------- -------- -- -------

@xmath is the probability of capture in the first slot of a CRP. Let
@xmath and @xmath denote the number of packets in the left and right
halves of the original allocation interval respectively, as shown in
Figure 7.6 . Capture occurs if and only if @xmath and @xmath . @xmath
and @xmath are independent Poisson r.v.s of mean @xmath each. Thus

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.9)
  -- -------- -------- -------- -- -------

State @xmath is entered after collision in state @xmath . Using ( 7.8 )
and ( 7.9 ), this occurs with probability

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.10)
  -- -------- -------- -------- -- --------

Since a capture is always followed by a deterministic success,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.11)
  -- -------- -------- -------- -- --------

###### Lemma 7.4.1.

The outgoing transition probabilities from @xmath , where @xmath , are
given by

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.12)
     @xmath   @xmath   @xmath      (7.13)
     @xmath   @xmath   @xmath      (7.14)
     @xmath   @xmath   @xmath      (7.15)
  -- -------- -------- -------- -- --------

###### Proof.

Refer to Figure 7.5 . For @xmath , @xmath is entered only via a
collision in @xmath . For @xmath , @xmath is entered only via a
collision in @xmath or @xmath . For @xmath , @xmath is entered only via
a collision in @xmath , @xmath , @xmath or @xmath . In every case, a
subinterval @xmath is split into @xmath and @xmath , and @xmath becomes
the new allocation interval. Let @xmath and @xmath denote the number of
packets in @xmath and @xmath respectively. A priori, @xmath and @xmath
are independent Poisson r.v.s of mean @xmath each. The event that a
collision occurred in the previous state is @xmath . Note that @xmath is
a Poisson r.v. of mean @xmath . From ( 7.7 ), @xmath @xmath @xmath . The
probability of success in @xmath is the probability that @xmath
conditional on @xmath , i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.16)
  -- -------- -------- -------- -- --------

The probability of idle in @xmath is the probability that @xmath
conditional on @xmath , i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.17)
  -- -------- -------- -------- -- --------

Let @xmath and @xmath denote the number of packets in @xmath and @xmath
respectively. @xmath and @xmath are independent Poisson r.v.s of mean
@xmath each, and @xmath . The probability of capture in @xmath is the
probability that @xmath and @xmath conditional on @xmath , i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.18)
  -- -------- -------- -------- -- --------

From ( 7.16 ), ( 7.17 ) and ( 7.18 ), we obtain

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.19)
  -- -------- -------- -------- -- --------

∎

###### Lemma 7.4.2.

The outgoing transition probabilities from @xmath are given by

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.20)
     @xmath   @xmath   @xmath      (7.21)
  -- -------- -------- -------- -- --------

###### Proof.

Refer to Figure 7.5 . For @xmath , @xmath is entered only via a success
in @xmath . Recall that @xmath was entered only via a collision from a
previous state. We use the notation introduced in the proof of Lemma
7.4.1 . Define the event

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.22)
  -- -------- -------- -------- -- --------

Let @xmath and @xmath denote the number of packets in @xmath and @xmath
respectively. @xmath and @xmath are independent Poisson r.v.s of mean
@xmath each. Since @xmath , a success or an idle can never occur in
state @xmath . Note that @xmath . The probability of capture in state
@xmath is the probability that @xmath and @xmath conditional on @xmath ,
i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.23)
  -- -------- -------- -------- -- --------

From ( 7.23 ), we obtain

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.24)
  -- -------- -------- -------- -- --------

∎

###### Lemma 7.4.3.

The outgoing transition probabilities from @xmath are given by

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.25)
     @xmath   @xmath   @xmath      (7.26)
     @xmath   @xmath   @xmath      (7.27)
     @xmath   @xmath   @xmath      (7.28)
  -- -------- -------- -------- -- --------

###### Proof.

Refer to Figure 7.5 . For @xmath , @xmath is entered only by an idle in
@xmath . For @xmath , state @xmath is entered by an idle in @xmath or an
idle in @xmath . In every case, a residual right subinterval, say @xmath
, is split into @xmath and @xmath , and @xmath becomes the new
allocation interval. Note that @xmath can be entered if and only if
there is a collision (in some time slot) followed by one or more idles.
Therefore, @xmath must contain at least two packets. Let @xmath and
@xmath denote the number of packets in @xmath and @xmath respectively. A
priori, @xmath and @xmath are independent Poisson r.v.s of mean @xmath
each. Let @xmath denote the number of packets in @xmath . Thus @xmath ,
@xmath is a Poisson r.v. of mean @xmath and @xmath .

The probability of success in @xmath is the probability that @xmath
conditional on @xmath , i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.29)
  -- -------- -------- -------- -- --------

The probability of idle in @xmath is the probability that @xmath
conditional on @xmath , i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.30)
  -- -------- -------- -------- -- --------

Let @xmath and @xmath denote the number of packets in @xmath and @xmath
respectively. A priori, @xmath and @xmath are independent Poisson r.v.s
of mean @xmath each. The probability of capture in @xmath is the
probability that @xmath and @xmath conditional on @xmath , i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.31)
  -- -------- -------- -------- -- --------

From ( 7.29 ), ( 7.30 ) and ( 7.31 ), we obtain

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.32)
     @xmath   @xmath   @xmath      (7.33)
  -- -------- -------- -------- -- --------

∎

###### Lemma 7.4.4.

The outgoing transition probabilities from @xmath are given by

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.34)
     @xmath   @xmath   @xmath      (7.35)
     @xmath   @xmath   @xmath      (7.36)
  -- -------- -------- -------- -- --------

###### Proof.

Refer to Figure 7.5 . For @xmath , state @xmath is entered if and only
if a success occurs in state @xmath . When @xmath was entered, a
residual right subinterval @xmath was split into @xmath and @xmath , and
@xmath became the new allocation interval. Recall that @xmath , since
@xmath can only be entered after a collision followed by one or more
idles. A success in @xmath implies @xmath . Hence, @xmath is entered if
and only if both these events occurs, i.e., @xmath and @xmath .
Therefore, @xmath can be entered if and only if @xmath . Note that there
can never be an idle from @xmath .

The probability of success in @xmath is the probability that @xmath
conditional on @xmath , i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.37)
  -- -------- -------- -------- -- --------

Let @xmath and @xmath denote the number of packets in @xmath and @xmath
respectively. Note that @xmath . @xmath and @xmath are independent
Poisson r.v.s of mean @xmath each. The probability of capture in state
@xmath is the probability that @xmath and @xmath conditional on @xmath ,
i.e.,

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.38)
  -- -------- -------- -------- -- --------

From ( 7.37 ) and ( 7.38 ), we obtain

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (7.39)
  -- -------- -------- -------- -- --------

∎

In summary, Figure 7.5 is a DTMC and the transition probabilities are
given by ( 7.8 ), ( 7.9 ), ( 7.10 ) and ( 7.11 ), and Lemmas 7.4.1 ,
7.4.2 , 7.4.3 and 7.4.4 .

We now analyze the DTMC in Figure 7.5 . Observe that no state can be
entered more than once before the return to @xmath . Let @xmath denote
the probability that state @xmath is entered before returning to @xmath
, where @xmath and @xmath . In other words, @xmath denotes the
probability of hitting @xmath in a CRP given that we start from @xmath .
Note that @xmath and @xmath . The probabilities @xmath can be calculated
iteratively from the initial state @xmath as follows:

  -- -------- -------- -------- -------- --------
     @xmath   @xmath   @xmath            (7.40)
     @xmath   @xmath   @xmath            (7.41)
     @xmath   @xmath   @xmath            (7.42)
     @xmath   @xmath   @xmath            (7.43)
     @xmath   @xmath   @xmath            (7.44)
     @xmath   @xmath   @xmath            (7.45)
                                @xmath   
     @xmath   @xmath   @xmath            (7.46)
     @xmath   @xmath   @xmath            (7.47)
     @xmath   @xmath   @xmath            (7.48)
     @xmath   @xmath   @xmath            (7.49)
  -- -------- -------- -------- -------- --------

Let random variable @xmath denote the number of slots in a CRP. Thus,
@xmath equals the number of states visited in the Markov chain,
including the initial state @xmath , before the return to @xmath . Thus

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.50)
  -- -------- -------- -------- -- --------

where we assume @xmath .

We evaluate the change in @xmath from one CRP to the next, i.e., we
evaluate the difference in left endpoints of initial allocation
intervals of successive CRPs. For the assumed initial interval of size
@xmath , this change is at most @xmath . However, if left allocation
intervals have collisions or captures (e.g., @xmath in Figure 7.1 ),
then the corresponding right allocation intervals (e.g., @xmath in
Figure 7.1 ) are returned to the waiting interval, and the change is
less than @xmath . Let random variable @xmath denote the fraction of
@xmath returned in this manner over a CRP, so that @xmath is the change
in @xmath . We distinguish between two cases:

1.  If a left allocation interval of type @xmath has a collision or a
    capture, then the corresponding right allocation interval @xmath is
    returned to the waiting interval. Let @xmath denote the probability
    that @xmath has a collision or a capture. Hence, @xmath denotes the
    probability that @xmath has two or more packets. Thus, @xmath .
    Using ( 7.14 ) and ( 7.15 ), we obtain

      -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (7.51)
      -- -------- -------- -------- -- --------

2.  If a left allocation interval of type @xmath has a collision or a
    capture, then the corresponding right allocation interval @xmath is
    returned to the waiting interval. Let @xmath denote the probability
    that @xmath has a collision or a capture. Hence, @xmath denotes the
    probability that @xmath has two or more packets. Thus, @xmath .
    Using ( 7.27 ) and ( 7.28 ), we obtain

      -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (7.52)
      -- -------- -------- -------- -- --------

In either case, the fraction of the original allocation interval
returned on such a collision or a capture is @xmath . Therefore, the
expected value of @xmath is

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.53)
  -- -------- -------- -------- -- --------

where we assume @xmath .

From ( 7.6 ), ( 7.50 ) and ( 7.53 ), we observe that @xmath and @xmath
are functions only of the product @xmath . Note that as @xmath , @xmath
. Using the Taylor series expansion for @xmath or L’Hôpital’s Rule, we
can easily prove that:

1.  -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (7.54)
         @xmath   @xmath   @xmath      (7.55)
         @xmath   @xmath   @xmath      (7.56)
         @xmath   @xmath   @xmath      (7.57)
      -- -------- -------- -------- -- --------

2.  -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (7.58)
         @xmath   @xmath   @xmath      (7.59)
         @xmath   @xmath   @xmath      (7.60)
      -- -------- -------- -------- -- --------

3.  -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (7.61)
         @xmath   @xmath   @xmath      (7.62)
         @xmath   @xmath   @xmath      (7.63)
         @xmath   @xmath   @xmath      (7.64)
      -- -------- -------- -------- -- --------

4.  -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (7.65)
         @xmath   @xmath   @xmath      (7.66)
      -- -------- -------- -------- -- --------

The proofs of these results are given in Appendix A . Hence, @xmath ,
@xmath , @xmath and @xmath tend to zero with increasing @xmath as @xmath
, while @xmath tends to zero with increasing @xmath as @xmath . Thus,
@xmath and @xmath can be easily evaluated numerically as functions of
@xmath .

Define the time backlog to be the difference between the current time
and the left endpoint of the allocation interval, i.e., @xmath . Note
that all packets that arrived in the interval @xmath have not yet been
successfully transmitted, i.e., they are backlogged. Moreover, we define
the drift @xmath to be the expected change in time backlog, @xmath ,
over a CRP, assuming an initial allocation interval of @xmath . Thus,
@xmath is the expected number of slots in a CRP less the expected change
in @xmath , and is given by

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.67)
  -- -------- -------- -------- -- --------

The drift is negative if @xmath . Equivalently, the drift is negative if

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (7.68)
  -- -------- -------- -------- -- --------

The right hand side of ( 7.68 ), @xmath , is a function of @xmath and is
plotted in Figure 7.7 . We observe that @xmath takes its maximum value
at @xmath . More precisely, @xmath has a numerically evaluated maximum
of @xmath at @xmath . If @xmath is chosen to be @xmath , then ( 7.68 )
is satisfied for all @xmath . Thus, the expected time backlog decreases
whenever it is initially larger than @xmath , and we infer that the
algorithm is stable for @xmath . We have therefore proved the following
result.

###### Proposition 7.4.5.

The maximum stable throughput of the PCFCFS algorithm is 0.5518.

### 7.5 Numerical Results

In our numerical experiments, we use values of system parameters that
are commonly encountered in wireless networks [ 42 ] . We compare the
performance of the following algorithms:

1.  FCFS with uniform power @xmath ,

2.  PCFCFS.

For each algorithm, the value of the initial allocation interval is
chosen so as to achieve maximum stable throughput. For FCFS, maximum
stable throughput occurs when its initial allocation interval, @xmath [
22 ] . From Section 7.4 , the maximum throughput of PCFCFS occurs at
@xmath . Let @xmath denote the number of successful packets in @xmath
and @xmath denote the departure time of @xmath packet.

For a given set of system parameters, we compute the following
performance metrics:

  -- -- -------- -------- -- --------
        @xmath   @xmath      (7.69)
        @xmath   @xmath      (7.70)
        @xmath   @xmath      (7.71)
  -- -- -------- -------- -- --------

Keeping all other parameters fixed, we observe the effect of increasing
the arrival rate on the throughput, average delay and average power.

The system parameters for our numerical experiments are shown in Table
7.1 . From ( 7.4 ) and ( 7.5 ), we obtain @xmath mW and @xmath mW. We
vary the arrival rate @xmath from @xmath to @xmath packets/s in steps of
@xmath . Figure 7.8 plots the throughput versus arrival rate for the
PCFCFS and FCFS algorithms. Figure 7.9 plots the average delay per
successful packet versus arrival rate for both the algorithms. Finally,
Figure 7.10 plots the average power per successful packet versus arrival
rate for both the algorithms.

For arrival rates exceeding @xmath , the throughput of PCFCFS is less
than the arrival rate (Figure 7.8 ) and the average delay of PCFCFS
increases rapidly (Figure 7.9 ), which leads to a substantial increase
in the number of backlogged packets and system instability. Hence, the
maximum stable throughput of PCFCFS is between @xmath and @xmath . Thus,
Figures 7.8 and 7.9 corroborate our result that the maximum stable
throughput of PCFCFS is @xmath (see Section 7.4 ).

For both PCFCFS and FCFS, the departure rate (throughput) equals the
arrival rate for all arrival rates up to 0.487 (Figure 7.8 ). Hence,
both these algorithms are stable for arrival rates below 0.487. For
arrival rates exceeding 0.487, the departure rate of FCFS is strictly
lower than its arrival rate, leading to packet backlog and system
instability. On the other hand, for PCFCFS, the departure rate still
equals its arrival rate for arrival rates between 0.487 and 0.5518. In
other words, the PCFCFS algorithm is stable for a higher range of
arrival rates compared to FCFS algorithm. However, the PCFCFS algorithm
becomes unstable for arrival rates exceeding 0.5518.

The PCFCFS algorithm achieves higher throughput and lower average delay
than the FCFS algorithm, albeit at the cost of expending higher average
power. For example, at @xmath , PCFCFS achieves @xmath higher throughput
and @xmath lower average delay than FCFS, at the cost of @xmath higher
power.

### 7.6 Conclusions

In this chapter, we have considered random access in wireless networks
under the physical interference model. By recognizing that the receiver
can successfully decode the strongest packet in presence of multiple
transmissions, we have proposed PCFCFS, a splitting algorithm that
modulates transmission powers of users based on observed channel
feedback. PCFCFS achieves higher throughput and substantially lower
delay than those of the well known FCFS algorithm with uniform
transmission power. We show that the maximum stable throughput of PCFCFS
is 0.5518. PCFCFS can be implemented in those scenarios where users are
willing to trade some power for a substantial gain in throughput.
Moreover, if users can estimate the arrival rate of packets, then they
can employ FCFS algorithm for arrival rates up to 0.4871 and PCFCFS
algorithm for higher arrival rates, thus leading to further reduction in
average transmission power.

## Chapter 8 Flow Control: An Information Theory Viewpoint

This thesis has so far explored various aspects of link scheduling in
wireless networks. An equally interesting problem is to analyze flow
control. We formulate the problem of controlling the rate of packets at
the ingress of a packet network (possibly a wireless link) so as to
maximize the mutual information between a source and a destination. We
discuss various nuances of the problem and describe related work. We
then derive the maximum entropy of a packet level flow that conforms to
linearly bounded traffic constraints, by taking into account the covert
information present in the randomness of packet lengths. Our results
provide insights towards the design of flow control mechanisms employed
by an Internet Service Provider (ISP).

The rest of the chapter is organized as follows. In Section 8.1 , we
define the problem of information theoretic analysis of flow control in
a packet network. In Section 8.2 , we introduce a Generalized Token
Bucket Regulator (GTBR) as our flow control mechanism. The concepts of
flow entropy and information utility are defined in Section 8.3 . We
formulate the problem of determining the GTBR with maximum information
utility in Section 8.4 . In Section 8.5 , we derive a necessary
condition for the optimal GTBR and compute its parameters. We explain
the results from an information theoretic viewpoint in Section 8.6 and
discuss the implications of our work in Section 8.7 .

### 8.1 System Model

Our system model is shown in Figure 8.1 , wherein a source sends packets
to a destination over a packet-switched network (possibly a wireless
network). The packets transmitted by the source are regulated (policed)
by a flow control mechanism at the ingress of the network. We are
interested in the packet probability distribution that maximizes the
mutual information between the source and the destination. In other
words, given the description of the flow control mechanism and the
stochastic characterization of the packet network, we seek the maximum
amount of information (in the Shannon sense) that can be transmitted
from the source to the destination.

The problem can be stated as:

  -- -------- -- -------
     @xmath      (8.1)
  -- -------- -- -------

where

  -- -------- -------- -------- --
     @xmath   @xmath            
                       @xmath   
     @xmath   @xmath            
                       @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

( 8.1 ) can be simplified to:

  -- -------- -- -------
     @xmath      (8.2)
  -- -------- -- -------

Thus, to maximize the information transfer from the source to the
destination, we not only have to characterize the entropy of the
source’s packets @xmath , but also the conditional entropy of the
source’s packets given the packets received at the destination @xmath .

We state the following remarks about our problem formulation:

1.  It is well-known that, in a packet-switched network, information can
    be transmitted not only by the contents, but also by the lengths and
    timings of packets. [ 20 ] is perhaps the first work to recognize
    this fact. Information transmitted by the lengths and timings of
    packets is referred to as covert information or side information .
    The channel that is used to convey covert information is called
    covert channel . Covert channels have been investigated in [ 20 ] ,
    [ 21 ] , [ 90 ] .

2.  By flow control, we mean a rate control mechanism that regulates the
    packets transmitted by a source (subscriber) at the ingress of a
    network. Note that we do not consider end-to-end flow control
    mechanisms such as Transmission Control Protocol (TCP). For
    simplicity, we consider a flow control mechanism that is described
    by a linearly bounded service curve ¹ ¹ 1 Consider a flow through a
    system @xmath with input and output functions @xmath and @xmath
    respectively. @xmath offers to the flow a service curve @xmath if
    and only if @xmath is a wide sense increasing function, with @xmath
    , and @xmath for all @xmath . [ 91 ] .

3.  In the packet network, packets can be received incorrectly at the
    destination due to fluctuations in the channel, like that in a
    wireless channel. We assume the existence of link layer mechanisms
    such as Forward Error Correction (FEC) which ensure that all packets
    are correctly received at the destination.

The packet network shown in Figure 8.1 only guarantees that the contents
and lengths of the packets transmitted by the source are the same as
those at the destination. However, the network can arbitrarily vary the
timings between packets. Equivalently, the network can highly distort
the covert timing information carried by the packets.

Taking a cue from this, we only take into account information that is
carried by the contents and lengths of the packets. Consequently, the
probability distribution of packet contents and lengths at the
destination is the same as that at the source. Hence, @xmath and ( 8.2 )
simplifies to

  -- -------- -- -------
     @xmath      (8.3)
  -- -------- -- -------

In other words, we seek the probability distribution of packet contents
and lengths that maximize the source entropy @xmath .

Typically, the entity that owns a network, say an Internet Service
Provider (ISP), implements certain mechanisms to ensure that packets
transmitted by a subscriber are not lost in the network. However, to
allocate network resources efficiently and guarantee zero loss of
packets, the entity also mandates that the aggregate traffic of a
subscriber be upper bounded by an envelope or a service curve. For
example, the entity can mandate that the aggregate traffic of the
subscriber be linearly bounded. A linearly bounded service curve can be
implemented by a class of regulators known as token bucket regulators.

The system model that we analyze incorporates a Token Bucket Regulator
(TBR) and is shown in Figure 8.2 . A source transmits packets to a
destination over a network, where every packet consists of an integer
number of bits. The packets transmitted by the source are regulated by a
TBR or leaky bucket regulator [ 92 ] . Intuitively, the regulator
collects tokens in a bucket of depth @xmath , which fills up at a
certain rate @xmath . Each token corresponds to the permission to
transmit one bit into the network. The packets to be transmitted by the
source accumulate in its data buffer over time. If there is a packet of
length @xmath bits in the data buffer at a given time, then it can be
sent into the network only if @xmath . If the packet is transmitted,
then @xmath tokens are depleted from the token bucket.

A TBR can be used to smoothen the bursty nature of a subscriber’s
traffic. We assume that the network is owned by an ISP. From a Quality
of Service (QoS) perspective, a TBR can be considered to be a part of
the Service Level Agreement (SLA) between a subscriber and an ISP. The
SLA mandates that the ISP should provide end-to-end loss and delay
guarantees to a subscriber’s packets, provided the traffic profile of
the subscriber adheres to certain TBR constraints. Specifically, the
onus of the ISP is to ensure that every packet of a conforming source
successfully reaches its destination within a certain permissible delay.

The Standard Token Bucket Regulator (STBR), as defined by the Internet
Engineering Task Force (IETF) and shown in Figure 8.2 , enforces
linear-boundedness on the flow. An STBR is characterized by its token
increment rate @xmath and bucket depth @xmath . We will be more general
and consider a TBR in which the token increment rate and bucket depth
(maximum burst size) can vary from slot to slot. Such a TBR, which we
define as a Generalized Token Bucket Regulator (GTBR), can be used to
regulate Variable Bit Rate (VBR) traffic ² ² 2 For example, a
pre-recorded video stream. from a source [ 93 ] . The continuous-time
analogue of a GTBR is the time-varying leaky bucket shaper [ 94 ] in
which the token rate and bucket depth parameters can change at specified
time instants.

The idea is to develop the notion of information utility of a GTBR.
Specifically, we derive the maximum information that a GTBR-conforming
traffic flow can convey in a finite time interval, by taking into
account the additional information present in the randomness of packet
lengths. These aspects are further elucidated in subsequent sections.

### 8.2 Generalized Token Bucket Regulator

In this section, we mathematically describe our system model and define
a GTBR. We also explain the differences between our system model and
those considered in existing literature.

Consider a system in which time is divided into slots and a source which
has to complete its data transmission within @xmath slots. In our
discrete-time model, we will evaluate the system at time instants @xmath
. Slot @xmath is defined to be the time interval @xmath , i.e., data
transmission commences with slot 0 and terminates with slot @xmath .

The traffic from the source is regulated by a GTBR. We define:

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (8.4)
  -- -------- -------- -------- -- -------

@xmath , @xmath , @xmath and @xmath , whose relative time instants are
shown in Figure 8.3 , are all non-negative integers. Let @xmath denote
the token increment sequence and @xmath denote the bucket depth
sequence. The system starts with zero tokens. So, @xmath . A GTBR with
the above parameters is denoted as @xmath .

The constraints imposed by @xmath on the packet lengths is

  -- -------- -- -------
     @xmath      (8.5)
  -- -------- -- -------

If ( 8.5 ) is satisfied, then @xmath is a conforming packet length
vector and the number of residual tokens will evolve according to

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (8.6)
  -- -------- -------- -------- -- -------

( 8.6 ) is referred to as the token evolution equation.

Note that if @xmath @xmath @xmath and @xmath @xmath @xmath , then the
GTBR @xmath degenerates to the STBR @xmath .

We should point out that our system model is similar to that of [ 95 ] .
However, unlike [ 95 ] , our traffic regulator is a deterministic
mapping of an input sequence to an output sequence. Also, the rate of
our regulator is defined by the average token increment rate and not by
the peak rate.

The system model encompasses that of [ 90 ] , wherein the authors have
derived the information utility of an STBR and suggested a pricing
viewpoint for its application. Our interest, however, is more
theoretical. Specifically, we consider an STBR as a special case of a
GTBR and describe a framework for their information-theoretic
comparison. The main objective is to investigate whether a GTBR can
achieve higher flow entropy than an STBR and explain the properties of
entropy-maximizing GTBRs. These aspects are addressed in the following
sections.

### 8.3 Notion of Information Utility

In this section, we introduce the concept of information utility of a
GTBR. We derive the entropy of a flow that is regulated by a GTBR by
considering the information present in the contents and lengths of the
packets. We formulate the problem of computing the maximum flow entropy
and subsequently describe a technique to compute the information utility
of the GTBR.

Consider a source which has a large amount of data to send and whose
traffic is regulated by a GTBR. We seek to maximize the information that
the source can convey to the destination in the given time interval or
the entropy present in the source traffic flow in an
information-theoretic sense. For a given transmission interval @xmath ,
token increment sequence @xmath and bucket depth sequence @xmath , the
maximum entropy achievable by any flow which is constrained by the GTBR
@xmath is termed as the information utility of the GTBR @xmath .

The source can send information to its destination via two channels:

1.  Overt channel: The contents of each packet. Let @xmath denote the
    length of a packet in bits. The value of each bit is @xmath or
    @xmath with equal probability and is independent of the values taken
    by the preceding and succeeding bits. Thus, this packet contributes
    @xmath bits of information.

2.  Covert channel: We consider the length of a packet as an event and
    associate a probability with it. Thus, side information is
    transmitted by the randomness in the packet lengths.

The joint entropy of i . and ii . is the sum of their entropies.

During any slot @xmath , the only method by which past transmissions can
constrain the rest of the flow is by the residual number of tokens
@xmath . So, @xmath captures the state of the system. The key
observation is that the future entropy depends only on the token bucket
level @xmath in slot @xmath . Hence, entropy is a function of system
state @xmath and is denoted by @xmath .

During slot @xmath , the source signals the termination of the current
flow by transmitting a special string of bits (flag). The information
transmitted by this fixed sequence of bits is zero. Thus

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (8.7)
  -- -------- -------- -------- -- -------

For a given state @xmath of the system, if a packet of length @xmath
bits is transmitted with probability @xmath , then

1.  The overt information transmitted is @xmath bits,

2.  As the event occurs with probability @xmath , the covert information
    transmitted is @xmath bits,

3.  Since @xmath is random, @xmath is also random (from ( 8.6 )). Thus,
    @xmath is also a random variable.

Adding all of the above and averaging it over all conforming packet
lengths, we obtain the entropy in the current slot (stage)

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (8.8)
                                @xmath   
  -- -------- -------- -------- -------- -------

The equation above, which will be referred to as the flow entropy
equation , intuitively states that the flow entropy of the current state
is given by the sum of the entropy of the packet contents, the entropy
of the packet lengths and the flow entropy of possible future states in
the next slot. Note that ( 8.8 ) is similar to the backward recursion
equation from dynamic programming [ 96 ] . Finally, the packet length
probabilities must satisfy

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (8.9)
  -- -------- -------- -------- -- -------

Let @xmath denote the vector of packet length probabilities for slot
@xmath with @xmath residual tokens. The dependence of @xmath and @xmath
on @xmath is assumed to be understood and is not always stated
explicitly. So, @xmath .

Our objective is to determine the sequence of probability mass functions
@xmath , @xmath , @xmath , @xmath which maximizes the flow entropy
@xmath for a given GTBR @xmath . From ( 8.7 )

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.10)
  -- -------- -------- -------- -- --------

From ( 8.8 )

  -- -------- -------- -- -------- --------
     @xmath   @xmath               (8.11)
                          @xmath   
  -- -------- -------- -- -------- --------

Given @xmath @xmath @xmath , there exists an optimum probability vector
@xmath which maximizes the flow entropy @xmath , i.e.,

  -- -------- -------- -------- -------- --------
     @xmath   @xmath   @xmath            (8.12)
                                @xmath   
  -- -------- -------- -------- -------- --------

Thus, the problem of computing the entire sequence of probability
vectors @xmath , @xmath , @xmath , @xmath decouples into a sequence of
subproblems. The subproblem for slot @xmath is: Given the function
@xmath , determine the probability vector @xmath so as to

  -- -- -- -------- -- --------
                       
           @xmath      (8.13)
  -- -- -- -------- -- --------

( 8.13 ) is an equality-constrained optimization problem and can be
solved using the technique of Lagrange multipliers [ 97 ] . Define the
Lagrangian

  -- -------- -------- -- -------- --------
     @xmath   @xmath               (8.14)
                          @xmath   
  -- -------- -------- -- -------- --------

At the optimal point @xmath , we must have

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.15)
     @xmath   @xmath   @xmath      (8.16)
  -- -------- -------- -------- -- --------

Solving ( 8.16 ) yields

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.17)
  -- -------- -------- -------- -- --------

which is ( 8.9 ) for the case of optimal probabilities. Solving ( 8.15
), we obtain

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.18)
  -- -------- -------- -------- -- --------

From ( 8.17 ) and ( 8.18 ), the optimal Lagrange multiplier is given by

  -- -- -- --------
           (8.19)
  -- -- -- --------

From ( 8.18 ) and ( 8.19 ), the optimum packet length probability is
given by

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.20)
  -- -------- -------- -------- -- --------

From ( 8.12 ) and ( 8.20 ), we finally obtain

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.21)
  -- -------- -------- -------- -- --------

( 8.21 ) will be referred to as the optimal flow entropy equation .

The information utility of the GTBR @xmath is defined to be @xmath , the
maximum flow entropy. @xmath is computed by starting with @xmath , and
using ( 8.21 ) to compute the optimal flow entropy @xmath for all @xmath
and then proceeding backward recursively for @xmath .

### 8.4 Problem Formulation

Having developed a method to compute the information utility of a GTBR
in Section 8.3 , we seek answers to the following questions:

1.  Can a GTBR achieve higher information utility than that of an STBR?

2.  If yes, what is the increase in information utility?

For the information-theoretic comparison of a GTBR @xmath and an STBR
@xmath , we impose the following conditions:

1.  @xmath and @xmath must operate over the same number of slots, i.e.,

      -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (8.22)
      -- -------- -------- -------- -- --------

2.  The aggregate tokens of @xmath and @xmath must be equal, i.e.,

      -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (8.23)
      -- -------- -------- -------- -- --------

3.  The aggregate bucket depth of @xmath must not exceed that of @xmath
    ³ ³ 3 Equality is present in ( 8.23 ) because every additional token
    directly translates to the permission to transmit one more bit,
    leading to increase in information utility. As this is not
    necessarily true for bucket depth, we permit inequality in ( 8.24 ).
    , i.e.,

      -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (8.24)
      -- -------- -------- -------- -- --------

4.  The bucket depth of @xmath cannot be very high compared to its token
    increment rate. To quantify this, we mandate ⁴ ⁴ 4 This assumption
    is practically justifiable. For example, in [ 94 ] , the authors use
    @xmath Mbps and @xmath Mbps for their simulations.

      -- -------- -- --------
         @xmath      (8.25)
      -- -------- -- --------

5.  The token increment rate of @xmath in every slot must not exceed the
    bucket depth of @xmath , i.e.,

      -- -------- -------- -------- -- --------
         @xmath   @xmath   @xmath      (8.26)
      -- -------- -------- -------- -- --------

If Conditions 1 , 2 , 3 , 4 and 5 are satisfied, then GTBR @xmath and
STBR @xmath are said to be comparable to each other.

The optimal GTBR problem is formally stated as:
Given an STBR @xmath , determine the token increment sequence @xmath and
bucket depth sequence @xmath of a comparable GTBR @xmath so as to

  -- -- -------- -------- -- --------
                 @xmath      
        @xmath   @xmath      (8.27)
        @xmath   @xmath      (8.28)
  -- -- -------- -------- -- --------

Note that we are maximizing a real-valued function over two finite
sequences of non-negative integers.

### 8.5 Results

In this section, we derive a necessary condition for the optimal GTBR in
terms of aggregate bucket depth. We also compute the parameters of the
optimal GTBR for some representative cases.

#### 8.5.1 Analytical Result

###### Proposition 8.5.1.

For an optimal GTBR, equality must hold in ( 8.28 ), except when @xmath
is small. In other words, if @xmath is the bucket depth sequence of an
optimal GTBR, it must satisfy

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.29)
  -- -------- -------- -------- -- --------

###### Proof.

We prove by contradiction. Define @xmath . Since @xmath , @xmath . From
( 8.21 )

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.30)
  -- -------- -------- -------- -- --------

@xmath is an increasing sequence in @xmath . Using ( 8.30 ), we can show
that @xmath is an increasing sequence in @xmath @xmath @xmath . Let
@xmath maximum number of tokens possible in slot @xmath . Thus

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.31)
     @xmath   @xmath   @xmath      (8.32)
  -- -------- -------- -------- -- --------

If @xmath , then we say that state @xmath is reachable in slot @xmath ,
otherwise it is unreachable.

Let @xmath be an optimal GTBR, for which equality does not hold in (
8.28 ). Then @xmath . Consider another GTBR @xmath with @xmath and
@xmath for some @xmath . Let @xmath denote the optimal flow entropy of
@xmath in slot @xmath with @xmath residual tokens. Define @xmath . From
( 8.21 )

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.33)
  -- -------- -------- -------- -- --------

@xmath satisfies ( 8.28 ). @xmath @xmath @xmath and @xmath @xmath .
Since @xmath , it follows that @xmath . If we determine a reachable
state @xmath such that @xmath , then @xmath , since the flow entropy in
slot @xmath is computed slot-by-slot as a linear sum of future possible
flow entropies with positive weights. Thus, the problem now reduces to
determining a slot @xmath and a reachable state @xmath such that @xmath
. One of the following must hold:

1.  There exists an @xmath @xmath @xmath such that @xmath , or

2.  There is no @xmath such that @xmath .

Case 1 : Consider the smallest @xmath such that @xmath . Substituting
@xmath in ( 8.30 ), we obtain

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (8.34)
  -- -------- -------- -------- -- --------

Substituting @xmath in ( 8.33 ), we obtain

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (8.35)
  -- -------- -------- -------- -- --------

( 8.34 ) and ( 8.35 ) hold only if

  -- -------- -- --------
     @xmath      (8.36)
  -- -------- -- --------

@xmath is a state which is reachable in the original system as well as
in the primed system and satisfies ( 8.36 ). Since @xmath is an
increasing sequence in @xmath , ( 8.34 ) and ( 8.35 ) imply @xmath .
Consequently, @xmath .

Case 2 : If no such @xmath exists, then we must have @xmath @xmath
@xmath . Adding these @xmath inequalities and using @xmath (from ( 8.26
)),

  -- -------- -------- -------- -------- --------
     @xmath   @xmath   @xmath            (8.37)
                       @xmath   @xmath   
              @xmath   @xmath            (8.38)
  -- -------- -------- -------- -------- --------

We cannot have @xmath @xmath @xmath (from ( 8.25 ), ( 8.26 ) and ( 8.27
)). Thus, @xmath cannot be of the order of @xmath . Thus, the lower
bound on @xmath given by ( 8.37 ) and ( 8.38 ) is a loose lower bound.
From ( 8.25 ), ( 8.28 ) and ( 8.38 ), @xmath grows as @xmath and is
upper-bounded by @xmath , which is impossible (except when @xmath is
small). So, we discard Case 2 .

From the result of Case 1 , @xmath . So, our assumption that @xmath is
an optimal GTBR is incorrect. Therefore, equality must hold in ( 8.28 )
for every optimal GTBR. ∎

#### 8.5.2 Numerical Results

For a given data transmission time @xmath , token increment sequence
@xmath and bucket depth sequence @xmath , we determine the optimal GTBR
by exhaustive search over the reduced search space obtained from
Proposition 8.5.1 . Our computation results are shown in Table 8.1 .
@xmath and @xmath denote the information utility of the STBR @xmath and
the optimal GTBR @xmath respectively. We also observe the variation in
information utility of the optimal GTBR with important parameters of the
comparable STBR, namely its bucket depth @xmath and token increment rate
@xmath . For a data transmission time of 4 slots and token increment
rate of 3 bits, Figure 8.4 shows the variation of information utility of
the GTBR versus the bucket depth of the comparable STBR. For a data
transmission time of 4 slots and bucket depth of 15 bits, Figure 8.5
shows the variation of information utility of the GTBR versus the token
increment rate of the comparable STBR.

Based on our computations, we draw the following inferences:

1.  A generalized token bucket regulator can achieve higher information
    utility than that of a standard token bucket regulator. The increase
    in information utility is significant (up to 7.2%), especially for
    higher values of @xmath .

2.  The optimal bucket depth sequence @xmath is uniform ⁵ ⁵ 5 @xmath .
    or near-uniform (the standard deviation is very small compared to
    the mean).

3.  The optimal token increment sequence @xmath is a decreasing sequence
    and is not uniform.

4.  For a fixed data transmission time @xmath and token increment rate
    @xmath :

    1.  If @xmath , @xmath is always uniform and @xmath is uniform
        except for the terminal values.

    2.  As @xmath increases from @xmath to @xmath , the variance of
        @xmath increases rapidly with a concentration of tokens in first
        few stages, the variance of @xmath increases slowly, while
        @xmath initially increases and then saturates at some final
        value. @xmath is an increasing and concave sequence ⁶ ⁶ 6 The
        sequence of first-order differences @xmath is a decreasing and
        non-negative sequence. in @xmath (see Figure 8.4 ).

5.  For a fixed data transmission time @xmath and bucket depth @xmath ,
    @xmath an increasing, highly linear and slightly concave sequence in
    @xmath (see Figure 8.5 ).

### 8.6 Information-Theoretic Interpretation

In this section, we provide explanations for empirical results in
Section 8.5 . The explanations are intuitive and rely on basic results
from information theory.

Consider a system with @xmath states, where @xmath denotes the
probability of state @xmath and @xmath . From classical information
theory, system entropy @xmath increases with decreasing Kullback-Leibler
distance between the given probability mass function (pmf) and the
uniform pmf [ 98 ] . @xmath is maximized only if @xmath . Also, @xmath
increases with @xmath . Analogously, a GTBR can achieve higher
information utility than that of an STBR because the pmfs of the packet
lengths at each stage are more uniform and have a larger support. Recall
that, for given @xmath and @xmath , information utility is computed
recursively using ( 8.6 ) and ( 8.21 ).

We argue that the optimal bucket depth sequence @xmath must be uniform
or near-uniform for maximum information utility. If @xmath is neither
uniform nor near uniform, then @xmath is much smaller than @xmath . This
restricts the range of values taken by @xmath and @xmath (from ( 8.5 )
and ( 8.6 )). The support of packet length pmfs at stage @xmath is
reduced, leading to lower flow entropy at stage @xmath and consequently
lower information utility. Thus, @xmath must be uniform or near-uniform
to maximize the minimum support of packet length pmfs at each stage . In
Table 8.1 , the observation that @xmath or @xmath throughout
corroborates our claim that @xmath is near-uniform.

We argue that for maximum information utility, the optimal token
increment sequence @xmath must be a decreasing sequence, subject to
@xmath for every @xmath . If @xmath for any @xmath , then a packet of
length zero cannot be transmitted in slot @xmath (from ( 8.6 )) and will
have zero probability. This decreases the support of the packet length
pmfs in slot @xmath and leads to lower information utility. More
importantly, from ( 8.8 ),

  -- -------- -------- -------- -- --------
     @xmath   @xmath   @xmath      (8.39)
  -- -------- -------- -------- -- --------

The major contribution to information utility @xmath is from the support
of the packet lengths @xmath and the pmf of the packet lengths @xmath ,
while the contribution from @xmath is relatively smaller. So, to
maximize @xmath , @xmath should be allowed to take its maximum possible
value, subject to @xmath , and the pmf of the packet lengths should be
close to the uniform pmf. The observation that @xmath consistently in
Table 8.1 corroborates this. Also, a high value of @xmath leads to
larger supports of packet length pmfs at intermediate and later stages.
Similarly, the first few elements of @xmath tend to take large values
till the aggregate tokens are exhausted. However, their contribution to
@xmath is not as pronounced and equality may not hold in @xmath . Thus,
@xmath must be a decreasing sequence and the first few elements of
@xmath tend to take their maximum possible values, subject to @xmath ,
to achieve uniformity and larger supports of packet length pmfs at
intermediate and later stages .

This “greedy” nature of @xmath is evident when @xmath and @xmath are
kept constant and @xmath increases (Result 6 ). A similar argument is
applicable when @xmath and @xmath are kept constant and @xmath increases
(Result 5 ). The only difference is that a unit increase in @xmath will
necessarily increase @xmath by at least @xmath bits ( @xmath bits are
contributed by the packet contents alone, which also explains the
dominant linear variation in Figure 8.5 ), while a unit increase in
@xmath will increase @xmath only by an amount equal to the difference in
covert information. The increase in covert information is positive only
if the optimal token increment and bucket depth sequences ( @xmath and
@xmath ) result in larger support and more uniformity for the packet
length pmfs. Indeed, when @xmath increases beyond the maximum number of
tokens possible at any stage ( @xmath ), clamping the residual number of
tokens at every stage becomes ineffective and the system behaves as if
bucket depth constraints were not imposed at all (Figure 8.4 ).

### 8.7 Discussion

In this chapter, we have studied linearly bounded flows over a packet
network. We considered a source whose traffic is regulated by a
generalized token bucket regulator and which seeks to maximize the
entropy of the resulting flow. Recognizing that the randomness in packet
lengths acts as a covert channel in the network, the source can achieve
maximum entropy by sizing its packets appropriately. We have formulated
the problem of computing the GTBR with maximum information utility in
terms of constrained token increment and bucket depth sequences. A GTBR
can achieve higher information utility than that of a standard IETF
token bucket regulator. Finally, we have information-theoretically
interpreted the observation that an entropy-maximizing GTBR always has a
near-uniform bucket depth sequence and a decreasing token increment
sequence.

## Chapter 9 Conclusions

The recent revolution in wireless communications has motivated
researchers and engineers alike to design ever better wireless networks
that deliver high data rates to users. The joint design of physical and
MAC layers is the key to breaking the “bandwidth bottleneck” of wireless
networks, which has been the primary inspiration for this thesis.

This thesis has focused on link scheduling in wireless mesh networks by
taking into account physical layer characteristics. The assumption made
throughout this thesis is that a packet is received successfully only if
the SINR at the receiver exceeds a certain threshold, termed as
communication threshold. The thesis has also discussed the complementary
problem of flow control.

The first part of this thesis has considered link scheduling in STDMA
wireless networks. The network is modeled by a finite set of
store-and-forward nodes that communicate over a wireless channel
characterized by propagation path loss. We have considered two nuances
of the scheduling problem: point to point link scheduling wherein a
transmitted packet is intended for a single neighbor only, and point to
multipoint link scheduling wherein a transmitted packet is intended for
all neighbors in the vicinity.

Specifically, in Chapter 2 , we have introduced the system model of an
STDMA wireless network. We have discussed two prevalent models for
specifying the criteria for successful packet reception: the protocol
interference model which mandates a “silence zone” around a receiver and
is better suited to represent WLANs, and the physical interference model
which mandates that the SINR at a receiver be no less than the
communication threshold and is more appropriate to represent mesh
networks. We have described the equivalence between a link schedule and
the coloring of edges of a certain graph representation of the network,
termed as communication graph. We have argued that STDMA link scheduling
algorithms can be broadly categorized into three classes: those based
entirely on a communication graph representation of the network, those
based on communication graph and SINR threshold conditions and those
based entirely on an SINR graph representation of the network. We have
reviewed representative research papers from each of these classes. We
have described limitations of algorithms that are based only on the
communication graph. Subsequently, we have introduced spatial reuse as a
performance metric that corresponds to aggregate network throughput.

Next, in Chapter 3 , we have critically examined ArboricalLinkSchedule,
a point to point link scheduling algorithm proposed in [ 16 ] . While
this is one of the earlier works on link scheduling with nice
theoretical properties, it could yield a higher schedule length in
practice. Specifically, the methodology employed by
ArboricalLinkSchedule is to represent the network by a communication
graph, partition the graph into minimum number of subgraphs and color
each subgraph in a greedy manner. We have modified the algorithm to
reuse colors while coloring successive subgraphs of the communication
graph. We have shown that the modified algorithm yields lower schedule
length in practice, albeit at a cost of slightly higher running time
complexity. Subsequently, we have proposed the ConflictFreeLinkSchedule
algorithm that not only utilizes the communication graph, but also
verifies SINR threshold conditions at receivers. We have demonstrated
that the proposed algorithm achieves higher spatial reuse than existing
algorithms, even under fading and shadowing channel conditions. We have
argued that the running time complexity of the proposed algorithm is
only marginally higher than those of existing algorithms.

Taking a step ahead, in Chapter 4 , we have provided a somewhat
different perspective on point to point link scheduling. For an STDMA
network, we recognize that interferences between pairs of links can be
embedded into edge weights and normalized noise powers at receivers of
links can be embedded into vertex weights of a certain graph
representation of the network, termed as SINR graph. We have then
proposed SINRGraphLinkSchedule, a novel link scheduling algorithm that
is based on the SINR graph. We have proved the correctness of the
algorithm and shown that it has polynomial running time complexity. We
have demonstrated that the proposed algorithm achieves high spatial
reuse compared to algorithms which utilize a communication graph model
of the network, including ConflictFreeLinkSchedule algorithm.

In Chapter 5 , we have considered point to multipoint link scheduling
and generalized the definition of spatial reuse for this scenario. We
have proposed a scheduling algorithm based on a communication graph
representation of the network and “neighbor-average” SINR threshold
conditions. Moreover, we have demonstrated that the proposed algorithm
achieves higher spatial reuse than existing algorithms, without any
increase in running time complexity.

Overall, we have observed the tradeoff between accuracy of the network
representation, spatial reuse and algorithm running time complexity in
our successive results. For a more accurate network representation,
higher spatial reuse is achieved, but at a cost of higher running time
complexity. For example, since the SINR graph representation of an STDMA
network is more accurate than the communication graph representation,
SINRGraphLinkSchedule achieves higher spatial reuse than that of
ConflictFreeLinkSchedule, but at a cost of increased running time
complexity.

A summary of existing and proposed link scheduling algorithms
investigated in the first part of the thesis is provided in Table 9.1 .

The second part of this thesis has considered link scheduling in random
access wireless networks. Specifically, it has focused on random access
algorithms for wireless networks that take into account channel effects
and SINR conditions at the receiver.

In Chapter 6 , we have reviewed representative research papers on such
random access techniques. We have also motivated the use of variable
transmission power in random access wireless networks.

Subsequently, in Chapter 7 , we have investigated a random access
scenario wherein multiple transmitters (users) attempt to communicate
with a single receiver over a wireless channel characterized by
propagation path loss. We have assumed that the receiver is capable of
power based capture and proposed an interval splitting algorithm that
varies transmission powers of users based on their arrival times and
quaternary channel feedback. We have modeled the algorithm dynamics by a
Discrete Time Markov Chain and consequently shown that its maximum
stable throughput is 0.5518. We have demonstrated that the proposed
algorithm has higher throughput and lower delay than the FCFS interval
splitting algorithm with uniform transmission power.

The third and final part of this thesis has considered
information-theoretic analysis of flow control in packet networks. We
have defined the problem of maximizing the information carried by
packets from a source to a destination, subject to a flow control
mechanism at the ingress of the network. We have considered a linearly
bounded flow and focused on the information carried by the randomness in
packet contents and lengths. Consequently, we have formulated the
problem of maximizing the entropy of a packet level flow that is shaped
by a generalized token bucket regulator. We have demonstrated that the
optimal regulator has a decreasing token increment sequence and a
near-uniform bucket depth sequence. Finally, we have provided
information theoretic interpretations for these observations.

To sum it up, in this thesis, we have investigated both fixed and random
access flavors of link scheduling problems in wireless networks from a
physical layer viewpoint. Finally, we have discussed a flow control
problem in packet networks.

Various avenues for further research have emerged from our
investigations. We outline some possible directions for future work.

1.  It would be interesting to derive approximation bounds of
    ConflictFreeLinkSchedule and SINRGraphLinkSchedule algorithms under
    reasonable assumptions on node deployment and interference regions.
    The assumptions and approximation techniques employed in [ 27 ] may
    provide some pointers in this direction.

2.  Though distributed link scheduling algorithms for STDMA wireless
    networks under the protocol interference model have been proposed in
    [ 31 ] , [ 99 ] , the design of distributed link scheduling
    algorithms under the physical interference model remains a
    challenging problem.

3.  Various generalizations of the PCFCFS algorithm are worth
    investigating. For example:

    1.  Design a variable power splitting algorithm under the assumption
        that users are at unequal distances from the receiver and can
        adjust their minimum transmission powers accordingly.

    2.  Design a splitting algorithm for the case when the receiver is
        capable of decoding more than one packet correctly (as in
        wideband systems) and the users can employ @xmath transmission
        power levels, where @xmath .

    3.  Analyze the throughput improvement in CSMA/CA based WLANs when
        power control is employed in conjunction with binary exponential
        backoff. The work done in [ 100 ] can be a useful starting
        point.

4.  A challenging task would be to analyze the expected delay of the
    PCFCFS algorithm. A useful starting would be [ 101 ] , [ 102 ] ,
    which have employed techniques to obtain upper and lowers bounds on
    the expected delay of the FCFS algorithm.

5.  Our results in Chapter 8 show the existence of upper bounds on the
    entropy of regulated flows. It would be interesting to construct
    source codes which come close to this bound. Furthermore, it would
    be insightful to develop a rate-distortion framework for a
    generalized token bucket regulator, perhaps using the techniques
    employed in [ 95 ] .

26] ]26 26] ]26

## Appendix A Proofs of Limiting Transition Probabilities

According to L’Hôpital’s Rule, if @xmath and @xmath are both zero or are
both @xmath and, if @xmath has a finite value or if the limit is @xmath
, then

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (A.1)
  -- -------- -------- -------- -- -------

We will employ L’Hôpital’s Rule to prove ( 7.54 ) - ( 7.66 )

In this appendix, we will only provide the proofs of ( 7.54 ), ( 7.55 ),
( 7.56 ) and ( 7.57 ). The proofs of ( 7.58 ) - ( 7.66 ) are similar to
those of ( 7.54 ) - ( 7.57 ) and are omitted.

### a.1 Proof of (7.54)

###### Proof.

In ( 7.25 ), substitute @xmath . From ( 7.7 ), @xmath . As @xmath ,
@xmath . Thus, using L’Hôpital’s Rule successively, we obtain

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

∎

### a.2 Proof of (7.55)

###### Proof.

In ( 7.26 ), substitute @xmath . Thus, using @xmath and applying
L’Hôpital’s Rule successively, we obtain

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

∎

### a.3 Proof of (7.56)

###### Proof.

In ( 7.27 ), substitute @xmath . Thus, using @xmath and applying
L’Hôpital’s Rule successively, we obtain

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

∎

### a.4 Proof of (7.57)

###### Proof.

In ( 7.28 ), substitute @xmath . Thus, using @xmath and applying
L’Hôpital’s Rule successively, we obtain

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
              @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

∎