# 1 Introduction

The satisfiability of first-order logic (FOL) is in general undecidable,
but when limited to domains of a finite and small size the search
becomes feasible. According to Jackson’s small scope hypothesis [
jackson_software_2012 ] , most flaws in formal models can be exposed by
counterexamples of small size, so if all possible interpretations up to
a sufficiently high size are explored and no counterexample is found,
then we can have a high degree of confidence in the correctness of the
model. Therefore, the process of finite model finding (FMF) is an
important tool for formal methods. This importance is evident with the
popularity of Jackson’s Alloy Analyzer [ jackson_software_2012 ] and its
underlying model finder Kodkod [ grumberg_kodkod:_2007 ] , which have
found applications in security, e-commerce, feature modeling, program
verification, network protocols, and many more fields.

Automated finite model finders generally take one of two main
approaches. In the SEM-style, the solver directly traverses the search
space to find a solution, usually through a backtracking algorithm with
constraint propagation techniques. Mace4 [ bonacina_mace4_2013 ] , SEM [
goos_system_1996 ] , and FALCON [ zhang_constructing_1996 ] are examples
of SEM-style solvers. There is also the MACE-style, in which a solver
does not directly search for a solution but instead encodes the problem
in another logic and invokes an external solver. Kodkod [
grumberg_kodkod:_2007 ] and Paradox [ claessen_new_2003 ] are MACE-style
solvers that reduce FMF to SAT, while Fortress [ fitzgerald_finite_2016
] is a MACE-style solver that instead reduces the problem to the logic
of equality with uninterpreted functions (EUF) and invokes an SMT
solver.

While decidable, FMF is NP-complete, and so powerful techniques are
needed to make the search feasible. The exploitation of symmetry is one
such technique. Consider the problem of finding a Latin Square. A Latin
Square is a @xmath grid of cells. Each cell contains one of the numbers
@xmath , and no row or column can contain the same number twice. Given a
Latin Square, the numbers @xmath can be permuted within it and another
Latin Square is obtained. While technically a different solution, these
two Latin Squares appear to be symmetric or isomorphic , equivalent in
structure but merely having different labels. Similarly, if given a
non-solution to the Latin Squares problem, permuting the numbers @xmath
within the non-solution will also yield a non-solution.

A naïve search over all possible interpretations will encounter many
isomorphic interpretations. However, only a single interpretation from
an isomorphism class needs to be examined to accept the entire class as
solutions or reject the entire class as non-solutions. Finite model
finders take advantage of these symmetries to perform symmetry breaking
and reduce the search space. Such symmetry breaking can be done
dynamically during a search, or statically by adding constraints that
eliminate redundant interpretations before attempting a search.

The goal of this thesis is to investigate symmetry and static symmetry
breaking in finite model finding, in particular with regards to
many-sorted finite model finding (MSFMF). To our knowledge, little work
has been done to explore how sorts impact the existence of symmetries
and the unique advantages a many-sorted setting gives to static symmetry
breaking. The first half of this thesis explores the surprisingly varied
definitions of “symmetry” throughout finite model finding literature as
well as literature for constraint satisfaction problems (CSPs) in order
to establish how these disparate definitions are related and explore
what new insights can be found about the relationship between symmetries
and sorts. The second half of this thesis investigates static symmetry
breaking techniques for MSFMF. We compare existing symmetry breaking
schemes, considering justification for their correctness, and propose
new symmetry breaking schemes with rigorous proofs of soundness. The
role of sorts in these schemes is given heavy emphasis. We also explore
conditions for when symmetry breaking schemes can be combined.

The contributions of this thesis are as follows.

1.  A review of symmetry and static symmetry breaking techniques in
    constraint satisfaction problems and finite model finding. We
    emphasize the connection to group theory and provide rigorous proofs
    of correctness for existing finite model finding static symmetry
    breaking techniques where previously appeals to intuition were
    relied upon.

2.  Unification of the various definitions of symmetry in finite
    model-finding and relating them to symmetry in constraint
    satisfaction problems. We provide a transformation to embed finite
    model-finding into the CSP symmetry framework proposed by Cohen et
    al. [ cohen_symmetry_2006 ] while preserving the notion of “value
    symmetry” between both problem types, and see how the notions of
    symmetry in these two worlds relate.

3.  New insight into the effects of a sort system on symmetries, using
    the above transformation and framework. We demonstrate that the use
    of many-sorted system does not affect the existence of symmetries,
    but rather a sort system proves the existence of symmetries and
    allows them to be more easily identified. Thus, we establish that
    sort inference is a symmetry detection mechanism.

4.  A new static symmetry breaking technique in the presence of
    “domain-range distinct” (DRD) functions. Such functions only exist
    in a many-sorted system. Rigorous proofs of correctness are provided
    for DRD functions of arbitrary arity.

5.  A new symmetry breaking strategy for unary predicates. A proof of
    correctness is provided, and it is discussed why this scheme does
    not easily apply to higher arity predicates.

6.  Conditions for when symmetry breaking techniques can be combined
    soundly, proved using a framework of extended FMF. To our knowledge
    this has not been rigorously done in existing FMF literature.

### 1.1 Outline of Thesis

Section 2 provides necessary background information in finite model
finding, constraint satisfaction problems, and group theory. Even if the
reader is very familiar with these concepts, we recommend at least
reading the definitions to familiarize oneself with our notation,
especially for finite model finding.

Sections 3 through 5 comprise the first half of this thesis that is more
theoretical and concerned with formalizing the concept of symmetry and
understanding how it arises in CSP and FMF problems. Section 3 looks at
symmetry in CSP and presents a framework developed by Cohen et al. [
cohen_symmetry_2006 ] to formalize symmetry in CSP. Section 4 explores
symmetry in FMF. In this section we look at existing definitions of
symmetry in FMF and use the Value Relabeling Theorem to present a
framework to unify these definitions. We also define extended FMF
problems and how this affects symmetry and then relate symmetry in FMF
and CSP. Section 5 investigates sorts, sort inference, and their impact
on the existence of symmetries.

The second half of this thesis exploring static symmetry breaking
consists of Sections 6 through 9 . Section 6 discusses static symmetry
breaking and the prevalent techniques used in single-sorted FMF. Section
7 introduces the concept of “domain-range distinct” functions and
presents a new static symmetry breaking technique that can be applied in
their presence. Section 8 also introduces a new symmetry breaking
scheme, this time for unary predicates. Finally, Section 9 explores
under what conditions the aforementioned schemes can be combined.

## 2 Background

We assume the reader has a general familiarity with first-order logic
(FOL), in particular the syntax and semantics of MSFOL. To understand
symmetry we must also pull from constraint satisfaction problems (CSPs)
and group theory, though we do not assume the reader has prior exposure
to these fields. Unless otherwise noted, all functions are total.

### 2.1 Finite Model Finding

We are concerned with a treatment of many-sorted first-order logic
(MSFOL), where the domain of discourse is broken into “sorts” or
“types”. Our definitions are based loosely on Vakili and Day’s work [
fitzgerald_finite_2016 ] , though we diverge in our treatments of
relations and domains in order to make later definitions and theorems
easier to state. The formulations are equivalent.

###### Definition 1 (Signature).

A signature is a triple @xmath where

-   @xmath is a finite set of symbols called sorts ,

-   @xmath is a finite set of functional symbols of the form @xmath ,
    where @xmath , and

-   @xmath is a finite set of relational symbols (or predicate symbols )
    of the form @xmath , where @xmath .

For functional symbol @xmath or relational symbol @xmath , @xmath is
called the arity of the symbol. Constants are nullary function symbols;
that is, constants are functional symbols with no argument sorts and
only an output sort. A constant symbol @xmath with output sort @xmath
will be written @xmath .

There are some important things to note about our formulation. First we
emphasize that functional and relational symbols are not themselves
actual functions and relations, they are merely symbols that act as
placeholders for them. Additionally, while some treatments of MSFOL
consider @xmath as a sort with some special rules, our formulation does
not consider @xmath to be a sort. We define @xmath -terms and @xmath
-formulas (usually called simply terms and formulas) in the usual way
for MSFOL. We allow the use of the equality predicate @xmath without it
needing to be explicitly in the signature.

Now that we can build formulas over a signature, we need a universe in
which to interpret them. We are only concerned here with finite domains.

###### Definition 2 (Domain Assignment).

A domain assignment for a signature @xmath is a function @xmath mapping
each sort @xmath to a non-empty, finite set of values @xmath , called
the domain or values of @xmath .

While it is common to think about distinct sorts being assigned disjoint
sets, this need not be the case. The sort system prevents there from
being any undesired interactions between distinct sorts regardless of
whether their underlying domains are disjoint. We are now ready to
define a finite model finding problem.

###### Definition 3 (Many-Sorted Finite Model Finding Problem).

A many-sorted finite model finding (MSFMF) problem is a tuple @xmath
where

-   @xmath is a signature,

-   @xmath is a finite set of MSFOL formulas over @xmath , and

-   @xmath is a domain assignment for @xmath .

Together the elements of the sets assigned by @xmath are referred to as
the values .

###### Definition 4 (Interpretation).

An interpretation of a MSFMF problem @xmath is a mapping @xmath that

-   assigns each functional symbol @xmath a function @xmath , and

-   assigns each relational symbol @xmath a relation @xmath .

Note that @xmath and @xmath are actual functions and relations, not just
symbols.

###### Definition 5 (The “Satisfies” Relation).

Let @xmath be a MSFMF problem and @xmath an interpretation of @xmath .
Given a formula @xmath , we say @xmath satisfies @xmath , written @xmath
, if @xmath is true when interpreted under @xmath using standard
first-order logic semantics. We say @xmath satisfies @xmath , written
@xmath , if it satisfies every formula in @xmath . If @xmath satisfies
@xmath , it is said that @xmath is a model or solution of @xmath . If
@xmath has a model, it is satisfiable , otherwise it is unsatisfiable .

The goal of finite model finding is to determine whether a given MSFMF
problem is satisfiable. We will discuss later how only the size of the
sets in the domain assignment affects the satisfiability of the MSFMF
problem, not the specific sets themselves. That is, if @xmath for all
@xmath , then @xmath is satisfiable if and only if @xmath is
satisfiable. Thus in many equivalent formulations of the finite model
finding problem there is no domain assignment but simply a number @xmath
for each sort @xmath that specifies the size of the domain for @xmath .
However, we opt for this more general formulation with domain
assignments because it facilitates later theorems and discussions.

### 2.2 Constraint Satisfaction Problems

Constraint programming is a general paradigm for finding solutions to
problems involving decision variables subject to a set of constraints.
We base our definition of constraint satisfaction problems (CSPs) on
those found in Freuder and Mackworth’s work [ freuder_constraint_2006 ]
, though we concern ourselves with only finite problems similar to Cohen
et. al [ cohen_symmetry_2006 ] .

###### Definition 6 (Constraint Satisfaction Problem).

A constraint satisfaction problem (CSP) is a triple @xmath where

-   @xmath is a finite set of variables @xmath ,

-   @xmath is a mapping that maps each variable @xmath to a nonempty,
    finite set @xmath , called its domain , and

-   @xmath is a finite set of constraints .

A constraint is a pair @xmath , where @xmath is a sequence of variables
@xmath , @xmath , called the scope ¹ ¹ 1 The word “scope” is overloaded.
In constraint programming, it refers to the variables affected by a
constraint. In finite model finding, it sometimes refers to the size of
the set of values in a domain assignment, what we earlier called @xmath
for a sort @xmath . From this point on, when we say “scope”, we refer to
the former and never the latter. of the constraint, and @xmath is a
relation @xmath that specifies the allowed tuples for variables in the
scope.

Following Cohen et al. [ cohen_symmetry_2006 ] , we allow a constraint
to be defined extensionally through an explicit list of allowed tuples,
as done above, or intentionally by instead giving an expression from
which the allowed tuples are determined. For example, consider a SAT
problem which has variables @xmath and @xmath . The constraint that
@xmath and @xmath must be the same can be stated extensionally by a
constraint @xmath where @xmath and @xmath , but is more commonly written
intensionally with the expression @xmath .

We now define how to form a solution to a CSP.

###### Definition 7 (Bindings, Assignments).

For a CSP, @xmath , a variable-value binding , or simply a binding , is
a tuple @xmath such that @xmath and @xmath . We denote the set of all
variable-value bindings of @xmath by @xmath . That is, @xmath . A set of
bindings is a partial assignment if it contains at most one binding of
the form @xmath for each @xmath . A partial assignment is a complete
assignment if it contains exactly one binding of the form @xmath for
each @xmath . We can alternatively view a complete assignment as a
function mapping variables to values, and so for complete assignment
@xmath we use @xmath to denote the value @xmath such that @xmath .

###### Definition 8 (The “Satisfies” Relation, Solution).

Let @xmath be a CSP. A complete assignment @xmath satisfies a constraint
@xmath if @xmath , where @xmath is the scope of @xmath and @xmath is the
relation of @xmath . A solution to @xmath is a complete assignment
@xmath that satisfies all of the constraints of @xmath .

For example, consider a CSP @xmath where @xmath , @xmath , @xmath ,
@xmath , and @xmath consists of a single constraint @xmath with scope
@xmath and relation @xmath . Consider the complete assignments @xmath
and @xmath . @xmath is not a solution since @xmath , but @xmath is a
solution because @xmath .

### 2.3 Group Theory

The intuitive, informal notion of a symmetry is that it is some
transformation, like a rotation or reflection, that preserves an
important property of an object. Symmetries can be composed, applied one
after another, and still maintain this property. Therefore a symmetry
can be created by composing symmetries together. Symmetries can also be
reversed while still maintaining the desired property of the object.
Hence, taking the inverse of a symmetry also yields a symmetry.

Group theory is the rigorous mathematical formalism used to explore
symmetry. The abstract definition of a group captures the composition
and inversion behaviours described above, as well as other important
properties. We take our definitions in this section from Dummit and
Foote [ dummit_abstract_2014 ] .

###### Definition 9 (Group).

A group is a set @xmath equipped with a binary function @xmath from
@xmath to @xmath (written infix, called the group operation ) such that

-   the @xmath operator is associative ; that is, @xmath for all @xmath
    ,

-   there exists an identity element @xmath such that @xmath for all
    @xmath ,

-   each element @xmath has an inverse @xmath such that @xmath .

For convenience, the @xmath function is often omitted in notation and
@xmath is instead written @xmath .

The most common example of a group is the symmetric group @xmath , which
is the set of permutations of a set @xmath . The group operation is
function composition, which is associative. The identity element is the
identity function, and the group inverse of a permutation @xmath is just
its standard inverse as a function. Another common example is the set of
non-zero real numbers @xmath . The group operation is multiplication,
the identity element is @xmath , and the group inverse of a non-zero
number @xmath is its multiplicative inverse @xmath .

A subset of a group might itself be a group under the same operation, in
which case it is called a subgroup .

###### Definition 10 (Subgroup).

Let @xmath be a group. A subset @xmath of @xmath is a subgroup of @xmath
, written @xmath , if

-   @xmath is non-empty,

-   @xmath is closed under the group operation, and

-   @xmath is closed under taking inverses.

Consider for example an undirected graph @xmath . An automorphism of
@xmath is a permutation @xmath of its vertices such that a pair @xmath
of its vertices forms an edge if and only if @xmath forms an edge. The
set of automorphisms of @xmath is a subgroup of the symmetric group
@xmath of its vertex set.

For our purposes we are interested in how the group elements act on
objects to transform them into other objects, which is formalized by the
notion of a group action .

###### Definition 11 (Group Action).

A group action of a group @xmath on a set @xmath is a binary function
@xmath from @xmath to @xmath (written infix) such that

1.  @xmath for all @xmath and @xmath , and

2.  @xmath for all @xmath .

It is then said that @xmath acts on @xmath by this group action.

As an example, consider the permutation group @xmath of the set @xmath .
@xmath acts on @xmath through function application. That is, defining
@xmath for each @xmath and @xmath forms a group action. Any group @xmath
acts on any set @xmath by the trivial action , defined by @xmath for all
@xmath and @xmath . A more complicated example of a group action is
conjugation . Any group @xmath acts on itself by @xmath for all @xmath .

One way, not mentioned in Dummit and Foote, that we find helpful in
visualizing group actions for those unfamiliar with them is to view the
action as a transition system or edge-labeled directed graph. The nodes
of the transition system are the elements of @xmath . For each @xmath
and @xmath there is an arc from @xmath to @xmath . The first property of
a group action says that to start from @xmath and follow the @xmath arc
and then the @xmath arc, the result is the same as starting from @xmath
and instead taking the single @xmath arc. If the reversed order seems
confusing, just note that this is exactly how function composition
works. The first property also implies that starting from @xmath and
following the @xmath arc, then the @xmath arc, results in returning to
@xmath .

Going back to Dummit and Foote, it is not hard to show that each
individual group element can be viewed as a permutation of the set
@xmath under the group action (and hence, group actions fundamentally
link groups to permutations and symmetric groups). This is called the
permutation representation of the group action.

###### Proposition 12 (Permutation Representation of a Group Action).

Let @xmath be a group acting on a set @xmath . For every @xmath , the
function @xmath defined by @xmath is a permutation of @xmath .

Next want to consider all the objects that we can get to from an @xmath
by acting on it with group elements.

###### Definition 13.

Let @xmath be a group acting on a set @xmath . For each @xmath , define
the orbit of @xmath by @xmath .

Since traveling along an arc can be reversed by traveling backwards
through the inverse group element, it is immediate that @xmath if and
only if @xmath . Being related in this way forms an equivalence relation
and so partitions @xmath into equivalence classes by the orbits.

###### Proposition 14.

Let @xmath be a group acting on a set @xmath . The relation @xmath on
@xmath defined by

  -- -------- --
     @xmath   
  -- -------- --

is an equivalence relation. The equivalence classes are the orbits, and
hence the orbits partition @xmath .

It is also worth noting that if a group @xmath acts on a set @xmath ,
any subgroup @xmath acts on @xmath by the same group action. This
proposition is immediate from the definitions of subgroup and group
action.

###### Proposition 15 (Subgroups and Group Actions).

If @xmath is a group acting on a set @xmath , then any subgroup @xmath
acts on @xmath by the same group action.

## 3 The CSP Symmetry Framework

Before symmetry can actually be exploited, we must clearly define what
exactly we mean by symmetry. However, as has been noted in the works of
Gent et al. [ gent_symmetry_2006 ] and Cohen et al. [
cohen_symmetry_2006 ] , definitions of symmetry across CSP research have
been surprisingly disparate. We refer the reader to those sources for a
more in-depth survey. Here we briefly summarize their findings. The
definitions of symmetry generally tend to disagree along one of the
following lines:

1.  whether symmetries are defined as acting on variables, values, or
    variable-value bindings, and

2.  whether symmetries are defined as preserving the set of solutions or
    the set of constraints .

To understand these different notions of symmetry, consider two examples
of CSP problems: SAT and Sudoku. In a SAT problem, two variables might
be interchangeable. For example if the constraints are @xmath and @xmath
, @xmath and @xmath would be interchangeable and we would consider a
permutation on the variables that swaps @xmath and @xmath to be a
symmetry. However, the values @xmath and @xmath are not in general
interchangeable, so permuting values is not considered in the definition
of symmetry in the context of SAT. Contrast this with Sudoku. In Sudoku,
the variables are the grid cells and the values are @xmath . There is
nothing special about the specific choice of values assigned to the cell
variables. For example, relabeling all @xmath s in a solution with
@xmath s and vice versa always generates a solution and so we would
consider a permutation on the values that swaps @xmath and @xmath to be
a symmetry. Thus, permuting values would be considered important in the
definition of symmetry for Sudoku problems, in contrast with SAT. More
general definitions would consider acting on variable-value bindings.

After having decided whether symmetries are permutations of variables,
values, or bindings, the question arises as to what property causes such
a permutation to be a symmetry. The more general notion is that a
symmetry preserves the set of solutions. That is, when it is applied to
a solution it always yields another solution, and when it is applied to
a non-solution it always yields a non-solution. The common criticism of
this “solution symmetry” definition is that it provides no guidance on
how to practically find such symmetries; finding the full set of
symmetries might require finding all of the solutions. “Constraint
symmetries” on the other hand are defined as preserving the set of
constraints. In the SAT problem above, swapping @xmath and @xmath leaves
the exact same set of constraints, so such a permutation would be
considered a symmetry. This disagreement in definitions is essentially
over whether the fact that symmetries preserve solutions is their
defining property or a consequence of preserving constraints.

Cohen et al. [ cohen_symmetry_2006 ] provide a framework to unify these
various definitions. This section gives a presentation of Cohen et al.’s
framework, with some extensions to make it slightly more general to
facilitate discussion of sorts later. This presentation is mostly not
our original work; the extensions to Cohen et al.’s work here are quite
natural. For example, we do not restrict the framework to a setting
where the domains of each variable are all the same as they did, but it
is not difficult to remove this restriction. However, we do endeavour to
provide greater intuition and explanations, including some more precise
definitions and additional proofs. The explanations are largely
original. In particular, Cohen et al. do not deeply elaborate on the
underlying group theory, so we interleave more discussions of the group
theory between the definitions.

### 3.1 Solution Symmetries

The approach taken by Cohen et al. [ cohen_symmetry_2006 ] is to define
a very general group (in the group theory sense) of symmetries, and then
view other kinds of symmetries as special cases (in particular,
subgroups). So the definition of symmetry starts more abstract, and can
be refined as needed. Their most abstract definition of symmetry acts on
variable-value bindings and preserves the set of solutions. That is, a
symmetry is a permutation on @xmath , and it must map solutions to
solutions. Variable and value symmetries are easily viewed as special
cases. We denote by @xmath the set of all permutations @xmath , which
forms a group. The objects we are interested in this group acting on are
sets of bindings (for example, partial and complete assignments). That
is, the space we wish to understand how symmetries act on is @xmath , We
must first be clear how a permutation @xmath acts on a set of bindings.

###### Definition 16 (Action of a Permutation on a Set of Bindings).

For a CSP instance @xmath , define the action of a permutation @xmath on
a set of bindings by lifting @xmath pointwise. Precisely, we define a
binary operator @xmath from @xmath to @xmath by

  -- -------- --
     @xmath   
  -- -------- --

###### Theorem 17.

For a CSP instance @xmath , the action of @xmath on the set @xmath is a
group action.

###### Proof.

Clearly the identity function @xmath acts on each set @xmath by sending
@xmath to itself, so the second requirement of group actions is
satisfied.

Now let @xmath and @xmath . Write @xmath for some @xmath . We see that

  -- -------- --
     @xmath   
  -- -------- --

and hence the first requirement of group actions is satisfied. ∎

Now that we have defined how permutations of @xmath act, we define what
makes such a permutation a symmetry.

###### Definition 18 (Solution Symmetry).

A solution symmetry of a CSP instance @xmath is a permutation @xmath of
@xmath that map solutions of @xmath to solutions of @xmath . That is, if
@xmath is a solution of @xmath , then @xmath is also a solution of
@xmath . We will denote the set of all solution symmetries of @xmath by
@xmath .

We also want symmetries to map non-solutions to non-solutions. It may
not be obvious to the reader and the sources we have read neglect to
explain this, but this is actually a consequence of the definition. We
use the following lemma, though we omit its proof.

###### Lemma 19.

Let @xmath be a finite set, @xmath , and @xmath a permutation of @xmath
. If @xmath is closed under @xmath , then @xmath is also closed under
@xmath .

We get the following corollary.

###### Corollary 20.

A solution symmetry @xmath of a CSP instance @xmath maps non-solutions
to non-solutions. That is, if @xmath is not a solution of @xmath , then
@xmath is not a solution of @xmath .

###### Proof.

Consider the function @xmath defined by @xmath for each @xmath . By
Proposition 12 , @xmath is a permutation on @xmath . The definition of a
solution symmetry implies that the set of solutions to @xmath must be
closed under @xmath . By Lemma 19 , the set of non-solutions in @xmath
must also be closed under @xmath . Therefore, if @xmath is not a
solution of @xmath , then @xmath is not a solution of @xmath . ∎

Knowing this now allows us to prove that the set of solution symmetries
forms a group.

###### Proposition 21.

For a CSP @xmath , @xmath is a subgroup of the group @xmath .

###### Proof.

The identity permutation lies in @xmath , so it is non-empty.

Let @xmath , and let @xmath be a solution to @xmath . Since @xmath map
solutions to solutions, @xmath is a solution. Furthermore since @xmath
maps solutions to solutions, @xmath is a solution. Therefore @xmath maps
solutions to solutions, and so @xmath . That is, @xmath is closed under
the group operation of function composition.

Suppose for a contradiction that for some solution symmetry @xmath , its
inverse @xmath is not a solution symmetry. Then there exists a solution
@xmath such that @xmath is not a solution. Since @xmath maps
non-solutions to non-solutions, @xmath is not a solution. However @xmath
, so this contradicts that @xmath is a solution. Therefore @xmath is
closed under taking inverses. ∎

Now that we have a group of solution symmetries and a group action of
this group on sets of bindings, we can consider the orbits (i.e.
equivalence classes) induced by this action. If two sets of bindings
@xmath and @xmath lie in the same orbit, it means that there must exist
a solution symmetry @xmath that acts on @xmath to produce @xmath .
Because each solution symmetry preserves whether a set of bindings is a
solution, @xmath is a solution if and only if @xmath is a solution.
Hence we have arrived at the following proposition.

###### Proposition 22.

Let @xmath be a CSP instance. If @xmath is an orbit produced by the
action of @xmath on @xmath , either all binding-sets @xmath are
solutions, or none of them are solutions.

These orbits are precisely the equivalence or isomorphism classes of
binding-sets that we are interested in when exploring symmetry. The key
insight in symmetry reduction is that to determine whether a solution
exists to a CSP instance, it is necessary only to examine a single
representative from each class, which can drastically reduce search
time. More on symmetry reduction will be discussed in later sections.

Note that a symmetry always maps solutions to solutions, but it may not
always map complete assignments to complete assignments.

### 3.2 Constraint Symmetries

As Gent et al. [ gent_symmetry_2006 ] remark, defining symmetries as
mappings that preserve solutions does not seem to give any guidance on
how such symmetries might be identified. To find the whole symmetry
group, one might need to compute all solutions to the CSP, which defeats
the purpose in taking advantage of symmetries. In order for any
definition of symmetry to be useful, it must obviously require that
solutions are mapped to solutions. As mentioned earlier, many other CSP
definitions do not make this the defining property of symmetries, but
instead look at a more structured group for which this property is a
consequence of the definition. In particular, many define a symmetry as
a mapping that somehow preserves the set of constraints.

Cohen et al. [ cohen_symmetry_2006 ] recognized that these “constraint”
or “problem” symmetries can simply be viewed as a subgroup of the
solution symmetries. Here we will present their formalization of this
result. To formalize the notion of preserving constraints, they define a
hypergraph called the microstructure of a CSP instance, pulled from
earlier work by Freuder [ freuder1991eliminating ] and Jégou [
jegou1993decomposition ] . We only need the complement of this
hypergraph, so we will provide the definition for its complement
directly. In this hypergraph, the edges connect bindings that cannot
together be part of a solution.

###### Definition 23 (Microstructure Complement).

Let @xmath be a CSP. The microstructure complement of @xmath is the
hypegraph @xmath , where @xmath and @xmath contains precisely the
following hyperedges:

-   @xmath contains the hyperedge @xmath for each @xmath and distinct
    @xmath , and

-   @xmath contains the hyperedge @xmath if @xmath is the set of
    variables of some constraint scope, but that constraint disallows
    the assignment @xmath .

We will call hyperedges of the first type consistency hyperedges , and
those of the latter type constraint hyperedges .

Consistency hyperedges reflect that assignments must be internally
consistent; that is, one cannot simultaneously assign variable @xmath to
have value @xmath and value @xmath . Constraint hyperedges reflect that
assignments must satisfy the constraints. An independent set in a
hypergraph is a set @xmath of vertices such that none of the hyperedges
is a subset of @xmath ( @xmath is allowed to intersect a hyperedge, but
it cannot entirely contain one). From the definition, we can see that a
solution to the CSP is exactly an independent set of size @xmath .

Consider the SAT problem on variables @xmath with the following
constraints.

  -- -------- --
     @xmath   
  -- -------- --

  -- -------- --
     @xmath   
  -- -------- --

The microstructure complement of this problem is presented below. The
green hyperedges are the consistency hyperedges. The blue and red
hyperedges are constraint hyperedges, arising from @xmath and @xmath
respectively. The independent set @xmath , which satisfies that @xmath ,
is a solution to the SAT problem.

[]

Consistency hyperedges can be viewed as a kind of implicit constraint
that a variable cannot be assigned multiple values at once, and each
remaining problem constraint clearly corresponds to a set of constraint
hyperedges. So the notion of “preserving constraints” can be viewed as
preserving hyperedges of the microstructure complement. Recalling that
an automorphism of a hypergraph is a permutation of its vertices that,
when extended pointwise to sets of vertices, maps hyperedges to
hyperedges and non-hyperedges to non-hyperedges, Cohen et al. define the
constraint symmetries as follows.

###### Definition 24 (Constraint Symmetry).

A constraint symmetry of a CSP instance @xmath is an automorphism of
@xmath . We will denote the set of all constraint symmetries of @xmath
by @xmath .

Next they prove that the constraint symmetries of a CSP instance are a
subgroup of the solution symmetries.

###### Theorem 25.

For a CSP instance @xmath , @xmath is a subgroup of @xmath .

###### Proof.

The automorphisms of a hypergraph always form a group under the
operation of function composition, so it suffices to show that @xmath .
Let @xmath . Suppose @xmath is a solution. Then in the microstructure
complement, @xmath is an independent set of size @xmath . Since @xmath
sends non-hyperedges to non-hyperedges, @xmath is an independent set of
size @xmath and hence is a solution. Thus @xmath always maps solutions
to solutions and @xmath . ∎

Cohen et al. also gave an example of a CSP where this containment is
strict; that is, there is a solution symmetry that is not a constraint
symmetry.

## 4 Symmetry in Finite Model Finding

We now explore notions of symmetry as they appear in finite model
finding, unify these concepts, and relate them to the CSP symmetry
framework.

### 4.1 Existing Symmetry Definitions in FMF

In the literature for finite model finding there likewise are many
definitions of symmetry, though they tend to be more consistent with
each other than those found in CSP literature. All those we have
surveyed are interested in a notion of value symmetry, noting that in
finite model finding all values are interchangeable. Relabeling the
values in an interpretation leads to another interpretation that
satisfies the formulas if and only if the original interpretation also
satisfies the formulas.

In their introduction to the Falcon model finder, Zhang [
zhang_constructing_1996 ] considers expanding FOL formulas into ground
equations. They then define a set of ground equations as symmetric with
respect to some set @xmath of values if permutating the values of @xmath
within the ground equations does not change the set of ground equations.
Peltier [ peltier_new_1998 ] , and later Claessen and Sörenson when
introducing their Paradox model finder [ claessen_new_2003 ] , define
isomorphic interpretations that can be created by permuting (relabeling)
the domain values. Torlak’s work [ torlak_constraint_2009 ] is in an FMF
setting where not all value permutations preserve solutions, and so
defines them to be specifically those that do preserve solutions.
Baumgartner et al. [ baumgartner_computing_2009 ] similarly define a
value symmetry to be a permutation of the values, but one that maps
partial solutions to partial solutions. Audemard and Benhamou [
audemard2001symmetry ] consider a multi-sorted setting and define
symmetry in terms of a dynamic search. For them, a symmetry is a
collection of permutations, one for each sort’s domain, that leaves
unchanged both the current instantiation and the set of ground clauses.

The papers by Zhang and Zhang that introduce their SEM tool [
goos_system_1996 ] and McCune’s Mace4 solver [ bonacina_mace4_2013 ] do
not define symmetry but base their symmetry exploiting techniques on
Zhang’s previous work for Falcon. Similarly, Vakili and Day’s paper [
fitzgerald_finite_2016 ] , introducing the Fortress solver, does not
define symmetry but uses the same symmetry breaking techniques found in
Paradox. The same is true for the paper by Reger et al. [
creignou_finding_2016 ] on their work in finite model finding using the
Vampire theorem prover.

As stated earlier, these definitions are mostly consistent, at least in
spirit. However, there are several limitations that we can identify.
First, the notions of symmetry are restricted only to values; unlike in
CSP, there is no concept of symmetries acting on variables or more
generally variable-value pairs. Second, most definitions, barring those
of Peltier and Audemard and Benhamou, only rigorously define symmetries
for single-sorted problems. Additionally, as was the case in CSP, there
is not a consensus as to whether symmetries should be defined as
preserving solutions or constraints. Torlak defines them as preserving
solutions, Zhang and Audemard and Benhamou define them as preserving
constraints, and others consider only restricted settings where the
distinction need not be addressed. Finally, while there are many
conceptual similarities between symmetry in CSP and symmetry in finite
model finding, and no doubt each field inspires work in the other, there
does not appear to be an attempt to rigorously tie the two together. In
this section, we propose to use the work of Cohen et al. [
cohen_symmetry_2006 ] to unify the symmetry definitions for finite
model-finding and CSP.

### 4.2 Value Relabeling

Earlier in this thesis, we mentioned that only the sizes of the sets
given by a domain assignment affect the satisfiability of the problem,
the actual sets themselves do not matter. What the values actually are
does not factor into the semantics of FOL; it only matters that the
values are distinct from each other. For example, it does not matter
whether we say that @xmath or @xmath or @xmath . The values can be
relabeled without affecting satisfiability. This well-known property of
FOL forms the basis of the current understanding of symmetry in FOL. The
following definitions and theorem express this relabeling phenomenon
formally. This theorem can be found in the works by Claessen and
Sörenson [ claessen_new_2003 ] and Peltier [ peltier_new_1998 ] .

###### Definition 26 (Domain Bijection).

Let @xmath be a signature. Given two domain assignments @xmath and
@xmath for @xmath , a domain bijection between @xmath and @xmath is a
collection of bijections, containing a bijection @xmath for each @xmath
.

###### Definition 27 (Action of a Domain Bijection on an
Interpretation).

Let @xmath be a signature, @xmath a set of formulas over @xmath , @xmath
and @xmath two domain assignments for @xmath , and @xmath a domain
bijection between @xmath and @xmath . Let @xmath be an interpretation
for @xmath . We define the action of @xmath on @xmath as producing an
interpretation @xmath for @xmath , constructed as follows.

For each functional symbol @xmath , define @xmath by

  -- -------- --
     @xmath   
  -- -------- --

Equivalently, if @xmath , then @xmath .

For each relational symbol @xmath , define @xmath by

  -- -------- --
     @xmath   
  -- -------- --

###### Theorem 28 (Value Relabeling).

Let @xmath be a signature, @xmath a set of formulas over @xmath , @xmath
and @xmath two domain assignments for @xmath , and @xmath a domain
bijection between @xmath and @xmath . For any interpretation @xmath of
@xmath , @xmath if and only if @xmath . Hence, @xmath is a model of
@xmath if and only if @xmath is a model of @xmath .

As an example, consider @xmath defined below.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

One possible domain bijection @xmath is given by the following.

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

Now define an interpretation @xmath for @xmath as follows.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

@xmath is a solution of @xmath . Now the interpretation @xmath is given
below.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

This new interpretation is a solution of @xmath .

The special case of the Value Relabeling Theorem where @xmath is crucial
to the understanding of symmetry in MSFMF problems. In this setting,
each bijection @xmath is a permutation of the set @xmath .

###### Definition 29 (Domain Permutation).

Let @xmath be a MSFMF problem. A domain permutation of @xmath is a
collection @xmath of permutations that contains a permutation @xmath for
each @xmath . We denote the set of all domain permutations of @xmath by
@xmath .

The two interpretations @xmath and @xmath related by a domain
permutation @xmath are both interpretations for the same MSFMF problem.
Moreover, @xmath is a solution of this problem if and only if @xmath is
a solution of this problem, so checking whether one interpretation
satisfies @xmath is equivalent to checking the other. We call such
interpretations isomorphic .

###### Definition 30.

Two interpretations @xmath and @xmath for an MSFMF problem @xmath are
isomorphic if @xmath for some domain permutation @xmath of @xmath .

We restate this special case of the Value Relabeling Theorem using our
new terminology for emphasis.

###### Theorem 31 (Value Permutation).

Let @xmath be an MSFMF problem and let @xmath be a domain permutation of
@xmath . For any interpretation @xmath of @xmath , @xmath if and only if
@xmath . Hence @xmath is a model of @xmath if and only if @xmath is a
model of @xmath .

For example, consider the same problem @xmath and interpretation @xmath
as in the previous example.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

After acting on @xmath with the domain permutation @xmath defined by

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

the resulting interpretation @xmath is given as follows.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

As expected, both @xmath and @xmath are solutions.

Since each domain permutation relates @xmath to a different isomorphic
interpretation, there are many essentially equivalent solutions to a
problem, related by these permutations of values. It would make sense to
call these domain permutations “value symmetries” for MSFMF. We will
avoid this for now since later we wish to relate them to our established
definition of value symmetries in CSP problems.

It is worth noting a couple of properties of domain permutations. These
trivially fall out of the definitions.

###### Definition 32 (Composition of Domain Permutations).

Let @xmath be a MSFMF problem. The composition @xmath of two domain
permutations @xmath and @xmath is defined as the domain permutation
whose permutation on @xmath is @xmath for each @xmath .

###### Proposition 33.

For any MSFMF problem @xmath , @xmath forms a group under composition.
The identity domain permutation is the domain permutation comprised of
the identity map on @xmath for each sort @xmath .

###### Proposition 34.

Let @xmath be a MSFMF problem. For any domain interpretations @xmath and
interpretation @xmath ,

-   @xmath , and

-   @xmath ,

where @xmath is the identity domain permutation.

The following corollary is immediate from the above two propositions.

###### Corollary 35.

Let @xmath be a MSFMF problem. The action of @xmath on the set of
interpretations is a group action.

### 4.3 Framework of Extended MSFMF Problems

Our ultimate goal is to unify these various definitions of symmetry in
finite model finding and Cohen et al.’s symmetry framework for CSPs.
First we will relate the definitions of symmetry in finite model finding
just within the context of finite model finding, then consider how they
integrate into Cohen et al.’s symmetry framework.

While not strictly allowed in first-order logic, it is useful to allow
domain elements as terms. For example, if a MSFMF problem @xmath
contains a sort @xmath , a functional symbol @xmath , and the domain
assignment @xmath has @xmath , it would be allowed to write @xmath as a
formula, with the domain element @xmath appearing as a term of sort
@xmath . To make this distinct from “pure” first-order logic where this
is prohibited, we call such terms extended .

###### Definition 36 (Extended Many-Sorted Finite Model Finding
Problem).

Let @xmath be a signature and @xmath a domain assignment for @xmath . An
extended term is constructed in the same way as terms, but for each sort
@xmath it allows every domain value @xmath to be an extended term of
sort @xmath . An extended formula is defined analogously to formulas,
but with extended terms rather than terms. Similarly, an extended
many-sorted finite model-finding problem (eMSFMF), an interpretation
thereof, and the satisfies relation are all defined analogously to their
pure MSFMF counterparts. Semantically, domain elements evaluate to
themselves.

There are many reasons to allow extended problems. As we will see later,
it can be used to add symmetry breaking constraints without straying far
from first-order logic, and also facilitates an easier discussion on how
to combine symmetry breaking strategies. Additionally, extended terms
can be used to represent partial interpretations as in Torlak’s work [
torlak_constraint_2009 ] or ground formulas that have expanded their
quantifiers as in Zhang’s work [ zhang_constructing_1996 ] . Solvers
such as Falcon [ zhang_constructing_1996 ] and Fortress [
fitzgerald_finite_2016 ] treat domain elements as terms for convenience
and simplicity.

It is extremely important to note that the Value Permutation theorem
does not necessarily hold when considering an extended MSFMF problem,
since values can occur within the formula in ways that make them
non-interchangeable. Thus, in eMSFMF problems it no longer suffices to
consider all domain permutations as being symmetries (as in pure
problems), but rather some subset of these permutations are symmetries.
Guided by the approach taken by Cohen et al. [ cohen_symmetry_2006 ] ,
we start with a very general definition of symmetry as those domain
permutations that preserve solutions.

###### Definition 37 (Domain Symmetry, Isomorphic Interpretations).

Let @xmath be an eMSFMF problem. A domain permutation @xmath of @xmath
is a domain symmetry if for every interpretation @xmath , @xmath exactly
when @xmath . We will denote the set of all domain symmetries of @xmath
by @xmath . Two interpretations @xmath and @xmath of @xmath are
isomorphic if @xmath for some domain symmetry @xmath of @xmath .

###### Proposition 38.

Let @xmath be an eMSFMF problem. The set @xmath of domain symmetries
forms a group under function composition.

The Value Permutation Theorem can be rephrased as stating that in a pure
MSFMF problem, every domain permutation is a domain symmetry. Thus,
domain symmetries encompass the definitions of symmetry found in the
works of Peltier [ peltier_new_1998 ] and Claessen and Sörenson [
claessen_new_2003 ] . It also matches the definition of value symmetry
by Torlak [ torlak_constraint_2009 ] as permutations of the values that
preserve solutions.

Next, we define a set of symmetries that preserves constraints as a
subgroup of the solution-preserving symmetries.

###### Definition 39 (Action of a Domain Permutation on Formulas).

Let @xmath be an eMSFMF problem, and let @xmath be a domain permutation
of @xmath . We define the action of @xmath on a formula @xmath as
producing the formula @xmath obtained by replacing each occurrence of
all domain elements in @xmath by applying the appropriate permutation in
@xmath . That is, where a domain element @xmath appears in @xmath as a
term of sort @xmath , in @xmath this term is replaced with @xmath . We
define the action of @xmath on @xmath by @xmath .

###### Definition 40 (Constraint Domain Symmetry).

Let @xmath be an eMSFMF problem. A domain permutation @xmath of @xmath
is a constraint domain symmetry if @xmath . We will denote the set of
all constraint domain symmetries of @xmath by @xmath .

Since partial instantiations and ground formulas can be represented by
extended terms, constraint domain symmetries capture the definitions of
Zhang [ zhang_constructing_1996 ] , Audemard and Benhamou [
audemard2001symmetry ] , and Baumgartner et al [
baumgartner_computing_2009 ] . So these definitions, domain symmetry and
constraint domain symmetry, are sufficiently general to encompass the
previous definitions of symmetry in finite model finding literature.
Like Cohen et al., we can view the constraint symmetries as a subgroup
of the more general class of symmetries. The following theorem will be
concluded as a corollary later.

###### Theorem 41.

For any eMSFMF problem @xmath , @xmath is a subgroup of @xmath .

### 4.4 Unused and Interchangeable Values

Now that we have this rigorous notion of domain symmetry, it is worth
considering one class of easily detectable domain symmetries. We
mentioned that some domain permutations may not be domain symmetries
since values may appear in formulas in ways that make them
non-interchangeable with other values. This suggests that any domain
permutation that acts as the identity on all values that appear in the
formulas is a domain symmetry.

###### Definition 42.

Let @xmath be an eMSFMF problem. A domain permutation @xmath is
occurrence-fixing if, for every sort @xmath and value @xmath , if @xmath
appears in @xmath as a term of sort @xmath then @xmath (i.e. it does not
change values appearing in the formulas).

It follows trivially from the definition that the set of
occurrence-fixing domain permutations is a subgroup of the constraint
domain symmetries. Since they leave all values that occur in the
formulas unchanged, applying them to the formulas leaves the formulas
unchanged.

###### Proposition 43.

For any eMSFMF problem @xmath , the set of occurrence-fixing domain
permutations of @xmath is a subgroup of @xmath .

Another way to think about this proposition is that values that do not
appear in the formulas are “interchangeable”.

###### Definition 44 (Solely Permute, Value-Interchangeable Set).

Let @xmath be an eMSFMF problem and @xmath . A domain permutation @xmath
solely permutes a subset @xmath if @xmath for all @xmath and @xmath for
all sorts @xmath (i.e. @xmath acts as the identity everywhere but on
@xmath ). A set of @xmath is value-interchangeable for @xmath if any
domain permutation @xmath of @xmath that solely permutes @xmath is a
domain symmetry.

So Proposition 43 can be rephrased as stating that for any sort @xmath ,
the set of values in @xmath that do not appear in formulas is
value-interchangeable. Depending on the specific @xmath , there may be
more sets of interchangeable values.

Recall that domain symmetries can be composed together and yield another
symmetry. Therefore we can compose together symmetries that each solely
permute a specific set of values to yield more complicated symmetries.

###### Proposition 45.

Let @xmath be an eMSFMF problem. For each sort @xmath , let @xmath be a
value-interchangeable set for @xmath . If @xmath is a domain permutation
such that, for every sort @xmath and @xmath , @xmath , then @xmath is a
domain symmetry.

### 4.5 FMF Symmetry in the CSP Framework

With these definitions of domain symmetry and constraint domain symmetry
to unify the symmetry definitions throughout finite model finding, we
now move to relate these notions of symmetry to symmetries in constraint
satisfaction problems. A natural approach is to view finite model
finding as a constraint satisfaction problem via a transformation
between the two kinds problems.

One such transformation is specified by Zhang [ zhang_constructing_1996
] . The idea is to view a function-argument pair @xmath , where @xmath
is a functional symbol and @xmath are appropriately sorted values, as a
single cell that needs to be assigned a value. Thus we can make these
function-argument pairs into the variables of the CSP. Essentially, this
CSP formulation forgets that there are functions and relations at all,
and instead turns each function-argument or relation-argument pair into
a variable, for which an appropriate value is searched.

###### Definition 46 (Flat CSP).

Let @xmath be an eMSFMF problem. The flat CSP of @xmath is the CSP
@xmath constructed as follows.

-   For each functional symbol @xmath and values @xmath , @xmath
    contains the function-argument pair @xmath as a variable, and @xmath
    .

-   For each relational symbol @xmath and values @xmath , @xmath
    contains the relation-argument pair @xmath as a variable, and @xmath
    .

-   @xmath contains one constraint @xmath for each formula @xmath . The
    scope of @xmath consists of the function-argument and
    relation-argument pairs whose function or relation occurs in @xmath
    . @xmath allows an assignment for its scope if and only if @xmath
    evaluates to @xmath under this assignment.

Unfortunately, this translation does not preserve the intuitive notion
of “value symmetry”. Recall that CSP symmetries are permutations on
variable-value pairs. We would hope that domain symmetries in an MSFMF
problem would correspond to value symmetries in its CSP, since domain
symmetries arise from permutations of values. However, consider an MSFMF
problem @xmath that has a function symbol @xmath and a domain symmetry
@xmath . Recall how @xmath acts on an interpretation @xmath : for @xmath
, if @xmath then @xmath . Therefore the natural way to create a
variable-value permutation @xmath from @xmath would be to have @xmath .
This is not necessarily a purely value symmetry since it may change the
variable in the binding.

We propose an alternative transformation from an eMSFMF problem to a
CSP. The key insight is that while it is usually thought that the
domains for variables in a CSP are simple, atomic objects like integers,
there is nothing restricting them from being more complicated objects
like functions and sets. Rather than forgetting that a functional symbol
@xmath represents a function and treating function-argument pairs as
individual variables, this transformation makes @xmath into a variable
and treats its possible values as functions from @xmath . This makes
complete assignments of the CSP exactly into interpretations of the
eMSFMF problem, and vice versa.

###### Definition 47 (Functional CSP).

Let @xmath be an eMSFMF problem. For each functional symbol @xmath , let
@xmath consist of the set of functions from domain @xmath to codomain
@xmath . For each relational symbol @xmath , let @xmath consist of the
set of @xmath -ary relations @xmath . The functional CSP of @xmath is
the CSP @xmath where

1.  @xmath is the set of functional and relational symbols of @xmath ,

2.  @xmath assigns each functional symbol @xmath the set of possible
    values @xmath and assigns each relational symbol @xmath the set of
    possible values @xmath , and

3.  @xmath contains one constraint @xmath for each formula @xmath ,
    where the scope of @xmath is consists of the functional symbols
    appearing in @xmath and @xmath allows an assignment for its scope if
    and only if @xmath evaluates to @xmath under this assignment.

We now define how to view a domain permutation as a permutation on
variable-value bindings in the functional CSP. Note that this functional
extension of a domain permutation leaves the CSP variables fixed, so
this transformation does not have the same limitation as the flat CSP
transformation.

###### Definition 48 (Functional Extension of a Domain Permutation).

Let @xmath be an eMSFMF problem let @xmath be a domain permutation of
@xmath . The functional extension @xmath of @xmath is a permutation
@xmath defined as follows.

Let @xmath be a functional symbol and @xmath a concrete function. @xmath
maps the binding @xmath to the binding @xmath , where @xmath is defined
by

  -- -------- --
     @xmath   
  -- -------- --

Equivalently, if @xmath , then @xmath .

Let @xmath be a relational symbol and @xmath a concrete relation. @xmath
maps the binding @xmath to the binding @xmath , where @xmath is defined
by

  -- -------- --
     @xmath   
  -- -------- --

For a set @xmath of domain permutations, we will let @xmath denote the
set of functional extensions of all domain permutations in @xmath .

An interpretation of an MSFMF problem is a complete assignment to the
functional CSP, and vice versa. We do not mean that one merely induces
another, but the interpretation itself is both kinds of mathematical
objects. Moreover, an interpretation satisfies the MSFMF problem if and
only if it is a solution to the functional CSP. It is plainly visible
how the functional extension is designed to mimic the action of the
domain permutation on an interpretation. The following proposition
follows easily from those respective definitions.

###### Proposition 49.

Let @xmath be an eMSFMF problem let @xmath be a domain permutation of
@xmath . Let @xmath be an interpretation of @xmath . We have that @xmath
. That is, the interpretation @xmath created by acting on @xmath by
@xmath (treating @xmath as an interpretation and @xmath as a domain
permutation) is the same object as the complete assignment @xmath
created by acting on @xmath using the functional extension of @xmath
(treating @xmath as a complete assignment to the functional CSP and
@xmath as a permutation on the bindings of the CSP).

We get the following corollary.

###### Corollary 50.

Let @xmath be an eMSFMF problem. If @xmath is a domain symmetry of
@xmath , then @xmath is a solution symmetry of @xmath .

###### Proof.

Let @xmath be a solution for @xmath (and hence also an interpretation of
@xmath ). By Proposition 49 , @xmath . Since @xmath is a domain
symmetry, @xmath satisfies @xmath , and hence @xmath is a solution to
the functional CSP. Therefore @xmath is a solution symmetry. ∎

The following two results also follow quickly from the definitions.

###### Lemma 51.

Let @xmath be an eMSFMF problem. If @xmath and @xmath are domain
symmetries of @xmath , then

-   @xmath

-   @xmath

###### Theorem 52.

For a MSFMF instance @xmath , @xmath is a subgroup of @xmath .

###### Proof.

Corollary 50 and Lemma 51 together show that @xmath is closed under
composition and inverses. @xmath is non-empty since @xmath is non-empty.
These are all the requirements for a subgroup. ∎

Additionally, since constraint domain symmetries preserve the set of
constraints of the MSFMF problem, they also preserve the hyperedges in
the microstructure complement of the functional CSP. Therefore we
conclude the following, and as promised have Theorem 41 as a corollary.

###### Theorem 53.

For a MSFMF instance @xmath , @xmath is a subgroup of @xmath .

The functional CSP transformation allows us to view the domain
symmetries of a finite model finding problem as a subgroup of the
solution symmetries for the functional CSP, thereby showing how
symmetries in finite model finding and CSP symmetries relate to each
other. This transformation also gives us a vehicle to discuss variable
symmetries and variable-value symmetries in finite model finding (as
those respective kinds of symmetries for the functional CSP). Such
symmetries are not examined in current FMF literature, so this suggests
further areas of research. While @xmath is a subgroup of @xmath , the
containment may be strict. There may be more solution symmetries to the
functional CSP than there are domain symmetries. Non-trivial variable
symmetries of the functional CSP are one example. In the next section we
will see a concrete example of even some value symmetries that do not
correspond to domain symmetries. A further exploration of the difference
between these two sets is warranted, and may enable us to have a greater
understanding of symmetries in finite model finding.

## 5 Effect of Sorts on Symmetries

Most presentations of first-order logic differ from ours in that they
are concerned with single-sorted (also called unsorted) first-order
logic. After all, sorts can be simulated using predicates, so there
appears at first glance to be no theoretical need for them. However as
Claessen and Sörenson [ claessen_new_2003 ] note, sort information
improves search time. Many widely used tools for automated theorem
proving, such as SMT solvers [ barrett_smt-lib_nodate ] , use a
many-sorted system. In this section, we first review work by Claessen
and Sörenson [ claessen_new_2003 ] linking many-sorted and single-sorted
systems. We then greatly expand on their work to provide new insights on
how sorts relate specifically to the existence of symmetries and come to
a new understanding of the process of sort inference.

### 5.1 Claessen and Sörenson’s Insights

Claessen and Sörenson [ claessen_new_2003 ] were primarily concerned
with single-sorted finite model finding, but were interested in how the
information acquired from sort inference could be used to help finite
model finding for originally single-sorted problems.

Their observation was how to link single-sorted and many-sorted
problems. We change the language of their presentation to match our
notation, but the ideas are the same. Consider a single-sorted finite
model finding problem @xmath where @xmath contains just one sort @xmath
and @xmath . It may possible to replace occurrences of the sort symbol
@xmath within @xmath and @xmath with new sort symbols @xmath and still
obtain a well-formed signature @xmath from @xmath and set @xmath of
@xmath -terms from @xmath .

For example, consider the following single-sorted problem.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

It is possible to replace some occurrences of @xmath with new sorts
@xmath and @xmath to obtain the following signature @xmath and set
@xmath of @xmath -terms.

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

After obtaining @xmath and @xmath , a domain assignment can be obtained
by setting @xmath for @xmath . That is, choose each sort to use the same
domain as the original problem. The key observation is that any
interpretation @xmath of the original single-sorted problem is an
interpretation of the many-sorted problem. Moreover, @xmath satisfies
@xmath if and only if @xmath satisfies @xmath . Therefore one can infer
sorts from the original single-sorted problem and then solve the
many-sorted problem instead. Sort inference is analogous to type
inference in programming languages, and standard algorithms such as
Hindley-Milner type inference can be used.

Claessen and Sörenson describe two benefits to inferring sorts. The
first is for symmetry breaking using constants, which we will discuss in
a later section. The latter, which they call sort size reduction , is
useful but not related to symmetry and so not discussed here.

### 5.2 New Insights

While Claessen and Sörenson were interested in inferring sorts for
single-sorted problems, a similar process can be done for problems
already containing multiple sorts. An even more general sorting can be
found. Let us formalize this notion. We could not find literature
formalizing sort inference specifically for FOL, so we adapt terminology
from Pierce’s book on type systems in programming languages [
pierce_types_2002 ] .

###### Definition 54 (Sort Substitution).

A sort substitution @xmath is a finite mapping from sort symbols to sort
symbols, usually written in the form @xmath for sort symbols @xmath ,
where each @xmath is distinct. For a given sort @xmath , if @xmath then
@xmath . Otherwise @xmath . A sort substitution @xmath acts on a
signature @xmath by producing a new signature @xmath obtained by
applying @xmath to each sort @xmath occurring in @xmath . A sort
substitution @xmath acts on a set @xmath of @xmath -formulas by
producing a set @xmath of @xmath -formulas obtained by applying @xmath
to each sort @xmath occurring in @xmath .

For example, consider the following signature and set of formulas.

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

Applying the sort substitution @xmath yields the signature @xmath and
set of formulas @xmath defined as follows.

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

Now we can formalize the idea of a more general sorting.

###### Definition 55 (Less Specifically or More Generally Sorted).

Let @xmath be signatures, and let @xmath be sets of formulas over @xmath
and @xmath respectively. We say that @xmath is less specifically sorted
, or more generally sorted , than @xmath if there exists a type
substitution @xmath such that @xmath and @xmath . If such a relationship
holds between @xmath and a type substitution @xmath , we write @xmath .

As an example, define @xmath and @xmath as follows.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

@xmath is less specifically sorted than @xmath since for the sort
substitution @xmath , we have that @xmath . Sort inference is the
process of going from @xmath to a less specifically sorted @xmath .

Now the question remains how to deal with domain assignments when
performing sort inference. Recall how during sort inference for the
single-sorted case, when the universal sort @xmath was split into
different sorts @xmath , we took @xmath for each @xmath . Now there are
possibly many sorts in the original problem with different domains, but
a similar approach can be taken. During sort inference, each sort is
split into one or more sorts. In the example above, going from @xmath to
the less specifically sorted @xmath splits the sort @xmath into two
sorts, @xmath and @xmath , since @xmath . Now, if a sort @xmath is split
into sorts @xmath by sort inference, we take @xmath . Once again this
means that any interpretation @xmath of @xmath is an interpretation of
@xmath and vice versa. If under @xmath some term @xmath of sort @xmath
occurring in @xmath evaluates to a value in @xmath , then in @xmath the
corresponding term @xmath , which is of sort @xmath , also evaluates to
a value in @xmath . Importantly, since @xmath and @xmath differ only by
sort annotations that play no role in evaluation, @xmath and @xmath
evaluate to the exact same value under @xmath . Therefore, each pair of
correspond formulas @xmath and @xmath evaluate to the same truth value
under @xmath . We formalize this concept and then summarize the above
discussion as a theorem.

###### Definition 56 (Less Specifically or More Generally Sorted MSFMF
Problem).

Let @xmath be an MSFMF problem. We say that an MSFMF problem @xmath is
less specifically sorted , or more generally sorted , than @xmath if all
of the following hold.

-   @xmath for some sort substitution @xmath , and

-   For each sort @xmath , each sort @xmath satisfies that @xmath . That
    is, if @xmath maps @xmath to @xmath then they share the same domain
    in their respective problems.

If such a relationship holds for a specific @xmath , we write @xmath .

###### Theorem 57.

Let @xmath and @xmath be MSFMF problems such that @xmath for some @xmath
. Let @xmath be an interpretation of @xmath (and hence also of @xmath ).
Then for every formula @xmath and its counterpart @xmath , @xmath if and
only if @xmath .

An easy corollary of this theorem is that instead of solving a given
MSFMF problem, we can instead solve a more generally sorted version of
the same problem. As will be seen, this is beneficial to symmetry
breaking. However, it also suggests something deeper about how sort
systems relate to symmetries.

A more generally sorted version of a problem may contain more domain
symmetries than the original problem. Consider the example below.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

Here @xmath , where @xmath . All domain permutations of @xmath are
domain symmetries (since the problem is pure), and there are exactly
@xmath such domain permutations. Similarly all domain permutations of
@xmath are domain symmetries, though there are @xmath of them. Therefore
@xmath has more domain symmetries than @xmath . This is at first seems
to suggest that the sort inference process introduced symmetries.

However, a closer look at Theorem 57 shows that this thinking is
misleading. It is true that @xmath has more domain symmetries than
@xmath . However, consider the functional CSPs of @xmath and @xmath .
Because of how the domain assignments are related, functions and
relations have the same domains in the CSPs of @xmath and @xmath .
Moreover, since corresponding formulas evaluate to the same truth values
under the same interpretations, the two CSPs also have the exact same
constraints. That is to say, the CSPs of the two problems are exactly
the same, and hence share the same set of solution symmetries. Therefore
sort inference did not “create” symmetries, but instead “moved” some
from the more abstract set of solution symmetries to the set of domain
symmetries. Alternatively, sort inference can be viewed as a symmetry
detection mechanism. The presence of sorts in the problem then certifies
the existence of these symmetries.

In summary, the CSP framework developed earlier has allowed us to make
two key realizations. First, there are more value symmetries to a MSFMF
problem than the domain symmetries. Second, sort inference is a
mechanism for detecting more abstract symmetries and subsequently
rewriting the problem so that they become domain symmetries.

## 6 Static Symmetry Breaking

Symmetries divide the search space into equivalence classes based on the
orbits of the group action on interpretations or sets of bindings. For a
given equivalence class, its members are either entirely solutions or
entirely non-solutions. This suggests a significant search optimization,
since only one member from each equivalence class need be tested to
determine whether the problem has a solution. A search that tests the
entire search space is redundant. In practice it is difficult to fully
eliminate this redundancy and test just one member from each class, but
there are practical ways of reducing the redundancy and avoiding
searching isomorphic interpretations. This process is called symmetry
breaking .

Gent et al. [ gent_symmetry_2006 ] describe three main approaches for
symmetry breaking for CSP. The first is reformulation , whereby the
abstract problem is re-written as a different equivalent problem in such
a way to reduce the amount of symmetry present. However this is
difficult to automate. The second is to add apply symmetry breaking
during the search process dynamically . The third tactic, pioneered by
Crawford et al. [ crawford_symmetry-breaking_1996 ] , is to add extra
constraints to the base problem in the hopes of preventing the solver
from exploring redundant parts of the search space. As long as the
constraints are satisfied by at least one member of each equivalence
class, this strategy of static symmetric breaking is sound.

These three general strategies have been used in finite model-finding as
well. SEM-style model finders that directly explore the search space use
dynamic symmetry breaking techniques. MACE-style model finders, which
reduce the model finding problem to another problem (such as SAT) and
then invoke an external solver, use static symmetry breaking techniques.
Our focus for this thesis is on static symmetry breaking. The seminal
strategies for static symmetry breaking in finite model finding are
those developed by Claessen and Sörenson [ claessen_new_2003 ] for their
Paradox solver. Their techniques are used for example by Reger et al. [
creignou_finding_2016 ] in their experiments with the Vampire theorem
prover and also Vakili and Day [ fitzgerald_finite_2016 ] in Fortress.
Claessen and Sörenson do not prove the soundness of their technique
since they claim it is intuitive, but for greater understanding and to
facilitate development of more techniques we believe that a rigorous
mathematical proof is valuable. Indeed, more nuances are at work with
their symmetry breaking technique for single-sorted functions than it
first appears. In this section we will present their symmetry breaking
techniques and prove their correctness. In later sections we move to
present new symmetry breaking techniques.

### 6.1 Existing Techniques for Constants

First, Claessen and Sörenson [ claessen_new_2003 ] propose a symmetry
breaking scheme for constants. Consider a pure finite model-finding
problem @xmath that has two constants @xmath of sort @xmath , and
suppose @xmath . Suppose there exists a satisfying interpretation @xmath
for this problem (which we do not necessarily have), and we wish to
construct our own satisfying interpretation. It is always possible to
apply a domain symmetry to obtain an interpretation @xmath where @xmath
. Therefore it would not affect the satisfiability of the problem to add
the constraint @xmath . In this new interpretation, either @xmath is
assigned the same value as @xmath or a different value. If it is the
same value then obviously @xmath is assigned @xmath . If it is a
different value, since @xmath are interchangeable, we can again apply a
domain symmetry that swaps @xmath and @xmath , thus obtaining an
interpretation @xmath where @xmath while leaving @xmath . Therefore, we
could initially have added the constraints @xmath and @xmath without
affecting satisfiability. Similarly, the constraint @xmath could be
added, reflecting that either @xmath is the same as @xmath or @xmath and
hence is @xmath or @xmath , or it is different and we can arbitrarily
choose it to be @xmath since the remaining values are interchangeable.
In general, the symmetry breaking constraint

  -- -------- --
     @xmath   
  -- -------- --

can be added for @xmath . We call these constraints the ordered constant
constraints . That is, @xmath must be assigned one of the first @xmath
values. Additionally, it can also be constrained that if @xmath is
assigned value @xmath , one of the earlier constants must have been
assigned @xmath . This is done by adding what Claessen and Sörenson call
canonicity constraints . For each @xmath and @xmath , they add the
constraint

  -- -------- --
     @xmath   
  -- -------- --

Claessen and Sörenson added these constraints at the SAT level during
translation, but we can treat them as extended terms.

We will prove the soundness of this scheme. To do this, we must show
that at least one member of each equivalence class of interpretations
satisfies these constraints. Equivalently, given an arbitrary
interpretation @xmath , we must show that there exists an isomorphic
interpretation @xmath of @xmath that satisfies these constraints.

###### Lemma 58.

Let @xmath be a set of size @xmath and let @xmath be elements of @xmath
that are not necessarily distinct. There exists a bijection @xmath such
that, for each @xmath ,

-   @xmath , and

-    for all @xmath , if @xmath then, for some @xmath , @xmath .

###### Proof.

Consider the subsequence @xmath obtained from @xmath by selecting only
the first occurence of each distinct element @xmath and maintaining the
same order. For example, if the original sequence is @xmath then select
the subsequence @xmath .

It suffices to show that there exists a bijection @xmath such that, for
each @xmath ,

-   @xmath , and

-   for all @xmath , if @xmath then, for some @xmath , @xmath .

To construct such a @xmath , simply define @xmath for @xmath . The rest
of the values @xmath for @xmath can then be chosen in any way to
complete @xmath to a bijection. ∎

###### Theorem 59 (Soundness of Constant Symmetry Breaking).

Let @xmath be a (pure) MSFMF problem with a sort @xmath . Enumerate
@xmath as @xmath . Let @xmath be constants of @xmath of sort @xmath .
Let @xmath be any interpretation of @xmath . There exists an isomorphic
interpretation @xmath of @xmath such that the following all hold.

1.   For @xmath , @xmath satisfies @xmath .

2.   For @xmath and @xmath , @xmath satisfies @xmath .

###### Proof.

Let @xmath . An interpretation @xmath satisfies the above constraints if
and only if, for @xmath ,

-   @xmath , and

-   for all @xmath , if @xmath then, for some @xmath , @xmath .

Define @xmath for each @xmath . We will construct @xmath that satisfies
the above requirements by applying an appropriate domain symmetry @xmath
to @xmath . For each sort @xmath that is not @xmath , choose @xmath to
be an arbitrary permutation on @xmath . For whichever @xmath is chosen,
we will have that @xmath . Any choice of @xmath makes @xmath a domain
symmetry, but we have additional requirements on @xmath for @xmath to
satisfy the constraints. So we need to construct @xmath such that, for
@xmath ,

-   @xmath , and

-   for all @xmath , if @xmath then, for some @xmath , @xmath .

Such a permutation exists by Lemma 58 . ∎

While their work is primarily about single-sorted finite model-finding,
Claessen and Sörenson do describe how to modify this approach for the
presence of multiple sorts. These constraints can be applied
individually for each sort. We will describe this in more detail, with a
proof of soundness, in Section 9 .

### 6.2 Existing Techniques for Single-Sorted Unary Functions

Next, we present Claessen and Sörenson’s symmetry breaking scheme in the
presence of single-sorted unary functions of the form @xmath . It seems
natural that if we can constrain @xmath , @xmath and so on up to @xmath
, that we could now add the constraints

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

and so on. This is the scheme that Claessen and Sörenson use. However,
as they note this scheme only works when @xmath (i.e. there is a
constant that has had symmetry breaking constraints added for it). If
there are no constants, Claessen and Sörenson add an artificial one and
add the corresponding symmetry breaking constraints. They do not
elaborate on why they do this, so we will explain why.

Consider if there are no constants and we wish to add symmetry breaking
constraints for a function @xmath . Our intuition for why we could
choose @xmath to be the value assigned to a constant @xmath was that all
of the values were “the same” as far as @xmath was concerned. However
things are more complicated when trying to assign a value for @xmath .
While choosing @xmath is not fundamentally different than choosing
@xmath , choosing @xmath is fundamentally different than choosing @xmath
. For example, @xmath satisfies @xmath while @xmath does not. The reason
that the proof for Theorem 59 fails to generalize to such functions is
because of how a domain permutation @xmath acts on an interpretation.
Recall that if @xmath then @xmath . The domain permutation must be
applied to inputs as well as outputs. If @xmath , it does not suffice to
simply assign @xmath since then we have an interpretation @xmath with
@xmath , which doesn’t necessarily satisfy that @xmath . In fact if
@xmath for all @xmath then there is no domain permutation such that
@xmath . We did not face this problem for constants because nullary
functions have no inputs that are permuted.

Nonetheless, the values @xmath are intuitively “the same” as far as
@xmath is concerned. It only matters whether the output is the equal to
or different than the input. Then for @xmath , either @xmath is @xmath
or @xmath , or it is one of the remaining unused values @xmath , which
again appear to be equivalent choices for @xmath . All unused values
that are distinct from the input are equivalent choices. This suggests
we should be able to add the following constraints.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

We call these constraints ordered range constraints . We now prove the
soundness of this symmetry breaking scheme for unary functions. It is
more involved than our first soundness proof, since constructing an
appropriate symmetry is non-trivial.

###### Lemma 60.

Let @xmath be a set of size @xmath and let @xmath be any function from
@xmath to @xmath . There exists a bijection @xmath such that, for each
@xmath , if @xmath then @xmath .

We find it helps to interpret this lemma graphically. Let @xmath be a
directed graph on node set @xmath such that each vertex @xmath has one
outgoing arc with head @xmath . This lemma says that there is a way to
order the vertices such that the head of each arc goes no further than
one vertex to the right of the tail.

###### Proof of Lemma 60.

To prove the existence of such a permutation, it is equivalent to show
that there is an ordering @xmath of the elements of @xmath (where @xmath
for @xmath ) such that @xmath for each @xmath . To do this, we will show
by induction that for @xmath there exists a sequence @xmath of distinct
elements of @xmath such that @xmath for each @xmath . We will say such a
sequence is a @xmath -good sequence .

First suppose @xmath . The required property for a sequence to be @xmath
-good is vacuously true. Therefore we can select an arbitrary vertex
@xmath to obtain the @xmath -good sequence @xmath .

Now suppose @xmath . By the inductive hypothesis there exists a @xmath
-good sequence @xmath . It remains to make a choice for @xmath from
@xmath and to show that @xmath , since then @xmath is a @xmath -good
sequence. There are two cases depending on whether @xmath lies in the
@xmath -good sequence. If @xmath , then any choice of @xmath from @xmath
will satisfy that @xmath , so @xmath can be chosen arbitrarily. If
@xmath , then selecting @xmath satisfies that @xmath . Hence we can
construct a @xmath -good sequence. ∎

###### Theorem 61 (Soundness of Ordered Range Constraints For
Single-Sorted Unary Functions).

Let @xmath be a (pure) MSFMF problem and let @xmath be a functional
symbol of @xmath . Enumerate @xmath as @xmath . Let @xmath be any
interpretation of @xmath . There exists an isomorphic interpretation
@xmath of @xmath that satisfies the ordered range constraints @xmath for
each @xmath .

###### Proof.

An interpretation @xmath satisfies the ordered range constraints if and
only if @xmath for @xmath .

For convenience let @xmath for each @xmath . We will construct @xmath by
applying an appropriate domain symmetry @xmath to @xmath . For every
sort @xmath that is not @xmath , choose @xmath to be an arbitrary
permutation on @xmath . For whichever @xmath is chosen, the newly
constructed interpretation @xmath is such that @xmath for each @xmath .
We need to construct a permutation @xmath such that, for each @xmath and
@xmath if @xmath then @xmath . Such a permutation exists by Lemma 60 . ∎

This symmetry breaking technique does not generalize easily to higher
arity functions. To get any symmetry reduction out of a binary function
@xmath , Claessen and Sörenson define a new unary function @xmath , add
the constraint @xmath , and then perform symmetry breaking using the
function @xmath .

## 7 New Symmetry Breaking for Functions

Although the symmetry breaking techniques introduced by Claessen and
Sörenson [ claessen_new_2003 ] are very effective, they have some
limitations. First, we discussed how extra values are needed for the
ordered range constraints when considering unary functions as opposed to
constants. Additionally, it was mentioned that their symmetry breaking
approach does not generalize easily to higher arity functions. While
their paper discusses how to add symmetry breaking constraints for
constants in a many-sorted setting, its discussion of functions is
limited to a single-sorted setting. The question remains whether more
can be done in a many-sorted setting. In this section, we will present
new symmetry breaking constraints for multi-sorted functions, as well as
rigorously prove the correctness of this new symmetry breaking scheme.
We will show that it generalizes very well to a class of higher arity
functions.

### 7.1 Multi-Sorted Unary Functions

Recall that the problem we faced for a function @xmath when attempting
to constraint @xmath is that because symmetries must be applied
consistently to both the arguments and result of a function, we cannot
just constrain @xmath . However if we consider a multi-sorted unary
function symbol @xmath , this problem vanishes. We can separately
permute the input and output values because they belong to different
sorts. The domain permutation can leave the input sort fixed, and only
permute the output sort. The proof of Theorem 59 now can be easily
generalized, and we can add the following strong ordered range
constraints .

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

###### Theorem 62 (Soundness of Strong Ordered Range Constraints For
Multi-Sorted Unary Functions).

Let @xmath be a (pure) MSFMF problem and let @xmath be a functional
symbol of @xmath , where @xmath and @xmath are distinct sort symbols.
Enumerate @xmath as @xmath and @xmath as @xmath . Let @xmath be any
interpretation of @xmath . There exists an isomorphic interpretation
@xmath of @xmath that satisfies the strong ordered range constraints
@xmath for each @xmath .

###### Proof.

Let @xmath . An interpretation @xmath satisfies the strong ordered range
constraints if and only if @xmath for @xmath .

Define @xmath for each @xmath . We will construct @xmath by applying an
appropriate domain symmetry @xmath to @xmath . For each sort @xmath that
is not @xmath , select @xmath to be the identity on @xmath . In
particular, choose @xmath to be the identity on @xmath . Now for
whichever @xmath is chosen, we will have @xmath for each @xmath . So we
need to construct @xmath such that @xmath for @xmath . The existence of
such a @xmath follows from Lemma 58 . ∎

### 7.2 Higher Arity Functions

Now that we know more symmetry breaking can be done for functions of the
form @xmath , the question remains what to do about higher arity
functions. Fortunately, this new symmetry breaking strategy can be
easily generalized to higher arities. What made the proof of Theorem 62
so simple was that we could leave the inputs sorts fixed and simply
permute the output sorts. Therefore if a function symbol does not have
its output sort as one of its input sorts, we can apply a similar
strategy.

###### Definition 63.

A function symbol @xmath is domain-range distinct (DRD) if its result
type @xmath is distinct from each of its argument types @xmath (though
@xmath need not be distinct).

###### Theorem 64 (Soundness of Strong Ordered Range Constraints For DRD
Functions).

Let @xmath be a (pure) MSFMF problem and let @xmath be a DRD function
symbol of @xmath . Take an arbitrary ordering @xmath of the tuples in
@xmath . Also enumerate @xmath as @xmath . Let @xmath be any
interpretation of @xmath . There exists an isomorphic interpretation
@xmath of @xmath that satisfies the strong ordered range constraints
@xmath for each @xmath .

###### Proof.

Let @xmath . An interpretation @xmath satisfies the strong ordered range
constraints if and only if @xmath for @xmath .

Define @xmath for each @xmath . We will construct @xmath by applying an
appropriate domain symmetry @xmath to @xmath . For each sort @xmath that
is not @xmath , select @xmath to be the identity on @xmath . In
particular, choose @xmath to be the identity on @xmath for each @xmath .
Now for whichever @xmath is chosen, we will have @xmath for each @xmath
. So we need to construct @xmath such that @xmath for @xmath . The
existence of such a @xmath follows from Lemma 58 . ∎

Consider the problem of finding a @xmath Latin Square. One way to
formulate this as a finite model finding problem is by having a single
sort @xmath with values @xmath along with a function symbol @xmath that
represents what entry is assigned to each row-column pair, and then
adding appropriate constraints on @xmath for columns and rows. Without
greater knowledge of the problem, not much symmetry breaking can be
justified using Claessen and Sörenson’s technique, since @xmath is a
binary function that uses only a single sort. However, sort inference
easily reveals that there is no reason that rows, columns, and grid
entries need to use the same sort. Instead, distinct sorts @xmath could
be used with @xmath . The function can instead become the domain-range
distinct function @xmath , and so we can justify adding the following
strong ordered range constraints.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

This demonstrates the advantage that having a many-sorted system and
sort inference can provide to symmetry breaking.

## 8 New Symmetry Breaking for Predicates

In this section we present a new symmetry breaking technique that we
have developed to reduce symmetries in the presence of predicates.
Occasionally in this section we use cycle notation for a permutation.
When @xmath is written, it means the permutation that sends @xmath to
@xmath for @xmath , sends @xmath to @xmath , and leaves any other values
of the set in question fixed.

### 8.1 Unary Predicates

Consider a signature @xmath with a sort @xmath and unary predicate
symbol @xmath as well as a domain assignment @xmath that assigns @xmath
. For an interpretation @xmath , @xmath is a unary relation @xmath ,
which is simply a set of domain elements. Now consider any pure MSFOL
formula @xmath over @xmath . Assume for now we do not add any other
symmetry breaking constraints.

Suppose we know that there is a satisfying interpretation @xmath which
assigns @xmath . There is nothing special about the particular values
@xmath . By using the Value Relabeling Theorem, we could consistently
interchange @xmath and @xmath with @xmath , and @xmath respectively in
the interpretation to get another interpretation @xmath that assigns
@xmath and still satisfies @xmath . Conversely, if we know that there is
no satisfying interpretation @xmath that assigns @xmath , we know by the
Value Relabeling Theorem that there is no satisfying interpretation
@xmath that assigns @xmath . The same is true not just for @xmath , but
any set of three elements of @xmath .

The key insight here is that there because values are interchangeable,
any choice for @xmath of size @xmath is just as good as any other choice
for @xmath of size @xmath . If we choose a specific @xmath -subset
@xmath of @xmath and learn that there is no interpretation that assigns
@xmath , there is no need to try any other @xmath -subset; we know none
of them will yield a solution. We need only try assigning @xmath to be
@xmath , @xmath to determine whether a solution exists.

We can enforce restricting the search this way by introducing predicate
membership constraints . To come up with these constraints, it is
perhaps more intuitive to think of constructing the set @xmath , and
what restrictions we place on the other elements given that a specific
element is in the set. If we wish to put the element @xmath to the set,
it means that we must include @xmath in the set, so we add the
constraint @xmath . Next if we wish to add the element @xmath , it means
that we must have include both @xmath and @xmath in the set, so we add
the constraint @xmath . We proceed similarly for the remaining elements
to get the following constraints.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

These constraints are satisfied if and only if @xmath is one of @xmath ,
or @xmath . We can simplify these constraints to the following.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

Now we prove the soundness of adding these predicate membership
constraints.

###### Theorem 65 (Soundness of Predicate Membership Constraints for
Unary Predicates).

Let @xmath be a (pure) MSFMF problem and let @xmath be a predicate
symbol of @xmath . Order @xmath as @xmath . Let @xmath be any
interpretation of @xmath . There exists an isomorphic interpretation
@xmath of @xmath that satisfies the predicate membership constraints
@xmath for each @xmath .

###### Proof.

An interpretation @xmath satisfies the required predicate membership
constraints if and only if @xmath is one of the following sets: @xmath .

Write @xmath as @xmath for some integer @xmath (note that the @xmath ’s
are distinct). We will construct @xmath by applying an appropriate
domain symmetry @xmath to @xmath . Choose @xmath to be an arbitrary
permutation of @xmath for any sort @xmath . Now, for whichever @xmath is
chosen, @xmath . Thus it suffices to show that there exists a
permutation @xmath such that @xmath . We can easily construct such a
permutation by defining @xmath for @xmath and @xmath for all @xmath . ∎

### 8.2 Binary Predicates

This symmetry breaking strategy is surprisingly difficult generalize to
higher arity predicates. We might intuitively think that since all
values are interchangeable, all argument tuples ought to be
“interchangeable” somehow as well. Then we could order the possible
argument tuples as @xmath and define predicate membership constraints
@xmath for @xmath . This intuition is not correct, for two reasons.

Consider a predicate @xmath and @xmath . It is wrong to say that any
pair in @xmath is interchangeable with any other pair in @xmath . While
we might consider @xmath to be interchangeable with @xmath , it seems
incorrect to consider @xmath and @xmath interchangeable because there is
a relationship between the first and second elements of the pair @xmath
that is not shared by the elements of the pair @xmath .

As a concrete example, consider the formula @xmath . This formula is
satisfied if the interpretation @xmath but is not satisfied if @xmath .
Determining whether there is a satisfying interpretation that assigns a
specific set of one tuple to @xmath does not immediately tell us whether
there exists a satisfying interpretation that assigns any other specific
set of one tuple to @xmath . Examining the proof of Theorem 65
illuminates where the error lies. There is no permutation @xmath that
can map @xmath to @xmath . Such a permuation would be required to send
both @xmath and @xmath to @xmath .

However, we have the benefit of working in a many-sorted system. If
instead we have a predicate @xmath , we should be able to avoid the
tuple element interdependence that arose above. Formulas like the @xmath
above would not be allowed. We would be allowed two permutations @xmath
and @xmath , the former operating on the first tuple element and the
latter on the second. The above problem would be no issue. Learning
whether there is a satisfying interpretation for a specific set of one
tuple to @xmath does allow us to immediately determine whether there
exists a satisfying interpretation that assigns any given set of one
tuple to @xmath .

Unfortunately, this fails to address a second complication. Consider the
formula @xmath , and say @xmath , @xmath . Here, no satisfying
interpretation assigns @xmath a set of one tuple, so our claim above
still holds. However, consider the sets @xmath and @xmath . Assigning
@xmath does not satisfy @xmath , while assigning @xmath does satisfy
@xmath . There do not exist permutations @xmath and @xmath such that
@xmath , since @xmath would need to send @xmath to both @xmath and
@xmath . The problem here is that @xmath appears twice (but in different
tuples) in one of the sets, but only once in the other. While any two
individual tuples are “interchangeable” in that there can be found a
pair of permutations (one for each sort) that maps one tuple to the
other, this is not in general true for two sets of tuples.

While we have painted a grim picture, we do not mean to suggest that
nothing can be done. Indeed, we should expect some symmetry breaking to
be possible for higher-arity predicates, since for example the sets
@xmath and @xmath are related by a pair of permutations, specifically
the identity function @xmath and the cycle @xmath . To break this
symmetry, we would want to say that the tuple @xmath should only be
included only if the tuples @xmath and @xmath have already been
included. We can take this further, and say that the set of all @xmath
such that @xmath should be one of @xmath , or @xmath , which is captured
by the following constraints.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

We call these the @xmath -predicate membership constraints . This can be
thought of as taking the partially applied predicate @xmath and creating
the unary predicate membership constraints for it. The proof that this
symmetry breaking strategy is sound is almost the same proof as for
Theorem 65 .

###### Theorem 66 (Soundness of Predicate Membership Constraints for
Binary Predicates).

Let @xmath be a (pure) MSFMF instance and let @xmath be a predicate
symbol of @xmath , where @xmath and @xmath are distinct sorts. Enumerate
@xmath as @xmath and @xmath as @xmath . Let @xmath be any interpretation
of @xmath . There exists an isomorphic interpretation @xmath of @xmath
such that @xmath satisfies the @xmath -predicate membership constraints
@xmath for @xmath .

###### Proof.

Given an interpretation @xmath , let @xmath . An interpretation @xmath
satisfies the @xmath -predicate membership constraint if and only if
@xmath is one of the following sets: @xmath , @xmath , @xmath , @xmath ,
@xmath .

We will construct @xmath by applying an appropriate domain symmetry
@xmath to @xmath . For each sort @xmath that is not @xmath , select
@xmath to be the identity on @xmath . In particular, choose @xmath to be
the identity on @xmath . Now we need to find is a permutation @xmath
such that, applying @xmath pointwise to let @xmath yields one of the
sets listed above. Such a permutation is easy to construct. Writing
@xmath , define @xmath such that @xmath for @xmath and @xmath acts as
the identity on @xmath . ∎

Note that the above theorem only claims that we can add the predicate
membership constraints for a single value of @xmath . We would hope that
we could add predicate membership constraints for more values of @xmath
, but unfortunately this is not the case. To do so, we would need to
find a single @xmath that sends @xmath to one of the sets @xmath for
every value of @xmath , which is not always possible. Consider the case
where @xmath and @xmath with a starting interpretation where @xmath .
There are only two permutations on @xmath , the identity and @xmath .
Applying the former yields the same interpretation @xmath , which fails
@xmath , while applying the latter yields @xmath , which fails @xmath .

We also want to emphasize that Theorem 66 might fail for a predicate
@xmath that uses only one argument sort. The proof takes advantage of
the fact that it can work with two permutations by defining @xmath to be
the identity and only needing to find a suitable @xmath . Such a
strategy no longer works when only working with a single permutation.
Consider where @xmath with a starting interpretation @xmath . Both
permutations of @xmath send @xmath to itself, and this interpretation
does not satisfy the constraint @xmath . Once more this demonstrates the
value of sort inference, since it can be used to identify circumstances
where @xmath could instead be more generally typed and allow for greater
symmetry breaking.

## 9 Combining Symmetry Breaking Strategies

We have rigorously proven the soundness of various static symmetry
breaking schemes in the presence of constants, functions, and
predicates. They cannot be arbitrarily combined however, since adding
symmetry breaking constraints introduces domain values into the
formulas, and values may no longer be interchangeable.

For example, consider the MSFMF problem @xmath defined as follows.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

This problem is satisfiable. Using Theorem 59 , we can add the ordered
constant constraint @xmath . Alternatively, using Theorem 65 , we can
add the predicate membership constraints @xmath and @xmath . However, we
cannot add all of these constraints simultaneously, since the resulting
problem becomes unsatisfiable. The issue is that after adding the
constraint @xmath , the problem is now an extended MSFMF problem instead
of a pure problem, and not all of the values in @xmath are
interchangeable.

Fortunately, after adding a set of symmetry breaking constraints, many
values are likely to still be interchangeable. For example, since @xmath
and @xmath have not been used after adding @xmath , the set @xmath is
still value-interchangeable. In this section we generalize our symmetry
breaking strategies and proofs of correctness to extended problems. The
result of this generalization is that we determine under what conditions
these symmetry breaking schemes can be combined soundly. In this
setting, for a given sort @xmath , @xmath may not necessarily be
interchangeable, but a subset of @xmath is value-interchangeable.

### 9.1 Theorems and Discussion

The significance of these theorems may be bogged down by the technical
details of the proofs, so first we will simply state the theorems and
discuss their implications. Rigorous proofs are provided in the next
subsection.

We begin with a theorem analogous to Theorem 59 , which involved
symmetry breaking for constants.

###### Theorem 67 (Soundness of Constant Symmetry Breaking, Extended).

Let @xmath be an eMSFMF problem with a sort @xmath . Let @xmath be a
value-interchangeable set for @xmath , and enumerate @xmath as @xmath .
Let @xmath be constants of @xmath of sort @xmath . Let @xmath be any
interpretation of @xmath . There exists an isomorphic interpretation
@xmath of @xmath such that all of the following hold.

1.   For @xmath , @xmath satisfies @xmath .

2.   For @xmath and @xmath , @xmath satisfies @xmath .

The first thing of note is that Theorem 67 justifies performing symmetry
breaking for constants separately for each sort in a pure MSFMF problem,
as done by Claessen and Sörenson [ claessen_new_2003 ] . For example,
suppose there are constants @xmath , and the domain assignment specifies
@xmath and @xmath . First, we can add the symmetry breaking constraints
@xmath and @xmath . In this new extended problem, the entirety of @xmath
is still value-interchangeable for @xmath , so we can add the
constraints @xmath and @xmath .

More interesting however is when we want to perform symmetry breaking on
constants of a sort that already has some of its domain values in the
formulas. For example, consider the extended MSFMF problem @xmath
defined as follows.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

The set of values @xmath does not appear in the formulas and so is
value-interchangeable. Therefore Theorem 67 justifies the addition of
the following constraints (the parentheses are just there for emphasis
to separate which of the disjuncts comes from the interchangeable values
and which come from the other values).

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

The following is the generalization of Theorem 64 , which considered DRD
functions.

###### Theorem 68 (Soundness of Strong Ordered Range Constraints for DRD
Functions, Extended).

Let @xmath be an eMSFMF problem and let @xmath be a DRD function symbol
of @xmath . Let @xmath be a value-interchangeable set for @xmath . Take
an arbitrary ordering @xmath of the tuples in @xmath . Enumerate @xmath
as @xmath . Let @xmath be any interpretation of @xmath . There exists an
isomorphic interpretation @xmath of @xmath that satisfies the strong
ordered range constraints @xmath for each @xmath .

We wish to emphasize the possibly surprising fact that it does not
matter whether the input values to a function are interchangeable or
not. As an example, suppose we have the extended MSFMF problem @xmath
defined by the following.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

While @xmath appears in the formulas, the values in the set @xmath do
not appear and are value-interchangeable for @xmath . Therefore we can
add the following symmetry breaking constraints, even though values of
sorts @xmath and @xmath have been used in the formulas (again the
parentheses separate the disjuncts arising from interchangeable values
from the other values).

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

Finally we generalize Theorem 65 .

###### Theorem 69 (Soundness of Predicate Membership Constraints for
Unary Predicates, Extended).

Let @xmath be an eMSFMF problem and let @xmath be a predicate symbol of
@xmath . Let @xmath be a value-interchangeable set for @xmath . Order
@xmath as @xmath . Let @xmath be any interpretation of @xmath . There
exists an isomorphic model @xmath of @xmath that satisfies the predicate
membership constraint @xmath for each @xmath .

Consider for example the extended MSFMF problem @xmath defined as
follows.

  -- -------- --
     @xmath   
     @xmath   
     @xmath   
  -- -------- --

This is the first problem we considered in this section, after we have
added the symmetry breaking constraint @xmath . As mentioned earlier, we
are not justified in adding the constraints @xmath and @xmath since
@xmath is not value-interchangeable for @xmath . However @xmath is
value-interchangeable for @xmath , so Theorem 69 justifies the addition
of the constraint @xmath .

### 9.2 Soundness Proofs

Here we recall the theorems from the previous section and provide proofs
for them. It is important to remember that unlike in the proofs of the
pure counterparts to these theorems, not all domain permutations are
domain symmetries, so value-interchangeability has to be taken into
consideration to prove that the constructed domain permutations are
domain symmetries.

See 67

###### Proof.

Let @xmath . An interpretation @xmath satisfies the above constraints if
and only if, for @xmath ,

-   @xmath , and

-   for all @xmath , if @xmath then, for some @xmath , @xmath .

Define @xmath for each @xmath . We will construct @xmath that satisfies
the above requirements by applying an appropriate domain symmetry @xmath
to @xmath . For each sort @xmath that is not @xmath , choose @xmath to
be the identity on @xmath . For whichever @xmath is chosen, we will have
that @xmath . By definition of value-interchangeability, if @xmath acts
as the identity on @xmath , then @xmath is a domain symmetry. So it
suffices to construct @xmath such that,

-   @xmath acts as the identity on @xmath ,

-   for @xmath , @xmath , and

-   for @xmath and @xmath , if @xmath then, for some @xmath , @xmath .

Define @xmath to be the union of the identity on @xmath and some as of
yet undetermined permutation @xmath on @xmath . This choice satisfies
the first requirement, as well as the second and third requirements for
any @xmath such that @xmath (the third requirement holds in this case
since @xmath and the antecedent of the implication is false). Therefore
we need only construct the permutation @xmath such that, for any @xmath
where @xmath ,

-   @xmath , and

-   for all @xmath , if @xmath then, for some @xmath , @xmath .

Construct a subsequence @xmath of @xmath by removing all values @xmath
such that @xmath and keeping the same relative ordering. By the
construction of the subsequence it suffices to construct @xmath such
that for @xmath ,

-   @xmath , and

-   for all @xmath , if @xmath then, for some @xmath , @xmath .

Such a permutation exists by Lemma 58 . ∎

See 68

###### Proof.

Let @xmath . An interpretation @xmath satisfies the strong ordered range
constraints if and only if @xmath for @xmath .

For simplicity, define @xmath for each @xmath . We will construct @xmath
by applying an appropriate domain symmetry @xmath to @xmath . For each
sort @xmath that is not @xmath , select @xmath to be the identity on
@xmath . In particular, choose @xmath to be the identity on @xmath for
each @xmath . Now for whichever @xmath is chosen, we will have @xmath
for each @xmath . Additionally, by definition of
value-interchangeability, if @xmath acts as the identity on @xmath ,
then @xmath is a domain symmetry. Therefore, it suffices to construct
@xmath such that

1.  @xmath acts as the identity on @xmath , and

2.  for each @xmath , @xmath .

Define @xmath such that it is the union of identity on @xmath and an as
of yet undetermined permutation @xmath on @xmath . This choice satisfies
the first requirement, and satisfies the second requirement for any
@xmath such that @xmath . Therefore we need only construct a permutation
@xmath such that, for any @xmath where @xmath , we have @xmath .

Construct a subsequence @xmath of @xmath by removing all values @xmath
such that @xmath , and keeping the same relative ordering. By the
construction of the subsequence, it suffices to construct a permutation
@xmath such that @xmath for @xmath . The existence of such a @xmath
follows from Lemma 58 . ∎

See 69

###### Proof.

An interpretation @xmath satisfies the required predicate membership
constraints if and only if @xmath is one of the following sets: @xmath .

Again we construct @xmath by applying an appropriate domain symmetry
@xmath to @xmath . Define @xmath to be the identity permutation of
@xmath for any sort @xmath . Additionally, define @xmath so that it is
the union of the identity permutation on @xmath and an as of yet to be
determined permutation @xmath . By the definition of
value-interchangeability, @xmath is a domain symmetry. Write @xmath as
@xmath . It suffices to show that there exists a permutation @xmath such
that @xmath . We can easily construct such a permutation by defining
@xmath for @xmath . ∎

## 10 Conclusions

Let us summarize the accomplishments of this thesis. We reviewed and
unified the various notions of symmetry in constraint satisfaction and
finite model finding. Next, we used this framework to demonstrate how
sorts serve as proofs of the existence of symmetries and that sort
inference operates as a symmetry detection mechanism, bringing us to a
fuller understanding of how sorts and symmetries relate. We presented
existing static symmetry breaking techniques used in FMF, providing
proofs of correctness that are omitted in existing literature. Following
this we introduced a new symmetry breaking scheme for domain-range
distinct functions, which exist only in the many-sorted setting, as we
all a new scheme for symmetry breaking with unary predicates. These new
schemes have the potential to increase the effectiveness of static
symmetry breaking and thereby improve solver performance, especially for
systems that use sorts. We additionally proved the soundness of both new
schemes. Hopefully our approach to proving the soundness of symmetry
breaking constraints can serve as a guide for future authors looking to
develop new symmetry breaking schemes so they need not retreat to
appealing to intuition. Finally, we proved conditions for when symmetry
breaking constraints can be combined.

There are many avenues for future work. We saw in Sections 4 and 5 that
there are more symmetries of a finite model finding problem than just
domain symmetries, and it remains to be seen how to exploit these other
symmetries. Also, while we proved conditions for when symmetry breaking
constraints can be combined, it still needs to be investigated what
combinations are most optimal at reducing symmetries. In particular, it
would be useful to develop some heuristics and collect empirical
results. Additionally, we aim to implement sort inference and these new
symmetry breaking schemes in the Fortress model finder.