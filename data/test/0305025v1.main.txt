# Part I Quantum Computation: Decoherence and Control

### Chapter \thechapter Philosonomicon

  wherein we gently embark on an inquiry into the computational depths
  of the physical universe and discover the fragile structure of
  information with quantum foundations

#### 1 Prologue

Our generous universe comes equipped with the ability to compute ¹ ¹ 1
Blessed be the computational universe which allows this very thesis [ 7
] to be typed onto a portable computer in the comfort of a sorted array
of pleasant locations. . By the use of appropriate physical systems
algorithmic tasks can be executed with repeatable results which in turn
allow for the development of our systems of mathematics and physics
consistent with this repeatability. In physics, determination of the
allowable manipulations of a physical system is of central importance.
Computer science, on the other hand, has arisen in order to quantify
what resources are needed in order to perform a certain algorithmic
function. For computer science to be applicable to the real world the
quantification of resources needed to perform a certain algorithmic
function should be delimited by what physics has determined to be
allowable manipulations. Thus we arrive at the realization that because
information is physical , our understanding of computer science should
be built on primitives which respect our understanding of the laws of
physics. Terse in expression, ghostly trivial in its conceptual
underpinnings, this mantra that,

“Information is physical!” [ 130 ]

nonetheless has deep consequences for both the physicist examining how
nature behaves and the computer scientist attempting to understand the
power and limitations of real world execution of algorithmic tasks. This
very thesis, an ever-growing body of scientific literature, and an
equally expanding community of scientists (rainbow in its composition of
physicists, mathematicians, and computer scientists), are but a small
testament to the usefulness, practical and abstract, of this one small
idea. “Information is physical”, we thus shout, and in this thesis we
explore, the consequences of this small idea in our large and generous
universe.

#### 2 Argument via the inevitability of technology

It is only through the bright light of hindsight that we can appreciate
the grandeur of scientific achievement during the twentieth century.
Unlike any previous historical era, this scientific century has erected
profound disciplines from a seeming vacuum of prior consideration,
pushing novel technologies and new understandings in directions
inconceivable only a few years prior. Among the two most far reaching
movements of the twentieth century’s scientific symphony have been the
composition of the quantum theory of nature and the rising crescendo of
the computer revolution. To first approximation these two fields appear
in independent coexistence. To master the art of computer programming,
knowledge of quantum theory is not prerequisite. Likewise, to learn
contemporary physical theory, understanding of modern computational
theory is not necessary.

The illusion of separation between computer science and modern physical
theory, however, fades quickly as one’s focus on details sharpens. On
one hand, comprehension of modern physical theory does not require
computation, but our understanding of the physical world is sharpened,
if not progressed, by the use of computers in the simulation of physical
systems. Whole realms of physics would be inaccessible were it not for
the use of computers to perform calculations impossible on a human scale
but possible with the calculational capabilities of modern computers.
Fields like physical chemistry and lattice quantum field theory now
depend on the use of computational power to such a degree that a growing
view among theoretical physicists is to play the cynic and declare they
are ‘‘computer programmers not physicists’’ ² ² 2 Posing a significant
retention problem for graduate physics programs! .

The reverse implication between the two fields also occurs because
computers are physical devices such that quantum theory is essential to
understanding their physical operation. The modern quantum theory of
these devices presents our best understanding of the physics behind the
computer revolution. Thus, while there is nothing which is essentially
quantum mechanical about the algorithmic operation of today’s computers,
our understanding of the mechanisms behind the computer architecture is
deeply rooted in the quantum theory of the solid-state.

How far can the two way relationship between computer science and
quantum theory be pressed? The forward implication asks the question
“what can computer science tell us about quantum theory?” [ 80 ] This
thesis will not concern itself with this question, and indeed it appears
that very little progress has been made along this line of inquiry (see,
however [ 158 , 203 ] ).

The reverse implication posses a different query: “what can quantum
theory tell us about computer science?” One important difference between
this implication and its inverse lies in the seeming inevitability of
the relevance of this question. This inevitability arises from two
different directions. In 1965 Gordon Moore noticed that the
computational power of a computer doubled approximately every two years
[ 149 ] . A more physical statement of this principle is that the number
of atom’s needed to represent one bit of information will halve
approximately every two years. Since Moore’s 1965 observation, Moore’s
law has continued to hold and been the barometer of astounding
technological progress in computer hardware. As Moore’s law moves into
its fortieth year of success, however, a new barrier has arisen on the
not so distant horizon. If Moore’s law continues to hold, around the
year 2015 Moore’s law predicts that the size of the computational
devices constructed will reach a scale where quantum effects will begin
to play a dominant operational role. One view of progress maintains that
this will be the essential limit to our current solid-state computer
architectures: quantum effects becoming dominant implies that no more
computational power can be squeezed out of the system. On the other
hand, it is unclear how a computer operating at this quantum limit will
behave. The argument of technological inevitability leads us to believe
that computers operating into the quantum regime will be built. Thus it
seems technologically relevant to consider how computers operating with
quantum effects dominating will behave. Quantum theory can tell us
something about how real computers of the future will function.

A second reason for confidence in the inevitability of the role quantum
theory can play in computer science builds from a long line of
experimental progress in control of quantum systems. In particular,
fields like cavity quantum electrodynamics [ 23 ] , ion and neutral atom
trapping [ 205 ] , and certain areas of quantum optics [ 90 , 169 , 207
] , have made considerable progress in demonstration of the control of
fully quantum degrees of freedom. These extremely sensitive experimental
successes point to a time in which control over multiple interacting
quantum systems will become possible. From the computer science
prospective, such quantum control will represent computational devices
operating in a quantum regime. Again technological progress leads us to
believe that quantum control will be pressed further and further until
at least small scale computational quantum devices are constructed.

Inevitably, we are thus led to assume that the relevance of quantum
theory to computational device will grow larger with time. What, then,
are the consequences of this seemingly inevitable crash between the
twentieth centuries most prolific offspring, quantum theory and modern
computation?

#### 3 The rise of the quantum algorithm

  One must solemly affirm one’s allegiance to the Quantum God before one
  may be admitted to the physics clan.

  –Carver A. Mead, Collective Electrodynamics [ 145 ]

In the early 1980’s Benioff [ 17 , 18 , 19 ] and Feynman [ 80 , 81 ]
began to consider computers whose algorithmic operation was fully
quantum mechanical. Benioff appears to have been motivated towards such
quantum computers via the requirement that description of quantum theory
should be self-consistently described by machines operating according to
quantum theory. Feynman, on the other hand, had a long standing interest
in the physical limits of computation [ 79 ] which apparently led him
towards considering computers with quantum components [ 82 ] . However,
while Feynman [ 80 ] , and earlier Manin [ 143 ] , clearly understood
that simulating quantum systems was in some form a difficult task, it
took the ground breaking work of Deutsch [ 56 ] and Deutsch and Jozsa [
59 ] to realize that computers built on quantum principles could perform
computational tasks in an intrinsically more efficient manner than could
classical computers. What these latter authors showed was that there
were circumstances under which information in a quantum setting
manipulated by a quantum computer had a different productivity than
equivalent classical information manipulated by a classical computer.
Here, then, was the first interesting answer to the query “what can
quantum physics tell us about computer science?” The quantification of
resources which is the main thrust of computer science was shown to be
different when operating in the quantum regime.

The work of Deutsch and Jozsa was followed up by a progression of work
demonstrating increasingly powerful applications of the idea of quantum
computation. The oracle problem Deutsch and Jozsa investigated (and
subsequent results by Berthiaume and Brassard [ 26 , 27 ] ) was one in
which the amount of resources needed in order to perform the computation
on a quantum computer was exponentially less than a similar exact
computation performed on a classical computer. However, a probabilistic
classical computer could solve the problem Deutsch and Jozsa posed with
similar use of resources if the problem output of the algorithm could be
wrong with some vanishingly small probability. Thus the work of Deutsch
and Jozsa alone did not demonstrate a clear separation between classical
and quantum computation.

Overcoming the exactness requirement of Deutsch and Jozsa, Bernstein and
Vazirani [ 24 ] put forth algorithms which showed a true superpolynomial
resource gap between quantum and classical computation in 1993. This was
followed closely by the work of Simon [ 176 ] who posed a problem which
required exponentially more resources to solve on a classical computer
than on a quantum computer. In 1994, following Simon’s lead, Shor [ 173
] remarkably demonstrated that quantum computers could factor numbers
and compute a discrete logarithm efficiently. Much work in complexity
theory has gone into attempting to develop efficient classical
algorithms for these two problems and it is widely believed that such
efficient solution on a classical computer is impossible [ 167 ] . In
fact, confidence in the difficulty of these two problems forms the basis
for the most widely used public key cryptography systems [ 164 ] .
Further evidence for the power of quantum computers over classical
computers was unveiled when Grover [ 99 , 100 ] demonstrated that
quantum computers could search unordered lists quadratically faster than
classical computers.

By 1996, a clear separation in productivity between the algorithmic
manipulation of quantum information and classical information had been
established. Further progress [ 30 , 113 ] demonstrated [ 105 ] that
Deutsch-Jozsa, Bernstein-Vazirani, Simon, and Shor’s algorithms were all
related to a single problem known as the hidden subgroup problem.
Separate from these Shor-type algorithms, research also broadened [ 31 ,
32 ] and quantified [ 20 ] the algorithm developed by Grover.

A third line of research has shown how to use a quantum computer to
efficiently simulate quantum systems [ 1 , 29 , 138 , 181 , 204 , 209 ]
. While there is no general proof that quantum systems are hard to
simulate on classical computers, the vast industry of physicists who
have attempted to provide such efficient simulations have all failed.
Building a quantum computer would profoundly change the complexity of
the quantum models studied by physicists.

The discovery that quantum algorithms can outperform their classical
brethren is a result which should be fundamentally shocking to all
studied computer scientists. The computational complexity classes of
yesteryear have ethereal foundations: the true foundations lie in a
quantum setting. Further shock should also occur to those who use public
key cryptosystems based on factoring and discrete logarithms: the future
building of a quantum computer will allow your encrypted messages to be
read! Like any infant discovery, however, the true power behind quantum
computation is currently unclear. Past ventures by humanity in
brandishing the skill of foresight–

  “I think there is a world market for maybe five computers.” - Thomas
  Watson, chairman of IBM, 1943

–give us the confidence and optimism to believe that the field of
quantum algorithms is only beginning to bloom.

#### 4 Control and the quantum computer

While the algorithmic speedup promised by quantum computers was being
developed, much work was done defining and understanding the basic
question: what exactly is a quantum computer?

A seminal step in modern computer science was taken when Turing defined
the class of functions now known as recursive or computable functions [
189 ] . The Church-Turing thesis [ 189 , 46 , 45 ] conjectures that this
class of functions corresponds precisely to what can be computed by an
algorithmic method in the real world. Thus the Church-Turing thesis
provides a fundamental grounding upon which modern theoretical computer
science is built: everything that is naturally computable by an
algorithm is precisely the class of recursive functions. Computer
scientists are thus assured of job security by basing their studies on
the class of recursive functions. Furthermore it was found that a
certain class of computers, universal computers [ 189 ] , could be used
to efficiently compute a recursive function. Thus, under the
Church-Turing thesis and universality results, a computer scientist
concerned with computation could be myopic to all models of computation
sans a universal computer. Of particular importance to computer science
is that the Church-Turing thesis and universality results allow for the
development of a quantification [ 49 , 108 ] of the computational
resources needed to perform a certain algorithmic task which is
essentially robust to the basic model of computation used to perform the
task. Modern computational complexity [ 156 ] theory is a house built
upon a frame of universal computers whose structural integrity is
encoded in the robustness claimed by the Church-Turing thesis.

The Church-Turing thesis, however, is not a mathematical proof, however,
but an empirical statement whose validity has withstood over seventy
years of testing. The advent of quantum computation, however, has
brought the validity of the computational complexity models founded upon
the Church-Turing thesis into question and in fact the very basis of
computation which is now claimed to be fundamental in computer science
has taken a severe detour into the quantum realm. Early research in
quantum computation generalized classical models of computing, the
Turing machine and the circuit model, into their quantum mechanical
analogies. The quantum equivalent of a Turing machine was first
considered by Benioff [ 17 , 18 , 19 ] . Deutsch [ 56 ] and Yao [ 208 ]
further developed quantum Turing machines. The quantum equivalent of
classical circuits was introduced by Deutsch [ 57 ] and this quantum
circuit model (with certain uniformity constraints) was shown to be
equivalent to the quantum Turing machine by Yao [ 208 ] .

In the simplest quantum circuit model a sequence of quantum gates
(unitary evolution) is applied (perhaps in parallel) to an array of
quantum mechanical two-level systems (qubits) with an appropriate
initialization and readout of the quantum information. One of the first
results in quantum computation was the demonstration that certain sets
of quantum gates acting on such an array are universal in the sense that
any unitary evolution on the array could be performed by an appropriate
sequence of such gates. Following early results which required
three-body interactions [ 57 ] between quantum systems it was
subsequently realized that two-body interactions [ 61 ] were sufficient
to perform universal quantum computation in the quantum circuit model.

Because quantum interactions are intrinsically analog in nature
(interaction times and coupling strengths are real numbers) the correct
description of universal quantum circuits requires some notion of
approximation [ 117 , 118 ] . This is similar to the situation with
probabilistic classical computers. At first glance it appears that the
analog nature of probabilities may cause unwarranted power due to
infinite accuracy in such classical probabilistic computers. Models
which contain bounded accuracy in their transition probabilities, the
real world equivalent to a classical probabilistic machine, however, can
be shown to form a robust computational class. Similarly, quantum
circuits must be cast within the framework of finite accuracy. In
particular, discrete sets of quantum gates implemented with a finite
accuracy are the real building blocks of a quantum circuit. Luckily such
discrete sets were shown to be able to approximate any exact quantum
circuit to within an accuracy @xmath (defined on some suitable distance
measure) with only @xmath computational overhead [ 112 , 177 ] . This in
turn allows for the establishment of robust computational complexity
classes within the context of such discrete gate universal quantum
computers.

The universality results in the quantum circuit model show that given
sufficient control over quantum systems there is a robust class of
computations based on the quantum circuit model. Thus sufficient quantum
control implies quantum computation. But what of the validity of the
quantum circuit model as a real description of quantum systems? Quantum
circuits clearly map to quantum systems, but how realistic are the
assumptions that go into the quantum circuit model?

#### 5 The decoherence roadblock

Unfortunately, the description adopted in the quantum circuit model does
not correspond to the real world in a particularly nasty detail. The
quantum circuit model describes a quantum computer as a closed quantum
system. The whole formalism of a quantum circuit assumes that there is a
system which executes the circuit but is completely isolated from the
rest of the universe. In the real world, however, there are no known
mechanisms for truly isolating a quantum system from its environment.
Real quantum systems are open quantum systems. Open quantum systems
couple to their environment and destroy the quantum information in the
system through the process known as decoherence [ 92 ] . When examining
the simple evolution of a single quantum system this system-environment
coupling appears to cause errors on the quantum system’s evolution. The
picture of a quantum circuit where only desired unitary evolution occurs
is thus naive.

Decoherence, then, is a direct attack on the physical viability of
quantum computers in the real world [ 101 , 129 , 190 ] . Because
quantum information is not easily isolated from its environment, physics
dictates that the quantum information will lose many of the properties
that make the information quantum and not classical. In fact, much of
the infamous transition from quantum to classical physics has been
attributed to the role of decoherence in physical systems [ 222 , 223 ,
224 ] . Thus to the question “what makes a computer classical and not
quantum?” the answer “decoherence” follows. While the algorithmic
speedup promised by quantum computers viewed as a closed system is a
profound observation, it is all for naught if this decoherence problem
cannot be overcome.

There is an analogy here with classical computers operating in noisy
environments. For example, conventional computers exposed to hard
radiation of space will not function properly due to the errors caused
on the computer hardware by the radiation. At first glance it would
appear that a classical computer operating in such an environment would
be useless. One mistake in the calculating the trajectory of a satellite
can mean the complete destruction of the satellite! Besides the obvious
practice of making the computer hardware resilient to the radiation,
perhaps surprisingly, there is another method for overcoming this
problem known a “fault-tolerant” computation. Fault-tolerant computation
is intimately related to the idea of error correcting codes. In
classical error correcting codes, information transmitted through a
noisy channel is made more resistant to the noise by making the
information redundant. This basic idea, that redundancy can protect
information, was extend by von Neumann [ 200 ] to provide a method for
performing computations in the presence of noisy environments and
imperfect operations. Thus the question that emerged around 1996 was
does there exists a theory of fault-tolerant quantum computation?

The first step towards solving the decoherence problem was taken in 1995
when Shor [ 174 ] (and independently Steane [ 182 ] ) discovered a
quantum analogue of classical error correcting codes. Shor discovered
that by encoding quantum information, this information could become more
resistant to interaction with its environment. Following this remarkable
discovery a rigorous theory of quantum error correction was developed [
21 , 38 , 37 , 78 , 120 ] . Many different quantum error correcting
codes [ 41 , 94 , 119 , 128 , 132 , 162 , 183 , 185 ] were discovered
and this further led to a theory of fault-tolerant quantum computation [
3 , 96 , 115 , 124 , 161 , 175 ] . Fully fault-tolerant quantum
computation describes methods for dealing with system-environment
coupling as well as dealing with faulty control of the quantum computer.
Of particular significance was the discovery of the threshold theorem
for fault-tolerant quantum computation [ 3 , 95 , 112 , 124 , 161 ] .
The threshold theorem states that if the decoherence interactions are of
a certain form and are weaker than the controlling interactions by a
certain ratio, quantum computation to any desired precision can be
achieved. The threshold theorem for fault-tolerance thus declares a
final solution to the question of whether there are theoretical limits
to the construction of robust quantum computers.

#### 6 Quantum Gemini: decoherence and control

The study of information in a quantum setting is beginning to describe
an amazingly rich computational universe. In this brief introduction we
have learned that quantum algorithms can perform astounding
computational feats. Quantum control can be used to perform these
algorithms, while decoherence can be overcome by this same quantum
control. In spite of these discoveries, the inevitability of quantum
technology remains unclear. Exactly what physical systems will be used
to build a quantum computer? There have been a plethora of proposed
physical systems for quantum computation and a few of these have even
moved from the drawing board to small scale implementation [ 188 , 148 ,
43 , 152 ] . Just as vacuum tubes of the past have been replaced by the
silicon wafers of today, the hardware of future quantum computers,
however, is currently far from certain.

Given the state of ignorance as to the suitability of different physical
systems for quantum computation, it is important to provide theoretical
groundwork towards understanding what does and does not make a good
quantum computer. This implies understanding the delicate dance between
quantum computation’s twin considerations: decoherence and control.

In Greek mythology, Castor and Pollux were twins born to the same mother
but with different fathers. Pollux’s father was a god while the Castor’s
father was a mere mortal. Thus Pollux was immortal while Castor was
mortal. When Castor died on the battlefield his brother was so stricken
with grief that he pleaded with Zeus to either send him to the same fate
or restore his brother to life. Zeus was touched by the brotherly love
and allowed Castor to spend alternating days on Olympus with the gods
and in the mortal world below the Earth, Hades. Due to their exemplary
example of brotherly love the star constellation Gemini was placed in
the heavens by Zeus in honor of these twins.

In this thesis we venture forth towards understanding a modern day
quantum Gemini. Quantum control, our Pollux, is the powerful
near-immortal master of quantum computation. Decoherence, our Castor,
pulls quantum computation down into the mortal real world. Sufficient
quantum control helps pull decoherence away from real world difficulty
and restores the glory of quantum computation. “Define, clarify, and
broaden his brotherly relationship between decoherence and quantum
control”, we thus beseech and in this thesis we explore, “and someday
quantum computers will move from myth to reality!”

#### 7 Thesis outline

This thesis is divided into three main parts. In part I of the thesis we
introduce the basic notions of decoherence, control and universality in
a quantum computer. Chapter I discusses the basic formalism of quantum
operators for describing decoherence and presents a non-standard
derivation of a semigroup master equation through the operator-sum
representation. Chapter I then introduces the notion of control of a
quantum system. Necessary and sufficient conditions for interactions
which can be used for control which does not cause decoherence are
presented. The Lie algebraic structure of control is then discussed
along with the important issue of approximation in quantum control.
Chapter I shifts focus towards universal quantum computation with a
special emphasis on the subsystems nature of universal quantum
computers. The notion of encoded universality is introduced with an
emphasis on the Lie algebraic structure of such encodings. A criteria
for universal quantum computation is derived which is useful for
deciding when even encoding cannot turn a set of interactions into a
universal set of interactions.

In part II of this thesis we turn to the theory of decoherence-free
subspaces and decoherence-free subsystems. We begin in Chapter II by
deriving necessary and sufficient conditions for the existence of
decoherence-free subspaces and their generalization decoherence-free
subsystems. The role of the OSR algebra is stressed as a fundamental
method for understanding both decoherence-free subspaces and
decoherence-free subsystems. The commutant of the OSR algebra is also
identified as an important characterizer of decoherence-free systems.
Decoherence-free subsystem conditions in the master equation are
introduced and the reason why such conditions are currently only
necessary are discussed. Finally the connection between symmetrization
schemes and decoherence-free subsystems is discussed. In Chapter II we
discuss the stability of decoherence-free systems to perturbations. We
show that perturbing interactions do not destroy the decoherence-free
properties. Chapter II discusses many of the issues which generically
arise when using a decoherence-free subsystem for quantum computation.
In Chapter II we introduce an important model of decoherence which
supports decoherence-free subsystems, the collective decoherence model.
Master equations are derived for both collective dephasing and for
collective amplitude damping in order to better illustrate the
conditions under which collective decoherence occurs. The notion of weak
and strong collective decoherence is introduced and the decoherence-free
subsystems for both of these cases is introduced. In Chapter II we
discuss universal quantum computation on the weak and strong collective
decoherence decoherence-free subsystems. The use of only the exchange
interaction for quantum computing is discovered and issues of the
explicit use of collective decoherence decoherence-free subsystems for
quantum computation are discussed. In Chapter II we discuss universal
quantum computation on an experimentally realized decoherence-free
subspace in ion traps. Explicit control sequences are identified for
such computation. Chapter II then discusses how solid state proposals
for quantum computation can be simplified and improved by the use of
encoded universality with the exchange interaction. Finally in Chapter
II we discuss decoherence-free subspaces in atomic systems.

In part III of this thesis we turn to methods for building a quantum
computer which rely on techniques of robustness due to the energetics of
the decoherence process. In Chapter III we describe the effect of
supercoherence where quantum information is protected at low environment
temperatures. A supercoherent system which allows for universal quantum
computation is derived and presented in the context of a solid-state
implementation of a quantum computer. We then present a spin ladder in
Chapter III which has many of the properties of supercoherence as well
as new error correcting properties. In Chapter III this is taken one
step further and a system with a ground state which is a quantum error
correcting is discussed. This is the first example of such a quantum
error correcting ground state which is fully quantum mechanical and
which does not require unreasonable physical resources. Finally in
Chapter III we discuss the possibility of naturally fault-tolerant
quantum computation. Analogies with the classical robustness of
information are discussed and a general framework for future natural
fault-tolerant quantum computation is provided.

### Chapter \thechapter The Pain of Isolating Quantum Information:
Decoherence

  so its quantum computers we want
  with computational power we can flaunt
  well there’s a price which we’ll have to pay
  because quantum coherences rejoice in decay

In this chapter we introduce the basic theory of quantum operations for
studying decoherence. We begin by giving a simple example of how
decoherence can destroy quantum information. We then introduce
decoherence in an abstract formalism known as the operator-sum
representation(OSR). Shortcomings of this formalism are illuminated. We
then discuss the physically motivated approximations of the operator-sum
representation known as master equations. A mystery in decoherence rates
calculated in the operator-sum representations is presented and solved.

#### 8 The degradation of quantum information

Quantum computation would be a matter of the control of quantum systems
(not itself a completely trivial subject) were it not for the fact that
quantum systems are open systems. The degradation of quantum information
due to the coupling of the system containing the quantum information to
the environment is called decoherence ³ ³ 3 An unfortunate state of
nomenclature exists as to the use of the word decoherence. Early
researchers [ 222 , 223 ] used the word decoherence to refer to
operations which destroyed quantum coherences and transferred
information to the environment in a very specific manner. With the
development of quantum computation many authors loosened the use of this
word to refer to any system-environment couplings, not just those which
destroy coherence in a specific basis or involve specific transfer of
information from the system to the environment. In this thesis we will
use the word decoherence to refer to such generic system-environment
couplings. . Let us begin our understanding of the degradation of
quantum information by examining a simple example.

Suppose we are given a system of consisting a single qubit and an
environment consisting of another qubit. The Hilbert space of this
combined system and environment is @xmath . Further suppose that there
is a coupling between the system and the environment given by the
Hamiltonian @xmath where @xmath is a fixed coupling constant.

We wish to encode on the system a qubit of quantum information, @xmath .
If @xmath we could create the state @xmath and the state of the system
would remain @xmath for all times after its creation: the quantum
information would be preserved. If however @xmath , there is a coupling
between the system and the environment given by the evolution operator

  -- -------- -- -----
     @xmath      (1)
  -- -------- -- -----

Suppose that the environment is initially in the state @xmath , so that
initially the state of the system plus environment is @xmath . At a time
@xmath latter, the state of the system plus environment will be

  -- -------- -- -----
     @xmath      (2)
  -- -------- -- -----

where @xmath . The density matrix of the system at time @xmath is given
by

  -- -------- -------- -------- -------- -----
     @xmath   @xmath   @xmath            (3)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -----

Here @xmath represents tracing over the environment. The residual
difference between this density matrix and the initial density matrix is

  -- -------- -- -----
     @xmath      (4)
  -- -------- -- -----

We here see that as time evolves, the off diagonal elements of the
density matrix oscillate in time. We thus say that the “coherence”
between the @xmath and @xmath states is being manipulated. Note that a
time @xmath , where @xmath is an integer, the quantum information in the
system is unaffected, @xmath . System-environment coupling alone is not
enough to degrade the quantum information. In addition to the coupling,
an assumption about the inaccessiblity of the environmental degrees of
freedom must be made in order for decoherence to occur . Suppose, for
example, that at time @xmath the coupling between the system and the
environment is turned off and the state of the environment is made
inaccessible to experiment. At this time the diagonal elements of the
density matrix in the @xmath basis completely vanish. Since the
environmental degrees of freedom are now, by assumption, assumed to be
inaccessible, the quantum information in the system has been degraded.
As described in Appendix E , the trace norm between two density matrices
is a good measure of the absolute distinguishability of the density
matrices. For this example we calculate that

  -- -------- -- -----
     @xmath      (5)
  -- -------- -- -----

The best measurement to distinguish the initial state from the decohered
state at time @xmath will produce measurements probabilities whose
absolute difference will differ by @xmath . If one is thinking about
using this qubit for some sort of computation, then we see that the
computation will err with a probability of at least this value.

This simple example of decoherence serves to illustrate the basic idea
that coupling between the system and environment can lead to degradation
of quantum information.

#### 9 Quantum operations

In this section we describe a basic formalism for understanding open
quantum systems. In particular we seek to understand the evolution of a
system when it is coupled to an environment as seen from the perspective
of the system alone.

##### 9.1 Derivation

Consider the dynamics of a system @xmath together with the rest of the
universe which we will call the environment @xmath . We will assume that
the system @xmath represents full degrees of freedom separate from those
of the environment @xmath . The state space of the system plus
environment then occupies a Hilbert space which is the tensor product of
the system and environment Hilbert spaces, @xmath .

Note that this is not the most general definition of a system–it is
possible that the system we are interested in does not have support over
a full degree of freedom. This is the case, for example, when one is
interested in a limited number of levels of a multi-level atom. In this
situation, probability can “leak” in or out of the system from or to the
rest of the degree of freedom. We will develop our formalism for the
situation where the system is a full degree of freedom but note where
results can be extended to this more general definition of a system.

The evolution of the system @xmath plus environment @xmath (which
together do from a closed system by postulate) is unitary with a
Hamiltonian given by

  -- -------- -- -----
     @xmath      (6)
  -- -------- -- -----

where @xmath acts on the system degrees of freedom @xmath , @xmath acts
on the environmental degrees of freedom and @xmath couples these degrees
of freedom. The evolution of the system and environment is then governed
by the evolution operator @xmath . When the coupling between the system
and the environment is zero, @xmath , the evolution of the system plus
environment are separately unitary @xmath with @xmath and @xmath . From
the perspective of the system alone, the evolution is therefore strictly
unitary independent of the possibly entangled initial state of the
system and environment:

  -- -------- -- -----
     @xmath      (7)
  -- -------- -- -----

If this were not true, it would allow for superluminal manipulation of
distant systems.

When, however, @xmath , the evolution of the system and the bath is more
complicated. Let us first examine the situation when the system and the
bath are initially in a tensor products state @xmath . From the
perspective of the system the evolution is given by

  -- -------- -- -----
     @xmath      (8)
  -- -------- -- -----

The initial state of the environment can be written in terms of its
spectral decomposition @xmath where @xmath is a complete orthogonal
basis for the environment which diagonalizes @xmath , @xmath , and
@xmath . Expanding the trace and using the spectral decomposition of the
environment we find that

  -- -------- -- -----
     @xmath      (9)
  -- -------- -- -----

or

  -- -------- -- ------
     @xmath      (10)
  -- -------- -- ------

where

  -- -------- -- ------
     @xmath      (11)
  -- -------- -- ------

The requirement that @xmath is unitary implies that

  -- -------- -- ------
     @xmath      (12)
  -- -------- -- ------

Eq. ( 10 ) together with the normalization condition Eq. ( 12 ) form the
trace-preserving operator-sum representation (OSR). Notice that the
exact form of the OSR operators depends on the basis @xmath (not the
@xmath basis which is determined by the spectral decomposition). The
evolution does not depend on this basis expansion, but the exact form of
the operators @xmath does depend on this basis choice. We will return to
this freedom

In fact it can be shown [ 126 ] that the most general evolution of a
density matrix, @xmath satisfying the requirements

1.  The map @xmath takes density matrices to density matrices.

2.  The map @xmath is a linear map.

3.  The map @xmath is completely positive. A completely positive map
    takes positive operators to positive operators when acting as
    identity on an auxiliary space @xmath for @xmath , with @xmath the
    identity operator on any addition Hilbert space.

must have the form of the OSR. Every possible OSR has a description in
terms of the action of a unitary operator on a larger Hilbert space.
This allows us to favor the more concrete derivation of the OSR from the
physical perspective of unitary evolution traced over the environment as
opposed to the more axiomatic approach.

##### 9.2 Fixed basis OSR

A tool which we will find useful later in our derivation of master
equations is the fixed basis form of the OSR [ 42 , 10 ] . Suppose we
choose a fixed basis (see Appendix C ) for expanding each of the
operators @xmath in the OSR:

  -- -------- -- ------
     @xmath      (13)
  -- -------- -- ------

The OSR can then be written as

  -- -------- -- ------
     @xmath      (14)
  -- -------- -- ------

where

  -- -------- -- ------
     @xmath      (15)
  -- -------- -- ------

Eq. ( 14 ) is the fixed basis or chi representation of the OSR.
Normalization requires that

  -- -------- -- ------
     @xmath      (16)
  -- -------- -- ------

Taking the trace of this equation we find that

  -- -------- -- ------
     @xmath      (17)
  -- -------- -- ------

The @xmath matrix is a positive hermitian matrix which specifies the OSR
in a given basis.

Separating out the identity components of Eq. ( 14 ) and Eq. ( 16 ) we
obtain

  -- -------- -- ------
     @xmath      (18)
  -- -------- -- ------

and

  -- -------- -- ------
     @xmath      (19)
  -- -------- -- ------

Multiplying the second of these equations by @xmath from both the left
and right, and substituting into the evolution equation, we obtain

  -- -------- -- ------
     @xmath      (20)
  -- -------- -- ------

where

  -- -------- -- ------
     @xmath      (21)
  -- -------- -- ------

This version of the fixed basis OSR will be useful in deriving master
equations. It is also convenient because any positive @xmath matrix
whose trace is @xmath corresponds to an OSR.

##### 9.3 Example OSR

As an example of the OSR consider the process described in Section 8 .
The system-environment evolution operator is given by Eq. ( 1 ) and the
initial density matrix of the environment is @xmath . In the derivation
of the OSR there are two terms,

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (22)
  -- -------- -------- -------- -- ------

Note that @xmath as required by unitarity. The evolution of the initial
density matrix @xmath is thus

  -- -------- -- ------
     @xmath      (23)
  -- -------- -- ------

which agrees with Eq. ( 3 ) derived above.

Suppose that instead of the environment being in the initial state
@xmath it is in the state @xmath . In this case, if we us the basis
@xmath , @xmath to calculate the OSR we find that

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (24)
  -- -------- -------- -------- -- ------

If we instead use the basis @xmath , @xmath to calculate the OSR, we
find that

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (25)
  -- -------- -------- -------- -- ------

There are two interesting facts about this case. First, we see how using
a different basis for calculating the OSR gives different operators but
the same evolution:

  -- -------- -- ------
     @xmath      (26)
  -- -------- -- ------

Second the evolution of the system is unitary, @xmath . Besides
demonstrating the non-uniqueness of the OSR, this example serves to
bring up an interesting question: under what conditions is the evolution
of the OSR correspond to unitary evolution? Since this question presages
future work we will address this question in the next subsection.

##### 9.4 OSR and unitary evolution

The question we pose is under what conditions does

  -- -------- -- ------
     @xmath      (27)
  -- -------- -- ------

where

  -- -------- -- ------
     @xmath      (28)
  -- -------- -- ------

for all . We claim that an iff condition for this to hold is @xmath with
@xmath [ 76 , 135 ] .

The forward implication is trivial. Clearly if @xmath with @xmath then
Eq. ( 27 ) and Eq. ( 28 ) both hold.

To prove the inverse, assume Eq. ( 27 ) and Eq. ( 28 ) both hold. It is
useful to rewrite Eq. ( 27 ) as

  -- -------- -- ------
     @xmath      (29)
  -- -------- -- ------

and then define @xmath so that this becomes

  -- -------- -- ------
     @xmath      (30)
  -- -------- -- ------

Since this equation must hold for all it must hold for a particular
choice of @xmath . This immediately leads to

  -- -------- -- ------
     @xmath      (31)
  -- -------- -- ------

For a given @xmath , the state @xmath can be split into two components
@xmath where @xmath is a vector perpendicular to @xmath . Eq. ( 31 )
then implies

  -- -------- -- ------
     @xmath      (32)
  -- -------- -- ------

The normalization condition Eq. ( 28 ) can be recast as

  -- -------- -- ------
     @xmath      (33)
  -- -------- -- ------

which implies

  -- -------- -- ------
     @xmath      (34)
  -- -------- -- ------

Together with Eq. ( 32 ) this implies that @xmath such that @xmath for
all @xmath . Thus @xmath is an eigenstate of all of the @xmath , @xmath
This must hold for all possible @xmath in the Hilbert space the OSR
operates on and therefore

  -- -------- -- ------
     @xmath      (35)
  -- -------- -- ------

Eq. ( 28 ) then implies @xmath .

##### 9.5 Limits of the OSR

The OSR is fairly satisfying in terms of describing the evolution of a
system coupled to an environment. The initial state of the environment
together with a description of the unitary evolution operator on the
system and environment allows for a description of the evolution of all
possible system density operators in a compact form. The most
troublesome assumption in this derivation is, perhaps, the assumption
that the system and the environment are initially in a tensor product
state @xmath .

Do there exist situations in which interaction between the system and
the environment cannot be expressed in the OSR? Consider the situation
where the system and environment are each single qubits and the initial
joint state is @xmath or @xmath . Suppose the system and environment
then evolve according to the unitary evolution @xmath . In some sense,
the state of the environment is the same in both of these situations:
the density matrices of the environment for both @xmath and @xmath are
both @xmath . Further, the density matrices of the system for both
@xmath and @xmath are also both @xmath . After evolution according to
@xmath , however, the state of the system is different for these two
cases differ

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (36)
  -- -------- -------- -------- -- ------

Thus we see that the same density matrix has evolved into two different
density matrices when the environment’s density matrices was identical.
Thus it is clear that there is no hope in deriving an OSR which depends
solely on the initial density matrix of the environment and the
system-environment unitary evolution. In particular the entangled nature
(see Appendix B for definition) of the system and environment leads to
situations where the OSR fails.

The initial condition of tensor product states for the system and
environment is an assumption that the system and the environment are
initially uncorrelated. Further we have shown how when the system and
the environment start an entangled state an OSR depending only on the
environmental density matrix and the full evolution is impossible. Let
us now show that even when the system and the environment are
classically correlated there are problems in the derivation of the OSR.
Suppose that the initial state of the system plus environment can be
written in the separable form (see Appendix B for definition)

  -- -------- -- ------
     @xmath      (37)
  -- -------- -- ------

with @xmath and @xmath and @xmath , @xmath valid density matrices. The
initial system density matrix is @xmath . Each environmental density
matrix has a spectral decomposition (perhaps over different environment
basis states): @xmath . The evolution of the system is then

  -- -------- -- ------
     @xmath      (38)
  -- -------- -- ------

This can be written in the form

  -- -------- -- ------
     @xmath      (39)
  -- -------- -- ------

where

  -- -------- -- ------
     @xmath      (40)
  -- -------- -- ------

and unitarity requires

  -- -------- -- ------
     @xmath      (41)
  -- -------- -- ------

Unless the basis used for each spectral decomposition of the bath is the
same @xmath and the spectral coefficients are the same @xmath , the
evolution of the system cannot be expressed as in the OSR form Eq. ( 10
).

#### 10 Master equations

While the OSR is a convenient formalism for discussing the coupling
between the system and the bath under appropriate initial conditions, it
is often too cumbersome to be used for calculations on real physical
system. One important reason for this fact is that the environment of
real physical systems are often large complex subsystems whose evolution
is difficult to model. The simplicity of the system is of little help
when dealing with open quantum systems which require an understanding of
environmental degrees of freedom. Despite this difficulty, a
surprisingly large class of decohering dynamics has been adequately
described by physically derived evolution equations.

A closed quantum system evolves according to the Liouville equation of
motion

  -- -------- -- ------
     @xmath      (42)
  -- -------- -- ------

where we have chosen a static Hamiltonian @xmath for simplicity.
Oftentimes it is possible to derive an approximate evolution equation
for an open quantum system which corresponds to an extra term in this
evolution equation:

  -- -------- -- ------
     @xmath      (43)
  -- -------- -- ------

A large class of these approximate evolution equations correspond to
semigroup master equations . If we let @xmath denote the parameterized
map of the initial density matrix to the density matrix at time @xmath ,
we define a semigroup master equation as a map @xmath which satisfies

1.  @xmath is a completely positive linear map continuous in @xmath (see
    Section 9.1 for the definition of complete positivity).

2.  @xmath is Markovian: @xmath .

3.  The initial state of the system and environment are in a tensor
    product state.

Gorini, Kossakowski, and Sudarshan [ 93 ] and Lindblad [ 139 ] have
shown that any map @xmath which satisfies these requirements has an
evolution which is generated by the semigroup master equation (SME)

  -- -------- -- ------
     @xmath      (44)
  -- -------- -- ------

where @xmath are a complete basis for the operators on the Hilbert space
which inhabits and @xmath is a positive hermitian matrix.

##### 10.1 Discrete coarse graining derivation of the SME

We now show that explicit use of a discrete coarse-graining over time
can lead naturally from the OSR evolution equation, Eq. ( 20 ) to the
SME, Eq. ( 44 ) [ 10 ] . A useful form of the fixed basis OSR Eq. ( 20 )
is found by taking the derivative of Eq. ( 20 ) with respect to time

  -- -------- -- ------
     @xmath      (45)
  -- -------- -- ------

The coarse graining of the evolution will be done with respect to a time
@xmath . This time-scale, we will eventually discover, is related to a
environment “memory” time scale. Coarse graining over @xmath corresponds
to

  -- -------- -- ------
     @xmath      (46)
  -- -------- -- ------

Further, rewriting the OSR Eq. ( 20 ) as @xmath and defining @xmath
through @xmath we find that

  -- -------- -- ------
     @xmath      (47)
  -- -------- -- ------

Defining @xmath , with @xmath , we have

  -- -------- -- ------
     @xmath      (48)
  -- -------- -- ------

Next we will make the assumption that on the time scale of the
environment @xmath , the evolution generators @xmath commute in the
“average” sense that @xmath . Physically, we imagine this operation as
arising from the “resetting” of the environment density operator over
the time-scale @xmath . Under this assumption, the evolution of the
system is Markovian when @xmath :

  -- -------- -- ------
     @xmath      (49)
  -- -------- -- ------

Under the discretization of the evolution, this product form of the
evolution implies that

  -- -------- -- ------
     @xmath      (50)
  -- -------- -- ------

In the limit of @xmath we expand this exponential, to find that

  -- -------- -- ------
     @xmath      (51)
  -- -------- -- ------

This equation is simply a discretization of Eq. ( 47 ) under the
assumption that @xmath , where @xmath is the time-scale of change for
the system density matrix. Notice in particular that the RHS of Eq. ( 51
) contains the average value of @xmath over the interval. From the OSR
evolution equation Eq. ( 45 ), we know the explicit form of @xmath over
the first interval from @xmath to @xmath . Discretizing over this
interval we find that

  -- -------- -------- -------- -------- ------
     @xmath   @xmath                     (52)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- ------

where

  -- -------- -- ------
     @xmath      (53)
  -- -------- -- ------

Thus, in the sense of the coarse graining above we have arrived at an
explicit form for @xmath .

Consider the evolution beyond this first interval. Deriving an explicit
form for @xmath and for higher terms is now impossible because Eq. ( 45
) gives the evolution in terms of @xmath . However, since we have made
the assumption that the environment “resets” over the time-scale @xmath
, we expect the environment to interact with the system in the same
manner over every @xmath -length coarse-grained interval. This is
equivalent to assuming that @xmath (which of course is the most trivial
way of satisfying the Markovian evolution condition @xmath ). Then,
using Eq. ( 51 ), one is led to the form of the semigroup equation of
motion,

  -- -------- -- ------
     @xmath      (54)
  -- -------- -- ------

We can write this equation of motion in an alternative form which
distinguishes between the system and environment contributions to the
evolution. Since Eq. ( 45 ) is linear in the @xmath matrix, one can
calculate @xmath for the isolated system and hence define the new terms
which come about from the coupling of the system to the environment:

  -- -------- -- ------
     @xmath      (55)
  -- -------- -- ------

The terms which correspond to the isolated system will therefore produce
a normal @xmath Liouville term in Eq. ( 54 ). Thus Eq. ( 54 ) can be
rewritten as

  -- -- -- ------
           (56)
  -- -- -- ------

which with the identification of @xmath with @xmath is equivalent to
Eq. ( 44 ), except for the presence of the second term derived from
@xmath in the Liouvillian. This second term induces unitary dynamics on
the system, @xmath , is referred to as the Lamb shift . This term
explicitly describes an unitary effect which the environment has on the
system. It is often implicitly assumed to be present in Eq. ( 44 ).

We have shown how coarse-graining the evolution over the environment
time-scale @xmath allows one to understand the connection between the
OSR and the semigroup evolution. The assumptions which went into this
derivation are explicitly

1.  The time-scale for the evolution of the system density matrix is
    much larger than the time-scale for the resetting of the environment
    ( @xmath ).

2.  The evolution of the system should be Markovian ( @xmath )

3.  The environment resets to the same state so that the system
    evolution is the same over every coarse graining ( @xmath ).

4.  The system and the environment start in a tensor product state.

The importance of Eq. ( 45 ) lies in the fact that it allows one to
pinpoint the exact point at which the assumption of Markovian dynamics
are made and further, due to the general likeness of its form to the
SME, provides an easily translatable connection when going from the
non-Markovian OSR to the Markovian SME. Notice also that the assumption
of Markovian dynamics introduces an arrow of time in the evolution of
the system through the ordering of the environmental states: the system
evolves through time in the direction of each successive resetting of
the environment.

A detailed study of this coarse graining procedure on a specific model
has been carried out in [ 136 ] where the authors examine the
application of this procedure to a spin-boson model. Amazingly at low
order in perturbation theory the coarse grain procedure described above
provides an accurate description of the open system dynamics.

The use of Markovian master equations in physics has a long and storied
history. From the early study of phenomenological models [ 28 , 202 ] ,
to more rigorous derivations [ 125 , 52 , 53 , 139 ] , and the
saturation of master equations in the quantum optics community [ 39 ] ,
master equations are a useful tool for modeling the behavior of many
different physical systems. It has even been suggested that instead of
an approximation of the full unitary dynamics, the SME is a fundamental
evolution equation for nature (for a good discussion of this matter, and
why it fails to solve the “measurement problem”, see [ 92 ] ). What we
have provided in this section is a different manner of understanding how
the SME can arise as an approximate evolution of a system. Eq. ( 20 )
and Eq. ( 45 ) provide an path between the exact OSR and the approximate
SME via our specific coarse graining procedure.

##### 10.2 Resolving a mystery in decoherence rates

Decoherence rates

  -- -------- -- ------
     @xmath      (57)
  -- -------- -- ------

(see Appendix F for the motivation behind this definition) can be used
to understand the time scales of a decoherence process. Interestingly,
under the SME, first order decoherence rates ( @xmath ) are finite while
in the OSR these decoherence rates vanish.

One can see the vanishing of the first order decoherence rate in the OSR
by directly substituting in the pre-OSR Hamiltonian dynamics and using
the cyclical nature of the trace operation,

  -- -------- -------- -------- -------- ------
     @xmath   @xmath   @xmath            (58)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- ------

The only possible manner in which this vanishing of this trace could not
occur would be to play some tricks with limits of infinite matrices.

However, in the SME, the first order decoherence rate does not vanish.
Explicitly, in the SME, we find that (in the absence of a system
evolution @xmath ),

  -- -------- -- ------
     @xmath      (59)
  -- -------- -- ------

which in general does not vanish (see for example [ 211 , 219 ] ).

Now lets present a bit (or more precisely a qubit!) of a paradox.
Consider the often quoted example of phase damping of a qubit. In this
case, it would appear that there is a finite first order decoherence
rate. Yet, phase damping of a qubit is often presented within the OSR [
42 , 120 , 153 ] , which, as we have just shown above, would predict
zero first order decoherence rates for any non-singular Hamiltonian. In
this example, the OSR operators are given by [ 42 ]

  -- -------- -- ------
     @xmath      (60)
  -- -------- -- ------

and a simple calculation using these operators yields a minimum first
order decoherence rate of @xmath . How can this be? In particular we
know that every OSR corresponds to some Hamiltonian dynamics on a larger
Hilbert space and we have previously showed that first order decoherence
rates vanish in the OSR. Yet, here is an example of an OSR where the
first order decoherence rate does not vanish!

We can resolve this apparent paradox by examining the coarse graining
procedure used to derive the SME from the OSR.

Using Eq. ( 45 ) the first order decoherence rate in the OSR becomes

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

Using the decomposition of the OSR operators, Eq. ( 11 ), and knowing
that @xmath , we find that @xmath . Thus, since the @xmath ’s form a
linearly independent basis, it follows, using Eq. ( 13 ), that the
expansion coefficients must be

  -- -------- -- ------
     @xmath      (62)
  -- -------- -- ------

where @xmath is dimension of the system Hilbert space. By direct
evaluation,

  -- -------- -- ------
     @xmath      (63)
  -- -------- -- ------

which implies the vanishing (as long as @xmath remains finite) in Eq. (
10.2 ) of every term except @xmath . However, this in turn vanishes by
cyclic permutation of the trace. Thus we see as claimed, that the OSR
first order decoherence rate vanishes.

We can now use our coarse graining derivation of the SME to understand
how first order decoherence rates appear in the SME. Examination of our
derivation of the SME, Eqs. ( 54 ) and ( 56 ), now shows how non-zero
first order decoherence rates can arise when the evolution is considered
to be Markovian. In the derivation of the semigroup equation in the
Markovian limit we made the assumption that the matrices @xmath can be
identified with the constant matrices @xmath of the semigroup equation,
Eq. ( 44 ). However, when this is done, the matrix elements @xmath in
Eq. ( 10.2 ) are replaced by their time-averaged values, for which the
relation Eq.( 63 ) no longer applies. Hence, in general, the first order
decoherence rates are necessarily not zero when the Markovian
coarse-graining is applied. For a finite total Hamiltonian @xmath ,
non-zero first order rates are therefore seen to be an artifact of the
Markovian assumption, and their appearance emphasizes the delicate
nature of the transition to the Markovian regime.

We have seen how the first order decoherence rate can not vanish in the
transition from the OSR to the SME, but we are still left with the
paradox of a first order decoherence rate in the OSR for the phase
damping example. To resolve this dichotomy, we consider how the above
phase damping OSR operators are generated from the unitary dynamics of a
qubit system @xmath and a qubit bath @xmath . The evolution operator

  -- -------- -- ------
     @xmath      (64)
  -- -------- -- ------

(where the first qubit represents the bath ( @xmath ) and the second
represents the system ( @xmath ) as denoted in the columns above) with
the bath initially in the state @xmath , immediately gives the OSR
operators of Eq. ( 60 ). It is easy to calculate the Hamiltonian which
generates this evolution, (using @xmath ):

  -- -------- -- ------
     @xmath      (65)
  -- -------- -- ------

where

  -- -------- -- ------
     @xmath      (66)
  -- -------- -- ------

However, we see that as @xmath , @xmath . Thus, in this simple example,
we find that at @xmath , the Hamiltonian becomes singular. This
illustrates our claim that first order decoherence rates in the OSR are
the result of an infinite Hamiltonian, and do not contradict the general
OSR result of zero rates for finite Hamiltonians.

##### 10.3 Diagonal form of the SME

In the SME, Eq. ( 44 ), we have selected used a specific full basis
@xmath . This choice of basis is, of course, arbitrary. A different
basis, @xmath could have been selected and this new basis will be
related to the old basis via

  -- -------- -- ------
     @xmath      (67)
  -- -------- -- ------

for @xmath . If we require the new basis to maintain the trace inner
product, then

  -- -------- -- ------
     @xmath      (68)
  -- -------- -- ------

Thinking about @xmath as a matrix, this implies that @xmath is a unitary
matrix.

The non-Hamiltonian generator of the SME, Eq. ( 44 ) is defined as

  -- -------- -- ------
     @xmath      (69)
  -- -------- -- ------

The change of basis, Eq. ( 67 ), transforms this generator to

  -- -------- -- ------
     @xmath      (70)
  -- -------- -- ------

This is a new generator for a SME

  -- -------- -- ------
     @xmath      (71)
  -- -------- -- ------

where

  -- -------- -- ------
     @xmath      (72)
  -- -------- -- ------

Since @xmath can be any unitary matrix, and @xmath is a hermitian
matrix, we can choose @xmath such that this matrix diagonalizes @xmath .
In this case, the generator of the SME is given by

  -- -------- -- ------
     @xmath      (73)
  -- -------- -- ------

which we can rescale such that the SME becomes

  -- -------- -- ------
     @xmath      (74)
  -- -------- -- ------

The operators @xmath are called the Lindblad operators after [ 139 ] and
this form of the SME is called the Lindblad diagonal form.

#### 11 Decoherence

In the previous two sections we have developed formalisms for
understanding the coupling of a system to its environment. Along the way
we have encountered assumptions which allowed us to make formal progress
in modeling the decoherence. Much of the justification for the
formalisms of the OSR and SME must come from the empirical evidence in
favor of these descriptions. Barring this justification, one must resort
back to the fully Hamiltonian description of the system plus environment
in order to make progress in understanding a particular decoherence
process. Thus, while the decoherence formalisms of the OSR and SME allow
a nice description of decoherence, there is much to be said for thinking
about decoherence from a purely Hamiltonian system plus environment
viewpoint. In this thesis we will have the chance to work with all three
of these approaches, the OSR, the SME, and the full Hamiltonian
formulation of decoherence.

### Chapter \thechapter Quantum Control

  Two questions:
  1. What does it mean to control the evolution of a quantum system?
  2. Given some control, what can be done?

In this chapter, we introduce the notion of control of a quantum system.
The role of control which does not cause decoherence is emphasized.
Various formalisms are developed to understand when such non-decohering
control is possible. This formalism is then applied to the case of
control of a qubit when coupled via a Jaynes-Cummings Hamiltonian to a
coherent state of the electromagnetic field. Finally, work regarding
what can be done with a given amount of control is reviewed with the
role of the Lie algebraic structure being emphasized.

#### 12 Control and measurement

Suppose one is given a quantum system @xmath and some means of
controlling this system. By a quantum system @xmath , we mean a system
which experiment has showed can produce effects whose description obeys
quantum mechanics or at least some semi-classical quantum principles. In
general, it seems that there are two forms of interactions which an
external system can influence on a quantum system: control and
measurement.

In control one manipulates a controlling apparatus whose state controls
the unitary evolution of the system. In order for this manipulation to
be a valid quantum control , the evolution of the system should not
become entangled with the controlling apparatus. Another way of stating
this is that the act of control should not induce decoherence on the
system .

In contrast to control, in measurement a measuring apparatus interacts
with the system in such a way that the state of the measuring apparatus
becomes entangled or correlated in such a way that the state of the
apparatus provides information about the system.

#### 13 Conditions for control

Let us try to quantify exactly what is meant for a control mechanism to
be a good control mechanism which does not cause decoherence on the
system. We will model the problem in a manner which we think reasonably
captures a large number of experimental methods for classical control of
quantum systems.

Suppose we are given a quantum system @xmath and an apparatus @xmath .
We will assume that there is some constant coupling Hamiltonian between
the system @xmath and the apparatus @xmath , @xmath . There are two
objections to this assumption. The first objection claims that this is
not a good assumption because it is possible to take an apparatus and
remove it across the room such that the apparatus no longer interacts
with the system. The resolution of this objection is two-fold. First of
all it seems to always be possible to model the removal of apparatus
from interaction within the Hamiltonian @xmath and the apparatus
evolution @xmath . The reason for this is our fundamental belief that
quantum mechanics is obeyed by all physical laws. Thus once we have
defined our system, there can only be Hamiltonian coupling to an outside
quantum system. The second reason this objection is not well founded is
the experimental reality that almost all control of quantum systems some
component of the apparatus in contact with the system. Thus, for
example, if one is manipulating the electronic state of an atom with a
laser, the atom is in constant contact with the electromagnetic mode
which will be used for control. The second objection to the model of a
constant @xmath is that it disallows a possibly time dependent @xmath .
Much of what we will derive can easily be extended to the case of a time
dependent Hamiltonian and our assumption of time-independence in this
respect is merely a convenience in order to simplify our discussion. We
thus start from a full system-apparatus evolution Hamiltonian of

  -- -------- -- ------
     @xmath      (75)
  -- -------- -- ------

with the corresponding unitary evolution of @xmath .

##### 13.1 Orthogonal pure state stationary control

  When sufficient is easy, necessary is almost always difficult.

Given the assumption of a constant system-apparatus coupling, let us
examine a simple general model for classical control.

###### Definition 13.1

(Orthogonal pure state stationary control) Suppose we are given an
orthogonal set @xmath of pure states @xmath of the apparatus A.
Orthogonal pure state stationary control is then defined as the
situation where for every input @xmath into the apparatus (defined as
the situation where the density matrix of the system plus apparatus is
@xmath ) the evolution of the system is unitary with some generating
Hamiltonian @xmath and the state of the apparatus is @xmath at all times
during the evolution.

The condition of orthogonal pure state stationary control is therefore

  -- -------- -- ------
     @xmath      (76)
  -- -------- -- ------

where @xmath . The question we now seek to answer is whether there is a
succinct method for determining whether a given Hamiltonian @xmath can
be used to perform orthogonal pure state stationary control?

Let us begin by expressing the system-apparatus evolution as an
expansion over the system tensor apparatus operators. In particular we
will choose a complete hermitian basis @xmath (see Appendix C ) for the
expansion over the system component of Hamiltonian

  -- -------- -- ------
     @xmath      (77)
  -- -------- -- ------

where we have conveniently expanded out the identity component of this
expansion. Hermiticity of the Hamiltonian implies that the @xmath
operators can be chosen to be Hermitian as well. Then, a sufficient
condition for pure state stationary control to hold is

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (78)
  -- -------- -------- -------- -- ------

for all @xmath . We can check that this is sufficient by direct
evaluation

  -- -------- -- ------
     @xmath      
     @xmath      
     @xmath      (79)
  -- -------- -- ------

which we can easily see by using the Taylor expansion of the
exponential, evaluating the apparatus operators and regrouping. Thus if
Eq. ( 78 ) holds then the evolution is that of orthogonal pure state
stationary control with the controlled Hamiltonians @xmath .

Let us now show that Eq. ( 78 ) is also a necessary condition for
orthogonal pure state stationary control. Differentiating the orthogonal
pure state stationary control condition, Eq. ( 76 ), with respect to
time @xmath and evaluating this equation at @xmath we find that

  -- -------- -- ------
     @xmath      (80)
  -- -------- -- ------

Expanding

  -- -------- -- ------
     @xmath      (81)
  -- -------- -- ------

and tracing over the system we find that this implies

  -- -------- -- ------
     @xmath      (82)
  -- -------- -- ------

This must hold for all @xmath . The @xmath , @xmath form a convex set in
the vector space @xmath where @xmath is the dimension of the system
Hilbert space. This convex set contains the origin (which corresponds to
@xmath ) and an open ball of dimension @xmath around the origin [ 225 ]
. This in turn implies that each of the terms in the expansion of Eq. (
82 ) must vanish separately

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (83)
  -- -------- -------- -------- -- ------

This in turn directly implies our claimed condition Eq. ( 78 ) and must
hold for all @xmath

##### 13.2 Commuting mixed state stationary control

In orthogonal pure state stationary control, we assumed that the system
was in one of an orthogonal set of states @xmath . Our choice of the
orthogonal input state @xmath was made in order to satisfy in a nebulous
manner some requirement that our apparatus is a classical control
device. A more satisfying requirement would be to loosen our apparatus
to start in a mixed state. In this case, the more appropriate choice of
classicality is that the different possible controlling mixed states
commute(see [ 15 ] for a good motivation for this choice). Thus we
define:

###### Definition 13.2

(Commuting mixed state stationary control) Suppose we are given a
commuting set @xmath of mixed-states @xmath of the apparatus A.
Commuting mixed state stationary control is then defined as the
situation where for every input @xmath into the apparatus (defined as
the situation where the density matrix of the system plus apparatus is
@xmath ) the evolution of the system is unitary with some generating
Hamiltonian @xmath and the state of the apparatus is @xmath at all times
during the evolution.

The condition of commuting mixed state stationary control is therefore

  -- -------- -- ------
     @xmath      (84)
  -- -------- -- ------

We claim that a necessary and sufficient condition for commuting mixed
state stationary control is

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      (85)
     @xmath   @xmath   @xmath      (86)
  -- -------- -------- -------- -- ------

for all of the commuting @xmath . Note that the orthogonal pure state
stationary control condition is contained within this condition.

We prove this claim via the time honored tradition of using purification
to map this onto the problem we already know how to solve: the
orthogonal pure state stationary control condition.

Let us introduce an auxiliary system @xmath such that the purifications
of the commuting @xmath are orthogonal:

  -- -------- -- ------
     @xmath      (87)
  -- -------- -- ------

where the @xmath are orthogonal. It is always possible to perform such
an orthogonal purification when the @xmath commute (but not possible
always possible when they do not commute). The commuting mixed state
stationary control condition Eq. ( 84 ) then becomes

  -- -------- -- ------
     @xmath      (88)
  -- -------- -- ------

which we can express as

  -- -------- -- ------
     @xmath      (89)
  -- -------- -- ------

where @xmath . A necessary and sufficient condition for this is just the
orthogonal pure state stationary control conditions from above with an
identity tensored onto the operators

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (90)
  -- -------- -------- -------- -- ------

Forming the operators @xmath and @xmath and tracing over @xmath we then
arrive at the claimed necessary and sufficient conditions Eq. ( 85 ) and
Eq. ( 86 ) holding for all of the commuting @xmath .

##### 13.3 Non-stationary control and throwing the switch

Throughout our derivation of the control equations we have required that
the input and the output of apparatus remain the same. Thus the
adjective “stationary” was appended to all of our derivations of
control. In general, it seems likely that a more general condition
allows no entanglement between the system and the apparatus but allows
the state of the apparatus to change. What we are not talking about here
is the situation where the apparatus and the system are entangled at
some midway point and then at some final time the state is no longer
entangled. This latter case is an example of quantum control via a
quantum apparatus because maintenance of the quantum nature of the
apparatus is necessary in order to perform the operation without
decoherence on the system.

One of the potential problems with non-stationary control is the fact
that observation of the apparatus as the state changes can lead to
entanglement of the apparatus with an external observer which then
induces decoherence on the system. Knowing the state of the apparatus
will provides information about how far along a certain evolution on the
system has progressed and when different observations are made at
different times, decoherence can result. It is an interesting open
question, then, to understand non-stationary control of quantum system.

Along similar lines of thought, the model we have presented for control
assumes that there is a manner in which the state of the apparatus can
be rapidly changed between the different controlling states @xmath . The
reason rapid control is needed in this model is that if the state of the
apparatus gets caught in either a superposition or mixture of two
controlling Hamiltonians which produce different evolution this will
cause decoherence from the perspective of the system. Thus the model we
present is one in which the state of the apparatus can be efficiently
manipulated on time scales shorter than the time scale of the controlled
dynamics on the quantum system.

#### 14 Control examples

Here we examine two simple control examples. One of these allows control
while the other does not allow for control. In both examples the systems
@xmath and the apparatus @xmath are single qubits.

The first example is a trivial example where pure state stationary
control is possible. Consider the system-apparatus Hamiltonian

  -- -------- -- ------
     @xmath      (91)
  -- -------- -- ------

The @xmath are a good fixed operator basis for the system Hilbert space,
we therefore find in the fixed-basis expansion Eq. ( 77 ) that

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (92)
  -- -------- -------- -------- -- ------

Clearly the eigenstates of @xmath , @xmath and @xmath , satisfy the
orthogonal pure state stationary control conditions Eq. ( 78 ). In
particular we see that if the apparatus is in the state @xmath , then
the evolution of the system is according to the Hamiltonian @xmath . If,
on the other hand, the apparatus is in the state @xmath , then the
evolution is governed by the Hamiltonian @xmath .

Next we present an example of a system-apparatus Hamiltonian which does
not allow for control. Consider the system-apparatus Hamiltonian

  -- -------- -- ------
     @xmath      (93)
  -- -------- -- ------

Again, using the @xmath as the fixed-basis for the system one finds the
terms in expansion Eq. ( 77 ),

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (94)
  -- -------- -------- -------- -- ------

There are no states which are the eigenstates of all three of these
operators (this would contradict @xmath ). Thus there are no states
which satisfy the orthogonal pure state stationary control conditions
Eq. ( 78 ).

#### 15 Control with coherent states

As a more physically relevant application of the orthogonal pure state
stationary control condition, let us consider the control of a two level
system via coupling to a boson field mode. We assume that the system is
a qubit and the apparatus is a boson field mode with creation and
annihilation operators @xmath and @xmath respectively. We will consider
the evolution of the system and apparatus as dominated by the
post-rotating wave approximation Jaynes-Cumming Hamiltonian exactly at
resonance [ 104 ] ,

  -- -------- -- ------
     @xmath      (95)
  -- -------- -- ------

where @xmath . Using the @xmath as a basis for the system operators, we
obtain the expansion

  -- -------- -- ------
     @xmath      (96)
  -- -------- -- ------

The issue of whether this Hamiltonian can be used for stationary control
is therefore reduced to whether the operators

  -- -------- -------- -------- -- ------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (97)
  -- -------- -------- -------- -- ------

have simultaneous eigenstates. First we will show why these operators do
not have simultaneous eigenstates but then we will show how in a certain
limit these operators can have a approximate simultaneous eigenstates.

Suppose that @xmath and @xmath had a simultaneous eigenstate @xmath with
eigenvalue @xmath and @xmath respectively. Since @xmath and @xmath are
both Hermitian, @xmath and @xmath are both real. The commutator between
@xmath and @xmath is

  -- -------- -- ------
     @xmath      (98)
  -- -------- -- ------

The fact that @xmath is a simultaneous eigenstate of the @xmath and
@xmath operator implies

  -- -------- -- ------
     @xmath      (99)
  -- -------- -- ------

However on the right hand side of Eq. ( 98 ) we find the @xmath . This
is a contradiction and therefore @xmath and @xmath cannot have
simultaneous eigenstates. Thus the Jaynes-Cummings Hamiltonian Eq. ( 95
) cannot be used for orthogonal pure state stationary control.

Let us show, however, despite the fact that the Jaynes-Cummings
Hamiltonian cannot be used for exact control, that with a suitable
approximation the Jaynes-Cummings Hamiltonian can indeed be used for
control.

The coherent state @xmath where @xmath is defined in terms of the number
states @xmath as [ 169 ]

  -- -------- -- -------
     @xmath      (100)
  -- -------- -- -------

and is an eigenstate of the annihilation operator @xmath . If the
bosonic field we are considering is an electromagnetic field, then
lasers produce coherent states with very high fidelity.

We next find that

  -- -------- -- -------
     @xmath      (101)
  -- -------- -- -------

Defining the normalized state

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (102)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

We find that

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (103)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

Now @xmath is nearly @xmath for large @xmath

  -- -------- -- -------
     @xmath      (104)
  -- -------- -- -------

In particular we find that

  -- -------- -- -------
     @xmath      (105)
  -- -------- -- -------

for @xmath . Similarly it can be shown that

  -- -------- -- -------
     @xmath      (106)
  -- -------- -- -------

for @xmath . Thus we have shown that @xmath is nearly an eigenstate of
@xmath and @xmath with eigenvalues @xmath and @xmath respectively.

We have therefore shown that a system interacting with an apparatus
which is in the coherent state @xmath will, to a high degree of
approximation, produce an evolution on the system when @xmath .

#### 16 The unitary control question

We have examined the conditions under which control of a quantum system
is possible. Now suppose that one is given some control over a quantum
system. In this section we address the issue of what can be done given
the ability to exercise some specified control. For discussions in this
section, we assume ideal control conditions (no decoherence, perfect
control of the controlling apparatus and related couplings). In the
section following this one we deal with the issue of approximation
within the issue of control although we will touch on the subject
briefly in this section. Another shortcoming of our discussion is the
fact that we ignore the effect which measurements can have for
controlling a system evolution. Thus what we are really asking is a
question of unitary control.

The most generic manner of posing the question of control is to assume
that a set of unitary evolutions @xmath can be enacted on the system via
some controlling apparatus. Given the ability to perform each of these
evolutions @xmath a sequence of control can then be enacted like

  -- -------- -- -------
     @xmath      (107)
  -- -------- -- -------

We will call such an evolution a control sequence .

##### 16.1 Densely filled group

It might seem obvious that the control sequences form a group, but it
turns out this is not true in an exact sense. The reason for this is
that the control sequences are finitely generated. Let us demonstrate a
trivial example of a control sequence which does not form a group.
Suppose there is only one @xmath which acts on a single qubit as @xmath
for some @xmath . Then the control sequences we can generate are @xmath
for @xmath . In order for @xmath to have an inverse (and hence form a
group) there must exist a @xmath such that @xmath or @xmath . The only
way in which this can be true for a finite @xmath is for @xmath to be a
rational number. Thus the control sequences do not always exactly form a
group.

However it is easy to see that to some degree of approximation, the
control sequences do form a group. Writing a given @xmath in the
diagonal form @xmath we see that for a given @xmath @xmath , @xmath are
reachable by repeated application of @xmath For a given @xmath , either
@xmath for some finite @xmath or @xmath densely fills @xmath and as such
densely fills the neighborhood around @xmath . Thus there always exists
a finite @xmath such that @xmath where the approximation is in the sense
of deviation from each @xmath from @xmath . Thus we see that all control
sequences densely fill a group: every group element can be arbitrarily
accurately approximated by some control sequence.

The question of what can be generated by a control sequence is therefore
generally answered with a group , with the understanding that this
answer hinges on the densely filling structure of the control sequences.

##### 16.2 Hamiltonian control

In most experimental control of a quantum system, instead of being given
a set of @xmath which can be implemented, one usually encounters the
situation where evolution according to some set of Hamiltonians @xmath
can be achieved. We will make the assumption that the achievable control
for such a set of Hamiltonians is given by all evolutions of the form
@xmath . This is an ideal assumption whose validity in the real world is
lacking due to (1) infinite precision in @xmath and (2) inability to
perform extremely fast turning on and off of a Hamiltonian. Problem (1)
is true for any control sequence and is addressed in the next section.
Problem (2), however, also doesn’t pose a huge problem because repeated
application of @xmath for a fixed @xmath can be used to densely fill the
torus of all @xmath . Thus it is a generally good assumption that
control of a quantum system will allow for the implementation of given
@xmath for all real values of @xmath . We call this case of control
Hamiltonian control . In Hamiltonian control, one asks the question what
can be achieved via a Hamiltonian control sequence

  -- -- -- -------
           (108)
  -- -- -- -------

##### 16.3 Lie structure of Hamiltonian control

Lloyd [ 140 ] and Deutsch, Barenco, and Ekert [ 58 ] , building on work
hinted at by DiVincenzo [ 61 ] , were the first to raise and answer the
question of what can be done with Hamiltonian control within the context
of quantum computation. We have seen in the previous section how control
sequences form a group. In the case of Hamiltonian control, the group
which is generated is a Lie group. In particular, the Hamiltonian
control sequences Eq. ( 108 ) generate a continuously parameterized
group with nice smoothness and continuity properties over the
parameterization.

When we refer to the Lie group structure of the Hamiltonian control
sequences, we are just referring to the abstract group multiplication
law between elements of the Hamiltonian control sequences @xmath where
@xmath are the parameters of the group elements @xmath . Our Hamiltonian
control sequences, however, have an explicit representation as unitary
linear operators on a Hilbert space @xmath , @xmath . This explicit
representation is called a unitary representation of the Lie group. A
representation of a Lie group is said to the reducible if it has an
invariant proper subspace, by which we mean that the action of any group
element @xmath on a vector in the subspace remains in the subspace. A
representation which is not reducible is irreducible. All of the Lie
groups generated by Eq. ( 108 ) are completely reducible Lie groups.
This means that the representations we deal with can always be written
as the direct product of irreducible representations (irreps),

  -- -------- -- -------
     @xmath      (109)
  -- -------- -- -------

where each @xmath is an irrep parameterized by @xmath .

Decomposing the action of the Hamiltonian control sequences into
completely reducible form tells us a lot about what can be done with
such sequences. It doesn’t give use direct access to what sort of
computation (something we haven’t even introduced, but the meaning
should be clear) can be performed on the quantum system because we
haven’t defined an input, output relationship on the system. On the
other hand, specifying the completely reducible form of a Lie group
describes exactly the limits of what can be done with a given
Hamiltonian control sequence. The completely reducible form of a given
Hamiltonian control sequence succinctly describes all possible unitary
actions which can be performed on a controlled system.

Lets also point out how just knowing which Lie group one is dealing with
is not enough to pin down what can be done with a given Hamiltonian
control sequence. One needs to also know which dimensional
representation one is dealing with. The easiest example for illustrating
this is to examine the one-dimensional representation of @xmath

  -- -------- -- -------
     @xmath      (110)
  -- -------- -- -------

and compare this to the two-dimensional representation of @xmath ,

  -- -------- -- -------
     @xmath      (111)
  -- -------- -- -------

where @xmath is the vector of the two-dimensional Pauli matrices.
Clearly the action of these two operators are very different. One does
absolutely nothing, while the other manipulates a two-dimensional
quantum system in a non-trivial manner. Thus just knowing what Lie group
one has control over is not enough–information about which irrep is also
needed.

Every Lie group has a corresponding Lie algebra which we can use to good
effect to understand what can be done with a given Hamiltonian control
sequence. Given the ability to enact the Hamiltonians @xmath , every
Hamiltonian which can be generated from these Hamiltonians via the
following two actions can be physically enacted:

1.  Real linear combination of elements: @xmath where @xmath .

2.  Lie commutation of elements: @xmath .

The reason Hamiltonian control sequences with Hamiltonians generated by
this set of operators are reachable follow from the two identities

  -- -------- -- -------
     @xmath      
     @xmath      (112)
  -- -------- -- -------

In fact, we know from the famous theorem of Lie that the reachable
operators are exactly those which can generated via these two processes.
Thus the Lie algebra generated by the @xmath describes the Hamiltonians
which can be enacted by a Hamiltonian control sequence.

Again, just knowing the Lie algebraic structure of the Hamiltonians,
however, does not tell everything about the Lie group generated by the
Hamiltonians. Here there is an even further complication in that
isomorphic Lie algebras may correspond to different Lie groups. Thus the
abstract specification of the Lie algebra is not enough to understand
what can be done with a Hamiltonian control sequence. In spite of this
fact, which just means that we can’t look at the abstract nature of the
Lie algebra and jump to conclusions, if we completely reduce a Lie
algebra this will tell us everything about what can be done with a given
Hamiltonian control sequence.

#### 17 Control and approximation

An important notion in control of quantum systems is how badly executed
operations influence the outcome of a control sequence. Bernstein and
Vazirani [ 25 ] were the first to discuss how a sequence of poorly
approximated quantum operations influence the outcome of a particular
control sequence. We follow the discussion of Nielsen and Chuang [ 153 ]
on the issue of approximating control sequences.

##### 17.1 Approximate unitary evolution

Suppose we start a quantum system in the state @xmath and then execute a
single unitary evolution @xmath on the system and then perform a
measurement with POVM elements @xmath (see Appendix D ). How do the
probabilities of these measurements differ if instead of enacting @xmath
, the evolution operator @xmath was executed? Outcome @xmath occurs with
probability @xmath if @xmath is executed but occurs with probability
@xmath if @xmath is executed. The absolute value of the difference in
these probabilities is

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (113)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where @xmath . Using Cauchy-Schwarz we find that

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (114)
                       @xmath   @xmath   
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where

  -- -------- -- -------
     @xmath      (115)
  -- -------- -- -------

Therefore @xmath gives a quantification of how different a measurement
outcome can be if the two different evolutions @xmath or @xmath are
executed. We will thus call @xmath the error between the evolutions
@xmath and @xmath .

An important class of error which can occur in an evolution occur when
the variation of the controlled Hamiltonian is negligible while there
are problem executing the evolution for a precise time @xmath . In this
case the error is

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (116)
                       @xmath   @xmath   
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

For small @xmath , the error is thus

  -- -------- -- -------
     @xmath      (117)
  -- -------- -- -------

Suppose we are attempting to execute a control sequence @xmath . Due to
inaccuracies, however, the control sequence @xmath was enacted. The
error between these two control sequences is then

  -- -------- -- -------
     @xmath      (118)
  -- -------- -- -------

It turns out that the error caused by such a sequence is at most the sum
of the errors of the individual operations

  -- -------- -- -------
     @xmath      (119)
  -- -------- -- -------

This can be proved via induction. For @xmath , we can use the triangle
inequality to show that

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (120)
                       @xmath   @xmath   
                       @xmath   @xmath   
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

The general case for @xmath then quickly follows from induction.

Thus we have seen how @xmath quantifies the notion of how close two
unitary operators are in terms of difference in measurement outcomes
following the different unitary operators. Further for a sequence of
unitary evolutions, the total error is bounded by the sum of the
individual errors. This latter property will be important when we
discuss the relationship between probabilities and computation.

##### 17.2 Approximate OSR evolution

Is there an equivalent definition of an error distance between two OSR
evolutions @xmath and @xmath ? As above, we can examine the absolute
difference in a POVM outcome measurement probability given the input
state @xmath , but now after the OSR evolutions via OSR operators @xmath
and @xmath ,

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (121)
                       @xmath   @xmath   
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where @xmath . Cauchy-Schwarz then implies

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (122)
  -- -------- -------- -------- -- -------

We can now use the trick of recalling that the OSR comes from unitary
evolution on a larger space. If the environment starts in the state
@xmath and the OSR operators @xmath and @xmath come from the unitary
evolution @xmath and @xmath respectively, we find that

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (123)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where we define the error between the two OSR evolutions @xmath and
@xmath as

  -- -------- -- -------
     @xmath      (124)
  -- -------- -- -------

Thus we see that OSR evolutions have a similar notion of error to those
of unitary evolution.

#### 18 Control

In this chapter we have seen how to define what is and what is not good
control. We have begun to explored what can be done with this control
and understood how approximate control can be given a quantitative
basis. Later in this thesis we will discuss the use of control sequences
for quantum computation. Oftentimes it will be useful to work in the
perfect control arena even though the validity of this assumption is
certainly not realized in experiment.

Consider this state of affairs from the perspective of the status of
classical computers in the 1940’s. At that time it was unclear that
machines could reliably execute computations, and indeed early computers
were prone to breaking down. Even today, hardware errors in computers
can occur but the probability of such errors occurring is extremely
small (due in part to the largess of Avogadro’s number, see Chapter III
). The myth of perfect control for classical computers is a good but
only approximate truth. The question for quantum computation, of course,
is whether it will ever be possible to achieve the low probability of
failure for a given control. Of particular note in this quest is the
demonstration of fault-tolerant quantum computation [ 3 , 96 , 115 , 124
, 161 , 175 ] where, even with imperfect control, nearly perfect control
is achievable without a drastic increase in resources. On the other
hand, there is no good reason to believe that there do not exist systems
which are naturally fault-tolerant (see Chapter III ). The issues of
control we have raised in this chapter then, are the central language
which will motivate our quest for reliable quantum computation.

### Chapter \thechapter Universal Quantum Computation

  “‘Mechanical process’ is supposed to be a metaphor, Alan…”

  –Niel Stephenson, Cryptonomicon [ 186 ]

In the previous two chapters we have seen how to understand the
evolution, both desired (in the form of controllable evolution) and
undesired (in the form of decoherence) of a quantum system. In this
chapter we address the issue of how to put the controllable evolution to
use to perform quantum computation. We begin with a discussion of the
notion of quantum subsystems. The fundamental localizable subsystems of
modern physical theories then allow us to define and make a case for the
quantum circuit model as a valid model of quantum computation. The
notion of a universal gate set is then introduced and two important
lemmas are presented which simplify the identification of universal gate
sets. The most commonly cited universal gate set is then shown to be
universal. In order to put the field of quantum computational complexity
on solid footing, the Kitaev-Solovay theorem is presented and the
connection between discrete and Hamiltonian control is discussed. We
then present an example of a gate set which is not fully universal. This
leads to a discussion of the concept of encoded universality wherein one
uses the fungible nature of quantum information to make a gate set
universal. An example of an encoded universal gate set is presented. An
open question about the relationship of representation theory of Lie
algebras to quantum computation is presented and a discussion of
different dimensional irreducible representations of @xmath is shown to
give a broad leeway into the question of what is a qubit. Finally, the
growth function of a Lie algebra is defined and shown to be a powerful
tool in showing when a gate set is not universal.

#### 19 Quantum subsystems

In our discussion of decoherence we divided the universe up into a
system and an environment. We made the assumption that this division was
such that the Hilbert space factorized as @xmath . This was an
assumption that the universe could be divided up into subsystems : the
system (perhaps a poorly planned nomenclature in hindsight!) and the
environment. Similarly when we discussed decoherence-free control we had
the two subsystems, the system and the apparatus. What dictates the
subsystem structure of quantum systems?

Let us first examine the notion of subsystems from an abstract
mathematical point of view. The simplest concept of a subsystems
structure is the one which we most frequently encounter in nature: full
tensor product subsystems. These are subsystems in which the full
Hilbert space @xmath can be divided up into a tensor product of @xmath
subsystems, @xmath where each @xmath is a Hilbert space corresponding to
a subsystem. Note, however, that this is not the most generic notion of
a subsystem. In particular it is possible that there are subspace tensor
product subsystems. This means that instead of the full tensor product
structure there is a tensor product structure over restricted subspaces
of the Hilbert space @xmath . Here @xmath labels a subspace of the
global Hilbert space @xmath and @xmath labels the @xmath th subsystem
over this subspace. We thus see that the most general notion of a
subsystems is one which act within different subspaces of the global
Hilbert space @xmath . Note that one could take one of the @xmath
Hilbert space and further decompose this Hilbert space into a subsystem
structure. If this is done, however, one can always express this
subsystem structure as in the subspace tensor product structure. Thus
the subspace tensor product structure is the most general subspace
tensor product structure possible.

Of course from a mathematical point of view, we can always view any
global Hilbert space @xmath as having any subsystem structure (full
tensor product or subspace tensor product) we desire. What is needed in
order to make progress in understanding subsystems is to ask how physics
dictates a subsystem structure. In particular, the notion of subsystems
is a empirically derived concept . The basic postulates of quantum
systems do not dictate the subsystem structure of quantum systems.

How, then, does the notion of subsystems arise in quantum systems?
Subsystems arise due to the empirically motivated physical theories
which we paste onto the basic postulates of quantum systems. The
physical theories provide Hamiltonians @xmath which dictate the
evolution of quantum systems and the manner in which these Hamiltonians
act on the system provide the notion of subsystems. Of particular
significance is the realization that currently all empirically verified
fundamental physical theories carry with them the requirement of
locality. The notion of locality establishes a causal structure on the
evolution of quantum systems in spacetime: the Hamiltonians of these
theories establish a subsystem structure corresponding to the idea of
local subsystems. The basic postulate of locality thus leads to physical
theories which contain localizable subsystems.

The fundamental physical theories thus provided a fundamental subsystem
structure on a quantum system. This can be separated from an induced
subsystem structure which takes the fundamental subsystem structure and
builds up subsystems from the fundamental physical subsystems. For
example, the notion of individual atomic systems as a being separate
subsystems is an induced subsystem structure arising from the more
fundamental physical subsystem structure of quantum electrodynamics (and
to a lesser degree the quantum theories of the weak and strong forces).
It is a basic conjecture of modern physics that

###### Conjecture 19.1

All empirical induced subsystems arise from localizable fundamental
subsystems.

Since induced subsystems are derived from fundamental subsystems, we are
therefore motivated to consider fundamental localizable subsystems as
the basic notion of quantum subsystems.

Let us be more concrete in our description of what we mean by
localizable subsystems. In particular we will not address the issue of
what does or does not constitute a localizable subsystem but instead we
will present a model of a localizable subsystem which we claim captures
the notion of locality in most modern theories. Suppose we are given a
@xmath dimensional hypercubic lattice with vertices @xmath and edges
@xmath . We associate with each of the vertices @xmath in this lattice a
subsystem @xmath such that the global Hilbert space factors with a full
tensor product @xmath . Local physical theories produce nonvanishing
Hamiltonians only when the Hamiltonians act as single-body interactions
on individual subsystem ( @xmath on a given vertices @xmath Hilbert
space @xmath tensored with identity on all other subsystems) or between
individual subsystems which are neighbors( @xmath acting nontrivially on
the combined Hilbert space @xmath where @xmath and @xmath are neighbors
on the hypercubic lattice tensored with identity on all other
subsystem). We claim that this model of local subsystems can be used as
the basis for all modern quantum physical theories. Of course in modern
field theory, the subsystem structure is really over a continuum of
subsystems, so what we are really claiming is that the continuum model
of quantum field theory can be well approximated by our basic model.

Further, as we have emphasized, the local subsystem structure of quantum
systems is really an empirical question for physical theories within the
framework of quantum principles. Of special note on this subject is the
collected work of Kitaev, Freedman, and coworkers [ 33 , 86 , 83 , 87 ,
84 , 116 ] who have examined different physical theories of nature in
terms of their local subsystem structure. For instance, these workers
have described how some modern topological field theories can be cast
within a local subsystem structure. The vigilant theorist, therefore,
should take an interest in new theories of nature which do not appear to
provide a local subsystem structure–if these theories turn out to have
an empirical basis and a non-local subsystem structure, the basis of
quantum computation which local subsystems provide may need updating!

We have introduced the notion of subsystems here because our future work
in this thesis will deal with induced subsystems of a nontrivial nature.
A crucial role of a quantum computer will be the ability to simulate the
fundamental local subsystem structure with this induced subsystem
structure. This is the motivation which makes this section fundamentally
important to the understanding of what makes a quantum computer.

#### 20 The quantum circuit model

We will now introduce the quantum circuit model of quantum computation.
This model was first introduced by Deutsch [ 57 ] with more rigorous
theory being presented by Yao [ 208 ] .

We know from the previous section that modern physical theories are well
described by localizable quantum subsystems. We would like to build a
model of quantum computation which, in the spirit of a modern day
Church-Turing thesis, provides a good model for what can be computed
using quantum systems in the real world. For concreteness we will
introduce the qubit quantum circuit model and then describe how this
model fits in with the more general notion of a quantum computer.

The qubit quantum circuit model on @xmath qubits is built of a
collection of @xmath two state systems. Given @xmath qubits, the
subsystem structure of this system is @xmath . We endow the qubits with
a computational basis @xmath and @xmath which are the @xmath eigenstates
of @xmath . The input to the quantum circuit is a basis vector @xmath
where each qubit is in a particular basis state @xmath or @xmath . The
input represents a prepared state upon which the quantum computation
will act. The evolution of the system once the input has been prepared
is then described by a series of local control operators known as local
quantum gates. A quantum gate acting on @xmath qubits is a unitary
@xmath evolution matrix which describes the effect of some evolution on
the prescribed @xmath qubits. We will assume that the quantum gates
whose evolution we can implement are all two or one qubit gates, but we
will allow parallel operation of such gates (see [ 2 ] for our
motivation for allowing parallel operators). We also restrict our
quantum computer to have some realistic localized subsystem structure
and only allow operators which operate nontrivially between local
subsystems. A quantum circuit is then a specification of the gates which
will operate upon the quantum system. Upon execution of the evolution
the qubits are measured in the computational basis and the output will
then be a computational basis output state @xmath . The outcome of the
circuit will, in general, be probabilistic.

The qubit quantum circuit model is clearly a restricted class of a much
larger class which we will label the subsystems quantum circuit model .
In the subsystems quantum circuit model, one is given a system with some
subsystem structure @xmath (if it is not a full tensor product
structure, then we will examine a full tensor product structure over
some subspace of a subspace tensor product). Preparation now corresponds
to preparing an input state which for each of the subsystems. The
quantum gates now correspond to operators on the subsystems and between
local subsystems. Finally, measurement is now a complete projective
measurement on each of the subsystem. In further discussion, we will
refer to the subsystems quantum circuit model as the quantum circuit
model unless needed.

A quantum circuit is a specification of the gates which will perform a
quantum computation on the input which results in an output with some
probability. In this definition, it will turn out (see below) that every
possible manipulation of an input to an output is a quantum circuit. For
a fixed @xmath , then, it is possible to construct every possible
quantum circuit. However, the notion of simply being a quantum circuit
is not enough to capture the notion of an algorithm: algorithms tell us
how to work with inputs of varying length in a uniform manner. In
particular there should be some method for constructing a quantum
circuit corresponding to some algorithm for all possible input sizes.

To resolve this inadequacy of the quantum circuit model we must
introduce the notion of uniform quantum circuit families . A quantum
circuit family is a set of circuits @xmath whose elements are circuits
@xmath indexed by a label @xmath which describes the number of input
bits into the given circuit. Each of these circuits can be augmented by
any number of extra work bits and the output may also have any number of
extra output bits (i.e. possible output greater than @xmath bits). On an
input string @xmath with @xmath qubits, the circuit labeled by @xmath
produces an output @xmath . We require that the circuits in @xmath be
consistent in that @xmath where @xmath and @xmath is an @xmath bit
input. Furthermore we must require that there is some procedure for
constructing the circuit for a given input @xmath . We say that a
circuit family @xmath is uniform is there is a (classical) Turing
machine which, given the input @xmath generates a description of the
circuit @xmath which will act on the input @xmath . We will not delve
into the definition of a classical Turing machine–for our purposes we
can just substitute our intuitive notion of a modern classical computer
(which is a Turing machine (almost: today’s computers do not have
unlimited memory!)).

We have thus seen that the notion of a quantum algorithm can be recast
into the notion of uniform quantum circuit families. The quantum circuit
model itself consisted of three major procedures: preparation, evolution
due to quantum gates, and measurement. The quantum circuit model was
also endowed with a specific subsystem structure and certain localized
limits on the actions which could be performed on this subsystem
structure. In order to make the quantum circuit model correspond to some
notion of an algorithmic task we have had to introduce the notion of
uniform quantum circuit families. The qubit quantum circuit model with
uniform quantum circuit families is a specific realization of what is
meant to carry out an algorithm on a quantum system.

#### 21 Universality

In the previous section we have defined a quantum algorithm as a quantum
circuit family acting on a qubit quantum circuit model. The circuit
family @xmath will contain an algorithm for constructing a given circuit
@xmath for input on @xmath bits. The output of the classical algorithm
describing as specific @xmath for a given input @xmath will contain a
set of instructions @xmath for building the circuit @xmath . In
particular these instructions @xmath will describe what gates should be
implemented, how they should be implemented (between which qubits), and
the order in which the gates should be executed. The execution of a
specific circuit family @xmath requires that certain specific quantum
gates are executed in the fashion described by the instructions @xmath .
Thus it would seem that different circuit families might require
different possible quantum gates. This would be a torrid state of
affairs for quantum computation if every quantum circuit family required
a complete reengineering of the quantum hardware.

We would thus like to ask the question of whether there exist some set
of elementary quantum gates which can be used to build our algorithms
such that once we have access to this set of gates, we can in principle
build up any quantum circuit desired. Actually what we want is a little
less restrictive because, as we discussed in Chapter I , we must deal
with some sort of approximate evolution. We want to ask if there is a
set of gates which we can use to approximate any quantum circuit. An
important note in this definition is that because the quantum circuit
description coming from a classical computer is finite, the set of
quantum gates we will use must also be finite.

Let us therefore begin by making the following definition:

###### Definition 21.1

( @xmath -qubit universal gate set) A set of quantum gates @xmath acting
on a qubit quantum circuit model with @xmath qubits is defined to be a
@xmath -qubit universal gate set if, for any @xmath a sequence of gates
from this set @xmath can be used to approximate any unitary evolution on
all @xmath qubits to accuracy @xmath (if @xmath represents the evolution
due to a sequence of such gates then we require @xmath where @xmath is
defined as in Section 17.1 ).

We can loosen this definition a bit if we allow some finite number of
ancilla qubits to be acted upon:

###### Definition 21.2

( @xmath -qubit universal gate set augmented by @xmath ancilla qubits) A
set of quantum gates @xmath acting on a qubit quantum circuit model with
@xmath qubits is defined to be a @xmath -qubit universal gate set
augmented by @xmath ancilla qubits if, for any @xmath a sequence of
gates from this set @xmath can be used to approximate any unitary
evolution on @xmath qubits to accuracy @xmath .

Further we can extend the notion of a universal set of quantum gates to
the subsystem quantum circuit model via simply substituting subsystem
quantum circuit model for qubit quantum circuit model. We then say that
a set of gates is a @xmath -subsystem universal gate set .

The first to demonstrate a universal set of gates was Deutsch [ 57 ] in
1989. The universal gate set obtained by Deutsch, however, consisted of
operators on three qubits. The three-body interactions necessary to
produce such a gate, however, are extremely difficult if not impossible
to experimentally realize. DiVincenzo was the first to demonstrate a
universal set of gates which required only two-body interactions [ 61 ]
. Perhaps the most widely cited universal gate set consists of the
controlled-not combined with a finitely generated group dense in single
qubit rotations [ 13 ] .

Another important result states that a generic gate together with the
ability to permute qubits is universal [ 58 , 140 ] . Here generic is
the rather limited notion of a gate with no inherit symmetry drawn from
the space of all possible gates. While this result is of great
existential value, as it allows maintains that generically universality
is not hard to achieve, in practice this result has few applications.
The reason for this is that physical interactions tend to have
symmetries in their interactions. Such symmetries confine the given
Hamiltonian to a lower dimensional space than the full space of all
operators on a given space. Nature, in general, does not uphold a
mathematician’s generic.

Below we assemble a list of important universal gate sets.

##### 21.1 The inductive subsystem lemma

Before proceeding, it is useful to introduce the following tools for
universality proofs.

###### Lemma 21.1

[ 4 ] Suppose one is given two sets @xmath and @xmath of operators which
densely act as @xmath and @xmath on two subspaces @xmath (dimension
@xmath ) and @xmath (dimension @xmath ) of a larger Hilbert space @xmath
. If @xmath and @xmath are not disjoint then the set of operators which
can be achieved by combining these operators is @xmath acting on the
union of these Hilbert spaces @xmath (dimension @xmath )

Proof: See [ 4 ] .

Following this lemma, the inductive subsystem lemma follows

###### Lemma 21.2

Suppose one is given a Hilbert space @xmath with a subsystem structure
@xmath , each subsystem @xmath of dimension @xmath . We say that two
subsystems @xmath and @xmath of dimensions @xmath and @xmath are
computationally connected if operators on the combined Hilbert space
@xmath densely generate @xmath . Let @xmath be the graph of
computationally connected subsystems for a given gate set. If this graph
is connected, then the gate set can densely generate @xmath .

Proof: Follows simply from induction using Lemma 21.1 .

##### 21.2 Universal gate set example

As a quick example of a universal gate set, we give here the example of
the controlled-not @xmath plus finitely generated dense single qubit
gates [ 13 ] .

By postulate, this gate set generates any single qubit operation to any
desired accuracy. In particular it generates an approximation to a
single qubit @xmath rotation near identity, @xmath . Sandwiching this
operation in between two controlled not operators, we find that on two
qubits

  -- -------- -- -------
     @xmath      (125)
  -- -------- -- -------

We recall (see Appendix G ) that elements of the single qubit Pauli
normalizer act as an automorphism on the single qubit Pauli operators.
This implies that there are single qubit operators which when conjugated
about @xmath produce the Pauli operators @xmath . Thus our gate set can
produce

  -- -------- -- -------
     @xmath      (126)
  -- -------- -- -------

where @xmath are elements of the single qubit Pauli normalizer. We have
therefore shown that the gate set can produce, to a given accuracy any
infinitesimal generator of the @xmath over two qubits:

  -- -------- -- -------
     @xmath      
     @xmath      
     @xmath      (127)
  -- -------- -- -------

Because we have the infinitesimal generators of @xmath , we can
therefore produce any gate in the @xmath of two qubits: we have shown
how to produce all two qubit unitary gates.

Next we can use Lemma 21.2 . Because we can generate @xmath between
local qubits, we can therefore produce any @xmath on @xmath qubits. Thus
we have shown how the controlled not plus local single qubit gates can
be used to enact any possible quantum circuit.

##### 21.3 The Kitaev-Solovay theorem

We have defined a universal gate set such that any quantum circuit can
be constructed to any desired accuracy from this gate set. Now, suppose
one is given a quantum circuit family. The circuits in this circuit
family will come with descriptions of the quantum gates to be executed
in the quantum algorithm. There are many ways to place the cost on
implementing such a circuit: the breadth of the circuit, the depth of
the circuit, the total number of gates used, etc. The field of quantum
computational complexity [ 24 , 25 , 26 ] seeks to understand how these
resources grow for different quantum algorithms. The cost function which
is perhaps most important is the depth of the circuit. This depth
corresponds in some fashion to the total running time of the circuit. In
view of the universality results for quantum circuits, it would be nice
to know that different universal gate sets do not lead to radically
different assessments of the complexity of different circuits.

That this is ostensibly true is guaranteed by a theorem due to Kitaev [
112 ] and independently Solovay [ 177 , 178 ] .

###### Theorem 21.1

( Solovay-Kitaev) Let @xmath be a finite set of quantum gates which
contains each gate’s inverse and which densely generates @xmath . For
@xmath , there is sequence of gates of length @xmath which is within
@xmath of every element of @xmath (using trace distance, Section 17.1 )
where @xmath where @xmath is some fixed constant which depends on @xmath
.

Proof: See [ 153 ] . It is interesting to note the connections between
this theorem and the study of “geometric group theory” [ 55 ] .

The Solovay-Kitaev theorem indicates that a universal set of quantum
gates can be used to approximate another universal set of gates with
only a polylogarithmic overhead in the depth of the circuit. Consider
two sets of gates @xmath and @xmath . Because each of these gate sets
are universal, every gate in @xmath can be approximated by a sequence of
gates in @xmath and vice versa. The content of the Solovay-Kitaev
theorem tells us the sequence of gates from one set used to approximate
a gate from the other set requires @xmath gates. Thus the depth
difference between circuits constructed with different universal sets of
gates to an accuracy @xmath is only @xmath .

##### 21.4 Discrete versus Hamiltonian control

In Chapter I we introduce the notion of a Hamiltonian control sequence
given a set @xmath of implementable Hamiltonians

  -- -- -- -------
           (128)
  -- -- -- -------

How do Hamiltonian control sequences, which we are most likely to
encounter in real quantum control situations, mesh with the idea of
universal quantum gate sets?

Universal sets of quantum gates are a finite set of gates which can be
implemented with a certain accuracy while Hamiltonian control sequences
are a continuum of gates which can be implemented with a certain
accuracy. In practice, one would take the set of Hamiltonian control
sequences and make these operators a discrete set in order to use the
control sequence as a universal set of gates. There is a simplification,
however, in describing the universality properties of Hamiltonian
control sequences which often makes determining their universality
properties simple. Given a subsystem structure and a Hamiltonian control
sequence, the universality properties follow directly from analysis of
the Lie algebra generated by the control Hamiltonians.

Representation theory of the Lie algebra for a set of control
Hamiltonian @xmath describes exactly what can be done with a Hamiltonian
control sequence. Combined with a description of the accuracy with which
a given Hamiltonian control sequence can be implemented, this
information describes how every element of a Lie group corresponding to
the Lie algebra can be obtain to within some accuracy given a
Hamiltonian control sequence. It is important to realize that just
understanding what can be done with some given control is insufficient
for resolving questions about universality. A mapping from the quantum
system to a subsystems quantum circuit model must also be made. Analysis
of Lie algebra alone does not give a complete understanding of
universality properties.

##### 21.5 Example use of Lie algebraic structure

Suppose we are given a linear array of @xmath qubits where @xmath is
odd. Each individual qubit has an energy @xmath which is always present
and we have no control of the energy spacing @xmath . Between
neighboring qubits there is an interaction @xmath over which we have
complete control. Thus at the set of implementable Hamiltonians we can
achieve is @xmath and @xmath .

Let us describe the Lie algebra achievable with these interactions.
Clearly we can start with @xmath and @xmath as our interactions because
the first is given up to scaling and the second can be obtain via
subtracting this first from @xmath . Taking the commutator yields

  -- -------- -- -------
     @xmath      (129)
  -- -------- -- -------

Taking the commutator of this operation with @xmath or @xmath yields

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (130)
  -- -------- -------- -------- -- -------

Because @xmath is odd, the last of these commutators implies that @xmath
is in the Lie algebra generated by @xmath . At this point it is clear
that the Lie algebra generated by @xmath is the same as the Lie algebra
generated by @xmath .

Suppose we wanted to use these interactions for a quantum circuit model
on all @xmath qubits, i.e. with subsystem structure @xmath . We can show
that this is not possible, i.e. that it is not possible to generate
@xmath with the operators in @xmath .

Consider the elements of the Lie algebra generated by @xmath . All of
these elements will be linear combinations of commutators of the
generators in @xmath . We will now show that the parity, defined as the
eigenvalue of @xmath , cannot be changed by the any element in the Lie
algebra generated by @xmath . First note that all of the elements of
@xmath commute with @xmath . This in turn implies that all commutators
formed from the generators of @xmath commute with @xmath . Thus @xmath
commutes with all elements of the Lie algebra generated by @xmath .
Since @xmath commutes with all of the elements of the Lie algebra
generated by @xmath there are elements of @xmath which are not in this
Lie algebra.

In this example we have shown how a specific control mechanism fails to
be fully universal. It is impossible to use the control of local @xmath
with each qubit having a constant energy to produce every unitary
evolution on @xmath qubits.

#### 22 Encoded universality

##### 22.1 The fungible nature of quantum information

An important property of classical information which carries over to the
quantum regime is the fungible nature of information [ 8 ] . A resource
is fungible if interchanging it with another resource does not destroy
the value of the resource. Whether we represent a classical bit by the
presence or absence of a chad on a punch-card [ 191 ] or in the
orientation of a billion electron spins, the intrinsic value of the
information (the value of the bit) is untouched. Information does not
depend upon the medium in which it is represented. The fungible nature
of information has been key to the exponential growth of the computer
revolution. The fact that it does not matter that the information is
being confined to smaller and smaller components on silicon chips has
been central to the continuing success of Moore’s law [ 149 ] . So, too,
goes quantum information: the plethora of experimentally proposed
systems from which a quantum computer could be built is made possible by
the fungibility of quantum information. Whether we store quantum
information in the electronic levels of an atomic system or in the spin
of a single electron impurity in a solid-state system, the information
is still quantum and can be used for the basis of building a quantum
computer.

One central aspect of the fungible nature of quantum information is that
the information can be encoded in some highly non-trivial manner. Of
course when we represent a qubit in the spin of an electron or in the
hyperfine levels of a ion, we are essentially encoding the qubit into a
given Hilbert space. However, it is important that this notion can be
considerably extended. In particular, given multiple quantum subsystem,
quantum information can be stored in highly entangled states between
these subsystems. The fact that quantum information can be encoded is
essential to the development of the theory of quantum error correcting
codes. By choosing a particular encoding of the quantum information,
quantum error correcting codes provide a method for identifying and
correcting the effect of quantum errors on the code. In part II of this
thesis, we will explore how certain encodings of quantum information can
be used to perfectly isolate the quantum information from particular
forms of decoherence.

The fungible nature of quantum information is a warning sign on the path
towards building a quantum computer. While a gaggle of labs quest to
develop a particular system for quantum computation, the fungible nature
of quantum information tells us that a successful architecture for
quantum computing may look nothing like the currently envisioned system.
Because information can be encoded, it is unclear exactly where we will
store the information that makes up a future quantum computer. An
optimistic viewpoint of the fungible nature of quantum information,
then, tells us that the quest for physical systems which can quantum
compute is far from a closed deal. We will return to this issue in
Chapter III .

##### 22.2 Encoded universality constructions

Encoding of quantum information can also be of use in the construction
of universal gate sets [ 8 ] . There are two complementary ways of
looking at this problem. On the one hand, because quantum information
can be encoded, certain interactions which were not universal over the
entire Hilbert space can be made universal on a particular encoded
space. At the other end of the spectrum, it is common in quantum
computing to develop a particular encoding (for error correction, due to
physical constraints, etc.) and then to ask: what manipulations are
needed to compute on such an encoded space. Of course, these viewpoints
are complementary to each other. In this section, we will discuss the
first of these viewpoints: how encoding can make gate sets universal
over an encoding.

Suppose one is given a gate set @xmath . As we have previously argued,
the universal properties of this gate set is really a question of the
relation of this gate set to representations of Lie groups. In fact the
notion of an irreducible representation directly contains our notion of
encoded universality. Thus the idea of encoded universality is nothing
more than the observation that the power of a set of gates is described
by the irreducible representations and these irreducible representations
may act on some encoded space. We refer to a set of gates which acts on
some encoded subsystem structure in a universal manner as a universal
set of gates on a quantum circuit model with encoded subsystems.

Notice that the notion of encoded universality changes the rules not
only for the manipulation of the quantum information, but also for the
preparation and measurement procedures of a quantum circuit model with
encoded subsystems. Of particular importance here it to note that the
preparation procedure should not be overly inefficient. We will return
to these questions when we address a specific example in Chapter II .

Let us define what is needed in order to present an encoded universality
quantum circuit model which can be used to construct uniform quantum
circuit families:

-   A particular subsystem structure on the Hilbert space must be
    described which maps onto a subsystem structure of an unencoded
    quantum circuit model. This is perhaps the most stringent of the
    requirements for an encoded quantum computer. Without a subsystems
    structure, uniformity cannot be enforced and the very nature of a
    scalable architecture is violated.

-   The ability to prepare the subsystems into a particular initial
    state. Here there is more leeway. It is, even for the standard
    quantum circuit model, never necessary to obtain perfect
    preparation. An important issue for encoded universality
    constructions is the fact that it is possible for quantum
    information to “leak” out of the encoded subsystem.

-   Operations which act in a universal manner on the encoded subsystem
    structure.

-   The ability to extract information from the encoded subsystems.
    Again, perfect measurement is not necessary. The ability to extract
    even a little bit of information is often sufficient for quantum
    computation.

A particularly interesting class of encoded universality constructions
are what we will term few subsystems encoded universality. While in
practice, given a gate set, @xmath one can analyze the action of this
gate set on ever larger numbers of qubits, the uniformity condition of
the quantum circuit model puts a condition on the encoding such that
there should be a some map onto a subsystem structure which grows
proportional to the number of qubits added. Thus the typical manner in
which encoded universality will be used is to take a constant number of
subsystems and the encode a basic subsystem into this constant number of
subsystems. For example one may find that taking triads of qubits allows
for an encoded qubit which can be robustly manipulated (prepared,
measured, unitarily controlled). Then one proceeds to take the encoded
subsystems, map it onto a quantum subsystem circuit model and
(hopefully) show universality on this encoded subsystem structure.

##### 22.3 Few subsystems encoded universality example

Suppose one is given a spin chain of @xmath qubits with interactions as
shown in Figure 3 below. In particular assume that the Hamiltonians
which can be enacted on this spin chain come from the set

  -- -------- -- -------
     @xmath      (131)
  -- -------- -- -------

To see that full universality on all @xmath qubits (the ability to
implement @xmath on the system) is not possible, note that @xmath
commutes with all of the elements of @xmath and thus, via the same
argument of Section 21.5 , the Lie algebra generated by these
Hamiltonians is not the full @xmath .

Let us examine the action of the Hamiltonians listed above on pairs of
qubits. Notice that these have the following Lie algebraic structure

  -- -------- -- -------
     @xmath      
     @xmath      
     @xmath      (132)
  -- -------- -- -------

The first of these commutation relations indicates an @xmath structure
for these operators and the final three commutation relations indicate
that @xmath is an abelian subalgebra over these two qubits. In
particular we note that over the subspace with basis states @xmath and
@xmath (for the @xmath and @xmath th qubit), the operators @xmath act as
@xmath on this encoded space, while @xmath acts as identity on this
subspace. Thus we can use these operators to enact @xmath on the encoded
subspace spanned by the logical qubits @xmath and @xmath . Also note
that the subspace @xmath and @xmath is not acted upon by these operators
in a non-commuting manner and hence over these operators cannot be used
as a qubit.

Having shown that there is an encoding over two qubits for which the
operators in @xmath act as @xmath , we then hope to extend this encoding
to a full quantum circuit model. In particular we take our encoded
qubits (the subsystems) to be two physical qubits with the encoding of
@xmath and @xmath . We have already shown that any single qubit
operation is possible on this encoded space and thus it is sufficient to
show that we can implement a non-trivial two body encoded operation
between the qubits in order to produce a encoded universal quantum
circuit. If we take the encoding between the @xmath st and @xmath nd,
@xmath rd and @xmath th, etc. qubits then the operation @xmath with
@xmath provides this coupling. In particular note that

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (133)
  -- -------- -------- -------- -- -------

Thus we see that this operation acts like an encoded @xmath between
encoded qubits. When this operation is enacted as a Hamiltonian ,
combined with single encoded qubit operators this allows for universal
control of the encoded qubits.

In this example we have seen how pairing the qubits together we can
obtain an encoding such that there is a mapping from encoded two-qubit
states to encoded qubits and universal quantum computation can be
obtained on this encoding.

#### 23 What to do with the strange irreducible representations

In constructing encoded universal gate sets from Hamiltonian control
sequences, one can perform an analysis of the Lie algebra structure
Hamiltonians to get a hold of how these Hamiltonians can be used for
encoded universality. Luckily the analysis of the Lie algebras we will
deal with on a quantum computer have long ago been identified and
classified! We will not deal with this issue here but instead refer the
reader to the standard texts of Cornwell [ 50 ] and Georgi [ 91 ] .

However, we would like to bring up two points related to representation
theory of Lie algebras which are important but have not received
extensive discussion in the quantum computing literature.

##### 23.1 What to do with Lie Algebra X?

All of the universality constructions to date have shown how a suitable
@xmath can be executed on a given circuit model. But there is more under
the sun than the Lie group @xmath ! In particular there are other Lie
groups with differing Lie algebras which, in theory, can arise or be
simulated on a quantum system. An interesting open question is if these
Lie algebras have anything to do with quantum computing.

###### Open Question 23.1

Do Lie algebras other than @xmath play any role in the realm of quantum
computing?

An important point in this discussion is that there are only four
infinite families of Lie algebras in the classification scheme ( @xmath
, @xmath , @xmath , and @xmath in the standard notation.) These would
appear to be the Lie algebras which are most likely to support some sort
of computation because they satisfy the requirement of allowing for the
notion of the power of the computer growing with the number of
subsystems added.

##### 23.2 What is a qubit?

The notion of encoded universality also raises some particularly
interesting questions. One particular issue which has been raised in the
literature is the notion of “what is a qubit?” Viola, Knill, and
Laflamme [ 193 ] present models of qubits encoded into different spaces.
These authors rightly take an operational view of a qubit. A qubit is
defined by how one can access the information in the qubit: both in
control and in measurement of the qubit. Unfortunately the authors only
present qubits where they have operators which act on the qubits which
satisfy both the commutation and anti-commutation relations of the
standard Pauli matrices:

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (134)
  -- -------- -------- -------- -- -------

This, however, is a limited notion of a qubit from the point of view of
the representation theory of quantum information. To see this, consider
three different irreps of @xmath : i.e. the Lie algebra which satisfies
the commutation relations above, but not necessarily the
anti-commutation relations. The first representation is the
one-dimensional irreducible representation. In this representation, the
@xmath operators all act as @xmath

  -- -------- -- -------
     @xmath      (135)
  -- -------- -- -------

The second representation is the two-dimensional irreducible
representation:

  -- -- -- -------
           (136)
  -- -- -- -------

Finally we examine the three-dimensional irreducible representation

  -- -- -- -------
           (137)
  -- -- -- -------

Clearly the one-dimensional irrep of @xmath is useless. This irrep can,
in no manner, be considered a qubit. And, of course, the two-dimensional
irrep of @xmath is what we normally think of as a qubit. But what about
the three-dimensional irrep? Let us show that any manipulation of the
two-dimensional irrep can be mimicked by the three-dimensional irrep.
Let @xmath , @xmath , and @xmath denote the vectors upon which the
three-dimension irrep acts and @xmath , @xmath denote the vectors upon
with the two-dimensional irrep acts.

In the two-dimensional irrep, a state of the system can be written as

  -- -------- -- -------
     @xmath      (138)
  -- -------- -- -------

Let us map the state of the two-dimensional irrep described by @xmath to
the three-dimensional state

  -- -------- -- -------
     @xmath      (139)
  -- -------- -- -------

Notice that a pure state in the two-dimensional irrep is not mapped onto
a pure state in the three-dimensional irrep.

An observable on the two-dimensional irrep is given by

  -- -------- -- -------
     @xmath      (140)
  -- -------- -- -------

The expectation of this observable is

  -- -------- -- -------
     @xmath      (141)
  -- -------- -- -------

For the three dimensional irrep we can define the equivalent observable

  -- -------- -- -------
     @xmath      (142)
  -- -------- -- -------

such that the expectation value of this observable is identical

  -- -------- -- -------
     @xmath      (143)
  -- -------- -- -------

Finally note that evolution on the two-dimensional irrep

  -- -------- -- -------
     @xmath      (144)
  -- -------- -- -------

can be directly mapped onto evolution of the three-dimensional irrep

  -- -------- -- -------
     @xmath      (145)
  -- -------- -- -------

such that the evolution of the density matrix has the same effect

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (146)
  -- -------- -------- -------- -- -------

Thus we have seen that there is a mapping between density matrices,
observables, and evolutions of the two and three-dimensional irreps
which perfectly preserves the structure of a qubit. In general @xmath
dimensional irreps of @xmath can be used in a similar manner to
construct a valid qubit. A qubit is more than just the two-dimensional
irreducible representations of @xmath !

#### 24 Subsystem growth of a Lie algebra and quantum computation

As important as the question of when a given Hamiltonian control
sequence has universal control is the negative of this question. Here we
present a useful criteria for detecting Lie algebras which are not
universal.

Suppose one is given a set of Hamiltonians @xmath which can be
implemented in a Hamiltonian control sequence on @xmath subsystems. Let
@xmath denote the Lie algebra which can be generated by @xmath and let
@xmath denote the number of linearly independent operators in @xmath .
We call @xmath the subsystems growth function.

###### Theorem 24.1

A growth function @xmath which is polynomial in @xmath is not universal
on a quantum circuit model.

Proof: The basic idea behind this theorem is to note that a quantum
circuit model on @xmath subsystems has a state space which grows
exponentially in @xmath and therefore performing unitary operators on
this space is equivalent to generating elements of an exponentially
growing Lie algebra.

Return now to the example presented in Section 21.5 where we examined
the power of Hamiltonian control sequences generated by Hamiltonians in
the set

  -- -------- -- -------
     @xmath      (147)
  -- -------- -- -------

We will now show that, even with the help of encoding, this set of
Hamiltonians is not universal.

Define the operation @xmath where @xmath and @xmath . We claim that the
operators in the Lie algebra generated by @xmath are all linear
combinations of the form @xmath plus the single qubit @xmath . Notice
that this is true for @xmath . We will prove the result by induction.
First we note that because our generators are made up of Pauli
operators, we need not worry about linear combinations of operators, but
only need to worry about the operators which can be generated by
commutation. Let @xmath denote the Lie algebra on @xmath qubits
generated by taking commutators in @xmath . For example @xmath as
claimed above. Assume that @xmath . First notice that taking commutators
of elements of @xmath and @xmath only produces elements in @xmath : the
only elements which @xmath do not commute with are @xmath and @xmath and
this commutation only serves to flip the value of @xmath or @xmath .
Finally, note that taking the commutator between elements of @xmath and
@xmath can only generate elements in @xmath . To see this, first note
that the only nontrivial commutators are those which occur with the
@xmath operators, which just produce elements in @xmath . Further
commutators between @xmath and @xmath only create @xmath which are one
qubit larger or smaller. Thus we have proved that the Lie algebra
generated by elements of @xmath are spanned by the set of linearly
independent operators in @xmath .

Let us count the operators in @xmath . There are @xmath @xmath operators
and @xmath @xmath operators. Thus the growth function for this Lie
algebra is @xmath . This growth function is polynomial in @xmath and
thus via Theorem 24.1 this set of operator is not universal.

#### 25 Universal quantum computation

Universality is one of the most powerful concepts to arise from the
theoretical study of computer science. In this chapter we have dealt
with the ideal conditions needed for universal quantum computation. This
ideal model presents an abstract connection to the question of exactly
what is a quantum computer. Real world realization of a universal
quantum computer, however, must deal with decoherence, faulty
operations, faulty preparation, and faulty measurements. Luckily the
theory of fault-tolerant quantum computation has been developed which
deals directly with these issues [ 3 , 96 , 115 , 124 , 161 , 175 ] and
a theorem which basically states that if these problems are not too
severe, the ideal model can nearly ideally be obtained [ 3 , 95 , 112 ,
124 , 161 ] .

If Alan Turing were to return from the dead and see the modern classical
computer, he would surely be shocked by the technological progress
achieved in the past fifty years. However, if one explained to Turing
how the modern computer works, he would surely recognize the manner in
which the modern computer attains universal computation (no slouch, that
Turing: he could work in a base-32 notation that others had to convert
to decimal to understand!) One of the main motivations for studying the
theory of universal quantum computation is simply the realization that
we do not know exactly what a future quantum computer will look like,
but we have some notion of what is required in order to obtain
universality. The unknowable future, then, has already given way to
novel proposals for quantum computation, and, in the end, may present
the ultimate road towards building a quantum computer.

## Part II Decoherence-Free Quantum Computation

### Chapter \thechapter Decoherence-Free Conditions

  wherein the demons of decoherence are first shown the door
  and the door is described by necessary and sufficient conditions

In this chapter we introduce the basic conditions for decoherence-free
subspaces and decoherence-free subsystems. We begin with a simple
classical example of a subsystem which withstands a classical error
process. The fundamental algebraic theorem of decoherence is then
derived and the concept of the OSR algebra is defined. Decoherence-free
subspaces are then introduced and an iff condition for such subspaces is
derived. A simple example of a decoherence-free subspace is presented
and how to handle system specific evolution is discussed.
Decoherence-free subsystems are then defined and with the help of a
basic theorem of the representation theory of complex associative @xmath
-closed algebras and an iff condition for such subsystems is derived. An
example of a decoherence-free subsystem is examined and the role of the
a nontrivial commutant is introduced. Finally decoherence-free
conditions for master equations are presented.

#### 26 Protecting information by encoding

Two parties, Alice and Bob, wish to communicate an important message. At
their disposal is a classical communication channel. Alice and Bob can
send two classical bits at a time down this channel. Unfortunately this
classical channel has a devilish manner of distorting the information
sent down the channel. When the parties send their two bits down the
channel, there is a noise process in the channel which will flip the
value of both bits. Thus if Alice sends @xmath down the line, Bob will
either receive the undisturbed @xmath or the flipped @xmath . If Alice
sends @xmath through the channel, Bob will either receive the
undisturbed @xmath or the flipped @xmath . Clearly, if Alice and Bob
wish to communicate using the full capacity of the classical channel
(meaning each using both bits of the classical channel) they will fail.

Let @xmath denote the classical bits sent down two bit channel. All of
the information which is in the pair @xmath is also in the pair @xmath
where @xmath is the exclusive-or of the two bits ( @xmath ). To see
this, simply note that this is a map which is one-to-one: @xmath ,
@xmath , @xmath , @xmath . The pair @xmath is a particular encoding of
the classical information. What is interesting to Alice and Bob about
this encoding is that the first bit @xmath is unchanged by the error
process of the channel. If the channel does not act on the bits, then of
course nothing happens to @xmath . If the channel flips both of the
bits, then @xmath where @xmath indicates the negation operation and we
have used the fact that the exclusive-or of two negated bits is the same
as the exclusive-or of the unnegated bits. On the other hand the second
bit in the encoding @xmath is unprotected from the action of the
channel.

Alice and Bob can thus use this noisy channel to communicate with
perfect fidelity by using the encoding @xmath . If Alice wants to send
an encoded bit down the channel, she encodes her bit into the parity of
the two bits (choosing either of the two possible @xmath for a given
choice of parity) and sends these two bits to Bob. The channel cannot
change the parity of the two bits and thus Bob can decode the bit which
Alice encoded by examining the parity of two bits he receives.

There are two morals from this simple example. The first moral is that
information can be protected from disturbance via an appropriate
encoding. The second moral comes from the observation that the reason an
appropriate encoding exists which perfectly protects the information is
due to a symmetry of the noise process. In particular the errors which
the channel induce on the two bits are identical on each individual bit.
This is the symmetry of the error process which allows for encoding into
parity which perfectly preserves the information.

The above example demonstrates how classical information can be
perfectly protected from noise via an appropriate encoding of the
information. In this part of the thesis we will be examining similar
constructions, but now in the context of quantum information.

#### 27 The OSR Algebra

Consider the evolution of a system @xmath and an environment @xmath with
joint Hilbert space @xmath which evolves according to some Hamiltonian
@xmath . Consider the expansion of the Hamiltonian into system and
environment operators

  -- -------- -- -------
     @xmath      (148)
  -- -------- -- -------

where @xmath ( @xmath ) acts on @xmath ( @xmath ). The expansion we give
above is, of course, always possible. The expansion, on the other hand
is not unique. We will place the requirement on this expansion that the
@xmath are a complete fixed basis which are linearly independent,
hermitian and have an inner product @xmath . Such a basis can always be
chosen over the environment Hilbert space (see Appendix C ). We will
often refer to the @xmath as the system operators and the @xmath as the
environment operators .

Let us recall that evolution of the system plus environment which
initially starts in a tensor product state @xmath is given by the OSR
evolution

  -- -------- -- -------
     @xmath      (149)
  -- -------- -- -------

We now claim that a basis for the OSR operators @xmath corresponding to
the Hamiltonian @xmath in Eq. ( 148 ) is given by the complex
associative algebra @xmath generated by the @xmath plus the identity
operator @xmath .

###### Definition 27.1

(Complex associative algebra) [ 122 , 131 ] The complex associative
algebra @xmath generated by the set of operators @xmath is the set of
operators which can be constructed from the operators @xmath via the
processes of linear combination over @xmath and simple operator
multiplication.

We claim that

###### Lemma 27.1

[ 122 ] Consider the evolution of a system plus environment due to a
Hamiltonian @xmath with expansion Eq. ( 148 ). The OSR operators @xmath
corresponding to evolution due to @xmath are elements of the complex
associative algebra @xmath generated by the @xmath in Eq. ( 148 ) plus
identity @xmath .

Proof: The Taylor expansion of the full system-environment evolution
operator is given by

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (150)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

A fixed basis form over the environment of the evolution operator can be
obtained by expanding

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (151)
  -- -------- -------- -------- -- -------

such that

  -- -------- -- -------
     @xmath      (152)
  -- -------- -- -------

Using the definition of the OSR operators, Eq. ( 11 ) we find that for
an initial evolution of @xmath

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (153)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where @xmath . Thus we see that each OSR operator @xmath is a complex
linear combination of products of the @xmath ’s plus identity @xmath for
@xmath . Thus the @xmath are elements of the complex associative algebra
@xmath generated by the @xmath plus identity @xmath as claimed.

Suppose we are given a complex associative algebra @xmath generated by
the elements @xmath plus identity @xmath . Let @xmath denote a complete
basis for the operators in this algebra which has an identical span as
the elements of @xmath . Then we can expand the elements of @xmath as

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (154)
  -- -------- -------- -------- -- -------

Expanding Eq. ( 153 ) in terms of @xmath ,

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (155)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where

  -- -------- -- -------
     @xmath      (156)
  -- -------- -- -------

For general initial environment initial conditions, we can use this
expression to show that there are evolutions such that @xmath is
non-vanishing for some time @xmath . Consider the @xmath th derivative
of @xmath with respect to time evaluated at @xmath ,

  -- -------- -- -------
     @xmath      (157)
  -- -------- -- -------

For general environmental initial conditions, we can choose an initial
environmental condition and basis @xmath such that @xmath for any @xmath
. Further, @xmath for at least one @xmath for any @xmath . Finally,
because the @xmath have an identical span to the complex associative
algebra generated by the @xmath plus identity @xmath , there must exist
a @xmath and @xmath such that @xmath . Thus we have shown that @xmath
for some @xmath for every @xmath .

Together with Lemma 27.1 this implies an extremely important theorem in
the study of decoherence. Let us first define the OSR algebra

###### Definition 27.2

(OSR algebra) The OSR algebra is the complex associative algebra
generated by (i) the @xmath operators in the expansion of a
system-environment Hamiltonian @xmath where the @xmath are linearly
independent operators and (ii) the identity @xmath .

###### Theorem 27.1

(Fundamental algebraic theorem of decoherence) [ 122 ] Suppose a system
and environment evolve according to the Hamiltonian @xmath where the
@xmath are linearly independent. The OSR evolution operators @xmath are
in the OSR algebra and the span of the @xmath for generic environment
initial conditions is identical to the OSR algebra.

The significance of this theorem is that it reduces the study of system
evolution with generic environment initial conditions to the study of
the algebraic structure of the corresponding OSR algebra. Thus if one
wishes to understand the effects and OSR operator can have, it is enough
to examine the span of the system operators of a system-environment
expansion of the Hamiltonian. It provides an iff connection between the
OSR operators and the OSR algebra under generic environmental initial
conditions.

#### 28 Decoherence-free subspaces

In the example from the first section of this chapter we saw that
information could be protected from an environment via a suitable
encoding of the information. In this section we present the first
discovered and simplest condition under which similar protection can be
endowed to a quantum system.

Consider a system @xmath with Hilbert space @xmath which evolves
according to some joint Hamiltonian @xmath with linearly independent
environment operators @xmath . Corresponding to this evolution and given
an environmental initial condition there are a set of OSR operators
@xmath for the evolution of the system. We say that a system density
matrix @xmath is invariant under the OSR operators @xmath if

  -- -------- -- -------
     @xmath      (158)
  -- -------- -- -------

Clearly an invariant density matrix does not evolve even though the
system and environment may have some non-trivial coupling.

###### Definition 28.1

(Decoherence-free subspace) A subspace @xmath of a system’s Hilbert
space @xmath is called a decoherence-free subspace (DFS) with respect to
a system-environment coupling if every pure state from this subspace is
invariant under the corresponding OSR evolution for any possible
environment initial condition:

  -- -------- -- -------
     @xmath      (159)
  -- -------- -- -------

A decoherence-free subspace is a perfect quantum memory. The fungible
nature of quantum information tells us that quantum information encoded
into a subspace has the same fundamental value as any other
representation of quantum information. Thus while the fundamental value
of the quantum information is unchanged by encoding into a DFS, an
important property of the way in which this information interacts with
its environment is changed by encoding into a DFS.

While we have defined a DFS in terms of invariant pure states, mixed
states fall nicely within the protection of a DFS as well. In particular
a mixed state which has support only over a the pure states of a DFS
will be also be invariant and hence protected from decoherence.

##### 28.1 Decoherence-free subspace condition

Let us describe a necessary and sufficient condition for the existence
of a DFS given a specific system-environment coupling as in Eq. ( 148 ).

###### Theorem 28.1

(Decoherence-free subspace Hamiltonian criteria) [ 216 ] A subspace
@xmath is a DFS iff the system operators @xmath act proportional to
identity on the subspace:

  -- -- -- -------
           (160)
  -- -- -- -------

Proof: First we prove sufficiency. Suppose @xmath . Due to the
fundamental algebraic theorem of decoherence, all OSR operators are
elements of the complex associative algebra generated by @xmath . Thus

  -- -------- -- -------
     @xmath      (161)
  -- -------- -- -------

where @xmath is some complex constant which is a complex combination of
the @xmath ’s. Therefore

  -- -------- -- -------
     @xmath      (162)
  -- -------- -- -------

The normalization condition @xmath implies @xmath . Thus if @xmath for
all @xmath in a subspace @xmath , the @xmath is a DFS. Next we prove
necessity. For every @xmath acting on a state @xmath , we can separate
the resulting state into a component which is along @xmath and a
component which is perpendicular to @xmath , @xmath which depends on
@xmath :

  -- -------- -- -------
     @xmath      (163)
  -- -------- -- -------

The invariant condition on @xmath , Eq. ( 158 )

  -- -------- -- -------
     @xmath      (164)
  -- -------- -- -------

or

  -- -------- -- -------
     @xmath      (165)
  -- -------- -- -------

The OSR normalization condition @xmath implies

  -- -------- -- -------
     @xmath      (166)
  -- -------- -- -------

Thus @xmath which implies @xmath for all @xmath and @xmath . Thus we see
that @xmath . We can now invoke the fundamental algebraic theorem of
decoherence. The span of the @xmath for generic environmental initial
conditions is identical to the complex associative algebra generated by
the @xmath . Thus @xmath implies @xmath .

We have seen how the condition Eq. ( 160 ) is an iff condition for the
existence of a DFS. Stated succinctly, a DFS is the degenerate common
eigenspace of the @xmath system operators. Perhaps the most important
aspect of the DFS criteria is to notice how degeneracy is essential to
the definition. A system-environment coupling which is degenerate cannot
distinguish between the degenerate states.

##### 28.2 Example decoherence-free subspace

Let us examine a particularly simple example of decoherence-free
subspace. Suppose two qubits are coupled to a harmonic oscillator
environment via the Hamiltonian

  -- -------- -- -------
     @xmath      (167)
  -- -------- -- -------

where @xmath ( @xmath ) is the destruction (creation) operator for the
harmonic oscillator. The OSR algebra is then the complex associative
algebra generated by the operators @xmath and @xmath . The second of
these operators has eigenstates @xmath , @xmath , @xmath , @xmath with
eigenvalues @xmath , @xmath , @xmath , and @xmath respectively. Thus
there is a subspaces spanned by @xmath and @xmath which satisfies the
DFS condition Eq. ( 160 ). We can now directly see how superpositions of
these two basis states do not decohere

  -- -------- -- -------
     @xmath      (168)
  -- -------- -- -------

because @xmath annihilates each basis state @xmath and @xmath . In
general the Hamiltonian operator will not annihilate the states, but
will act as a constant on the states. This implies that a global phase
to the subspace will be applied. However a global phase does not cause
decoherence on the system.

##### 28.3 System Hamiltonian and the DFS

We have defined a decoherence-free subspace as a subspace for which the
OSR evolution produces no evolution of the quantum information stored in
the subspace. Clearly such a subspace would be useless for quantum
computation because the information stored in the subspace does not
evolve!

A system-environment Hamiltonian can be expanded as @xmath where the all
of the nontrivial coupling between the system and the environment is
included in the @xmath term. For time independent Hamiltonians, all of
the decoherence for general environmental initial conditions comes from
the @xmath coupling. Thus the decoherence-free subspace condition should
be applied to an expansion of the @xmath . The unitary evolution will
then be due to @xmath . This evolution should preserve the DFS. By this
we mean that the evolution due to @xmath should not take states with
support over the subspace to states with support outside of the
subspace.

###### Definition 28.2

(Subspace preserving Hamiltonian) A Hamiltonian @xmath preserves a
subspace @xmath if the spectral decomposition of the Hamiltonian @xmath
can be expanded such that the states @xmath which are entirely within
the subspace @xmath or entirely outside of the subspace @xmath .

Notice that because the spectral decomposition is not unique when there
is a degeneracy of the system Hamiltonian, the subspace preserving
condition must be defined in terms of if the spectral decomposition can
be made such that the subspace is preserved.

If a system Hamiltonian @xmath preserves a subspace and that subspace is
a DFS with respect to the system-environment coupling @xmath , then the
evolution of the DFS will be entirely unitary. We will refer to a DFS
which evolves unitarily by the term DFS unless a distinction is needed
and then we will refer to a unitarily evolving DFS.

Another way in which the presence of a system Hamiltonian can be dealt
with is to work in the interaction picture. In the interaction picture,
the evolution of a system due to the Hamiltonian @xmath is recast into
examining the evolution of @xmath where @xmath . The evolution of @xmath
is given Schrödinger equation evolution under the interaction
Hamiltonian @xmath . If @xmath consists only of separate system and
environment evolution (i.e. no system-environment coupling) then a state
@xmath which is invariant with respect to @xmath will evolve unitarily.
To see this simply note that if a state is invariant in the interaction
picture, then @xmath where @xmath represents the system evolution
operator alone.

##### 28.4 Decoherence-free subspaces and quantum error correction

The theory of quantum error correction (see, for example, [ 120 , 96 ,
153 ] ) provides a method of preserving quantum coherence by actively
manipulating the quantum information. In this theory, one can show that
certain encodings of quantum information can be arranged such certain
error processes can be detected and corrected on this encoding without
destroying the coherence between the encoded quantum information.
Suppose @xmath are a set of error operators which act on a given system.
These errors are usually taken from an expansion of the OSR algebra, but
are not necessarily a complete basis for the OSR algebra. These errors
usually represent “the largest” component of the OSR operators often on
some short time expansion of the OSR operators.

A necessary and sufficient condition for there to exist a subspace which
can detect and correct these errors is given by [ 21 , 120 ]

  -- -------- -- -------
     @xmath      (169)
  -- -------- -- -------

for the basis states @xmath and @xmath in the subspace and for all
errors @xmath and @xmath . The intuition behind this criteria is that
the errors should take the basis states to distinguishable subspaces so
that these errors can be diagnosed and then corrected.

How do DF subspaces fit in with the theory of quantum error correction?
If we identify the error operators @xmath with the OSR algebra, then the
DF subspace characterizing Theorem 28.1 , implies that a DF subspace
necessarily satisfies the condition

  -- -------- -- -------
     @xmath      (170)
  -- -------- -- -------

where @xmath and @xmath are both in the DF subspace. Since @xmath is a
rank one matrix, it is possible to choose a basis for the error
operators @xmath such that @xmath . In the theory of quantum error
correcting codes, the rank of the @xmath matrix in Eq. ( 169 ) is known
as the degeneracy of the code [ 96 ] . Thus we are lead to the
characterization [ 135 , 75 ]

###### Lemma 28.1

A decoherence free subspace @xmath from some OSR algebra is a fully
degenerate quantum error correcting code for all elements of the OSR
algebra.

For more discussion of the relationship between quantum error correction
and decoherence-free subspaces the reader is referred to [ 135 , 75 ] .

#### 29 Decoherence-free subsystems

In the previous section we have seen how information can be encoded into
a subspace of the system’s Hilbert space such that the information does
not decohere. For constructing a quantum computer, however, this
condition is not the most general condition under which quantum
information can be stored in a decoherence-free manner. The basic reason
for this is that quantum information is stored most generally in
subsystems and not necessarily subspaces.

To define a decoherence-free subsystem, we must first define an
operation which we will call the subsystem trace operator.

###### Definition 29.1

Suppose a Hilbert space @xmath has a general subsystem structure @xmath
. Let @xmath denote a basis for the subspace defined by @xmath in this
expansion. @xmath is in the Hilbert space @xmath and a basis over this
tensor product structure is given by @xmath . We define the subsystem
trace operator over the subsystem @xmath as

  -- -------- -- -------
     @xmath      (171)
  -- -------- -- -------

We say that information @xmath has been encoded into a subsystem @xmath
when the density matrix of the full Hilbert space satisfies

  -- -------- -- -------
     @xmath      (172)
  -- -------- -- -------

Let us define the above operator as the @xmath subsystem extractor,

  -- -------- -- -------
     @xmath      (173)
  -- -------- -- -------

This allows us to define what it means to be decoherence-free when
information is encoded into a subsystem.

###### Definition 29.2

(Decoherence-free subsystem (DFS)) Given a system Hilbert space with a
general subsystem decomposition @xmath . A subsystem @xmath is said to
be a decoherence-free subsystem (DFS) with respect to a
system-environment coupling if every pure state encoded into this
subsystem is invariant with respect to this subsystem under the
corresponding OSR evolution for any possible environment initial
condition. If @xmath denotes the situation where the pure state @xmath
has been encoded in the @xmath subsystem, then this condition is
equivalent to

  -- -------- -- -------
     @xmath      (174)
  -- -------- -- -------

We use the abbreviation DFS for both decoherence-free subspaces and
decoherence-free subsystems. We can see from the above definition of a
decoherence-free subsystem, decoherence-free subspaces are examples of
decoherence-free subsystems. In particular decoherence-free subspaces
occur when the matrix algebra @xmath is one dimensional @xmath and hence
all of the operators act as a constant on a subspace. Unless we need to
distinguish between the subsystem and subspace definitions, we will
refer to both as DFSs.

What is the difference between storing information in a subspace and
storing information in a subsystem? This question often leads to
confusion, so let us address this by examining an illuminating example.
Consider encoding a single qubit of information into a two qubit system.
One particular way to encode a qubit into the four dimensional Hilbert
space of two qubits is to encode the information into a subspace spanned
by two orthogonal states. Thus for instance we can encode the
information of a qubit @xmath as @xmath :

  -- -------- -- -------
     @xmath      (175)
  -- -------- -- -------

We then say that the information has been encoded into a subspace of the
two qubit Hilbert space. Suppose we simply encode the information into
the first qubit of the two qubits. It doesn’t matter, then, what the
state of the second qubit is

  -- -------- -- -------
     @xmath      (176)
  -- -------- -- -------

Notice that this map is a one-to-many mapping from the quantum
information in one qubit to a two qubit Hilbert space. For a particular
mapping to a @xmath , the mapping is the same as the mapping from a
qubit to a subspace of the two qubit Hilbert space.

##### 29.1 Representation theory for the OSR algebra

  “The universe is an enormous direct product of representations of
  symmetry groups.”

  –Steve Weinberg (as quoted in [ 89 ] )

We now present a theorem which exactly delineates where quantum
information can be stored decoherence-free in a quantum system. First we
note that the OSR algebra is a @xmath -closed algebra. A @xmath -closed
algebra is an algebra that satisfies the requirement that if @xmath is
the algebra, then @xmath is also in the algebra. For the OSR algebra,
this follows from the hermiticity of the system-environment Hamiltonian.

The theorem we want is a basic theorem from representation theory of
complex associative algebras which are @xmath -closed (see, for example,
[ 131 ] )

###### Theorem 29.1

(Basic representation theorem of @xmath -closed complex associative
algebras) Let @xmath be a complex associate algebra which is @xmath
-closed acting on a Hilbert space @xmath and which contains the identity
operator. In general @xmath will be a reducible subalgebra of the full
algebra over @xmath . In particular the algebra @xmath is isomorphic to
a direct sum of full matrix algebras

  -- -------- -- -------
     @xmath      (177)
  -- -------- -- -------

Here @xmath is the @xmath dimensional identity algebra (which just
consists of the @xmath dimensional identity operator) and @xmath is the
@xmath dimensional complex associative algebra corresponding to all
general linear operators on the @xmath dimensional space.

@xmath is a set describing the different irreducible representations and
@xmath is referred to as the degeneracy of the @xmath th irreducible
representation (irrep). This theorem implies that there is a basis such
that the operation of every operator @xmath in a @xmath -closed complex
associative algebra acts on the Hilbert space as

  -- -------- -- -------
     @xmath      (178)
  -- -------- -- -------

where @xmath is a @xmath dimensional operator and @xmath is the @xmath
dimensional identity operator. Because @xmath is the @xmath dimensional
complex associative algebra corresponding to all general linear
operators on a @xmath dimensional space, the @xmath span the entire
space of @xmath dimensional operators.

Corresponding to the decomposition in Eq. ( 178 ) we can construct a
basis which will simplify our notation considerably. Let @xmath denote
the basis where @xmath labels the subspace of the irrep, @xmath labels
the degenerate component of the decomposition and @xmath labels the
component of the composition which is acted upon non-trivially by the
irrep. This basis implies that the decomposition Eq. ( 178 ) can be
written as

  -- -------- -- -------
     @xmath      (179)
  -- -------- -- -------

Another useful operator to define is the operator which performs the
subsystem trace over the matrix algebra component of a given irrep.
Define

  -- -------- -- -------
     @xmath      (180)
  -- -------- -- -------

where we implicitly use the subsystem structure for a given @xmath ,
@xmath in this sum.

The basic representation theorem of complex associative @xmath -closed
algebras describes a subsystem structure which we previously identified
as a subspace tensor product structure. Given a @xmath for an algebra
@xmath there is a subspace over which the operators act. One manner in
which quantum information can be encoded with respect to the algebra
@xmath is to encode the information into the subspace for a given @xmath
. Information encoded in this manner is acted upon non-trivially by the
operators in the algebra @xmath . Over the subspace for a given @xmath ,
there is a two-fold tensor product structure. Information which is
encoded into the subspace corresponding to a particular @xmath can then
be encoded such that it respects this tensor product structure. Thus
information in the subspace can be encoded into the degenerate degrees
of freedom corresponding to the @xmath algebra or the information can be
encoded into the degrees of freedom corresponding to the @xmath algebra.
We say that information has been encoded into the degeneracy of the
@xmath th irrep if that information has support only over the degrees of
freedom of the @xmath algebra. Notice that because we are encoding into
a subsystem, for a given @xmath information which is encoded into the
degeneracy will be accompanied by information encoded into the degrees
of freedom of the @xmath algebra.

##### 29.2 Decoherence-free subsystem condition

The basic representation theorem of complex associative algebras
combined with the fundamental algebraic theorem of decoherence together
form an excellent iff description of decoherence on a quantum system.
Given an OSR algebra generated by the system operators @xmath , we can
decompose this algebra as in Eq. ( 178 ). This in turn implies that we
can represent the OSR operators as

  -- -------- -- -------
     @xmath      (181)
  -- -------- -- -------

where @xmath are @xmath dimensional OSR operators. The span of the
@xmath are the entire space of all @xmath linear operators and the
@xmath are themselves valid OSR operators which satisfy the completeness
relation @xmath .

###### Theorem 29.2

(Decoherence-free subsystem Hamiltonian criteria) [ 122 ] A subsystem is
a decoherence-free subsystem iff this subsystem is encoded in the
degeneracy of single irrep @xmath from the OSR algebra @xmath .

Proof: First, sufficiency. Suppose that the pure state @xmath is encoded
into the degeneracy of a single irrep @xmath of the OSR algebra @xmath .
This means that

  -- -------- -- -------
     @xmath      (182)
  -- -------- -- -------

where @xmath is any arbitrary @xmath dimensional density matrix and
@xmath is the @xmath dimensional zero matrix. We will represent this
state as

  -- -------- -- -------
     @xmath      (183)
  -- -------- -- -------

where the support of the density matrix is taken to be only over the
@xmath irrep. The OSR operators then act on the this states as

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (184)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

Thus we see that the pure state @xmath encoded into the degeneracy of
the algebra is invariant with respect to the subsystem. Next we prove
necessity. Notice that the decoherence-free subsystem can be thought of
as a decoherence-free subspace after a certain subsystem reduction has
been performed. We can thus use the necessary component of the
decoherence-free subspace condition after we trace over the appropriate
subsystem. Suppose the information was encoded into a subsystem which
does not correspond to the degeneracy of a given irrep @xmath in Eq. (
181 ). This information will not be acted upon proportional to identity
because (i) a component of the information is encoded into the @xmath
algebras, (ii) a component of the information is encoded into different
irreps labeled by @xmath , or (iii) both (i) and (ii). In case (i), the
information will be acted upon nontrivially over the subsystem because
the @xmath are the full matrix algebra over such a space. In case (ii),
the information will be acted upon by differing algebras. This allows
for differing global factors between the OSR operators. Finally, in case
(iii) the information is infected by both of these problems. The
decoherence-free subspace iff condition then implies that the
information must be encoded into the degeneracy of the a single irrep of
the OSR algebra.

##### 29.3 The commutant of the OSR algebra and DFSs

Given an OSR algebra @xmath , how does one know whether there is a
degeneracy over which information can be encoded in a degenerate manner?
The easiest way to examine this question is to examine the commutant of
the OSR algebra. The commutant of an algebra @xmath is denoted by @xmath
and is the set of all operators which commute with all of the elements
of @xmath . The commutant of the commutant of an algebra is itself the
algebra @xmath . If the algebra @xmath is reducible to the form

  -- -------- -- -------
     @xmath      (185)
  -- -------- -- -------

as in Eq. ( 177 ), then the commutant of the algebra is reducible to the
form

  -- -------- -- -------
     @xmath      (186)
  -- -------- -- -------

Thus the existence of a non-trivial commutant of the OSR algebra implies
the existence of a DFS for the OSR algebra.

##### 29.4 Example decoherence-free subsystem

Here we consider a simple example of a decoherence-free subsystem. This
example is not motivated physically (we will return to physically
motivated examples later) but serves as a good illustration of a
decoherence-free subsystem. Consider a three qubit system coupled to a
bath via the Hamiltonian

  -- -------- -- -------
     @xmath      (187)
  -- -------- -- -------

where @xmath are linearly independent bath operators. The OSR algebra
@xmath for this Hamiltonian is generated by the set of operators @xmath
. Closing this algebra @xmath we see that the OSR algebra @xmath is
spanned by the operators @xmath .

A complete set of commuting observables for the three qubit system is
given by the operators @xmath , @xmath , and @xmath . Define the basis
labeled by the eigenvalues of these operators via @xmath . Expressing
these basis states in terms of the standard computational basis we find
that

  -- -------- -- -------
     @xmath      
     @xmath      
     @xmath      (188)
  -- -------- -- -------

Next notice how the operators in the OSR algebra @xmath only affect the
@xmath index:

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (189)
  -- -------- -------- -------- -- -------

i.e. we could have written this such that only the @xmath subsystem is
affected

  -- -------- -- -------
     @xmath      (190)
  -- -------- -- -------

Thus two qubits of information can be stored in @xmath and @xmath which
will not decohere under the coupling Hamiltonian Eq. ( 187 ). Notice how
the OSR algebra can and does affect the @xmath quantum number, but this
coupling does not destroy the information in the quantum numbers @xmath
and @xmath . This is the essential component of a decoherence-free
subsystem which differs from a decoherence-free subspace. In the
subspace case, the information in an subspace does not evolve while in
the subsystem case, degrees of freedom other than those of the subsystem
evolve. In terms of the OSR algebra @xmath we see that the algebra is
reducible to the form

  -- -------- -- -------
     @xmath      (191)
  -- -------- -- -------

We also could have seen that information can be encoded into a DFS by
examining the commutant of the OSR algebra. The commutant of the OSR
algebra is generated by the operators @xmath . The algebra generated
this set of operators is a two-fold degenerate @xmath dimensional matrix
algebra:

  -- -------- -- -------
     @xmath      (192)
  -- -------- -- -------

#### 30 Master equation decoherence-free conditions

We recall that the diagonal form of the semigroup master equation (SME)
is given by

  -- -------- -- -------
     @xmath      (193)
  -- -------- -- -------

where the @xmath are the Lindblad operators. Here we present conditions
for decoherence-free evolution for the SME. We will ignore the evolution
due to the system Hamiltonian (see Section 28.3 ), @xmath .

###### Theorem 30.1

(Decoherence-free subspace master equation criteria) [ 211 , 137 ] A
subspace @xmath of the system Hilbert space @xmath is a decoherence-free
subspace when evolving due to a semigroup master equation iff the
Lindblad operators all satisfy @xmath for every @xmath .

Proof: Sufficiency follows via the fact that if @xmath , then @xmath .
Thus if the initial state is @xmath , then the decoherence term
vanishes:

  -- -------- -- -------
     @xmath      (194)
  -- -------- -- -------

Thus @xmath and the state is a DFS. To show the necessity of this
condition, note that @xmath implies that

  -- -------- -- -------
     @xmath      (195)
  -- -------- -- -------

If each @xmath acts on the states @xmath as @xmath , then this implies

  -- -------- -- -------
     @xmath      (196)
  -- -------- -- -------

and hence each @xmath . Thus the condition is also necessary.

For subsystems, the situation, unfortunately is not quite as easy. First
let us define the SME algebra

###### Definition 30.1

(SME algebra) Suppose one is given a semigroup master equation with
diagonal Lindblad operators @xmath . The SME algebra is the complex
associative algebra generated by the Lindblad operators @xmath , their
adjoints @xmath and identity @xmath .

Having defined the SME algebra, we can present a sufficient condition
for decoherence-free evolution under the SME.

###### Theorem 30.2

(Decoherence-free subsystem semigroup master equation criteria) A
sufficient criteria for the existence of a decoherence-free subsystem
under the evolution of a semigroup master equation is that the subsystem
is acted upon as identity by the corresponding SME algebra.

Proof: The Lindblad operators and their adjoints along with the identity
act as the reducible complex associative algebra such that we can
express these operators as

  -- -------- -- -------
     @xmath      (197)
  -- -------- -- -------

If we encode into the degeneracy of irrep @xmath , then the initial
density matrix of the system will be

  -- -------- -- -------
     @xmath      (198)
  -- -------- -- -------

such that @xmath . It is then easy to check that

  -- -------- -- -------
     @xmath      (199)
  -- -------- -- -------

Let us also give an example of why the above condition cannot be also a
necessary condition [ 109 ] . Suppose we are given a single qubit which
is subjected to a semigroup master equation with only one non-zero
@xmath . This situation corresponds to a single two-level system subject
to spontaneous decay. Clearly there is a stationary state of the system
@xmath which does not evolve. However, if one examine the algebra
generated by @xmath , @xmath and @xmath , one can easily see that any
linear operator over the two-qubits can be found in this algebra. Then
according to the above criteria, there would be no states which do not
evolve. But this is a contradiction to our earlier observation. Thus the
condition is sufficient but not necessarily necessary. Only in the
subspace regime does the above condition become necessary and
sufficient.

Why did the condition we used in the OSR fail for the SME? The main
reason for this is that the SME represents evolution which is a
semigroup (a group without the requirement that every element have an
inverse). What is needed in order to obtain a necessary and sufficient
condition is representation theory for semigroups. We will not delve
into this subject but in the finite dimensional case there should be no
difficulty applying representation theory of semigroups to the
decoherence-free problem.

#### 31 Inducing decoherence-free conditions

A final topic which we would like to address is the issue of inducing or
symmetrizing the evolution of a system such that the system-environment
coupling exhibits a certain symmetry which supports a decoherence-free
condition. Viola and Lloyd [ 196 , 197 ] were the first to suggest that
it might be possible to use ultra-fast system evolution to reduce
decoherence in the context of quantum computation (see also [ 74 , 77 ,
199 ] ). Viola, Lloyd, and Knill [ 198 , 194 ] and independently Zanardi
[ 213 , 212 , 218 ] then developed the mathematical theory behind these
symmetrization schemes and demonstrated how universal quantum
computation could also be performed on these systems. With the seminal
paper of Knill, Laflamme, and Viola [ 122 ] which introduced the notion
of decoherence-free subsystems, it was quickly realized by Viola, Knill,
and Lloyd [ 195 ] and by Zanardi [ 214 ] that there is an intimate
relationship between the ideas of symmetrized evolutions and
decoherence-free subsystems. It is this relationship which we will now
briefly described.

Suppose that one has the ability to perform ultra-fast gates and their
inverses on a system from some the unitary representation of some finite
group @xmath . Let @xmath be represent of the element @xmath of this
group. If one applies the operation @xmath , then allows the system to
evolve according to some Hamiltonian @xmath , and finally applies the
operation @xmath , the resulting operation is

  -- -------- -- -------
     @xmath      (200)
  -- -------- -- -------

so that the system effectively evolves according to the Hamiltonian
@xmath . Suppose that all elements of the groups are applied in this
fashion to an evolution due to some Hamiltonian @xmath . The evolution
is then approximately

  -- -------- -- -------
     @xmath      (201)
  -- -------- -- -------

where @xmath is the order of the group @xmath and

  -- -------- -- -------
     @xmath      (202)
  -- -------- -- -------

Define the @xmath -symmetrizing operator

  -- -------- -- -------
     @xmath      (203)
  -- -------- -- -------

Notice that @xmath commutes with all of the element of @xmath

  -- -------- -- -------
     @xmath      (204)
  -- -------- -- -------

Define @xmath as the complex associative algebra generated by elements
of the group @xmath . We call this algebra the group algebra. This
algebra is reducible, @xmath . Operators acted on by @xmath , @xmath are
all in the commutant @xmath of the group algebra. This algebra is
reducible to the form @xmath .

Suppose the @xmath -symmetrizing procedure is applied to the system
component of a system-environment coupling @xmath . Then if this
procedure is applied fast enough [ 196 ] , the evolution of the system
and environment will be governed by the effective Hamiltonian

  -- -------- -- -------
     @xmath      (205)
  -- -------- -- -------

One can now apply the decoherence-free conditions to the symmetrized
system operators

  -- -------- -- -------
     @xmath      (206)
  -- -------- -- -------

As we described above, the @xmath can be reduced because they are in the
commutant of the group algebra. More generally, if the @xmath for a
complete basis for the full matrix algebra of the system’s Hilbert
space, then the @xmath will exactly realize the entire commutant @xmath
of the group algebra @xmath .

  -- -------- -- -------
     @xmath      (207)
  -- -------- -- -------

where @xmath are @xmath dimensional operators which act on the
degeneracy of the @xmath th irrep.

Thus we see that there is an intimate connection between the
symmetrization procedure described above and decoherence-free condition.
By symmetrizing the evolution, a symmetry in the system-environment
coupling can be induced and a decoherence-free subspace or subsystem can
be used to store protected quantum information.

#### 32 A brief history of decoherence-free conditions

Decoherence-free subspaces are somewhat related to pointer bases [ 222 ,
223 ] . In particular decoherence-free subspaces can be thought of as
degenerate pointer basis: the kind of pointer basis which would cause
fits for the measurement problem interpretation usually attached to
environment-induced pointer basis selection. Also related are the Dicke
states of optics [ 60 ] . Both of these example, however, degeneracy was
nothing more than a theoretical hindrance.

The first indication of states which are resistant to decoherence as
applied to quantum computation was the work of Palma, Suominen, and
Ekert [ 155 ] as well as the work of Chuang and Yamamoto [ 44 , 51 ] .
These authors made observations of specific dephasing based DF subspaces
and noted the consequences of these states for quantum computation.

Work on concrete realizations of DF subspaces was presented in a series
of papers by Duan and Guo [ 67 , 68 , 215 , 69 , 70 , 71 , 72 , 73 , 76
] . These authors derived different physical conditions under which DF
subspaces could exist. Most of this work was presented in the context of
semigroup master equations and focused solely on the theory the
existence of such subspaces for specific examples.

The first work to mathematically put down the DF subspace condition were
the seminal papers of Zanardi and Rasetti [ 216 , 210 , 217 ] . In these
papers Zanardi and Rasetti put forth the Hamiltonian iff criteria for
the existence of a DF subspace. Zanardi and Rossi also developed
proposals for physical realization of DF subspaces in quantum dots [ 219
, 220 ] . The semigroup master equation iff criteria for DF subspaces
was then derived by Zanardi [ 211 ] and by Lidar, Chuang, and Whaley [
137 ] .

Developing, at first independently from DF conditions, Viola and Lloyd
presented the notion that symmetrization could be used to avoid
decoherence [ 196 , 197 , 198 , 194 ] . Duan and Guo also examined
pulsed control of decoherence [ 74 , 77 ] . Zanardi developed the
general mathematical theory of such symmetrization [ 213 ] . Both Viola,
Lloyd and Knill [ 195 ] along with Zanardi [ 212 ] also presented
methods for performing computation on such symmetrized evolutions.

In an important generalization of the DF subspace notion, the work on
dynamical induced symmetrization led Knill, Laflamme, and Viola to
introduce the notion of DF subsystems [ 122 ] . DF subsystems were also
derived, independently, by de Filipo. This was the first derivation of
the DF subsystem criteria. Zanardi [ 214 , 218 ] and Viola, Knill, and
Laflamme [ 195 ] then discussed the dynamical generation of coherence
preserving evolutions and the general theory of DF subsystems.

#### 33 Decoherence-free conditions

DF subspaces and their generalization DF subsystems offer a method for
avoiding specific symmetric decoherence mechanism. In the next few
chapters we explore the stability of DFSs and how DFSs fit in with the
notion of a quantum computer before turning to a concrete physical
realization of a DFS. It should be mentioned, however, that a recent
experiment [ 111 , 110 ] using ion traps has demonstrated the existence
of a DF subspace. Thus this work is not just a matter of wishful
theorizing: there is experimental evidence that the notion of DFSs will
play an important role in a future quantum computer.

### Chapter \thechapter Stability of Decoherence-Free Systems

  Does poking and prodding decoherence-free systems remove the free from
  decoherence-free?

In this chapter we address the issue of the stability of
decoherence-free systems to additional perturbing decoherence processes.
We first give a simple example of the stability of a decoherence-free
subspace. The stability of a DFS with respect to a memory fidelity is
treated within both the OSR and SME. If the strength of the perturbation
is @xmath , the decoherence-rates to all orders are shown to vary as
@xmath . Finally, the issue of the dynamical stability of a DFS is
addressed.

#### 34 Stability example for a decoherence-free subspace

Suppose one has a decoherence-free subsystem corresponding to some
system-environment coupling. This coupling may be extremely strong and
thus it is not unreasonable to think that a perturbing
non-decoherence-free supporting interaction could couple with this
strong evolution yielding a decoherence-free subsystem which is highly
unstable. In this chapter we will concern ourselves with understanding
the stability of such a situation. Before we proceed to the
mathematically messy calculation, however, it is useful to present the
simplest example of such stability. This analysis was first presented by
Lidar, Chuang and Whaley in [ 137 ] .

Consider the addition of a perturbing interaction to that of a DFS
supporting evolution in the SME:

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (208)
                                @xmath   
                                @xmath   
  -- -------- -------- -------- -------- -------

We are interested here in the first-order decoherence rate (see Appendix
F )

  -- -------- -- -------
     @xmath      (209)
  -- -------- -- -------

If we encoded into a DF subspaces, @xmath , then @xmath where we have
made the simplifying assumption that @xmath is hermitian and is a basis
with the same algebraic structure as that of the Lindblad operators and
their adjoints (the SME algebra). This in turn implies that

  -- -------- -- -------
     @xmath      (210)
  -- -------- -- -------

by using the cyclical property of the trace. This holds for the other
perturbing term as well. Thus we see that the first-order decoherence
rate vanishes to order @xmath under a @xmath strong perturbation. In the
following sections we expand this result to higher orders and work in
both the OSR and the SME. Furthermore we also generalize this result to
the subsystems situation. This extends the subspace analysis originally
presented in [ 10 ] .

#### 35 Stability under the operator-sum representation

Consider the addition to a DFS supporting Hamiltonian of new perturbing
terms in the interaction Hamiltonian: @xmath . The new full evolution
operator is given by

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (211)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (212)
  -- -------- -------- -------- -- -------

etc. Here @xmath is the unperturbed evolution operator. In this chapter
we will concern ourselves with the correction due of the evolution to
first order in the perturbing parameter @xmath :

  -- -------- -- -------
     @xmath      (213)
  -- -------- -- -------

Corresponding to this evolution operator are the OSR operators

  -- -------- -- -------
     @xmath      (214)
  -- -------- -- -------

Expand the unperturbed OSR operators and the perturbing terms about
different fixed basis (see Section 9.2 ) @xmath and @xmath :

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (215)
  -- -------- -------- -------- -- -------

such that the evolution operator to first order in @xmath is

  -- -------- -- -------
     @xmath      (216)
  -- -------- -- -------

The evolution due to this OSR is thus

  -- -------- -- -------
     @xmath      (217)
  -- -------- -- -------

where @xmath , @xmath ,and @xmath . The normalization condition is

  -- -------- -- -------
     @xmath      (218)
  -- -------- -- -------

As in Section 9.2 we can separate out the identity components of the
evolution and normalization conditions and obtain

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (219)
                                @xmath   
  -- -------- -------- -------- -------- -------

where

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (220)
  -- -------- -------- -------- -- -------

and

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (221)
  -- -------- -------- -------- -- -------

Suppose that quantum information @xmath is encoded into the degeneracy
of the @xmath th irrep of the OSR algebra of the unperturbed OSR
evolution: @xmath , or @xmath The @xmath th order decoherence rate
@xmath for this evolution is given by (see Appendix F )

  -- -------- -- -------
     @xmath      (222)
  -- -------- -- -------

where @xmath is the @xmath th time derivative of the evolved density
matrix @xmath evaluated at @xmath . Recall that

  -- -------- -- -------
     @xmath      (223)
  -- -------- -- -------

transforms an operator @xmath on the full Hilbert space to an operator
which acts only on the degeneracy of the @xmath th irrep. Now,
explicitly, we can calculate that

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (224)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

Using this expression we can evaluate the contribution of each term to
@xmath th order decoherence rate. First we find that

  -- -------- -- -------
     @xmath      
     @xmath      
     @xmath      
     @xmath      
     @xmath      (225)
  -- -------- -- -------

where we have used the fact

  -- -------- -- -------
     @xmath      (226)
  -- -------- -- -------

Next, because the unperturbed evolution is a DFS,

  -- -------- -- -------
     @xmath      (227)
  -- -------- -- -------

To show that the final two traces vanish, we recall that basic
representation theory of complex associative algebras tells us that the
expansion operators @xmath can be taken to have the same reducible
structure as the OSR algebra

  -- -------- -- -------
     @xmath      (228)
  -- -------- -- -------

Thus we find that

  -- -------- -- -------
                 
     @xmath      
                 (229)
  -- -------- -- -------

and using the fact that @xmath pulls out only the @xmath th irrep,

  -- -- -------- -------- -------- -------
        @xmath   @xmath            (230)
                          @xmath   
  -- -- -------- -------- -------- -------

Finally, using the cyclic property of @xmath , Eq. ( 226 ), this implies
that

  -- -------- -- -------
     @xmath      (231)
  -- -------- -- -------

A similar calculation finds that

  -- -------- -- -------
     @xmath      (232)
  -- -------- -- -------

Thus, we have shown that, to first order in @xmath , the decoherence
rates of a DFS on the OSR for a perturbing interaction of strength
@xmath vanishes

  -- -------- -- -------
     @xmath      (233)
  -- -------- -- -------

This result implies that perturbing interactions can indeed be treated
as perturbing. A priori one can worry that a strong DFS supporting
interaction could produce effects that scale like @xmath where @xmath is
the coupling strength of the unperturbed interaction. The above
calculation shows that one must go to order @xmath before such
interactions can destroy the decoherence-free nature of the DFS.

Finally we note that we have worked with a pure input state @xmath .
Notice, however, that a mixed state which evolves according to the OSR
can be thought of as a convex combination of the pure state evolutions

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (234)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

This implies that the above perturbative analysis carries over to the
initial mixed state case.

#### 36 Stability under the semigroup master equation

Consider in addition to a DFS supporting SME

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (235)
  -- -------- -------- -------- -- -------

and additional @xmath perturbing term

  -- -------- -- -------
     @xmath      (236)
  -- -------- -- -------

where

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (237)
  -- -------- -------- -------- -- -------

The @xmath time derivative of @xmath evaluated at @xmath is then given
by

  -- -------- -- -------
     @xmath      (238)
  -- -------- -- -------

where

  -- -------- -- -------
     @xmath      (239)
  -- -------- -- -------

Now suppose that quantum information @xmath is encoded into the
degeneracy of the @xmath th irrep of the SME algebra: @xmath . The
decoherence rates are then, as in the previous section, given by

  -- -------- -- -------
     @xmath      (240)
  -- -------- -- -------

To first order in @xmath , the only nonvanishing terms in @xmath are

  -- -------- -- -------
     @xmath      (241)
  -- -------- -- -------

because @xmath . We can now expand the @xmath ’s in terms of the SME
algebra:

  -- -------- -- -------
     @xmath      (242)
  -- -------- -- -------

It is useful here to notice that

  -- -------- -- -------
     @xmath      (243)
  -- -------- -- -------

where @xmath . Because we can choose @xmath to be hermitian, @xmath so
that

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

Now

  -- -------- -- -------
     @xmath      
     @xmath      
     @xmath      (245)
  -- -------- -- -------

The @xmath is essentially a trace operator over @xmath and since only
@xmath acts non-trivially over the decomposition, we see that we can
cycle the operators such that this term vanishes

  -- -------- -- -------
     @xmath      (246)
  -- -------- -- -------

A similar conclusion holds for the @xmath term.

Thus we see that, as is the case for the OSR, in the SME

  -- -------- -- -------
     @xmath      (247)
  -- -------- -- -------

#### 37 Dynamical stability

The results derived in the previous Section imply that DFSs are robust
to small perturbations when the DFS is operating as a quantum memory .
In order to address what happens when perturbations are made on the
system as it evolves according to some desired quantum computation , we
have to first define an analog of the mixed-state memory fidelity for an
evolving system. This is

  -- -------- -- -------
     @xmath      (248)
  -- -------- -- -------

where @xmath is the desired unitary evolution,

  -- -------- -- -------
     @xmath      (249)
  -- -------- -- -------

Here @xmath is the system Hamiltonian. This dynamical fidelity is a good
measure of the difference between the desired evolution of the system
and the actual, noisy evolution. Thus, @xmath , with @xmath if and only
if the evolution is perfect, i.e., @xmath . The decoherence rates for
the dynamical fidelity are defined in the same manner as for the memory
fidelity:

  -- -------- -- -------
     @xmath      (250)
  -- -------- -- -------

In [ 10 ] , it was shown that @xmath for both the OSR and the SME. The
interested reader is referred to this article for more information on
this result.

#### 38 Stability

We assemble in Table 2 all of the perturbation results

The first indications of the stability of a DF subspace can be found in
the numerical simulations done by Zanardi in [ 211 ] . Lidar, Chuang,
and Whaley [ 137 ] then presented the general memory stability condition
of @xmath in the context of DF subspaces. The general memory stability
results to all orders in time for DF subspaces were derived by Bacon,
Lidar, and Whaley in [ 10 ] . In this chapter, we have broadened these
stability results from the arena of DF subspaces to DF subsystems.

The stability of DFSs to perturbations is a particularly nice result for
using DFSs as a stable quantum memory. It is unlikely that absolutely
perfect DF conditions will exist in nature and therefore it is important
to understand how perturbing interactions change the DF nature of the
system. The above perturbation results indicate that one can treat
perturbing interactions on a DFS as independent of the DF condition.
This will later turn out to be an important issue when one thinks about
how to use DFSs within the context of fault-tolerant quantum error
correction.

### Chapter \thechapter Decoherence-Free Subsystems and the Quantum
Computer

  To compute or not to compute, that is the question.

In this chapter we address the issue the relationship between DFSs and
quantum computation. We begin by describing how DFSs can be used in a
concatenated manner and how this fits in with the idea of fault-tolerant
quantum computation. A particularly important aspect of DFSs necessary
for their use in quantum computation is the ability to perform universal
quantum computation on the encoded information. The special, but not
unique, role of the commutant of the OSR or SME algebra for universal
quantum computation is outlined. The issue of measurement on a DFS and
leakage errors is also introduced with application to more concrete
models put off until the following chapters.

#### 39 Quantum computation and decoherence-free subspaces

In the previous two chapters we have introduced the notion of
decoherence-free subsystem and examined the stability of such DFSs to
perturbing interactions. We have seen that it is possible to perform an
encoding of quantum information such that the information is protected
from a certain source of decoherence. Let us now discuss how such
decoherence-free subsystems can be put to use towards building a quantum
computer.

One of the common misconceptions about decoherence-free subsystems is
that they were intended as an ultimate solution towards building a
quantum computer. There are two main reasons why such a future is highly
unlikely to unfold.

The first reason why DFSs are not the ultimate solution arises from the
fact that the symmetries necessary for maintaining a decoherence-free
condition will almost certainly not be perfectly realized in the
physical world. Encoding into a DFSs, should be thought of in the
context of eliminating a particular decoherence mechanism. This
decoherence mechanism may be the dominant mechanism or it may be on
equal footing with other non-DFS supporting decoherence mechanisms. This
is not to deemphasize the importance of DFSs towards building a quantum
computer: elimination of a particular decoherence mechanism should not
be brushed under the rug and dismissed.

The second reason why DFSs are not the ultimate solution to building a
quantum computer is because the concept of a decoherence-free subsystem
does nothing to address the issue of fault-tolerant quantum computation.
Suppose one has, miraculously, found a system whose only decoherence
mechanism supports a DFS and it is possible to encode and make suitable
measurements on the DFS. In order to use such DFSs for quantum
computation, one must be able to perform operations on the DFS which
manipulate the quantum information. These operations will most likely be
faulty: it will not be possible to perfectly execute an operation on the
DFS perhaps. The condition of being decoherence-free says nothing about
the faulty operation of gates on the encoded DFS.

So, in general, the theory of DFSs must be cast within the broader quest
towards building a quantum computer. The most likely usefulness of the
DF idea in quantum computation is to work alongside the theory of
fault-tolerant quantum error correction. The theory of fault-tolerant
quantum computation [ 3 , 96 , 115 , 124 , 161 , 175 ] describes how
faulty operations and decoherence, if the effects of both are
sufficiently weak and sufficiently non-pathological, can be used to
perform quantum computation to any desired accuracy with only a
polynomial slowdown in the quantum computation. The idea of putting DFSs
to work in quantum computation is the elimination of a particular
decoherence mechanism such that the threshold for fault-tolerant quantum
computation can be achieved. This philosophy is perhaps best summarized
by the saying “use symmetry first!” implying that symmetries in the
system-environment coupling should be used to first eliminate bothersome
decoherence mechanisms before quantum error correction is then applied
to build a reliable quantum computer.

#### 40 DFSs for quantum computation

To build a quantum computer, we must make a mapping to the quantum
subsystem circuit model. The most straightforward manner of achieving
this goal in the context of DFSs is to take individual DFSs as the
subsystems of the quantum subsystem circuit model. The idea is something
like that depicted in Figure 4 .

Information in physical subsystems is encoded into a DFS which may span
several physical subsystems. These encoded subsystems then will become
the building blocks of the quantum subsystem circuit model. Viewed from
the lens of coding theory what we are doing is using the DFSs as a code
from which the quantum subsystems circuit model is constructed.

Suppose one has two OSR or SME algebras @xmath and @xmath which have
representations @xmath and @xmath . Now suppose that these two algebra
act on two separate subsystems of a Hilbert space @xmath . The algebra
on this conjoined space then acts as @xmath . Using the reducible
representation of each algebra we find that

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (251)
                       @xmath   @xmath   
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where we have used the fact that the tensor product of two full matrix
algebras is the full matrix algebra on the tensor product state @xmath .
This result implies that if we store build a quantum subsystem circuit
out of subsystems which are each individually DFSs, then the conjoined
subsystems will still be DF. This, however, will not always be the
situation. Due to the particular symmetry involved in a DFS, it may be
possible that conjoining two DFSs produces an OSR or SME algebra which
is larger than the simple tensor product structure of the above
decomposition.

Here it should be pointed out that, much like the case of the quantum
subsystems circuit model itself, there is some arbitrariness in the how
we map from a DFS to the quantum subsystem circuit model. In the above
description, and as depicted in Figure 4 each encoded subsystem is in
one-to-one correspondence with a set of physical qubits. The tensor
product between these sets of physical qubits then becomes the tensor
product between the encoded subsystems in the quantum circuit model.
This model, of course, is not the most general. We will, however
concentrate on this model as it appears to be the most physically
relevant model.

DFS encoded subsystems will be used in the quantum subsystem circuit
model to perform fault-tolerant quantum computation. Placing quantum
information into a DFS presents extra challenges for the theory of
fault-tolerant quantum computation. Let us enumerate the ways in which a
DFS fits in with the standard model of fault-tolerant quantum
computation.

1.  Preparation. There should be some manner to create states with
    support over a DFS with a certain fidelity of preparation. In the
    theory of fault-tolerant quantum error correction there are often
    cases where preparation of a particular state is desired. Specific
    DFS models then will require these special preparation steps.

2.  Measurement. Closely tied with the issue of preparation, it should
    be possible to extract information via a measurement which makes
    some distinction between different encoded information. Of course it
    would be highly desirable to perform any possible measurement, but
    much of the theory of fault-tolerant quantum computation can be
    adapted to models where only minimal information extraction is
    possible. We will address this issue in Section 42 .

3.  Universality. A set of interactions must be possible which act on
    the information encoded in the DFS. If the DF condition is to
    maintained there is an important restriction here that does not
    appear in normal quantum computation: the interactions should always
    act within the protected subsystem. This issue is addressed in
    Section 41 .

4.  Noise models. The threshold theorem for fault-tolerant quantum
    computation deals with noise models of a specific form. This means
    that the perturbing noise (i.e. non-decoherence-free) on DFSs should
    fit within these noise models. Of non-trivial significance in this
    context is the problem that information which has been encoded can
    leak out of the encoding. A particularly useful technique for
    attacking leakage in the context of error correction is given in
    Section 43

#### 41 The commutant and universal quantum computation

Using DFSs to construct a quantum subsystems circuit model one must be
able to perform computation on the encoded subsystems. In a given
physical setup where one is attempting to couple or act on single
subsystems, there will be a given OSR or SME algebra @xmath which is
relevant when the evolution on the encoded subsystem is being acted
upon. The operation which is enacted on the encoded subsystem may be on
a single encoded subsystem or between multiple subsystems, but in both
cases, there will be a relevant OSR or SME algebra @xmath describing the
DFS. In particular because leaving a DFS may be disastrous to the
encoded quantum information, we require that the evolution of the system
never cause information in the DFS to leak out of the DFS. What are the
necessary and sufficient conditions for a Hamiltonian dynamics @xmath to
maintain the DF condition?

We recall that every algebra @xmath has a commutant @xmath which is the
set of all operators which commute with the elements of the algebra
@xmath . These operators have a dual reducible structure (recall Section
29.3 )

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (252)
  -- -------- -------- -------- -- -------

In particular we see that elements of the commutant act to preserve the
reducible structure of the algebra @xmath . This leads us the following
sufficient condition for a Hamiltonian @xmath to act only on information
encoded in a particular irrep.

###### Lemma 41.1

Suppose one is given an OSR or SME algebra @xmath and information has
been encoded into the degeneracy of the @xmath th irrep. A Hamiltonian
@xmath which commutes with all of the elements of @xmath will act on
this encoded information and will not take this encoded information out
of the @xmath th irrep.

Proof: Trivial application of the idea of the commutant of the algebra
@xmath . If @xmath commutes with @xmath , then it is in @xmath and
therefore has the decomposition described in Eq. ( 252 ) which preserves
the information encoded into the degeneracy.

##### 41.1 Example of the commutant condition

Recall in Section 29.4 we found that the OSR algebra @xmath spanned by
@xmath supported a four dimensional DFS. The commutant of the OSR
algebra @xmath is generated by the operators @xmath . Let us discuss how
this commutant can be used to enact interactions on the DFS.

The DFS corresponding to @xmath is four dimensional. We can therefore
think of this subsystem as composed of two qubits. The splitting of the
space into two qubits is, as always, arbitrary in where we place the
tensor product structure. We recall that a complete set of commuting
observables for the three qubit Hilbert space of this DFS is given by
@xmath , @xmath , and @xmath with a corresponding basis @xmath . The DFS
information is encoded into the subsystem spanned by the @xmath . We
will take our two qubits to be the @xmath subsystem structure. We
therefore see that the operation @xmath acts non-trivially on this
encoded information

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (253)
  -- -------- -------- -------- -- -------

Similarly for @xmath acts only on the @xmath component of @xmath . The
@xmath and @xmath act as an encoded @xmath on each of the encoded
qubits. Similarly we find that

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (254)
  -- -------- -------- -------- -- -------

such that this operator acts as an encoded @xmath on the @xmath qubit.

What should now be clear this that these operators which are in the
commutant of @xmath act as single qubit Pauli operators on the encoded
subsystems. Let us denote the two qubits via @xmath and @xmath . Then
the encoded operators on the these subsystems are enacted by the encoded
Pauli operators

  -- -------- -- -------
     @xmath      
     @xmath      (255)
  -- -------- -- -------

Thus if one wishes to perform a single qubit rotation on the qubit
@xmath , one can use a Hamiltonian of the form

  -- -------- -- -------
     @xmath      (256)
  -- -------- -- -------

Similarly we can construct the operators which act between qubits @xmath
and @xmath . For example the operator which acts as @xmath on the
encoded qubits is given by

  -- -------- -- -------
     @xmath      (257)
  -- -------- -- -------

This operator and all the other similar two qubit operators is, like the
@xmath , in the commutant of @xmath .

Thus we see how examining the commutant of an algebra @xmath can allow
us to find operators which perform interactions on the encoded
subsystem.

##### 41.2 Why the commutant condition is sufficient but not necessary

While Lemma 41.1 describes a sufficient condition for a Hamiltonian to
preserve the information encoded into a DFS subsystem, the condition is
not necessary. To see this, one recalls that information will be stored
in a particular @xmath irrep of the algebra @xmath . Information which
has been encoded into the degeneracy of a particular single @xmath irrep
is unaffected by what happens in the other irreps. Elements which
commute with operators in @xmath preserve every @xmath irrep.
Information which is encoded in a particular single degeneracy can be
acted upon by operators which are not in the commutant of @xmath and
which still preserve the DF encoded information.

Using the criteria that a Hamiltonian commute with the OSR or SME
algebra, then, is not a necessary condition for preserving information
encoded into the corresponding DFS. We will find, however, that while
the criteria is not necessary it is often sufficient for our needs.

##### 41.3 Representation theory and the commutant

A further area which often causes confusion in describing computation on
a DFS is the difference between a complex associate algebra and a Lie
algebra. Suppose one is given the ability to enact a set of Hamiltonians
which generate the commutant of the OSR or SME algebra @xmath for a
certain DFS. The ability to enact the Hermitian generators of the
commutant is not enough to guarantee that every operation on the encoded
DFS can be enacted. The reason for this is that the generators we have
specified are generators in the sense of a complex associative algebra
(multiplication, linear combination) and not in the sense of a Lie
algebra (Lie bracket, linear combination).

Let us given an illustrative example of this situation to clarify the
problem. Suppose we are given the ability to enact a three-dimensional
irrep of the Lie algebra @xmath ,

  -- -- -- -------
           (258)
  -- -- -- -------

It is easy to check that the complex associative algebra generated by
multiplication and linear combination is the entire space of linear
operators on the three-dimensional space. However, the Lie algebra
generated by these operators is just the three operators @xmath which do
not span the space of linear operators on the three-dimensional space.
Elements like @xmath are in the complex associative algebra generated by
the @xmath , but are not in the Lie algebra generated by the @xmath .

The correct way to state Lemma 41.1 in terms of the generators of a Lie
algebra is then

###### Lemma 41.2

Suppose one is given an OSR or SME algebra @xmath and information has
been encoded into the degeneracy of the @xmath th irrep. A set of
Hamiltonians @xmath each of which commutes with all of the elements of
@xmath will act on this encoded information without taking this encoded
information out of the @xmath th irrep. Furthermore this set of
Hamiltonians @xmath will generate a Lie algebra @xmath which has a
reducible structure of the form

  -- -------- -- -------
     @xmath      (259)
  -- -------- -- -------

where @xmath is a (perhaps further reducible) @xmath dimensional Lie
algebra and @xmath represents the identity action on a @xmath
dimensional space.

##### 41.4 Existential universality on a DFS

It is important to realize that universal sets of gates always exist for
any given subsystem structure mapped onto a quantum circuit model [ 140
, 212 ] . This is to say that it is always possible to construct a given
set of interactions between subsystems. However, for a specific DFS,
there are important limitations which prevent this existential result
from holding any weight. In particular, the set of operators which can
be enacted on the DFS often is from a limited set of physically viable
operators. In most systems, more that two-body interactions will be very
difficult to enact on the system. Thus existentially there are always
universal gate sets, but under most conditions, these existential
results are not of use.

Suppose, for example, that one has encoded on qubit of information into
@xmath physical qubits in terms of the basis states @xmath and @xmath .
Clearly there is a single qubit encoded @xmath between these qubits
which is given by @xmath . Notice however, that this is a five-qubit
interaction which we would not expect to be easily implementable on a
system. On the other hand, one can also see that a single Pauli @xmath
acting on a single qubit of this encoding produces an encoded @xmath :
@xmath and @xmath .

#### 42 Measurement on DFSs for quantum computation

Suppose we are trying to extract information via a measurement which has
been encoded into the degeneracy of the @xmath th irrep of some OSR or
SME algebra @xmath . Clearly the measurement of an operator which is
this OSR will not yield any information about the information encoded
into the degeneracy. This is because these operators all act as identity
on the encoded information and measuring identity gives no information
about the encoded information.

Suppose we wish the measurement operators to preserve the DFS structure
of the encoded information. In this case, the nontrivial elements of the
commutant of @xmath provide operators which preserve the DFS structure
and return information about the encoded information.

###### Lemma 42.1

Let @xmath be a hermitian observable which is a member of the commutant
of the OSR or SME algebra @xmath . Information which has been encoded
into a irrep of the algebra @xmath will remain in the irrep after a
measurement of @xmath .

The issue of measurements, however, is again far from contained within
elements of the commutant only. Just like in the unitary manipulation of
DF encoded information, there are measurements which are not in the
commutant which still preserve the encoded information.

#### 43 Making leakage into noise

Finally we would like to address the issue of noise models on a DFS. In
the standard theory of error correction, one works with operators @xmath
which are called the errors , and represent the action of major
component of the OSR algebra on system evolution.

An important form of noise on a DFS is a leakage error [ 135 ] . If we
encode information into the @xmath th irrep of some algebra @xmath ,
then we can classify three types of errors.

1.  Errors which act on the DFS information but preserve the subsystem
    structure. These errors act on the @xmath th irrep in a non-trivial
    manner. If we are using a given DFS for fault-tolerant error
    correction, these errors will be the standard errors which the
    fault-tolerant error correction serves to fix.

2.  Error which preserve the DFS information but act nontrivially
    otherwise. These are errors like those generated by the OSR algebra
    @xmath .

3.  Errors which do not preserve the DFS information. These errors take
    information in a subsystem and leak the information to outside of
    the subsystem. For example information in the @xmath th irrep may be
    moved to the @xmath th irrep.

If the subsystem structure of the algebra @xmath corresponds to

+-----------------------+-----------------------+-----------------------+
|                       | +--------+--------+   |   ---                 |
|                       | |   --   |   --   |   |   0                   |
|                       | | ------ | ------ |   |   ---                 |
|                       | |        |        |   |                       |
|                       | | @xmath | @xmath |   |                       |
|                       | |   --   |   --   |   |                       |
|                       | | ------ | ------ |   |                       |
|                       | |        |        |   |                       |
|                       | | @xmath |        |   |                       |
|                       | +--------+--------+   |                       |
+-----------------------+-----------------------+-----------------------+
| @xmath                |                       |                       |
+-----------------------+-----------------------+-----------------------+
|                       |   ---                 |   --------            |
|                       |   0                   |   @xmath              |
|                       |   ---                 |   --------            |
+-----------------------+-----------------------+-----------------------+

Then the errors detailed above correspond to operators with nonvanishing
element in the following locations

+-----------------------+-----------------------+-----------------------+
|                       | +--------+--------+   |   ---                 |
|                       | |   ---  |   ---  |   |   3                   |
|                       | |   1    |   2    |   |   ---                 |
|                       | |   ---  |   ---  |   |                       |
|                       | |        |        |   |                       |
|                       | | @xmath |        |   |                       |
|                       | +--------+--------+   |                       |
+-----------------------+-----------------------+-----------------------+
| @xmath                |                       |                       |
+-----------------------+-----------------------+-----------------------+
|                       |   ---                 |   -------             |
|                       |   3                   |   1,2,3               |
|                       |   ---                 |   -------             |
+-----------------------+-----------------------+-----------------------+

Of these errors, those in 3 are the most troublesome in the use of a DFS
concatenated within a fault-tolerant quantum error correction procedure.
These “leakage” errors, however, do not pose a fundamental problem for
the theory of fault-tolerant quantum computation [ 161 , 96 ] . A
particularly nice technique for deal with leakage errors is to simply
make these errors type 1/2 errors. To do this one makes a measurement
which distinguishes between states in the DFS and states outside of the
DFS and then depending on the outcome takes states outside of the DFS
back into states in the DFS. Thus it is possible to convert errors which
leak out of the subsystem and make these errors which occur on the
subsystem. For a specific example of this technique applied to a
DFS/quantum error correction scheme see [ 135 ] .

#### 44 Decoherence-free subsystems as components of a quantum computer

The purpose of this chapter was to address some of the issues which
occur when attempting to use DFSs in conjunction with the theory of
fault-tolerant quantum computation. There are no fundamental
difficulties in such a melding of DFSs and fault-tolerant quantum
computation. Much like in the theory of fault-tolerant quantum
computation, however, specific application to a specific physical system
which supports a DFS poses different challenges in melding DFSs with
fault-tolerance. In the next few chapters we will have the opportunity
to examine a specific physically relevant model of a DFS and thus the
results in this chapter will be directly addressed for this physical
model.

### Chapter \thechapter Collective Decoherence

  Where not being able to distinguish subsystems is a symmetry

In this chapter we introduce an important physical model of decoherence
which supports decoherence-free evolution: collective decoherence. This
model is, in some sense, a generic model and demonstrates an important
symmetry which can be realized in suitable natural quantum systems. Due
to the physical relevance of this model, it will be the subject of this
thesis in the following four chapters. We begin with a non-rigorous
discussion of the conditions which lead to collective decoherence. We
then turn to the example of collective dephasing and present models of
this decoherence process in the Hamiltonian and master equation
formulations. Specific conditions for collective dephasing are derived.
We then discuss collective amplitude damping and the conditions under
which such a process occurs. Finally, we categorize the three different
types of collective decoherence as weak collective decoherence, strong
collective decoherence, and collective amplitude damping. The DFS
structure of each of these models is then given.

#### 45 Collective coupling to an environment

Consider two physical qubits which are situated in close proximity to
each other. When we think about the environment of these qubits, we are
generally thinking about the environment as the rest of the universe.
Thus even when the qubits are not in close proximity, the entity of the
environment is really the same for each qubit. However, as the qubits
are brought from close proximity to large separation, the environments
with which each qubit most strongly acts separate out into two local
environments for each qubit. Physical assumptions then usually allow us
to consider each qubit as coupling strongly to a local environment and
weakly or vanishingly to the other qubits’ environment. Conversely, when
the two qubits are situated close together, the environment which each
qubit interacts with is essentially the same environment.

In most physical situations it is impossible to put two physical qubits
on top of each other–especially without these qubits interacting with
each other–but let us imagine for the moment that this is possible. In
the limit of qubits on top of each other and not interacting, we expect
each qubit to couple to the environment in an identical manner. Now
suppose we increase the physical separation between these qubits.
Clearly the identical manner in which the qubits couple to the system
will now no longer be identical. The coupling to the same environment,
however, for small enough separation, should still be the main mechanism
of decoherence for these closely spaced qubits. This is exactly
analogous to the reasoning behind distant qubits having separate local
environments. We will refer to the situation where each qubit couples in
an identical manner to individual quantum subsystems as the case of
collective decoherence .

Another way to metaphorically codify the idea of collective coupling is
to think about decoherence as a spying process on the system.
Decoherence is the process through which the environment becomes
entangled with the system and some of the quantum information of the
system is transferred to a joint system-environment state. Viewed in
this manner, the decoherence process is the manner in which the
environment observer the system. Now consider the case of two closely
spaced qubits which are being observed by an environment. Since the
qubits are closely spaced, the environment may not be able to
distinguish between each of the qubits when the environment observers
(interacts) with the two qubits. The inability of the environment to
distinguish two or more closely spaced physical qubits is exactly the
case of collective decoherence.

#### 46 Collective dephasing

Consider the evolution of a system of @xmath qubit coupled to an
environment. These qubits have a natural energy levels and the process
of dephasing is the mechanism through which the populations of these
levels do not change but the coherence between the levels do change.
This setup is most generally characterized by a system-environment
Hamiltonian of the form

  -- -------- -- -------
     @xmath      (260)
  -- -------- -- -------

where @xmath is some environment Hamiltonian. If these energy levels are
identical then @xmath . The case of collective dephasing corresponds to
the situation when @xmath and the energy levels are identical. This then
corresponds to the Hamiltonian

  -- -------- -- -------
     @xmath      (261)
  -- -------- -- -------

where we have defined

  -- -------- -- -------
     @xmath      (262)
  -- -------- -- -------

In the collective dephasing setup, the OSR algebra will be generated by
@xmath and @xmath (and thus consists of all higher powers of @xmath .)
We will discuss the DFSs generated by the collective dephasing model in
Section 49 .

Let us introduce a less generic model of the dephasing of qubits which
we can use to make arguments about the situations under which collective
decoherence in the form of dephasing should occur. Consider a system of
@xmath identical qubits @xmath coupled to a quantized field expressed as
a set of harmonic oscillator modes which are the environment @xmath via
the Hamiltonian

  -- -------- -- -------
     @xmath      (263)
  -- -------- -- -------

where @xmath ( @xmath ) is the annihilation (creation) operator for the
@xmath th mode. The coupling constant @xmath will, in general, depend on
the location of the @xmath th system. In many situations it may be
possible to make approximations directly on the coupling constants
@xmath . The situation corresponding to collective dephasing is then
when the coupling between the system and the environment is identical
for each qubit @xmath . In this case the Hamiltonian is given by

  -- -------- -- -------
     @xmath      (264)
  -- -------- -- -------

To give an idea of when @xmath we recall that the spatial dependence of
@xmath is given by a normal mode expansion of the field. Thus @xmath
where @xmath is the location of the @xmath th qubit and @xmath describes
the spatial variation of the @xmath th mode. The condition of @xmath
then corresponds to @xmath for all @xmath and @xmath . In other words,
when the spacing between the qubits is small enough that the normal mode
@xmath does not vary significantly over the positions of these qubits,
collective dephasing will dominate. If the normal mode, for example, is
a plane wave @xmath and the spacing between the qubits is much less than
the wavelength of this plane wave, @xmath , then @xmath or @xmath .

##### 46.1 Master equation collective dephasing

In order to obtain the collective dephasing regime, it is necessary that
there be a reason why modes which distinguish between different qubits
contribute little to the dynamics of the system-environment evolution.
In order to clarify the role of this assumption, we present a derivation
of a semigroup master equation for this Hamiltonian which can help
clarify under what conditions this assumption is a good assumption. This
is the semigroup master equation formulation of collective dephasing [
155 , 69 ] .

The first step in the derivation of the master equation is to move into
the interaction picture. Define @xmath and @xmath . Then the interaction
picture Hamiltonian is given by

  -- -------- -- -------
     @xmath      (265)
  -- -------- -- -------

The @xmath each individually commute with this Hamiltonian and thus the
populations of each qubit will be unaffected by the evolution due to
this Hamiltonian. Under the approximation, the general form of a master
equation is given by

  -- -------- -- -------
     @xmath      (266)
  -- -------- -- -------

We will make the assumption that the environment is in thermal
equilibrium at temperature @xmath (we set @xmath , @xmath ). When we
make this assumption we will refer to the environment as the bath. The
bath density matrix is thus given by [ 90 ]

  -- -------- -- -------
     @xmath      (267)
  -- -------- -- -------

where @xmath is the mean occupation number for mode @xmath ,

  -- -------- -- -------
     @xmath      (268)
  -- -------- -- -------

and @xmath is a coherent state for the @xmath th mode.

The first term in the master equation, Eq. ( 266 ), is given by

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (269)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where @xmath and

  -- -------- -- -------
     @xmath      (270)
  -- -------- -- -------

This term vanishes identically for a bath in equilibrium @xmath .

The second term in the master equation, Eq. ( 266 ), is given by

  -- -------- -- -------- -------- -------
     @xmath      @xmath            (271)
                          @xmath   
  -- -------- -- -------- -------- -------

where

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

Using the thermal equilibrium density matrix it is easy to calculate
that

  -- -------- -------- -- -- -------
     @xmath   @xmath         
     @xmath   @xmath         (273)
  -- -------- -------- -- -- -------

The evolution is therefore given by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (274)
     @xmath   @xmath   @xmath      
  -- -------- -------- -------- -- -------

This dephasing master equation shows how the coefficient matrix @xmath
contains information about the correlation of decoherence between
different qubits.

There are two important limits to Eq. ( 274 ). In the first limit,
@xmath . In this case the master equation can be written as a sum of two
Lindblad operators on each qubit

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (275)
  -- -------- -------- -------- -- -------

This is the case of independent dephasing. Each qubit evolves
independent of the evolution of the other qubit. The other important
limit is when @xmath is constant, @xmath . In this case the master
equation contains just one Lindblad operator which acts on all qubits

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (276)
  -- -------- -------- -------- -- -------

This is the case of collective dephasing.

In the continuum model where the bath corresponds to some quantized
field, we can make the substitution @xmath where @xmath is the dimension
of the field. We will examine the case of @xmath . The other dimensional
cases follow similar lines of investigation.

We assume the coefficients @xmath have a spatial relationship @xmath
where @xmath is the position of the @xmath th qubit. Then if the
quantized region is length @xmath ,

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (277)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

We would like to see what conditions the length scale at which the
approximation @xmath occurs. Moving into the frequency domain, we find
that

  -- -------- -- -------
     @xmath      (278)
  -- -------- -- -------

where we have dropped the superfluous @xmath index on @xmath . Define
the envelope function @xmath such that @xmath . The function @xmath
determines which @xmath modes contribute maximally to this integral. We
can split @xmath into two contributions

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (279)
  -- -------- -------- -------- -- -------

@xmath represents the thermal contribution to @xmath while @xmath comes
from the vacuum fluctuation contribution to @xmath . The thermal
contribution to the @xmath has a natural cutoff frequency given by the
thermal frequency

  -- -------- -- -------
     @xmath      (280)
  -- -------- -- -------

Thus for @xmath , @xmath is exponentially suppressed. Assuming a linear
dispersion relation @xmath , if the qubits are spaced such that @xmath ,
then the integral is not exponentially suppressed in the region where
@xmath . Thus, if the qubits are spaced closer than the thermal spacing
@xmath , the thermal contribution to @xmath will contribute @xmath
independent of @xmath and @xmath . For a given temperature, there is a
spectrum of bath modes which are occupied. The temperature then
determines the longest wavelength which has non-negligible occupation
and this wavelength then determines the spacing needed in order to
achieve collective dephasing.

The vacuum contribution to @xmath however, does not have such an
exponential suppression except as given by the field theory which
provides a coupling constant with a cutoff frequency @xmath . If the
bath field is a phonon field, the natural cut-off can be identified with
the Debye frequency. In this case an identical argument to the thermal
case gives a characteristic vacuum spacing @xmath . Qubits spaced closed
that this vacuum spacing will dephase collectively due to the vacuum
contribution @xmath .

#### 47 Collective amplitude damping

In the previous section we investigated the situation where no
population transfer occurred on the system’s qubits but the phase of the
qubits state was affected. Let us now examine the situation where
population transfer does occur.

Consider the situation of @xmath qubits coupled to a radiation field. In
the interaction picture and under the rotating wave approximation, the
Hamiltonian for this system plus environment is given by

  -- -------- -- -------
     @xmath      (281)
  -- -------- -- -------

where @xmath and @xmath is the energy spacing of each qubit. Under the
assumption of @xmath , this Hamiltonian becomes

  -- -------- -- -------
     @xmath      (282)
  -- -------- -- -------

where @xmath . Notice that the system operators couple collectively to
the bath

  -- -------- -- -------
     @xmath      (283)
  -- -------- -- -------

where

  -- -------- -- -------
     @xmath      (284)
  -- -------- -- -------

The OSR algebra for this Hamiltonian under the assumption @xmath is
therefore generated by @xmath and @xmath . We will later return to this
situation, which we will label strong collective decoherence.

##### 47.1 Master equation collective amplitude damping

Let us examine the evolution due to the pre-approximated (except the
rotating-wave approximation) Hamiltonian Eq. ( 281 ) [ 69 ] . Using the
master equation Eq. ( 266 ) and the assumption that the environment
modes are all in the vacuum state, we can easily obtain the master
equation in the interaction picture as

  -- -------- -- -------
     @xmath      (285)
  -- -------- -- -------

where

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (286)
  -- -------- -------- -------- -- -------

In the continuum limit, the main contribution to these terms occur at
@xmath . Thus in order to attain a collective regime, the requirement is
that

  -- -------- -- -------
     @xmath      (287)
  -- -------- -- -------

where @xmath is the wavenumber where @xmath . Due to the resonance
condition, the conditions for collective amplitude damping are much
easier to describe than those of collective dephasing. The main pathway
for amplitude damping is exchange of @xmath energy with the bath and
therefore this dominant pathway provides the condition for collective
amplitude damping.

In the collective regime, the master equation reduces to

  -- -------- -- -------
     @xmath      (288)
  -- -------- -- -------

where @xmath are defined as in Eq. ( 284 ). Notice that the Lindblad
operator @xmath here does not include an equivalent @xmath Lindblad
operator. The case of collective amplitude damping, then, is a case
where the SME algebra may give differing DFS structures than the actual
DFS for the master equation.

In both collective dephasing and collective amplitude damping, the
fundamental requirement to enter into these regimes is that the spacing
of the qubits be sufficiently small that the important wavelengths of
the interacting baths cannot distinguish the qubits. There are other
natural situations where collective decoherence will dominate. For
example if both qubits are coupled to another quantum system external to
the two qubits, the wavelength criteria need not be met, but only the
fact that the two qubits couple identically to the states of the other
system is needed. The models we have presented in Sections 46 and 47 are
meant to serve as guides to finding systems where collective decoherence
is exhibited.

#### 48 Collective decoherence

In the last two sections we have examined models which exhibit
collective coupling of a system to the environment. There are three
relevant arenas for this collective coupling which we will label weak
collective decoherence, strong collective decoherence, and collective
amplitude damping. For completeness, we recall our definition of the
collective operators on @xmath qubit,

  -- -------- -- -------
     @xmath      (289)
  -- -------- -- -------

where @xmath . When we need to refer to the collective operators on a
specific number of qubits, we will do this with a superscript @xmath is
the collective operator on @xmath qubits

  -- -------- -- -------
     @xmath      (290)
  -- -------- -- -------

These operators form a representation of the Lie algebra @xmath ,
meaning they satisfy the commutation relations

  -- -------- -- -------
     @xmath      (291)
  -- -------- -- -------

The three cases of collective decoherence are then specified by

###### Definition 48.1

(Weak collective decoherence) When the OSR or SME algebra consists of
only a single @xmath ( @xmath , @xmath ) and identity we call this
decoherence mechanism weak collective decoherence . Single qubit
rotations are always possible which take this operator to the operator
@xmath . We will assume that this has been done and thus weak collective
decoherence for our purposes will be when the OSR or SME algebra
consists only of @xmath and @xmath .

###### Definition 48.2

(Strong collective decoherence) When the OSR or SME algebra contains all
@xmath , @xmath and the identity we call this decoherence mechanism
strong collective decoherence .

###### Definition 48.3

(Collective amplitude damping) When the SME contains only the Lindblad
operator @xmath and a Hamiltonian term @xmath , we call this decoherence
mechanism collective amplitude damping . Notice that collective
amplitude damping when extended to the full SME algebra is strong
collective decoherence.

#### 49 Weak collective decoherence DFSs

In weak collective decoherence on @xmath qubits, the only nontrivial
error operator is @xmath . This error operator thus forms an abelian
algebra @xmath with elements spanned by the set @xmath . Due to the fact
that @xmath is hermitian, there is not difference between the DFSs in
the Hamiltonian/OSR treatment and the SME treatment. In the first case
(OSR) @xmath will be the system operator and in the second case (SME)
@xmath will be the sole Lindblad operator. Furthermore, because the
algebra for the weak collective decoherence is abelian, the DF structure
will be that of DF subspaces. This is because abelian algebras all have
irreps which are one-dimensional and one-dimensional irreps simply
correspond to DF subspaces (note that the converse is does not hold.
There can be DF subspaces when the algebra is non-abelian. The algebra
will be abelian over the subspaces, but over the entire space it can be
non-abelian.)

The easiest way to understand the weak collective decoherence DFS is to
work in the basis where @xmath is diagonalized. This basis is just the
standard computational basis @xmath ,

  -- -------- -- -------
     @xmath      (292)
  -- -------- -- -------

Let @xmath denote the Hamming length of number @xmath in binary: @xmath
is the number of @xmath ’s in the binary expression of @xmath . Then
this is just

  -- -------- -- -------
     @xmath      (293)
  -- -------- -- -------

Notice that for a given Hamming distance @xmath , the action of @xmath
on all states with this Hamming distance @xmath is identical. The DF
subspace criteria is the @xmath for each of the states @xmath in the
subspace. Thus in our case we see that the DF subspaces correspond to
states with equal Hamming weight.

###### Definition 49.1

(Weak collective decoherence DF subspace DFS @xmath ) Weak collective
decoherence on @xmath qubits supports DF subspaces labeled by the
integer @xmath , DFS @xmath . DFS @xmath is spanned by basis states in
the computational basis @xmath which have Hamming weight @xmath equal to
@xmath .

This result follows directly from the DF subspace Hamiltonian and
semigroup master equation criteria.

The dimension of a given DFS @xmath is given by the number of ways a
@xmath bit number can be written which has a Hamming distance @xmath .
This is given by

  -- -------- -- -------
     @xmath      (294)
  -- -------- -- -------

The largest DFS for a fixed number of qubits then corresponds to the
case when @xmath when @xmath is even, or @xmath when @xmath is odd.

##### 49.1 The weak DFS basis

A complete set of commuting observables for the weak collective
decoherence DFS on @xmath qubits is given by the set of operators @xmath
[ 109 ] . The corresponding basis is then denoted by @xmath . This basis
is especially nice because it allows a for a graphical representation of
the DFSs and their basis states. We will call this basis the weak DFS
basis.

In Figure 5 , the horizontal axis marks the number of qubits and the
vertical axis measures the eigenvalue of @xmath . Each state in the
basis @xmath corresponds to a path from the origin to the given DFS in
which only connections which act from left to right are allowed.

A simple example will help explain our notation. For @xmath , there are
@xmath DF subspaces. These correspond to Hamming distances @xmath ,
@xmath , @xmath , and @xmath . The basis states for these DFSs in the
standard computational basis are

  -- -------- -------- -------- -- -------
     @xmath   @xmath               
     @xmath   @xmath   @xmath      (295)
  -- -------- -------- -------- -- -------

In the weak DFS basis, these states would be denoted by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (296)
  -- -------- -------- -------- -- -------

A qutrit of information, for example, can encoded into the DFS @xmath

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (297)
                       @xmath   @xmath   
                                @xmath   
  -- -------- -------- -------- -------- -------

and @xmath acts on @xmath as a scalar @xmath .

Finally in Table 3 we assemble the dimension of the weak collective
decoherence DFS. Notice that these numbers are just Pascal’s triangles.
It is easy then to see the connection between the number of paths in
Figure 5 and the degeneracy in Eq. ( 294 )

#### 50 Strong collective decoherence DFSs

Strong collective decoherence on @xmath qubits is characterized by the
action of the three operators @xmath , @xmath , and @xmath . These
operators act as the Lie algebra @xmath and this will help us to
characterize the DFSs arising from these operators. In particular, the
rules of addition of angular momentum allow us to completely understand
the irreps of the @xmath . In particular we think of the computational
basis states @xmath and @xmath as spin- @xmath particles under the
mapping @xmath and @xmath .

The operators @xmath do not commute with each other and thus they cannot
be simultaneously diagonalized. Following standard addition of angular
momentum, we find that the operators

  -- -------- -- -------
     @xmath      (298)
  -- -------- -- -------

do commute. These two operators do not form a complete basis for the
entire Hilbert space. Thus for given eigenvalues of these two operators
we must assign a degeneracy index which completes the basis. By
simultaneously diagonalizing these two operators we have a basis @xmath
which are a representation of @xmath ,

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (299)
  -- -------- -------- -------- -- -------

Here, @xmath and @xmath and @xmath labels the degeneracy mentioned
above. In analogy with the addition of angular momentum, we will of
think of the qubits as spin- @xmath particles. @xmath then represents
the total angular momentum of the particles and @xmath labels the
projection of the angular momentum along the @xmath -axis. It is
important to realize that the qubit does not necessarily correspond to a
spin- @xmath particle in the physical system. However, using the
language of angular momentum and addition of spin- @xmath particles will
simplify our nomenclature significantly. Using these basic observations,
we can move on to study the irreps of the algebra @xmath for strong
collective decoherence.

The algebra @xmath generated from @xmath , @xmath , and @xmath plus
identity @xmath can be decomposed as

  -- -------- -- -------
     @xmath      (300)
  -- -------- -- -------

where @xmath labels the total angular momentum of a particular irrep
(and hence the @xmath or @xmath depending on whether @xmath is even or
odd, respectively), @xmath is the algebra of all linear operators on a
@xmath dimensional space, and @xmath is the algebra consisting only of
the identity operator @xmath . @xmath is then the degeneracy of the
@xmath th irrep and @xmath is dimension of the @xmath th irrep. The
degeneracy of the @xmath th irrep is given by [ 142 ]

  -- -------- -- -------
     @xmath      (301)
  -- -------- -- -------

Corresponding to the decomposition Eq. ( 300 ) the action of the @xmath
’s act as

  -- -------- -- -------
     @xmath      (302)
  -- -------- -- -------

where @xmath is the @xmath dimensional representation of @xmath .
Corresponding to this representation is a basis @xmath which is acted
upon as @xmath . Notice that this action depends on which @xmath is
acted upon, but is independent of the degeneracy index @xmath .

###### Definition 50.1

(Strong collective decoherence DF subsystem DFS @xmath ) Strong
collective decoherence on @xmath qubits supports DFS labeled by the
integer @xmath , DFS @xmath . DFS @xmath in general has a subsystem
structure. The states in DFS @xmath are all eigenstates of @xmath with
eigenvalue @xmath . The action of the collective decoherence operators
@xmath act as representations of @xmath on the eigenstates of @xmath for
a particular total angular momentum @xmath . Finally, the DFS is
realized by the degeneracy of the @xmath th irrep.

The strong collective decoherence DFS, then has information which is
encoded into the degeneracy for a particular irrep label by the total
angular momentum @xmath . In addition of angular momentum, one takes two
spin- @xmath and spin- @xmath representations of @xmath adds them
together to form spin- @xmath representation of @xmath . For the strong
collective decoherence DFS, we perform this addition of angular momentum
with spin- @xmath particles. Thus the degeneracy for a given @xmath is
given by the different ways in which @xmath qubits can be added together
under the laws of angular momentum addition such that the total angular
momentum is @xmath .

It is useful to present the first few DFS @xmath states in order to gain
some intuition for what is going on here. DFS @xmath consists of only
one DFS, DFS @xmath

  -- -------- -- -------
     @xmath      (303)
  -- -------- -- -------

DFS @xmath now consists of two DFSs, DFS @xmath and DFS @xmath ,

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (304)
  -- -------- -------- -------- -- -------

Here we see that the DFSs for @xmath simply correspond to the singlet
and triplet spaces. Up to this point, however, there is no degeneracy (
@xmath for all DFSs). For @xmath however, this changes. At @xmath we saw
that we had a singlet and a triplet. When we add a spin- @xmath particle
to these states we can produce a @xmath by either adding to the singlet
or subtracting from the triplet. Thus we see that there is a degeneracy
in the DFS corresponding to @xmath ,

  -- -------- -- -------
     @xmath      
     @xmath      (305)
  -- -------- -- -------

The states with @xmath were obtained by taking a singlet and adding a
single spin- @xmath and the states with @xmath were obtained by taking a
triplet and subtracting a single spin- @xmath . Thus we see that for
@xmath , we can encoded one qubit of information into the degeneracy
index @xmath .

##### 50.1 The strong DFS basis

The DFS corresponding to different @xmath values for a given @xmath can
be computed using standard methods for the addition of angular momentum
[ 98 ] . This can best be illustrated by examining a full basis for the
entire Hilbert space. The set of operators

  -- -------- -- -------
     @xmath      (306)
  -- -------- -- -------

forms a complete set of commuting observables for the Hilbert space of
@xmath qubits, @xmath [ 109 ] . Corresponding to this set of observables
is a basis which we will label as

  -- -------- -- -------
     @xmath      (307)
  -- -------- -- -------

This basis is acted upon by the complete set of commuting observables in
Eq. ( 306 ) as

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (308)
  -- -------- -------- -------- -- -------

We call this basis the strong DFS basis. We will always assume that the
@xmath and @xmath are consistent with the laws of the addition of
angular momentum.

One can understand this basis by thinking of the addition of angular
momentum in a piecewise fashion. We start with a spin- @xmath particle.
Adding another qubit which is just a spin- @xmath particle, we can then
create a spin- @xmath or a spin- @xmath particle. If we proceed in this
manner, for @xmath qubits we may have a spin- @xmath particle and adding
another qubit allows for the creation of spin- @xmath or spin- @xmath
(if @xmath is positive) particles. This graphical addition of angular
momentum can be easily visualized as in Figure 6 below.

The horizontal axis of Figure 6 is the number of qubits @xmath and the
vertical axis is the total angular momentum @xmath obtained by summing
angular momenta of @xmath spin- @xmath particles. Each state in a DFS is
represented by a pathway from the origin always moving from left to
right.

Thus we find that the degeneracy @xmath is labeled by the set of
pathways via which one can piecewise construct a given @xmath
dimensional representation of @xmath . Symbolically we might express
this as @xmath . When we are talking about a particular @xmath qubit DFS
we will often use the notation @xmath to mesh with the strong DFS basis.

Finally we include in Table 4 the degeneracy of the @xmath th
irreducible representation for @xmath qubits. The entries of this table
are obtained just as in Pascal’s triangle, except half of the triangle
is missing because negative angular momentum @xmath is not allowed. The
entries are exactly those in Eq. ( 301 ).

#### 51 Collective amplitude damping DF subspaces

Finally let us consider the DFSs for collective amplitude damping [ 70 ]
. On @xmath qubits, collective amplitude damping consists of a
Hamiltonian evolution @xmath and a collective annihilation Lindblad
operator @xmath . Using the @xmath basis from Section 50 the action of
both of these operators can be evaluated:

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (309)
  -- -------- -------- -------- -- -------

As mentioned previously, if we extend these operators to form a @xmath
-closed complex associative algebra, we obtain exactly the case of
strong collective decoherence. Thus it is clear that information encoded
into the degeneracy of the strong collective decoherence DFS can be used
to store information in the collective amplitude damping case. However
we recall that the condition we used to show the strong collective
decoherence DFS was a sufficient but not necessary condition for the
existence of a DFS.

Here, then we will examine the DF subspaces of collective amplitude
damping where we have a criteria which is both necessary and sufficient.
The DF subspace condition is that the Lindblad operators act as identity
on the states in the DF subspace. In the case of the collective
amplitude damping the Lindblad operator is only @xmath . From equation
Eq. ( 309 ), the only states for which this holds true are the states
@xmath . In particular we see that

  -- -------- -- -------
     @xmath      (310)
  -- -------- -- -------

Furthermore, the Hamiltonian term @xmath preserves this subspace

  -- -------- -- -------
     @xmath      (311)
  -- -------- -- -------

Thus we find that

###### Definition 51.1

(Collective amplitude damping DF subspace DFS @xmath ) Collective
amplitude damping, in addition to supporting the DF subsystem of strong
collective decoherence, supports a DF subspace. The elements of this
subspace are the states annihilated by the @xmath operator. These states
have a projection of the total angular momentum along the @xmath -axis
which is negative the total angular momentum of the state.

Below we list the elements of the collective amplitude damping DFS for
between @xmath and @xmath qubits

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (312)
  -- -------- -------- -------- -- -------

From this list we find that we can encode a single qubit of information
into two physical qubits.

The dimension of the collective amplitude damping DF subspace is given
by

  -- -------- -- -------
     @xmath      (313)
  -- -------- -- -------

which can be found by summing the degeneracy of the appropriate strong
collective decoherence DFSs @xmath .

Since we will not work with universality or quantum computing structures
on the collective amplitude damping DF subspace, we will not construct a
nice basis for this DFS.

#### 52 Collective decoherence

In this chapter we have seen how collective coupling of a system to a
bath can occur under reasonably generic conditions. In latter chapters
we will encounter physical systems which explicitly realize this regime.
The value of the collective decoherence model, of course, is limited by
how realistic collective coupling is as a source of decoherence.

### Chapter \thechapter Universality on Collective Decoherence
Decoherence-Free Subsystems

  Is it possible to compute on collective decoherence decoherence-free
  subsystems or are these decoherence-free subsystems useless for
  quantum computation?

In this chapter we discuss how to use the weak and strong collective
decoherence DFSs for quantum computation. The first issue we address is
understanding how to perform universal quantum computation on the weak
and strong DFS. We begin this task by examining the nontrivial one and
two qubit interactions which preserve the relevant DFS structure. We
then discuss universal control on both the strong and weak collective
decoherence DFSs. A discussion of the issue of conjoining DFSs then
allow us to claim universal unitary manipulation on the DFSs.
Preparation and measurements on the collective DFSs is then discussed.
Finally fault-tolerant quantum computation using concatenated collective
DFSs is discussed.

#### 53 Nontrivial one and two qubit interactions on the collective DFSs

It is always possible to construct a set of interactions which is
universal on an encoding corresponding to a given DFSs (see Section 41.4
.) For physical reasons, however, we would like to limit the
interactions on qubit subsystems to be either single qubit or multiple
qubit operators.

In this section we find the one and two-qubit interactions which are in
the commutant of the relevant algebra @xmath for the weak and strong
collective decoherence DFSs. It will turn out to be sufficient for
universality to examine only elements of the commutant @xmath .

##### 53.1 Weak collective decoherence DFS commutant operations

Weak collective decoherence on @xmath qubits has an OSR or SME algebra
@xmath generated by the operations @xmath .

Consider the single qubit Hamiltonian acting on the @xmath th qubit,
@xmath . Taking the commutator of this operator with the nontrivial
element of @xmath , we find that

  -- -------- -- -------
     @xmath      (314)
  -- -------- -- -------

Using the trace-inner product, this implies that the only single qubit
operators which are in the commutant of @xmath are the operators @xmath
.

Consider next a two qubit Hamiltonian acting between the @xmath th and
@xmath th qubit, @xmath . Taking the commutator of this with @xmath we
find that

  -- -------- -- -------
     @xmath      (315)
  -- -------- -- -------

The first point directly relevant is the @xmath operator commutes with
@xmath . Furthermore if we collect like terms on the right hand side of
the above commutator, and use the trace inner product we find that we
can make the commutator vanish by setting @xmath and @xmath . Thus the
two-qubit operators which are in @xmath are all given by

  -- -------- -- -------
     @xmath      (316)
  -- -------- -- -------

The most general Hamiltonian on two qubits @xmath and @xmath is then of
the form

  -- -------- -- -------
     @xmath      (317)
  -- -------- -- -------

where we have expressed the operator in the standard computational basis
[ 109 ] .

##### 53.2 Strong collective decoherence DFS commutant operations

Strong collective decoherence on @xmath qubits has an OSR or SME algebra
@xmath generated by @xmath .

There are no single-qubit operators in the commutant of @xmath . To see
this note that for a single qubit operator @xmath , one can always
construct a collective operator @xmath for some @xmath such that @xmath
and thus @xmath .

For the two-qubit operators, we can immediately reduce the possible
commuting Hamiltonians to the two-qubit operators which are in the
commutant for the weak collective decoherence DFS,

  -- -------- -- -------
     @xmath      (318)
  -- -------- -- -------

Taking the commutator of this operator with @xmath we find that

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (319)
                                @xmath   
                                @xmath   
  -- -------- -------- -------- -------- -------

which vanishes only if @xmath and @xmath . Thus we see that the
Hamiltonian

  -- -------- -- -------
     @xmath      (320)
  -- -------- -- -------

Including a global phase @xmath operator and scaling appropriately, this
operator is the exchange interaction between qubits @xmath and @xmath

  -- -------- -- -------
     @xmath      (321)
  -- -------- -- -------

where we have expressed the exchange operator in a matrix form over the
standard computational basis over the two qubits @xmath and @xmath . The
exchange operator @xmath exchanges qubits @xmath and @xmath : @xmath .

#### 54 Weak collective decoherence DFS universality

In this section we discuss universal quantum computation on the weak
collective decoherence DFSs. Recalling Eq. ( 317 ), define the operators

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (322)
  -- -------- -------- -------- -- -------

where @xmath represents the a matrix with diagonal elements in the
standard computational basis. Define the set

  -- -------- -- -------
     @xmath      (323)
  -- -------- -- -------

where @xmath is the exchange interaction between the @xmath and @xmath
th qubit. Notice that this set @xmath contains nearest neighbor
interactions. All of the operators in this set are in the commutant of
the algebra generated by @xmath and thus preserve the DFS structure of
the weak collective decoherence DFS.

The control afforded over the weak collective decoherence DFSs with
Hamiltonians from @xmath is described by the following theorem:

###### Theorem 54.1

[ 109 ] For any @xmath qubits undergoing weak collective decoherence,
the set of Hamiltonians @xmath generates (in the sense of a Lie algebra)
a Lie algebra which acts independently as @xmath on DFS @xmath . If
@xmath denotes the Lie algebra generated by @xmath , then

  -- -------- -- -------
     @xmath      (324)
  -- -------- -- -------

To say that the Lie algebra @xmath acts independently on DFS @xmath
means that there are elements in the Lie algebra which act only on DFS
@xmath and annihilate all other DFS @xmath , @xmath .

Proof: See Appendix III .

Let us reflect on what this theorem implies. This theorem tells us that
given control over the Hamiltonians in @xmath , any unitary action on an
encoded weak collective decoherence DFS can be enacted. Since these
operators are in the commutant of the weak collective decoherence
algebra @xmath , these operators are in some sense maximal: they can not
mix different DFSs and they operate as full @xmath on the DFSs.

In Chapter II we will have the opportunity to calculate explicit
representations of the gates needed for the physically relevant case of
an ion trap quantum computer.

##### 54.1 Conjoining weak collective decoherence DFSs and universality

In order to use weak collective decoherence DFSs for universal quantum
computation, there must be map from the DFSs to the quantum circuit
model. In particular the mapping from the encoded information to the
subsystem structure of the quantum circuit model must be made. The fact
that weak collective decoherence is most likely to occur when qubits are
closely spaced puts certain constraints on the subsystem structure.
Suppose we use a weak collective decoherence DFS on @xmath qubits as our
basic subsystem which encodes @xmath qubits of information. Notice that
the subsystem structure of the physical qubits is mapped to the
subsystem structure of the quantum circuit model in the weak collective
decoherence DFS case. Theorem 54.1 implies that given the operators in
@xmath we can construct @xmath operations on these encoded subsystems.

But what about when we bring the two subsystems together to implement
more complicated gates? When two encoded subsystems are thus conjoined
we would like to maintain the DF property of these states. When we
conjoin two weak collective decoherence DFSs, these states inhabit a DFS
of the combined space. If @xmath is the Hamming weight of the first
subsystems DFS and @xmath is also the Hamming weight of the second
subsystems DFS, then the conjoined system inhabits the @xmath Hamming
weight DFS (more general situations where the DFSs are of differing
Hamming weights follow similar arguments.) Furthermore, Theorem 54.1
tells us that given the operators in @xmath we can perform operations
which preserve the @xmath Hamming weight DFS. Among these operations are
the operations which have an input output property which individually
preserve each @xmath Hamming weight DFS. Thus we can perform nontrivial
operations between the two subsystems which always maintain the combined
( @xmath Hamming weight) weak collective decoherence DFS.

Thus we see that Theorem 54.1 allows for universal quantum computation
on subsystems while maintaining the DF condition under the caveat that
conjoined subsystems must also be DF. Since weak collective decoherence
is conditioned on the close spacing of the qubits, one would therefore
expect that subsystems involving the smallest number of qubits would be
used in such a conjoining scheme.

#### 55 Strong collective decoherence DFS universality

The following theorem demonstrates how the exchange interaction can be
used for quantum computation on the strong collective decoherence DFS:

###### Theorem 55.1

[ 109 ] For any @xmath qubits undergoing strong collective decoherence
let @xmath be the set of exchange Hamiltonians @xmath acting between
qubits @xmath and @xmath . The Lie algebra generated by @xmath contains
the ability to perform @xmath independently on the degeneracy of every
irrep @xmath . If @xmath is the Lie algebra generated by @xmath then

  -- -------- -- -------
     @xmath      (325)
  -- -------- -- -------

where @xmath represents an identity operator on the @xmath dimensional
irrep space. The ability to perform each @xmath independently means that
the Lie algebra contains elements which act nontrivial on the @xmath th
irrep but annihilate all states outside of this irrep.

Proof: See Appendix III .

This theorem implies that the only interaction needed to perform
computation on the strong collective decoherence DFS is the exchange
interaction. Like the weak collective decoherence case, this result is
in some sense maximal: the operations do not mix DFSs but act fully on
the DFS encoded information.

This remarkable theorem implies that quantum computation can be
performed with only the exchange Hamiltonian between qubits. In Chapter
II we will have the opportunity to give explicit gate constructions in
the context of a solid-state exchange based quantum computer.

##### 55.1 Conjoining strong collective decoherence DFSs for
universality

Conjoining strong collective decoherence DFSs is slightly more
complicated than in the weak collective decoherence case because the
DFSs are now subsystems and not subspaces. Suppose we use a strong
collective decoherence DFS on @xmath qubits as our basic subsystem which
encodes @xmath qubits of information. On these @xmath qubits suppose we
encode into the subsystem with total angular momentum @xmath . Theorem
55.1 implies that the exchange Hamiltonian can be used to perform any
encoded @xmath on each of these individual subsystems.

When the two subsystems are conjoined, the resulting states inhabit many
different irreps of the conjoined system. This can be understood via the
rules of addition of angular momentum. If two @xmath irreps are
conjoined, then the resulting system will have support over irreps on
the conjoined system with total angular momentum @xmath .

  -- -------- -- -------
     @xmath      (326)
  -- -------- -- -------

where @xmath and @xmath label the degeneracies of the individual
subsystem and @xmath denotes the total degeneracy when the subsystems
are conjoined. In particular @xmath contains the tensor product of
@xmath and @xmath . If we let @xmath denote the Hilbert space of this
degenerate information, then

  -- -------- -- -------
     @xmath      (327)
  -- -------- -- -------

where @xmath contains the information in the @xmath th degeneracy and
@xmath denotes all of the other degeneracies. Via Theorem 55.1 we can
now perform any unitary manipulation on each of the subsystems. Thus we
can perform operations which act as operations whose final result is an
operation on @xmath . This will represent an encoded action between the
encoded subsystem.

It is important to note that while the two subsystem are conjoined,
strong collective decoherence errors will affect the different DFSs
indexed by @xmath . This decoherence can distinguish between the
different DFSs and thus it might appear that this would lead to problems
for the conjoined information. To see that this is not a problem, one
notes that the actions which distinguish between each of the different
@xmath only act to change the manner in which the conjoining is
achieved. During the course of an operation on two conjoined DFSs,
strong collective decoherence errors act on the @xmath index. When the
action on each of the @xmath irreps on the @xmath components is
identical, however, the effect of these errors only serve to perhaps
entangle the @xmath and @xmath degrees of freedom.

#### 56 Weak collective decoherence DFS preparation and measurement

In order to make use of a weak collective decoherence DFS for quantum
computation, we must, in addition to the universal manipulations
described above, be able to prepare and measure the states in the DFS.

Here we would like to note that it is not necessary to prepare states
that have support exclusively within the DFS, i.e. that have no
component outside of the DFS. This follows from the fact that in our
construction, while a computation is performed, there is no mixing of
states inside and outside of the DFS. If an initially prepared state is
“contaminated” (has support outside of the DFS we want to compute on),
then the result of the computation will have the same amount of
contamination, i.e. the initial error does not spread.

For example, suppose we can prepare the state @xmath where @xmath is a
state of a particular DFS and @xmath is a state outside of the DFS.
Computation on the DFS will proceed independently on the DFS and the
states outside of the DFS. Readout will then obtain the result of the
computation with probability @xmath . Repeated application can then be
used to magnify this computation. Thus perfect preparation is not a
strict requirement. Preparation which is not perfect, however, will
hinder the quantum computer and thus it is desirable to be able to
prepare DFS states.

For weak collective decoherence DFSs preparation of initial pure state
is rather simple. Purse state preparation into a DFS with a Hamming
weight @xmath corresponds to the preparation of a state with a specific
number of @xmath and @xmath (eigenstates of the @xmath ). This can be
easily accomplished if measurements in the @xmath basis are possible as
well as the ability to perform @xmath gates (to “flip” the bits).

The second crucial ingredient for computation on a DFS (in addition to
preparation) is the decoding or readout of quantum information resulting
from a computation. Once again, there are many options for how this can
be performed. For example, in the weak collective decoherence case one
can make a measurement which distinguishes all of the DFSs and all of
the states within this DFS by simply making a measurement in the @xmath
basis on every qubit. Further, all measurements with a given number of
distinct eigenvalues can be performed by first rotating the observable
into one corresponding to a measurement in the computational basis
(which, in turn, corresponds to a unitary operation on the DFS) and then
performing the given measurement in the @xmath basis, and finally
rotating back. There are other situations where one would like to, say,
make a measurement of an observable over the DFS which has only two
different eigenvalues. This type of measurement can be most easily
performed by a conjoined measurement [ 9 ] . In this scheme, one
attaches another DFS to the original DFS, forming a single larger DFS.
Then, assuming universal quantum computation over this larger DFS one
can always perform operations which allow a measurement of the first DFS
by entangling it with the second DFS, and reading out (destructively as
described for the weak collective decoherence case above) the second
DFS.

For example, suppose the first DFS encodes two bits of quantum
information, @xmath , @xmath , and the second DFS encodes a single bit
of quantum information @xmath , @xmath . Then one can make a measurement
of the observable @xmath on the first DFS by performing an encoded
controlled- NOT operation between the first and the second DFS, and
reading out the second DFS in the encoded @xmath basis. For the weak
collective decoherence case the ability to make this destructive
measurement on the ancilla (not on the code) simply corresponds to the
ability to measure single @xmath operations.

Finally, we note that for a weak collective decoherence DFS there is a
destructive measurement which distinguishes between different DFSs
(corresponding to a measurement of the number of @xmath ’s). One can
fault-tolerantly prepare a weak collective decoherence DFS state by
repeatedly performing such a measurement to guarantee that the state is
in the proper DFS. The conjoined measurement procedures described above
for any DFS are naturally fault-tolerant in the sense that they can be
repeated and are non-destructive [ 95 , 9 ] . Thus fault-tolerant
preparation and decoding is available for the weak collective
decoherence DFS.

#### 57 Strong collective decoherence DFS preparation and measurement

At first glance it might seem difficult to prepare pure states of a
strong collective decoherence DFS, because these states are nontrivially
entangled. However, it is easy to see that every DF subspace contains a
state which is a tensor product of singlet states:

  -- -------- -- -------
     @xmath      (328)
  -- -------- -- -------

because these states have zero total angular momentum. Thus a supply of
singlet states is sufficient to prepare DF subspace states. Further, DF
subsystems always contain a state which is a tensor product of a DF
subspace and a pure state of the form @xmath . This can be seen from
Figure ( 6 ), where the lowest path leading to a specific DFS @xmath is
composed of a segment passing through a DF subspace (and is thus of the
form @xmath ), and a segment going straight up from there to DFS @xmath
. The corresponding state is equivalent to adding a spin- @xmath (DF
subspace) and a spin- @xmath DF subsystem (the @xmath state of the
latter is seen to be made up entirely of @xmath ). In general, addition
of a spin- @xmath DFS and a spin- @xmath DFS simply corresponds to
tensoring the two states. Note, however, that addition of two arbitrary
DF subsystems into a larger DFS is not nearly as simple: concatenation
of two @xmath DFSs does not correspond to tensoring.

Pure state preparation for a strong collective decoherence DFS can thus
be as simple as the ability to produce singlet states and @xmath states
(it is also possible to use the @xmath or any of the other @xmath states
plus singlets). Other, more complicated pure state preparation
procedures are also conceivable, and the decision as to which procedure
to use is clearly determined by the available resources to manipulate
quantum states. The pure state preparation of singlets and computational
basis states has the distinct advantage that verification of these
states should be experimentally achievable. Such verification is
necessary for fault-tolerant preparation [ 95 ] .

Measurements on the strong collective decoherence DFS can be performed
by using the conjoined measurement scheme detailed in the weak
collective decoherence DFS discussion in Section 56 . In particular, by
attaching a strong collective decoherence DF subspace ancilla via such
conjoining, one can construct any conjoined measurement scenario. All
that remains to be shown is how to perform a destructive measurement on
such an ancilla.

One way to perform a destructive measurement on the @xmath strong
collective decoherence DF subspace was presented in [ 9 ] (for another
see [ 64 ] ). This scheme involves measuring @xmath , @xmath , @xmath ,
@xmath on the four qubits. To see how this measurement works, note that
the four qubit strong DF subspace is spanned by the two states

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (329)
  -- -------- -------- -------- -- -------

If measurement of @xmath and @xmath yields @xmath or @xmath , then one
declares that the state must be @xmath . If however, the measurement
yields, @xmath or @xmath , then the remaining two qubits are in the
states

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (330)
  -- -------- -------- -------- -- -------

Where we have rewritten the states in the eigenstates of @xmath : @xmath
. Measurement of @xmath on the remaining qubits then destructively
distinguishes between @xmath and @xmath .

Further, we note that the ability to perform a conjoined measurement
scenario by conjoining an ancilla DFS composed of a single
encoded-qubit, can be used to perform any possible conjoined DFS
measurement scenario. As mentioned in the weak collective decoherence
case, the conjoined measurement procedures are fault-tolerant. Thus we
have shown how to perform fault-tolerant preparation and decoding on the
strong collective decoherence DFS.

#### 58 Fault-tolerant quantum computation and collective decoherence
DFSs

So far we have shown how to implement universal computation with local
Hamiltonians on a collective DFS corresponding to a single block of
qubits. This construction assumes that the only errors are collective.
This is a very stringent symmetry requirement, which obviously becomes
less realistic as the number of particles @xmath increases
significantly. It is thus necessary to be able to deal with
perturbations that break the collective-decoherence
(permutation) symmetry. To deal with these perturbations we will have to
use a quantum error correcting code (QECC). This quantum error
correcting code will work on the encoded DFS information. We then say
that the DFSs are concatenated into a QECC.

One particular realization of this concatenation scheme was proposed in
[ 135 ] . In [ 135 ] DFS blocks of four particles (each block
constituting a single encoded qubit) into a QECC. The QECC in the outer
layer then takes care of any single encoded-qubit errors on each of its
constituent DFS-blocks. By choosing an appropriate QECC it is thus
possible to deal with the appropriate type of non-collective error on
the encoded DFS-qubits. More generally any dimensional collective DFS
can be concatenated into a fault-tolerant QECC scheme. In the previous
sections we have shown how to manipulate this information, how to
fault-tolerantly measure the information, and how to prepare the
information.

One issue arising with concatenation which we have not yet addressed is
the ability to fault-tolerantly detect leakage errors on a DFS.
Concatenation resulting in unreliable leakage detection would be
useless. However, this is not a problem here, since detection can easily
be performed when one has the ability to make some fault-tolerant
measurements on the DFS and also to perform universal manipulations over
any combination of DFS states. Both of these are valid with the DFS-QECC
concatenation, as we have summarized above. In particular, it is always
possible to measure the relevant observables for leakage by (i)
attaching ancilla encoded DFS states, (ii) performing the leakage
syndrome detection routine onto the ancilla states, and (iii)
fault-tolerantly measuring this ancilla ( [ 9 , 109 ] ).

We re-emphasize that the fault-tolerance in our proposed scheme is not
solely a result of properties of decoherence-free subsystems.
Decoherence-free subsystems must be combined with quantum error
correcting codes to achieve full fault-tolerant quantum computation.

#### 59 Collective decoherence and quantum computation

In this chapter we have seen how collective decoherence DFSs can be used
as a quantum computer. Of particular importance was the discovery that
one and two-body interactions are sufficient for universal quantum
computation on the encoding corresponding to the DFS. Furthermore,
realistically implementable preparation and measurement scenarios were
put forth. Thus we see that under some fairly non-stringent conditions
collective decoherence DFSs can be put to use to build a quantum
computer. This being said, the actual details of the implementations in
physical systems will have many important issues of actual execution of
the tasks we have described in this chapter. In the following two
chapters we detail some of the details of the using collective
decoherence DFSs in specific physical systems.

### Chapter \thechapter The Weak Collective Decoherence Ion Trap Quantum
Computer

The first physical realization of a decoherence-free subspace under
ambient conditions (i.e. naturally occuring decoherence) was realized in
a trapped ion experiment performed by a group at NIST [ 111 , 110 ] in
2001. In this chapter we discuss how to perform universal quantum
computation on the ion trap DFS of this experiment. The ion trap DFS
corresponds of [ 111 , 110 ] is the weak collective decoherence DFS. In
this chapter we discuss how to perform universal quantum computation on
clusters of these two qubit DFSs within the context of an ion trap
multi-qubit manipulation scheme proposed by Sørensen and Mølmer [ 179 ,
147 , 180 ] . This is an important concrete application of the concepts
presented in previous sections for universal quantum computation on a
DFS.

#### 60 The ion trap quantum computer

Ion traps are among the leading architectures for a future quantum
computer. In the ion trap quantum computing architecture multiple ions
are confined strongly in two directions ( @xmath and @xmath ) compared
to the confinement along a third direction ( @xmath ). With few numbers
of ions confined into an appropriate trap, the ions form a linear chain.
The physical qubits of an ion trap quantum computer are associated with
internal quantum numbers for each ion (usually hyperfine levels). The
internal state of the ions can be prepared using optical pumping and
highly efficient readout of the qubit state can be achieved via electron
shelving [ 151 , 166 , 22 ] .

The first proposal for an ion trap quantum computer was the proposal of
Cirac and Zoller [ 47 ] . These authors showed how to use the collective
center of mass motion of the trapped ions as a logical bus state for
enacting a nontrivial quantum operation between the internal states of
two ions. Combined with single qubit gates on the qubits and the
preparation and readout mentioned above, this showed that ions traps
could in principle realize all of the components needed for quantum
computation. In order to make this architecture scalable, some method of
moving ions between traps [ 205 ] or of coupling multiple traps together
[ 48 , 157 , 192 ] must be added onto this basic scheme.

Much progress has been made in the experimental demonstration of ion
traps as coherent manipulators of quantum information culminating with
the recent demonstration of an entangled state of four ions [ 165 ] .
The reader is referred to [ 184 , 205 ] for a review of some of the
basics of the ion trap quantum computer.

#### 61 The ion trap DFS

Among the particular achievements of ion trap quantum computing is the
recent demonstration of a DF subspace of two ions [ 111 , 110 ] . In the
experiment described in [ 111 , 110 ] a single ion was initially
prepared in the state @xmath . The physical qubits @xmath and @xmath in
this experiment corresponded to the @xmath , @xmath and @xmath , @xmath
sublevels of the @xmath ground state of a @xmath Be @xmath ion. A two
qubit interaction (of the form described in Section 62 below) was then
applied to this single qubit state and a prepared @xmath state of a
second ion. This two qubit interaction has the effect of moving the
information in the single qubit to a two qubit encoding

  -- -------- -- -------
     @xmath      (331)
  -- -------- -- -------

where @xmath . Note that @xmath span the same space as @xmath , @xmath .
The state then has been encoded into the weak collective decoherence DFS
@xmath . In the ambient conditions experiment, this state was then
allowed exposure to the environment and then the reverse encoding
procedure was applied and the state of the qubit was read out. A similar
experiment with no encoding and decoding but with preparation into the
state @xmath was also performed. From these two experiments, the
decoherence time without encoding was @xmath while the decoherence time
with the DFS encoding was @xmath . This, then, clearly demonstrates how
DF coding can result in protection of quantum information from
decoherence. Furthermore, the decoherence rates in this experiment were
severely limited by the fidelity of the encoding, decoding, and
preparation mechanisms. Thus it appears that the limiting decoherence
rate attained with the DFS encoding is mostly the result of the heating
of the trap. This heating is not seen as a fundamental obstacle to ion
trap quantum computing [ 205 ] but has so far defied identification.

We would like to address the issue of how to use the DFS encoded states
for quantum computing in the “quantum CCD” model of an ion trap quantum
computer [ 110 ] . In the quantum CCD model a large trap with many
independent microtraps is envisioned. The ions in the microtraps can
perform local quantum computations (using the microtraps vibrational
modes for the computation) and the ions from the microtraps can be moved
in between individual microtraps to realize the quantum circuit model. A
particularly nice feature of encoding into the DFS states in the quantum
CCD model is that spatial variation of magnetic fields will not dephase
the ions as they are moved around between the microtraps. The question
which arises when using the two qubit weak collective decoherence DFS
for ion trap quantum computing is how to perform manipulations of the
information stored in the traps without leaving the DFS. We will call a
quantum computer based around the encoded weak collective decoherence
DFS the ion trap DFS quantum computer .

#### 62 The Sørensen and Mølmer quantum gates

The four ion entanglement experiment [ 165 ] and the two ion DFS
experiment [ 111 , 110 ] both used a method for manipulating trapped
ions which was devised by Sørensen and Mølmer. This scheme [ 179 , 147 ,
180 ] is an improvement over the proposal given by Cirac and Zoller [ 47
] in that it does not require that the vibrational state of the center
of mass of the ions be cooled to the ground state. The Sørensen and
Mølmer scheme is fairly insensitive to the occupations of the
vibrational states of the trap. In this section we present an overview
of the Sørensen and Mølmer scheme and demonstrate how it can be used to
enact two different operations which we will then use to show how to
perform universal quantum computer on the ion trap DFS quantum computer.

@xmath ions in a linear trap interacting with a laser field of frequency
@xmath are described by the Hamiltonian

  -- -------- -- -------
     @xmath      (332)
  -- -------- -- -------

where

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (333)
  -- -------- -------- -------- -- -------

Here @xmath is the frequency of the vibrational mode, @xmath and @xmath
are the ladder operators for this mode, @xmath is the energy difference
between the ions internal states which are being used as qubits, and
@xmath is the Rabi frequency of the @xmath th ion. @xmath is the
Lamb-Dicke parameter which represents the projection of the laser @xmath
vector along the direction of the string ions and rms excursion of the
ionic center-of-mass along this direction and @xmath is the phase of the
laser on the @xmath th ion. We have replaced the position of the ions by
the ladder operators @xmath and assumed that the laser is close to a
sideband @xmath for a single vibrational mode. For simplicity, we will
also assume that @xmath : i.e. the coupling of the recoil to vibration
is the same for all ions. The center of mass mode is one for which this
assumption is valid. We assume also that the mode has been sufficiently
cooled so that we are in the Lamb-Dicke regime @xmath so that @xmath .
For simplicity of notation, we place the phase into a new operator
@xmath . We will further assume ions experience identical Rabi
frequencies, @xmath .

Notice that we have assumed that we can control the phase @xmath of the
laser on each ions. We will only need this single ion phase control for
the two qubit case. In this case the phase between the ions can be
adjusted by changing the oscillation frequency of the trap. By changing
the oscillation frequency of the trap, the ion spacing can be precisely
controlled and therefore the relative phase between the two ions can be
controlled [ 111 ] .

Consider two lasers acting on the string of ions and assume that these
are tuned to frequencies @xmath and @xmath . In the Lamb-Dicke limit in
the interaction picture with respect to @xmath , the interaction
Hamiltonian is given by

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (334)
                                @xmath   
  -- -------- -------- -------- -------- -------

where @xmath , @xmath , and the we have defined the operators

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (335)
  -- -------- -------- -------- -- -------

If the laser intensity is less than the detuning @xmath and the detuning
is close the sidebands then the Hamiltonian becomes

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (336)
  -- -------- -------- -------- -- -------

The evolution operator for this Hamiltonian is of the form

  -- -------- -- -------
     @xmath      (337)
  -- -------- -- -------

where

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (338)
  -- -------- -------- -------- -- -------

By choosing the time @xmath the ion-mode entangling components of the
gate vanish @xmath , @xmath and

  -- -------- -- -------
     @xmath      (339)
  -- -------- -- -------

such that the evolution is

  -- -------- -- -------
     @xmath      (340)
  -- -------- -- -------

We will call the gate @xmath Sørensen and Mølmer gates [ 180 ] . By
adjusting @xmath , @xmath and @xmath , the Sørensen and Mølmer gates
gives us basic Hamiltonian control over the (effective) Hamiltonian
@xmath .

#### 63 Universal quantum computation on the ion trap DFS quantum
computer

In this section we discuss how to use the Sørensen and Mølmer gates to
perform quantum computation on the ion trap DFS quantum computer.

##### 63.1 Single qubit rotations using Sørensen and Mølmer gates

Notice that the operation @xmath is not in the commutant of the weak
collective decoherence OSR algebra, @xmath . For the single qubit gates,
however, the Sørensen and Mølmer gates can still be used to perform
computation entirely within the ion trap DFS. Note however, that during
the operation of the Sørensen and Mølmer gates, the states are entangled
with the vibrational modes and are also not within the DFS. Before and
after the gates we will describe below, however, the DFS is preserved.
Thus these gates must be executed faster than the weak collective
decoherence of the system in order to not expose the system to too much
weak collective decoherence.

The single qubit gates on the ion trap DFS will be executed when @xmath
ions have been maneuvered such these two ions are the only ions in a
microtrap. Consider the following two ion operators

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (341)
  -- -------- -------- -------- -- -------

While neither of these operators in the in the commutant of the OSR
algebra form the weak collective decoherence case, the operations do
preserve the two qubit weak collective decoherence DFS. Specifically we
see that, neglecting the global phase shift produced by the identity
@xmath ,

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (342)
  -- -------- -------- -------- -- -------

We thus see that @xmath and @xmath act as encoded @xmath and @xmath
respectively on the @xmath , @xmath basis. These are examples of
operations which are not in the commutant but which preserve a
particular DFS. Note that these operations do not preserve all of the
@xmath qubit weak collective decoherence DFSs: DFS @xmath ( @xmath ) and
DFS @xmath ( @xmath ) are mixed.

Using the Sørensen and Mølmer gates we can implement the two Hamiltonian
evolutions

  -- -------- -- -------
     @xmath      (343)
  -- -------- -- -------

Thus encoded rotations about @xmath and @xmath are possible using the
Sørensen and Mølmer gates. These two operations in combination then
serve to generate any single qubit rotation on the encoded states @xmath
and @xmath .

##### 63.2 A nontrivial two qubit gate utilizing Sørensen and Mølmer
gates

Having shown how to implement single qubit gates on the ion trap DFS, we
now address the question of encoded two qubit operations. For encoded
two qubit operations two two-ion DFSs are brought together into a
microtrap where the four ions are subjected to Sørensen and Mølmer
gates. The conjoined qubits are now given by the states @xmath , @xmath
, @xmath , and @xmath .

Let us show that there is a particular choice of parameters for which we
can construct a Sørensen and Mølmer gate which acts non-trivially on the
DFS, preserving the conjoined DFS space, but which must take the state
out of the DFS during the course of the gate operation.

Consider the four ion operator

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (344)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

Disregarding the irrelevant global phase producing @xmath , we find that

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (345)
  -- -------- -------- -------- -- -------

Evaluating this for @xmath , we find that

  -- -------- -- -------
     @xmath      (346)
  -- -------- -- -------

This is a nontrivial gate on the two encoded DFSs:

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (347)
  -- -------- -------- -------- -- -------

This is a nontrivial encoded two-qubit gate between the ion trap DFSs.
Together with single qubit rotations, this forms a universal set of
gates.

The gate @xmath is a Sørensen and Mølmer gate executed with @xmath .
This condition is met if @xmath and the time to execute this operation
is given by [ 180 ]

  -- -------- -- -------
     @xmath      (348)
  -- -------- -- -------

If @xmath is required to satisfy the above condition, then the ion will
repeatedly cycle through being entangled with the system and the
vibrational mode and will only return fully to the DFS after the
completion of the operation. The gate we described above is exactly the
gate used to create four body entanglement in [ 165 ] .

#### 64 Universal quantum computation on the ion trap DFS

In the previous section we have seen how to perform gates on the ion
trap DFS which preserve the DFS. These gates, unlike our previous
discussion of universal gates on a DFS, do not preserve the DFS during
the entire operation of the interaction. This is reminiscent of the
universal set of operators described by Lidar, Bacon, Kempe, and Whaley
in [ 133 , 134 ] . If these gates are fast on the time-scale of the weak
collective decoherence mechanism, then these gates mesh nicely with the
theory of fault-tolerant quantum error correcting codes. The reader is
referred to for more information on this topic.

The example of the ion trap DFS is a good example of how encoding can be
used to reduce decoherence in a quantum computing architecture. Just
having an encoding which can help, however, is not in and of itself the
only necessary component of building a quantum computer. In this chapter
we have seen that using already developed methods for manipulating
trapped ions universal control of the encoded information can also be
easily achieved.

### Chapter \thechapter The Exchange-Based Quantum Computer

In this chapter we discuss a quantum computer based only on the exchange
interaction. This is particularly relevant to solid-state proposals for
quantum computation due to the difficulty in supplementing the exchange
interaction with other interactions to make the architecture fully
universal. In contrast to these original proposals, in this chapter we
discuss how to use encoded universality with the exchange interaction as
the basis for universal quantum computation. We begin by discussing some
of the generic properties of solid-state proposals including the
difficulty of engineering single qubit manipulations on these systems.
We then discuss the relevance of geometry, parallel operations, and
subsystems in an exclusively exchange-based solid state quantum
computer. An explicit proposal using the smallest possible encoding is
then proposed. Single qubit gates and a two-qubit gate are then
explicitly calculated. Finally, preparation, measurement, and leakage
are discussed so as the present a complete proposal for solid state
quantum computation using only the exchange interaction.

#### 65 Solid-state quantum computer proposals and the exchange
interaction

Among the plethora of experimental proposals for quantum computers there
has been widespread interest in a number of solid-state approaches [ 141
, 106 , 201 ] . In the majority of these proposals, a genuine spin-
@xmath particle is used as the basic qubit for the architecture. These
approaches have proposed as their basic qubit, for example, the spin of
a single electron on quantum dots [ 141 ] , donor-atom nuclear spins [
106 ] , and electron spins in heterostructures [ 201 ] . A common thread
throughout all of these spin-based solid-state architectures is their
use of the exchange interaction (also known as the Heisenberg
interaction) in order to produce two qubit gates between neighboring
spins. In all of these proposals, control of this exchange interaction
is then supplemented by single qubit gates in order to generate a fully
universal quantum computer.

Compared to the exchange interaction, the single qubit gates in most
solid-state proposals are considerably slower, require greater device
complexity and potentially lead to an increase in the decoherence rate
of the device. In the Table 5 , we assemble estimated exchange
interactions strengths, single qubit interaction times, and the
difficulty in constructing such single qubit interactions in a few of
the solid state based quantum computers.

Table 5 illustrates that removal of the requirement of single qubit
gates may greatly benefit these solid-state proposals. Luckily, we have
seen in Chapter II that the exchange interaction without the single
qubit gates can be used to perform encoded universal quantum
computation. The idea, then, is to use the exchange interaction alone
for solid-state quantum computers via encoding the quantum information.
In principle, the proof (see Appendix III ) of the universality of the
exchange interaction tells us that such a construction is possible.
Possibility however has little say in practicality. In this chapter we
will address some of the details of such an solely-exchange-based
quantum computer. From explicit gate constructions, to description of
preparation and measurement procedures, we therefore will construct the
basic outline of how an exchange-only based solid state quantum computer
would function.

#### 66 Universality and practicality

To get an idea of why it is important to understand the specifics of the
exchange interaction universality for practical purposes, consider the
results presented by Bacon et al. in [ 9 ] . This was the first work to
demonstrate that the exchange operation alone could be used to perform
quantum computation. In this work, the four qubit strong collective
decoherence DF subspace was used as the basis of the subsystems for the
quantum computer. After demonstrating how the exchange interaction could
be used to perform single qubit gates on this encoding, it was shown
that a controlled phase Hamiltonian could be realized on this encoding
via executing a complicated series of commutators involving exchange
interactions. In particular defining

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (349)
  -- -------- -------- -------- -- -------

We then find that the operator @xmath acts a two-qubit interaction
between two four-qubit encoded DFSs. If @xmath and @xmath denote the
encoded qubits in a particular basis, then @xmath acts as @xmath ,
@xmath , @xmath , @xmath . This operation can be used, in conjunction
with single qubit operations to perform universal quantum computation.

In a similar manner, because the proof in Appendix III is inductively
constructive it is always possible to exhibit such complex commutator
and linear combinations which enact any operation on the strong
collective decoherence DFS. Via the Kitaev-Solovay theorem, we know that
this gate set will be on equivalent footing with any other gate set,
yet, in a practical sense we have not seen how to implement this
interaction without resorting to the approximate formula Eq. ( 112 ).

An example of the problem we face will help explain this problem.
Suppose we were given the ability to perform the Hamiltonians @xmath and
@xmath and we wished to implement the Hamiltonian @xmath for a time
@xmath . Using a standard Euler angle construction we could perform a
series of evolution with @xmath and @xmath which would result in this
evolution. Suppose, however, instead of this Euler angle construction we
decided to use the Trotter approximation formula

  -- -------- -- -------
     @xmath      (350)
  -- -------- -- -------

to execute this gate. Recalling the definition of the error between two
unitary operators from Section 17.1 we can explicitly calculate this
error for our simple example. The results of this calculation are
plotted in Figure 9

Since the error scales line @xmath , in order to obtain an accuracy,
say, that is sufficient for the threshold for quantum computation which
is currently estimated at @xmath , we see that @xmath must be of order
@xmath . Given gates with an interaction strength @xmath , this implies
that these interactions must we switched on an off at a rate of @xmath
in order to obtain a reasonable approximation. For almost all proposals,
however, such rapid control of the system will not be achievable.
Without knowing about the Euler angle construction, then, the real world
functioning of the universality is unclear.

We are faced with the problem of knowing that the exchange gates are
universal but not knowing the explicit methods for explicit construction
of the gates in this set. Of course, one can always resort to the
Kitaev-Solovay theorem, which is constructive, to determine such gate
sequences. For situations larger than a few qubits, however, this is an
extremely daunting task to approach by brute force.

#### 67 Subsystems and geometric layout

Before we discuss universality on the solely-exchange-based quantum
computer, we must first discuss the subsystem structure of such a
quantum computer. In this chapter we will focus on the smallest encoding
which supports universality using the exchange interaction. This is the
subsystems encoding of one logical qubit into three physical qubits. In
this chapter we will not be concerned with the decoherence-free
properties of these states and will instead just focus on their use in a
quantum computer. Specifically, we will focus on the encoding

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (351)
  -- -------- -------- -------- -- -------

An important component of any quantum computer is the geometric layout
and connectivity of the physical qubits. In an encoded universality
construction it is especially important to consider the geometry of the
encoded qubits. We will consider three different geometries which will
probably best represent future solid-state device layouts. Other
arrangements are, of course, possible, but these layouts should be
representative of real world constraints imposed on most solid-solid
state systems.

In the first layout, which will call the one-dimensional layout , the
physical qubits are assumed to lie in linear succession. Only nearest
neighbor exchange interactions are allowed such that within an encoded
qubit only two of three possible exchanger interactions can be
implemented. This model is sketched in Figure 10 .

In the second layout, which we will call the triangular layout , the
physical qubits are assumed to be arranged in a linear succession of
triangular encoded qubits. Each triangle represents an encoded qubit and
successive triangles are only coupled by one exchange interaction. This
model is sketched in Figure 11 .

Finally the third layout, which we call the two-dimensional layout ,
consists of a square grid layout of physical qubits. The encoded qubits
are then grouped into triplets of physical qubits which can couple only
with other physical qubits which are nearest neighbors. This model is
sketched in Figure 12 .

Finally we will also have the opportunity to consider serial and
parallel operation of the device. In serial operation it is assumed that
only one exchange interaction between qubits can be turned on for a
single time period. In parallel operation, multiple exchange
interactions, perhaps with varying strengths, can be turned on for a
single time period. Of course, for full quantum error correction some
amount of parallel operation is necessary [ 2 ] , however for early
implementations of the exchange-only solid-state proposals, this will
not be an issue and considerable experimental simplification is expected
when operations are not enacted in parallel.

#### 68 Single encoded qubit gates using the exchange interaction

For single encoded qubit gates, the geometries described above motivate
two different scenarios. In the first scenario, only the exchange
interaction between qubits @xmath and @xmath can be enacted and in the
other scenario, interaction between all qubits can be enacted. We call
these situations the constrained and unconstrained geometries
respectively. Furthermore we must also consider the case where parallel
or serial operation is allowed. Thus we have four scenarios: parallel
constrained, parallel unconstrained, serial constrained and serial
unconstrained.

First, it is easy to calculate the explicit action of the exchange gates
on the logical basis defined in Eq. ( 351 ):

  -- -------- -- -------
     @xmath      (352)
  -- -------- -- -------

where we have used the @xmath , @xmath basis. We can also define the
encoded @xmath matrices in the obvious manner such that

  -- -------- -- -------
     @xmath      (353)
  -- -------- -- -------

Let us deal with two of the four scenarios, the parallel unconstrained
scenario and the parallel constrained scenario. In particular we can use
the fact that

  -- -------- -- -------
     @xmath      (354)
  -- -------- -- -------

Therefore if we allow parallel operations, then in both the
unconstrained and constrained geometries, we have the ability to enact
the Hamiltonians @xmath ( @xmath ) and @xmath (from above). Using an
Euler angle construction, we therefore have a method for constructing
every possible single qubit gate on this encoding. In particular every
single qubit gate can be constructed via a sequence like

  -- -------- -- -------
     @xmath      (355)
  -- -------- -- -------

for some combination of @xmath . The circuit for this procedure is given
in Figure 13 where the arrows indicate an exchange interaction between
the connected qubits for the duration specified beside the arrow.

When serial operations are required and a constrained geometry is used
it is impossible to construct certain rotations with only three
applications of the exchange gates. Notice that in this case there are
two possible orders for the application of the exchange interactions

  -- -------- -- -------
     @xmath      
     @xmath      (356)
  -- -------- -- -------

In order to understand why it is not possible to perform all single
qubit gates with these two orders of rotations it is useful to work in
the Bloch sphere description of single qubit rotations (see Chapter 4 of
[ 153 ] ), i.e. mapping the @xmath rotations onto @xmath .

Suppose we are given two vectors on the block sphere. If we can perform
any single qubit rotation, then we can manipulate these two vectors such
that they point in any direction consistent with the inner product
between the vectors unchanged. But now consider the first sequence in
Eq. ( 356 ). If we start the state in @xmath , then the first rotation
does nothing, the second rotation can reach a ring on the bloch sphere
which is not a great circle and the third rotation will finally be able
to rotate this state to everywhere on the Bloch sphere except a small
cap. This is illustrated in Figure 14 .

Similarly using the second sequence in Eq. ( 356 ) one can start with
the @xmath eigenstate of @xmath and there is an unreachable cap for this
sequence of operations. See the second sequence in Figure 14 .

Thus if we take these two vectors (the @xmath eigenstates of @xmath and
@xmath ) for each sequence there is a region which the vector cannot be
rotated to. Thus there are rotations which cannot be achieved by the
sequences in Eq. ( 356 ).

In order to be able to implement any single qubit gate on the serial
constrained scenario we must, in fact, use four exchange interactions.
In fact, with four operations there is an equivalence between
constrained exchange interactions and the three interaction
unconstrained case. One possible order for the four interactions is
given by

  -- -------- -- -------
     @xmath      (357)
  -- -------- -- -------

Choosing @xmath and @xmath , this becomes

  -- -------- -- -------
     @xmath      
     @xmath      (358)
  -- -------- -- -------

Different orderings of the four interactions allow for different three
interaction orderings. We therefore see that the four interaction
constrained model can be mapped onto the three interaction unconstrained
model.

To show that the three interaction unconstrained model is sufficient to
perform any single qubit operation one simply follows the standard
argument of an Euler angle constructions.

#### 69 Explicit encoded controlled-not using a sequence of exchange
interactions

Having shown how to explicitly construct the encoded single qubit
rotations the question now arises as to how to coupled together
different encoded qubits. This is a challenging question. The first item
to note is that there is no Hamiltonian which by itself will directly
enact a coupling which preserves the two logical qubits. To see this,
examine the two angular momenta on two conjoined encoded qubits

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (359)
  -- -------- -------- -------- -- -------

where @xmath . It is easy to see that no linear combination of exchanges
commutes with both of these operators unless the exchanges in the linear
combination act exclusively between the first three qubits or
exclusively between the final three qubits. But these are just the
encoded single qubit operators. Therefore there is no linear combination
of exchange operations which preserves the original DFSs.

In Appendix III we present a gate sequence for enacting a
controlled-phase between two four qubit strong collective decoherence
DFSs. This sequence uses parallel operations and was analytically
derived using insights gained from using the strong DFS basis. Working
with the three qubit strong collective decoherence DFSs is not as
amenable to such analysis because conjoining two strong collective
decoherence DF subsystems is not as straightforward as in the subspace
case.

In order to deal with deriving some nontrivial gate on our encoded
qubit, it is therefore necessary to resort to numerical searches. Much
of the difficulty of these searches arises from the fact that while the
four basis states @xmath , @xmath , @xmath , and @xmath have totals spin
@xmath , the complete space with these quantum numbers for six spins has
nine states and exchanges perform rotations on this nine dimensional
space. The numerical search algorithm then must search for a series of
exchanges confined to this @xmath dimensional space which performs a
nontrivial gate @xmath on the encoded qubits and any unitary matrix on
the five dimensional component of the space perpendicular to this
encoded space, i.e. @xmath where @xmath is any unitary matrix on the
@xmath dimensional perpendicular space. A numerical search for optimal
gates on the encoded states was performed in [ 62 ] . In this work
search for a controlled-not gate was performed with the aid of two
invariants identified by Makhlin. Explicitly, a controlled-not on the
basis states acts as

  -- -------- -- -------
     @xmath      (360)
  -- -------- -- -------

Figure 15 presents the optimal (in the sense of fewest exchange
interaction gates) serial operation solution for the one-dimensional
layout. In this figure, the @xmath values represent the duration of the
exchange interaction as in @xmath . In Figure 15 the serial operation
has been compressed where gates commute. The uncertainty of the final
digits is indicated in parenthesis and the accuracy of the gate is to
@xmath .

In Table 6 we assemble a list of the different optimal (in the sense of
the best found by the search algorithm) solutions for different
operation modes of described above. One shortcoming of our construction
is that it does not make use of the subsystem nature of collective
decoherence. A true controlled-not which preserves the subsystem
structure was searched for and none was found for less than @xmath
serial exchange interactions, although in parallel operation, sequences
with @xmath exchange interactions where found. It would be worthwhile to
obtain optimal gate sequences not only for the three qubit subsystem
example, but also to examine the four qubit subspace example. There are
certain simplifications which seem to imply that these gate sequences
for the subspace case might be simple enough even for analytical
treatment (as in the parallel operation of Appendix III ).

Together with the single qubit rotations described above the
controlled-not forms a universal gate set. The tradeoffs inherit in the
exchange-only based techniques are thus clear. For a factor of @xmath in
space and @xmath in clock cycles universality can be achieved using only
the exchange interaction.

#### 70 Preparation, measurement, and leakage

Finally let us describe preparation, measurement, and leakage detection
on the exchange-based quantum computer.

Preparation can be achieved by preparing the state @xmath . This state
can be prepared by turning on an exchange interaction of strength @xmath
between the first two qubits and a moderately strong magnetic field
@xmath pointing along the @xmath direction is applied such that @xmath .
With these physical parameters, the ground state of the system is @xmath
and a gap to the next excited state is of energy @xmath . Thus at low
temperature in comparison to this gap the encoded register will be
initialized to the @xmath state.

Measurement on the encoded qubit can be achieved in a variety of
manners. In particular if the singlet states of the first two qubits can
be distinguished from the triplet states of the first two qubits then
the encoded qubits can be distinguished. A method which meshes nicely
with our current scheme is the a.c. capacitance scheme proposed by Kane
[ 106 ] . When two electrons occupy a common potential well, in the
absence of a magnetic field, the Pauli exclusion principle mandates that
the singlet state of the two electrons lies at a lower energy than the
triplet state. Therefore an electrometer capable of detecting the number
of electrons occupying a bound state can be used to determine whether
the singlet or triplet is occupied. The a.c. capacitance scheme of Kane
is directly analogous to this procedure for the solid-state quantum
computing proposals.

Finally we can briefly address the problem of leakage in the
exchange-only setup. While encoded universality allows for an
interaction which was previously not fully universal to be used in a
universal manner, one of the tradeoffs is that there is a particular
nasty type of error which can occur in which the information in leaks
out of the encoded subspace. One particularly simple manner of dealing
with leakage errors is to engineer a system such that the subspace upon
which one is working on is the ground state of the system. If this is
the case, then at low enough temperature, the leakage errors will be
self-corrected by energy exchange with the environment. One way to
achieve this in our case is to apply exchange interactions with equal
strength between all three qubits and a moderate magnetic field along
the @xmath direction. In this scenario the @xmath and @xmath states are
the degenerate ground state of the system. Further, a.c. capacitance
probing of this system can be used to determine if states have leaked
outside of the subspace. Therefore leakage detection can be achieved via
this fairly straightforward methodology.

#### 71 Exchange-based quantum computation

In this chapter we have seen how to achieve quantum computation using
only the exchange interaction. This allows for a considerable device
simplification as well as fundamental speed increases for certain
solid-state quantum computation proposals. An important open question is
whether other quantum computing architectures would benefit from a
similar encoded universality.

### Chapter \thechapter Decoherence-Free Subspaces in Multilevel Atomic
Systems

  Decoherence-free subspaces in single atomic systems?

In this chapter we discuss the application of the theory of
decoherence-free subspaces to multilevel atomic systems. It is
interesting to question whether decoherence-free conditions can exist in
single atomic systems. We begin by developing a sort of no-go theorem
for DF subspaces with nondegenerate energy spectra. This leads to a
discussion of coherent population trapping and we demonstrate how
coherent population trapping can be thought of as a semi-classical DF
subspace.

#### 72 OSR DF subspaces in multilevel systems

Suppose we are given an atomic multilevel system with @xmath levels
labeled by the states @xmath , @xmath , with energies @xmath , which is
coupled to a free space electromagnetic field with modes labeled by
@xmath and polarizations @xmath . The Hamiltonian for this system is
given by:

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (361)
  -- -------- -------- -------- -- -------

where @xmath . In general the coefficient @xmath will separate out into
functions of @xmath and of @xmath : @xmath . This decomposition implies

  -- -------- -- -------
     @xmath      (362)
  -- -------- -- -------

The creation and annihilation operators @xmath and @xmath combined as we
have done form a single operator and therefore the OSR algebra from this
interaction is generated by @xmath and @xmath . The DF subspace
condition then becomes

  -- -------- -- -------
     @xmath      (363)
  -- -------- -- -------

for @xmath in a DF subspace defined by @xmath and @xmath . In order for
both of these conditions to be met, @xmath and the condition is really
one condition

  -- -------- -- -------
     @xmath      (364)
  -- -------- -- -------

where @xmath , @xmath , and @xmath . Thus the spectrum of @xmath
essentially determines the states for which the DF subspace condition is
fulfilled. However, we also desire that @xmath not take the state
outside of the DFS. We recall that this will be true if the diagonal
form of system Hamiltonian can be written so that it contains on states
from a particular DF subspace.

The first result we will prove along these lines is that degeneracy of
the system energy spectrum is necessary for a perfect DF subspace under
the condition that there are no completely isolated levels of the
multilevel system.

###### Lemma 72.1

A multilevel system with a non-degenerate energy spectrum does not
support a DF subspace (in the strict sense of not evolving) with respect
to interaction with an electromagnetic field if every energy level has
at least one non-vanishing transition from the state to another state (
@xmath for every fixed @xmath for at least one @xmath ).

Proof: Suppose that such a system did support a DF subspace. The
diagonalized form of the system Hamiltonian @xmath is unique @xmath
because the energy spectrum is non-degenerate by assumption. Via
arguments in Section 28.3 , the state @xmath must be a DF state for the
supposed DF subspace in order that @xmath preserve the DF subspace.
However @xmath acting on @xmath does not satisfy the DF condition
because there is at least one transition from @xmath to another state.
Therefore @xmath cannot be DF and there can be no DF subspace for this
setup.

This lemma implies that there can be no perfect DF subspace for a
multilevel atomic system unless there is a degeneracy in the energy
spectrum of the multi-level system. Furthermore it follows from the
proof of this lemma that the only way a DF subspace can exist in a
multilevel atomic system is if the DF subspace has support over
degenerate states of the system.

#### 73 Coherent population trapping and DF subspaces

Consider now an example from quantum optics which appears to be a DF
subspace but which violates Lemma 72.1 . This is the case of coherent
population trapping. Consider a three level system @xmath , @xmath , and
@xmath with nondegenerate energies @xmath , @xmath and @xmath ,
respectively. The levels are in the so-called @xmath configuration in
which the lower two levels @xmath and @xmath are coupled to a single
higher level @xmath . The transition between the @xmath and @xmath
levels is assumed to be strongly forbidden. We suppose that this atom is
being driven by two lasers of frequency @xmath and @xmath . See Figure
16 .

The semi-classical description of this problem is given by the
Hamiltonian

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
     @xmath   @xmath   @xmath   
  -- -------- -------- -------- --

where @xmath is the Rabi frequency associated with the laser with
frequency @xmath . In the interaction picture with respect to @xmath ,
this Hamiltonian becomes

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (366)
                                @xmath   
  -- -------- -------- -------- -------- -------

At resonance this becomes

  -- -------- -- -------
     @xmath      (367)
  -- -------- -- -------

This Hamiltonian has three eigenstates, two of which contain components
along the @xmath state and one of which does not. The eigenstate which
does not have a component along the @xmath state is given by the
coherent population trapped state

  -- -------- -- -------
     @xmath      (368)
  -- -------- -- -------

This state shares some of the characteristics of a state in a DF
subspace. The state does not couple to resonant radiation field even
though it is a state which is a superposition of states which
individually couple to the resonant radiation field.

Notice however that if the resonance condition is not met or the phases
@xmath fluctuate the trapped state is different than that given in Eq. (
368 ). In particular, this state is not robust to interaction with any
environmental electromagnetic field mode. However, in the semiclassical
picture given above, the trapped state is indeed isolated from the
driving lasers.

#### 74 DF subspaces with respect to spontaneous emission

Despite the fact that coherent trapped states are not examples of DF
subspaces, we can still use the idea of this trapped states within the
context of DF subspace for a multilevel atomic system subject to an
approximation of which processes are most likely to cause decoherence.

Consider again the @xmath configuration but now in a fully quantum
treatment. In this system, spontaneous emission from @xmath into the
@xmath and @xmath state is clearly possible. This is due to a @xmath or
@xmath term in the coupling Hamiltonian where @xmath is the creation
operator for the photon mode @xmath . Suppose @xmath . Spontaneous
emission from @xmath to @xmath can still occur, but now it must
transverse virtually through the @xmath mode. This occurs from higher
order interactions like @xmath and will in most cases be much weaker
that the spontaneous emission from @xmath .

If one derives a master equation for the @xmath configuration, unless
the interaction is taken to high enough order, the only decohering terms
when interacting with the electromagnetic vacuum are the spontaneous
emission terms. In such a treatment the Lindblad operators for the
@xmath configuration are given by

  -- -------- -- -------
     @xmath      (369)
  -- -------- -- -------

With respect to these Lindblad operators it is clear that there is a DF
subspace is given by the two ground states @xmath and @xmath ( @xmath
annihilates both of these states).

In general, multilevel atomic systems then can have DF subspaces with
respect to the spontaneous emission given by the states which do not
spontaneously emit. This observation is not very profound. Given,
however, that such states exist we can however ask the more interesting
question of how one can manipulate the information in these states. Of
significance here is that the multiple states which do not spontaneously
emit do not have strong transitions between themselves because if they
did this would be a spontaneous emission pathway.

#### 75 Manipulation of information in spontaneous emission DF subspaces

In order to understand how it might be possible to manipulate the
information stored in states which do not spontaneously emit, consider
the scenario diagramed in Figure 18 below.

Here four laser with frequencies @xmath illuminate a five level system,
four states @xmath which do not spontaneously emit and a fifth level
@xmath which is subject to spontaneous emission. Two of these
transitions are driven on resonance and the other two are driven at a
detuning of @xmath as shown in Figure 18 . The semiclassical Hamiltonian
for this system in the interaction picture is given by

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (370)
                                @xmath   
  -- -------- -------- -------- -------- -------

where we have assumed a fixed phase for all of the incident light and
@xmath are the Rabi frequencies of the transitions. Moving into a frame
rotating with @xmath and @xmath , this becomes

  -- -------- -- -------
     @xmath      (371)
  -- -------- -- -------

For simplicity we will assume that @xmath for all @xmath . There are
then two eigenstates of @xmath which have no support on the
spontaneously emitting state @xmath . These states are

  -- -------- -- -------
     @xmath      (372)
  -- -------- -- -------

which are eigenstates of @xmath with eigenvalue @xmath and @xmath
respectively. Thus we could imagine encoding a qubit of information into
the states @xmath and @xmath . It is then possible to use the above
transitions so that a gate which acts as @xmath over these two states is
achieved. Thus we see that it is possible to achieve differing phase
evolutions via the application of resonant coherent population trapping
beams and detuned coherent population trapping beams.

However, the question which now remains is how to perform other single
qubit operations other that the encoded @xmath ? We can show, in fact,
that it is not possible to first order in time for such transitions to
occur.

To see this, we note that the operations which we wish to enact are of
the form

  -- -------- -- -------
     @xmath      (373)
  -- -------- -- -------

The general coupling Hamiltonian of these five levels to laser fields
is, assuming only the allowed transitions,

  -- -------- -- -------
     @xmath      (374)
  -- -------- -- -------

where @xmath labels the laser mode of frequency @xmath , @xmath is the
energy of @xmath , @xmath is the energy of @xmath and @xmath is the
phase of the @xmath th mode on the @xmath th level @xmath . Examining
this Hamiltonian, it is apparent that there is no way to get an operator
like that in Eq. ( 373 ). In particular, no terms like @xmath appear in
this formula.

#### 76 Outlook

In this chapter we have addressed the issue of DF subspaces in
multi-level atomic systems. Interestingly we have seen that such
subspaces can exist under ideal assumptions only when a level is
degenerate. When levels are not degenerate, it is still possible that
ground states may be decoherence-free under the assumption of a vacuum
environment. Unfortunately, there are no first or processes which
preserve the DF subspace in such multilevel-level atomic systems for the
same reason that the DF subspace exists. An interesting question is the
existence of DF subsystems in multi-level atomic systems.

### Chapter \thechapter Decoherence-free Subsystems for Quantum
Computation

In part II of this thesis we have had the opportunity to examine a
particular method for avoiding the detrimental process of decoherence.
The experimental demonstration of a DF subspace in the ion trap quantum
computing architecture [ 111 , 110 ] (as well as proof-of-principle
demonstrations with engineered decoherence done by Kwiat, et al. [ 127 ]
) lends credit to the notion that the notion of DFSs will be an
important of future quantum computers. Theoretical arguments for DFSs in
other physical systems (of particular note are the solid state proposals
of Zanardi and Rossi [ 219 , 220 ] and the use of a decoherence-free
subspaces for creating Schrödinger cat states of a Bose-Einstein
condensate [ 54 ] ) also lend credit to the notion that decoherence-free
systems will play an important part in overcoming decoherence in
constructing a quantum computer.

An important lesson to be taken from DFSs is the notion that just
because a system has a high decoherence rate that does not mean that the
system cannot be used for robust quantum computation. Symmetries of the
system-environment coupling allow for system which might otherwise be
discarded as having “too high a decoherence rate” to be managed into a
realm where quantum computation may become possible.

DFSs are a good example of a small subsystems technique for dealing with
decoherence. They cannot and are not the end-all solution for quantum
computation for reasons which we have detailed in the previous chapters.
That being said, they can represent a large step towards making such a
solution technologically feasible.

## Part III Natural Fault Tolerance

### Chapter \thechapter The Road Ahead

  How difficult is it to build a quantum computer?

The discovery that fault-tolerant quantum computation can be used to
solve the decoherence problem was among one of the greatest theoretical
achievements of the end of the twentieth century. With enough control,
decoherence can be reversed! While this discovery is heartening to the
prospects of building a quantum computer, the road towards the eventual
construction of a quantum computer is far from paved and it is certainly
unknown if this pavement is made of gold or rather, as some pessimists
believe, mere asphalt.

Towards this end, there is much to be said for thinking deeper about
error correction, fault-tolerance, and the ultimate use of physical
systems to achieve the goal of quantum computation. In Part III of this
thesis, we make first steps towards the idea that building a quantum
computer may not be as difficult as early experiments and theoretical
understanding indicates. In particular we will eschew the notion that
quantum computers must be build from the single quantum system up in
lieu of the idea that there may be many-body quantum systems which are
naturally fault-tolerant .

One way to look at this is from the perspective of why classical
computers have achieved such success. When Turing, von Neumann and
others began thinking about constructing a physical device which carried
out the theoretical concepts of computer science, it was certainly
unclear that classical computers would eventually attain today’s amazing
speeds and versatility. Having achieved so much with the modern day
silicon revolution, it is important to realize, however, that strict
physical principles are responsible for the robustness of classical
computers . The discovery that decoherence is not a fundamental
roadblock towards building a quantum computer leads us to question
whether there are similar physical principles which can lead to the
robustness of a naturally fault-tolerant quantum computer.

### Chapter \thechapter Supercoherence

  No, decoherence, you cannot forever walk uphill!

One of the physical principles which helps make classical computers
robust is their use of energetics. In particular, a classical current in
a transistor is robust because the energetics of the device directs the
flow of information through the transistor. Classical conservation of
the energy helps transistors from not making errors. In this chapter we
take the first steps towards developing quantum systems which similarly
harness the power of the transfer of energy to reduce the destructive
effect of decoherence. We begin with a discussion of the relationship
between (near) energy conservation and decoherence pathways. We then
introduce a simple example of a supercoherent system using a Pauli
stabilizer error detecting code. A supercoherent system is a multi-qubit
system which has a ground state in which degenerate quantum information
is encoded. The degeneracy of this ground state is broken by single
qubit error and these single qubits errors take the ground state to a
state of higher energy. At low environment temperatures, decoherence is
then ineffective in destroying the coherence of the degenerate
supercoherent information. We then discuss the difficulties of
manipulating the information in the particular Pauli stabilizer example.
We then present an example of a supercoherent qubit for which universal
manipulation of the quantum information can be obtained while still
retaining supercoherence. Solid state implementation of the
supercoherent qubit is then discussed. A bath of harmonic oscillator
coupling to a supercoherent system is then analyzed and the
supercoherence is directly demonstrated. Finally it is demonstrated the
Cooper pairs are quantum error detecting codes for resistance causing
processes and the relationship of this to supercoherence is discussed.

#### 77 Energetics and decoherence

  It is typical of modern physicists that they erect skyscrapers of
  theory upon the slender foundations of outrageously simplified models

  –J.M. Ziman [ 221 ]

In the absence of coupling, a system and its environments have separate
dynamics governed by separate energy spectra. If a perturbing
interaction between the system and environment is then introduced, the
dynamics of the system and environment is dominated by mechanisms which
conserve the energies of the unperturbed system and environment energy
spectra. This is the essence of the rotating wave approximation in
quantum optics (see, for example, [ 5 , 169 ] ). Thus the flow (or lack
of flow) of energy between a system and the environment is, in the
perturbing regime commonly encountered, essential to determining the
effective mechanisms of decoherence. Let us examine a simple analytical
example which we can use to gain an understanding of this principle.

Consider a system consisting of a qubit and its environment also made of
a qubit. In the absence of coupling, we suppose the Hamiltonian of the
system is given by

  -- -------- -- -------
     @xmath      (375)
  -- -------- -- -------

where @xmath is the energy of the system and @xmath is the difference
between the energy of the system and the environment qubit. We set
@xmath and @xmath so as to set the positivity of the energies on a solid
footing. Now suppose that a perturbing interaction of strength @xmath is
introduced between these two qubits and is of the form

  -- -------- -- -------
     @xmath      (376)
  -- -------- -- -------

where @xmath is the interaction energy. The evolution operator for this
system can be exactly calculated and found to be

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (377)
                                @xmath   
                                @xmath   
                                @xmath   
  -- -------- -------- -------- -------- -------

where @xmath and @xmath . In the limit of @xmath (the perturbing
interaction limit), the coupling between the @xmath and @xmath states
reduces to the unperturbed evolution

  -- -------- --
     @xmath   
     @xmath   
  -- -------- --

Thus the evolution of the @xmath and @xmath subspace in the perturbing
limit is nearly identical to the unperturbed dynamics. The dynamics of
the @xmath and @xmath subspace, does not escape so easily and is more
drastically affected by the perturbing interaction. In the absence of
perturbation, the system has energies @xmath ( @xmath ) and @xmath (
@xmath ) and the environment has energies @xmath ( @xmath ) and @xmath (
@xmath ). When the perturbation is now turned on, the dynamics is
dominated by the action on the @xmath , @xmath pathways. These are
exactly the pathways which most closely conserve the original energies
of the system and environment. Furthermore the pathways which least
conserve energy and act on the @xmath and @xmath states contribute
little dynamics different from the normal evolution of these states.
This simple example then demonstrates how decoherence is dominated by
pathways which most nearly preserve the unperturbed energies of the
system and environment.

Under the assumption of such a perturbative interaction, energetics play
a key role in determining the rate of decoherence processes. The notion
that energetics plays a key role in determining decoherence rates is
often confused with the statement that “the most damaging decoherence is
that in which energy is not exchanged between the system and the
environment”. We emphasize here that the fact that the most damaging
decoherence is often of a form where no energy is exchanged between the
system and the environment is different from the fact that energetics
play a key role in determining the dynamics of decoherence. Certainly it
is true that the fact that energetics determines the decoherence
pathways allows decoherence which does not exchange energy to act, but
the reason why such decoherence is typically more destructive is not
related to the fact that decoherence is dominated by nearly energy
conserving dynamics.

Having emphasized that energetics is key in determining decoherence
dynamics, it is useful to place decoherence in three different
categories. Specifically, energy conserving decoherence has three
possible forms: energy is supplied from the system to the environment (
cooling ), energy is supplied from the environment to the system (
heating ), or no energy is exchanged at all ( non-dissipative ). Thus
even when the environment is a heat bath at zero temperature, cooling
and especially non-dissipative decoherence processes occur. A schematic
of these process is presented in Figure 19 .

Among the possible decoherence energetics, non-dissipative decoherence
is often, but not always, the most damaging source of decoherence. Of
the possible energetically favored pathways, the easiest to eliminate is
heating where energy is transferred from the environment to the system.
By cooling down the environment, heating can often be nearly completely
eliminated as a decoherence pathway. Cooling and non-dissipative
dynamics, on the other hand, cannot be eliminated by simply cooling the
environment.

#### 78 A simple Pauli stabilizer supercoherent quantum bit

Having shown that energetics dominates the allowed dynamics of
decoherence, we now present an approach to reducing decoherence which
relies on this observation.

Consider the smallest possible additive quantum error detecting code
which detects single qubit errors, the @xmath code (see Appendix G for
information on this nomenclature and stabilizer codes). The stabilizer
of this code is generated by the two Pauli operators

  -- -------- -- -------
     @xmath      (379)
  -- -------- -- -------

and encodes two qubits of information. The logical (informational)
operators for this code (modulo the stabilizer) are given by

  -- -------- -- -------
     @xmath      
     @xmath      (380)
  -- -------- -- -------

( @xmath , for each code, of course). A complete set of commuting
operators for this code is thus given by (for example) @xmath . We will
denote the basis corresponding to this complete set of commuting
operators by @xmath .

Now consider the Hamiltonian

  -- -------- -- -------
     @xmath      (381)
  -- -------- -- -------

The stabilizer of the @xmath code commutes with this Hamiltonian. @xmath
and @xmath also both commute with this Hamiltonian. This implies that
the action of the Hamiltonian acts only on the first encoded qubit.
Indeed we see that this Hamiltonian can be written in terms of this code
as

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (382)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

Notice how this Hamiltonian does not depend on the second qubit.
Therefore this Hamiltonian will have a spectrum which is two-fold
degenerate: this degeneracy corresponding to the second encoded qubit.

We recall that the codespace of the @xmath code is labeled by the
eigenvalues, @xmath and @xmath , of the stabilizer generators, @xmath
and @xmath respectively. For each set of eigenvalues for the stabilizer
generators the action of @xmath on the corresponding subspace is
different. In fact we see that

  -- -------- -- -------
     @xmath      
     @xmath      
     @xmath      
     @xmath      (383)
  -- -------- -- -------

The eigenvalues of @xmath for these four cases are thus @xmath and
@xmath respectively. We therefore see that the ground state of @xmath
will be within the @xmath subspace of the @xmath code and will be the
@xmath eigenvalue of @xmath over the first encoded qubit. But what about
the second encoded qubit? Here we see that the ground state of the code
is actually two-fold degenerate: corresponding directly to the second
encoded qubit. The spectrum of this Hamiltonian is given in Figure 20 .

The ground state of this Hamiltonian has a spectacular property with
respect to single qubit operators on this four qubit system. First
recall that the code stabilized by @xmath and @xmath is a single qubit
error detecting code. Thus every single qubit operator @xmath
anticommutes with at least one of @xmath and @xmath . This in turn
implies that every single qubit error flips the value of the eigenvalue
of @xmath or @xmath for every basis state @xmath .

For example, suppose we are in the state labeled by @xmath , with the
Hamiltonian eigenvalue of @xmath , and logical basis @xmath for the
second encoded qubit. This state is one of the ground states of @xmath ,
the other being the logical basis @xmath . The action of a single qubit
operation will act to change the value of @xmath or @xmath or possibly
both. In any case, this implies that the action of the single qubit
operator is to take the system from this ground state to one of the
higher energy eigenvalue states of @xmath . Diagrammed in Figure 21 is
the action of @xmath on the energy levels of @xmath

In fact we see that this is generically true for single qubit operators
acting on a system with this Hamiltonian. Every single qubit operator
changes a value of @xmath and @xmath and therefore takes the system from
the ground state to a higher energy state. We term such a Hamiltonian a
supercoherent Hamiltonian and make the following general definition:

###### Definition 78.1

(Supercoherence) A system of qubits with a system Hamiltonian @xmath
which has a degenerate ground state and for which every single qubit
operator takes the system out states in this degenerate ground state is
called a supercoherent Hamiltonian . In more generality, we may allow
the subsystems which make up the system to be take any desired subsystem
structure. The criteria used for supercoherence is then that every
operator on an individual subsystem must take the system out of the
degenerate ground state. If @xmath denotes the degenerate ground state
of the Hamiltonian @xmath , then the condition for supercoherence is

  -- -------- -- -------
     @xmath      (384)
  -- -------- -- -------

for all @xmath , @xmath in the degenerate ground state and @xmath is the
single subsystem operator @xmath acting on the @xmath th subsystem.
Information which has been encoded into the degenerate ground state of a
supercoherent Hamiltonian is referred to as a supercoherent qubit or
supercoherent qudit, depending on the dimension of the degeneracy.

Note that the supercoherence condition Eq. ( 384 ) implies the ground
states are an error detecting code for the operators single qubit
(subsystem) operators.

Why do we label such degenerate ground states supercoherent? The main
reason for this lies in the fact that the Hamiltonian of such a system
has been constructed so that the only single qubit operations which can
destroy the coherence of the system are interactions which heat the
system. As we mentioned previously, it is often possible to
substantially decrease such decoherence mechanisms by simply cooling the
system’s environment. We will have a chance to analytically demonstrate
this effect in Section 80 . In general, we expect that the condition for
supercoherence to hold will occur when the temperature @xmath (we set
@xmath ) is much less than the energy gap of from the degenerate ground
state to the lowest state excited by the single qubit operators. What
kind of robustness should we expect for the supercoherent qubit? If the
individual baths have a temperature @xmath , then we expect the
decoherence rate of the supercoherent qubit to scale at low temperatures
as @xmath , where @xmath . At low temperatures there should thus be an
exponential suppression of the decoherence.

It is helpful to compare a supercoherent qubit to a single qubit with
two different Hamiltonians.

First compare a supercoherent qubit to a single qubit with
non-degenerate energy levels @xmath . Now the single qubit error @xmath
is a error which takes the system from a state of higher energy to one
of lower energy. This error, then, will be involved in a cooling type
decoherence. The single qubit error @xmath takes the system from a state
of lower energy to one of higher energy. This is a heating type
decoherence. Finally the single qubit error @xmath does not change the
energy of the system but acts to dephase the system. Therefore this
error is of the non-dissipative form. In contrast to this single qubit
example, all single qubit errors acting on a supercoherent ground state
must take the system from the ground state to a state of higher energy.
Thus all of the above error @xmath , @xmath and @xmath are errors on the
supercoherent Hamiltonian of the heating form.

Second it is useful to compare the supercoherent qubit to a single qubit
with a degenerate Hamiltonian. In this case all @xmath errors act on
this qubit are of the non-dissipative form because the two qubits have
the same energy. This is in direct contrast to the supercoherent qubit
for which all errors are of the heating form. Degeneracy alone is not
enough for supercoherence.

##### 78.1 Encoded operations on the Pauli supercoherent qubit

Returning now the specific Pauli stabilizer supercoherent example we
began with, we can now ask the question of how to manipulate the
information encoded into the degeneracy. Nothing is worse than a quantum
memory which one cannot manipulate!

In this case, we already know how to manipulate the quantum information
in the degeneracy because this degeneracy is simply the second encoded
qubit. In particular the two-qubit operations @xmath and @xmath are
encoded single qubit rotations on this qubit. By turning on an off these
interactions it is therefore possible to perform computation any @xmath
rotation on the supercoherent qubit.

The question which is immediately raised, however, is how turning on an
off the interactions affects the supercoherent property of the system.
Suppose that we have a supercoherent system with a gap from the ground
state to the single qubit excited states of energy @xmath . When we turn
on @xmath or @xmath , we want to make sure that this gap is still
preserved and the supercoherent property that any single qubit gate will
take the supercoherent qubit to a state of higher energy is maintained.

In order for the gap to be still maintained the interaction strength
must be weak in comparison with the temperature of the bath. To see
this, we note that @xmath and @xmath break the degeneracy of the system.
If these interactions are of strength @xmath , then this degeneracy is
split by @xmath . The gap of size @xmath is therefore shrunk by @xmath
where @xmath is a prefactor which may be state dependent. In order to
maintain the supercoherent condition, this shrinking must not remove the
condition that the gap is large compared to the temperature of the bath.
Thus if @xmath , the gap is maintained while the computation is being
performed.

Also notice that the manipulation of the degenerate information does not
change the fact that single qubit interactions take the ground states
(which are no longer degenerate due to the interaction) to states of
higher energy. To see this is sufficient to notice that the interactions
we implement act only on the degeneracy. If, for example, we tried to
implement a @xmath on the codespace with @xmath , we would act not only
on the degenerate supercoherent qubit, but also on the space of the
Hamiltonian @xmath .

Having shown how to perform single qubit rotations on the information in
the supercoherent qubit, we can now ask the question of whether it is
possible to perform universal quantum computation to perform universal
quantum computation on conjoined sets of such supercoherent qubits. The
difficulty here is that any two qubit interaction which acts between two
conjoined supercoherent qubits act as single qubit operations on each
individual supercoherent systems. Therefore any two qubit interaction
necessarily excites the information in the supercoherent ground state to
an excited energy level. Of course, we could resort to more than two
qubit interactions. This method, however, is highly unlikely to be
practical and we will therefore disregard this technique.

One method for overcoming this problem is, when an interaction between
the encoded qubits is desired, another set of Hamiltonians is turned on
which maintains the ground state condition of the individual
supercoherent qubits but also creates other ground states which are
degenerate with these states. Manipulation of the quantum computation is
then performed over this larger supercoherent ground state. We know of
no such method for the Pauli stabilizer supercoherent example we have
just presented, however, in the next section we will present a more
complicated supercoherent system which can be used to perform universal
quantum computation in a manner similar to what we have just described.

#### 79 Exchange-based supercoherent quantum bit

Amazingly there is a supercoherent system which is intimately related to
the strong collective decoherence DFS states which we have so thoroughly
studied in Part II of this thesis. Consider the Hamiltonian

  -- -------- -- -------
     @xmath      (385)
  -- -------- -- -------

where we recall that @xmath . This Hamiltonian has eigenvalues @xmath ,
with corresponding eigenstates given by the strong DFS basis @xmath .

Let us briefly recall the definitions of the strong DFS basis for
completeness. Let @xmath be a Hilbert space of @xmath qubits, and let
@xmath be the @xmath th Pauli spin operator acting on the @xmath th
qubit tensored with identity on all other qubits. The @xmath satisfy the
commutation and anticommutation rules, @xmath and @xmath . We define the
@xmath th partial collective spin operators on the @xmath qubits, @xmath
. The total collective spin operators acting on all @xmath qubits,
@xmath , form a Lie algebra @xmath which provides a representation of
the Lie algebra @xmath : @xmath . Thus @xmath can be decomposed in a
direct product of irreducible representations (irreps) of @xmath ,
@xmath , where @xmath is the @xmath dimensional irrep of @xmath which
appears with a multiplicity @xmath . If we let @xmath be the operators
of the @xmath dimensional irrep of @xmath , then there exists a basis
for the total collective spin operators such that @xmath . Corresponding
to this decomposition of @xmath , the Hilbert space @xmath can be
decomposed into states @xmath classified by quantum numbers labeling the
irrep, @xmath , the degeneracy index of the irrep, @xmath , and an
additional internal degree of freedom, @xmath . A complete set of
commuting operators consistent with this decomposition and providing
explicit values for these labels is given by @xmath [ 109 ] . Therefore
a basis for the entire Hilbert space is given by @xmath , where @xmath
and @xmath . The degeneracy index @xmath of a particular irrep having
total collective spin @xmath is completely specified by the set of
partial collective spin eigenvalues @xmath , @xmath : @xmath . This
degeneracy is simply due to the ( @xmath ) different possible ways of
constructing a spin- @xmath out of @xmath qubits.

Thus the (possibly degenerate) ground state of the Hamiltonian in Eq. (
385 ) is given by the lowest @xmath states for a particular @xmath . For
@xmath even, these states have @xmath , and for @xmath odd they have
@xmath . Furthermore, @xmath can be constructed from two-qubit
interactions alone:

  -- -------- -- -------
     @xmath      (386)
  -- -------- -- -------

Thus we see that @xmath is nothing more than the Heisenberg coupling
@xmath acting with equal magnitude between every pair of qubits. The
identity component of @xmath produces only a trivial global phase on the
system and is not relevant to our discussion.

@xmath has a highly degenerate spectrum, with energies determined by
@xmath . To determine the effect of single qubit operations on these
states we first examine the effect of a single qubit operation on the
@xmath th qubit, @xmath . Since @xmath for @xmath , we see that @xmath
can not change the degeneracy index @xmath of a state @xmath . Let
@xmath (defined for @xmath ). @xmath determines which final step is
taken in making the addition from qubit @xmath to qubit @xmath (see
Figure 22 ). If the final step from @xmath to @xmath was taken by adding
@xmath , then the eigenvalue of @xmath will be @xmath , while if it was
taken by subtracting @xmath , then @xmath . It is convenient to replace
@xmath by @xmath in our set of commuting operators, which can clearly be
done while still maintaining a complete set of commuting operators. We
can then replace the quantum number @xmath by @xmath , to obtain the
basis @xmath . It is easy to verify that @xmath . If we examine the
effect of @xmath on the basis @xmath (where we have defined @xmath as
the orientation corresponding to @xmath ), then we find that

  -- -------- -- -------
     @xmath      
     @xmath      (387)
  -- -------- -- -------

Thus we see that the only non-zero matrix elements occur when @xmath or
@xmath . From this it follows that the final step in the paths of Figure
22 can either flip sign ( e.g. , @xmath ) or else must remain the same.
Using the relation between @xmath and @xmath above, shows that this
results in the selection rules @xmath for @xmath acting on states in the
@xmath basis. Note further that if we had chosen a basis with @xmath
instead of @xmath in Eq. ( 387 ) ( @xmath ), we would have obtained the
same selection rule but now the @xmath components could be mixed by the
operation of @xmath . We recall (see Appendix III ) that the exchange
operation @xmath which exchanges qubits @xmath and @xmath modifies only
the degeneracy index @xmath of the @xmath basis. Because @xmath , this
implies that any single qubit operator @xmath can therefore give rise to
mixing of both the spin projections @xmath , and of the degeneracy
indices @xmath .

These selection rules must be modified for the @xmath states. @xmath and
@xmath for all @xmath states and any transitions between these states
will therefore have zero matrix element, i.e. , @xmath . Thus the
transitions @xmath are forbidden for @xmath , and @xmath must take
@xmath states to @xmath states. Furthermore, since @xmath , the
degeneracy index @xmath for @xmath states is not affected by any single
qubit operation.

To summarize, we have shown that any single qubit operation @xmath
enforces the selection rules @xmath with the important exception of
@xmath which must have @xmath . The degenerate @xmath states are
therefore a quantum error detecting code for single qubit errors [ 10 ,
109 ] , with the special property that they are also the ground state of
a realistically implementable Hamiltonian.

Figure 22 shows that for an even number of qubits the @xmath ground
state of @xmath is degenerate. For @xmath physical qubits the ground
state is two-fold degenerate [ 216 ] . This degeneracy cannot be broken
by any single qubit operator and single qubit operations must take the
@xmath states to @xmath states as described above. This ground state is
therefore a supercoherent qubit. If each qubit couples to its own
individual environment, we expect that the major source of decoherence
for this ground states will indeed be the processes which take the
system from @xmath to @xmath .

##### 79.1 Encoded operations on the exchange-based supercoherent qubit

We now turn to the question which we could not solve for the Pauli
stabilized supercoherent qubits. In order to be useful for quantum
computation, the supercoherent qubits should allow for universal quantum
computation. Extensive discussion of fault-tolerant universal quantum
computation on qubits encoded in decoherence-free subsystems has been
given in Chapter II where it was shown that computation on these encoded
states can be achieved by turning on Heisenberg couplings between
neighboring physical qubits. This means that we need to add extra
Heisenberg couplings to the supercoherent Hamiltonian @xmath . For a
single supercoherent qubit these additional Heisenberg couplings can be
used to perform any SU @xmath rotation, i.e. , an encoded one-qubit
operation. In the present scheme one would like this additional coupling
to avoid destroying the energy gap which suppresses decoherence. This
can be achieved if the strength of the additional couplings, @xmath , is
much less than the energy gap, i.e. , @xmath . The trade-off between the
decoherence rate and the speed of the one qubit operations can be
quantified by calculating the gate fidelity @xmath . @xmath quantifies
the number of operations which can be done within a typical decoherence
time of the system. For small @xmath the gates are slower while for
larger @xmath the gap is smaller resulting in a tradeoff. @xmath is
minimized for @xmath . At this minimum @xmath is still exponentially
suppressed for lower temperatures, in particular, @xmath .

Of more concern for the present scheme is how to perform computation
between two encoded supercoherent qubits, the question which perplexed
us in the previous section. In Section 69 we saw that using only
Heisenberg couplings, a nontrivial two encoded qubit gate cannot be done
without breaking the degeneracy of the @xmath Hamiltonian on the two
sets of four qubits. This can be circumvented by considering a joint
Hamiltonian of the eight qubits, @xmath . This Hamiltonian has a ground
state which is @xmath -fold degenerate, including the tensor product
states of the degenerate ground state of the @xmath Hamiltonian. The
universality constructions previously presented in Chapter II and
explicitly in Appendix III can then easily be shown to never leave the
ground state of this combined system. Thus we see that we can circumvent
the problem of the previous section. When a gate between two conjoined
exchange-based supercoherent qubits is needed, additional exchange
interactions must be turned on to obtain the Hamiltonian @xmath and
additional exchanges must be used to produce a nontrivial gate between
the two conjoined supercoherent qubits.

##### 79.2 Implementation of the exchange supercoherent qubit in quantum
dot arrays

The technological difficulties in building a supercoherent qubit are
daunting but we believe within the reach of present experiments. In
particular the supercoherent qubit states appear perfect for solid state
implementations of a quantum computer using quantum dots [ 141 , 64 , 63
] . Related encodings on @xmath -qubit states were recently shown to
permit universal computation with the exchange interaction alone in [ 62
] . The main new requirement for the supercoherent encoding, which
allows the additional exponential suppression of decoherence, is the
construction of @xmath and @xmath . @xmath can be implemented by a two
dimensional array with Heisenberg couplings between all four qubits.
@xmath poses a more severe challenge, since the most natural geometry
for implementing this Hamiltonian is eight qubits on a cube with
couplings between all qubits. Such structures should be possible in
quantum dots by combining lateral and vertical coupling scheme. Finally,
estimates of the strength of the Heisenberg coupling in the quantum dot
implementations are expected to be on the order of @xmath meV [ 141 , 64
, 63 ] . Thus we expect that at temperatures below @xmath meV @xmath K,
decoherence should be suppressed for such coupled dots by encoding into
the supercoherent states proposed here.

#### 80 Harmonic baths coupled to a supercoherent qubit

As an example of the expected supercoherence we consider a quite general
model of @xmath qubits coupling to @xmath independent harmonic baths for
the exchange-based supercoherent qubit. The unperturbed Hamiltonian of
the system and bath is @xmath where @xmath is the creation operator for
the @xmath th bath mode with energy @xmath . The most general linear
coupling between each system qubit and its individual bath is @xmath .
According to the selection rules described above we can write @xmath ,
where @xmath takes states @xmath to @xmath (and acts on @xmath and
@xmath in some possibly nontrivial manner) and @xmath is the set of
allowed transitions @xmath . In the interaction picture, after making
the rotating-wave approximation [ 169 ] , this becomes

  -- -------- -- -------
     @xmath      
     @xmath      (388)
  -- -------- -- -------

where @xmath . Coupling to thermal environments of the same temperature,
under quite general circumstances (Markovian dynamics, smooth spectral
density of the field modes) we are led to a master equation (see for
example [ 169 ] )

  -- -------- -- -------
     @xmath      (389)
  -- -------- -- -------

with @xmath . The only operators which act directly on the supercoherent
qubit are @xmath . The relative decoherence rates satisfy @xmath where
@xmath is the thermal average Bose occupation number @xmath . Thus we
see, as predicted that the supercoherent qubit decoheres at a rate which
decreases exponentially as @xmath decreases below @xmath .

#### 81 Cooper pairs as error detecting codes and supercoherence

Finally let us mention an interesting connection between our
supercoherent constructions and Cooper pairs in superconductivity. In
the standard derivation of superconductivity as initially put forth by
Bardeen, Cooper, and Schrieffer [ 11 ] electrons with energies near the
Fermi energy of a metal interact via the exchange of a phonon producing
an attractive effective potential between the electrons. The Hamiltonian
which describes the system is well described by [ 11 ]

  -- -------- -- -------
     @xmath      (390)
  -- -------- -- -------

where @xmath is the single electron annihilation operator for an
electron with wavenumber @xmath and spin @xmath , @xmath is the energy
of an electron with wavenumber @xmath , and @xmath represents the
attractive coupling. The ground state of the superconductor to a good
approximation (in the thermodynamic limit) is [ 11 ]

  -- -------- -- -------
     @xmath      (391)
  -- -------- -- -------

where @xmath and @xmath are real coefficients and @xmath is the vacuum
state. The ground state is composed of Cooper pairs of electrons with
opposite momentum @xmath . If we work in the frame of reference which is
drifting with the superconducting current, then the types of effects
which normally establish resistivity in a conductor are those that
change the momentum of a single electron (via scattering from
impurities, phonons, etc). We will now show that Cooper pairs are a form
of quantum error detecting code for these single electron scattering
processes.

We recall that the open system evolution of a system which is initially
decoupled from its environment is described in the operator-sum
representation [ 126 ] as @xmath where @xmath . Quantum error correction
and detection begin by expanding @xmath in terms of a suitable basis
@xmath of possibly non-unitary “error” operators. A sufficient condition
for the detection of such processes on a code with states @xmath
representing the encoded quantum information is given by [ 120 ]

  -- -------- -- -------
     @xmath      (392)
  -- -------- -- -------

Consider now a single Cooper pair with different wavenumbers @xmath and
@xmath : @xmath and @xmath . Any error operator @xmath which acts on
only one of the electrons and changes the momentum of the electron, the
operators which would normally cause resistance, can easily be seen to
satisfy @xmath because of the orthogonality of states on the electron
which is not operated on. Further because @xmath changes the momentum of
the single electron,

  -- -------- -- -------
     @xmath      (393)
  -- -------- -- -------

for both @xmath and @xmath . We therefore see that Cooper pairs satisfy
Eq. ( 392 ) for all resistance causing interactions. Cooper pairs, then,
are quantum error detecting codes for resistance cause scattering. If we
could store quantum information in the wavenumber of a Cooper pair then
we could use these Cooper pairs as a supercoherent system. We note here
that the fact that Cooper pairs are single electron error detecting
codes which exhibit supercoherence does not however explain the zero
electrical resistance of superconductors. It is interesting to note,
however, the connections between Cooper pairs and supercoherence.

#### 82 Supercoherence and the importance of energetics

In this chapter we have introduced the notion of supercoherence. When
the interaction between a system and its environment is perturbing
(which is the case in most systems of interest) decoherence follows
pathways which preserve the unperturbed system and environment energies.
This allows us to construct a method for avoiding decoherence by
engineering the system Hamiltonian such that all single qubit
decoherence processes are processes which heat the system. Thus by
cooling the environment decoherence in a supercoherent system can be
minimized. We have therefore harnessed the power of energetics to help
strengthen the resistance of quantum information to decoherence. This
represents a small step towards constructing a system which has
resistance to decoherence built into the natural evolution of the
system.

### Chapter \thechapter A Supercoherent Spin Ladder with Error
Correcting Properties

  To be an Error and to be Cast out is part of God’s Design

  – William Blake

In this chapter we study a spin ladder which has both supercoherent and
error correcting properties. We begin by presenting a stabilizer
encoding which maps this model into clusters of Ising models with
transverse fields. We then explicitly calculate the spectrum of this
model and show that there is a unique two-fold degenerate ground state
for this spin ladder. It is then shown that this ground state detects
single bit flips and corrects multiple phase errors. The ground state is
therefore supercoherent with the added benefit of being quantum error
correcting. We then discuss the role of encoded operations on this state
and conclude with some discussion of the shortcomings of this spin
ladder for quantum computation.

#### 83 Description of the spin ladder

Suppose we are given a spin ladder of @xmath qubits. We label these
qubits via the indices @xmath where @xmath and @xmath with the operator
@xmath acting on the @xmath th qubit tensored with identity on all other
qubits as @xmath . Define the two operators

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (394)
  -- -------- -------- -------- -- -------

The spin ladder we consider is the sum of these two Hamiltonians with
equal negative strengths

  -- -------- -- -------
     @xmath      (395)
  -- -------- -- -------

where @xmath . This spin ladder is sketched in Figure 23

Let us begin by understanding the intuition behind why this spin ladder
system may have interesting supercoherent properties. The ground state
of this spin ladder system will attempt to minimize the energy of the
total Hamiltonian. Any given qubit is acted upon by an interaction which
acts as @xmath or @xmath where the first qubit is the qubit of concern
and the other qubit is one of the qubits neighbors. We call such
couplings between the qubits bonds. If we individually diagonalize the
interactions corresponding to the bonds, single qubit interactions
@xmath act to change the eigenvalue of each of these operators. In
particular, because we are dealing with Pauli operators, the eigenvalue
will flip sign and therefore increase in energy. The real ground state,
of the system, of course cannot be analyzed in such a manner because all
of the bond operators do not commute. However, it is not unreasonable
that the ground state will maintain some of this intuition, that single
qubit interactions increase the energy and indeed we will see that our
intuition does pay off and this is exactly what happens. Such spin
ladders are known as frustrated spin ladders [ 187 ] due to the
competition of the different bonds in establishing a ground state.

##### 83.1 Stabilizer encoding

There are two transformations which make exact calculation of the
spectrum of this spin ladder possible. The first of these is a Pauli
stabilizer encoding (see Appendix G ). Instead of the Pauli basis @xmath
, consider instead the following set of Pauli operators

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (396)
  -- -------- -------- -------- -- -------

In particular, there is an encoding of information such that @xmath act
as corresponding Pauli operators on the first qubit and @xmath act as
corresponding Pauli operators on the second qubit. In fact this encoding
is simply the controlled-not basis change on the qubits from adjacent
qubits connected by the rungs of the ladder

  -- -------- -- -------
     @xmath      (397)
  -- -------- -- -------

Under this basis, we find that the spin ladder Hamiltonian becomes

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (398)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

At this point it is useful to introduce a basis corresponding to the
operators Eq. ( 396 ). A complete set of commuting operators
corresponding to this basis is given by the operator @xmath and @xmath .
We label this basis by the @xmath eigenvalues of these operators as
@xmath . We will sometimes abbreviate this as @xmath under the obvious
correspondence.

Under this basis

  -- -------- -- -------
     @xmath      (399)
  -- -------- -- -------

Now @xmath is either @xmath if the signs of @xmath and @xmath differ or
@xmath if the signs of @xmath and @xmath are identical. This
identification allows us to see that the spin ladder Hamiltonian Eq. (
398 ) acts as a different Hamiltonian depending only the value of @xmath
. In particular we see that

  -- -------- -- -------
     @xmath      (400)
  -- -------- -- -------

where

  -- -------- -- -------
     @xmath      (401)
  -- -------- -- -------

Notice @xmath is a list over @xmath of either @xmath or @xmath . We
therefore see that the spin ladder Hamiltonian has been brought to a
block diagonal form where each of the blocks corresponds to a given
@xmath . Given a particular block with a @xmath the values of the @xmath
@xmath then specify the exact form of the Hamiltonian in this block.

We will now focus on these block diagonal Hamiltonians for a fixed
@xmath . We see that a Hamiltonian for a particular @xmath corresponds
to multiple Ising chains in a transverse field. Define the Ising chain
with a transverse field Hamiltonian as

  -- -------- -- -------
     @xmath      (402)
  -- -------- -- -------

and the transverse field only Hamiltonian as

  -- -------- -- -------
     @xmath      (403)
  -- -------- -- -------

The Hamiltonian over the @xmath qubits for a fixed @xmath is given by a
sum of such chains with transverse fields and transverse fields only:

  -- -------- -- -------
     @xmath      (404)
  -- -------- -- -------

Since each of the @xmath @xmath act on different @xmath qubits they can
each be individually diagonalized and the total energy added up. For the
systems with simply a transverse field this is trivially achieved. The
eigenstates are simply the single qubit configurations of the qubits
pointing with or anti to the transverse field. Luckily, also, we can
analyze the Ising chains with a transverse field and find analytical
expressions for the energy and eigenstates of these chains up to a small
correction.

##### 83.2 The one dimensional Ising chain in a transverse magnetic
field

We need to consider an Ising chain of length @xmath in a transverse
field of the form

  -- -------- -- -------
     @xmath      (405)
  -- -------- -- -------

where we have relabeled our qubit operators in an obvious notion for
simplicity in this calculation. We follow the calculation in [ 40 ] .
Define the raising and lowering operations

  -- -------- -- -------
     @xmath      (406)
  -- -------- -- -------

such that

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (407)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

Henceforth, we will drop the identity constant @xmath and recover such
constant terms at the end of our calculation (they will turn out to be
important!).

Next we can use the Jordan-Wigner transformation to take this model,
which is that of hard-core bosons, from spin operators to fermions. In
particular if we define

  -- -------- -- -------
     @xmath      (408)
  -- -------- -- -------

then we see that the operators @xmath are fermionic operators satisfying

  -- -------- -- -------
     @xmath      (409)
  -- -------- -- -------

Expressing our model in terms of the fermionic operators we find

  -- -------- -- -------
     @xmath      (410)
  -- -------- -- -------

where addition is done modulo @xmath and @xmath is a correction

  -- -------- -- -------
     @xmath      (411)
  -- -------- -- -------

We will ignore the correction term @xmath for now and return to the
effect of this term later. Notice also that this correction term only
appears when @xmath .

To diagonalize this Hamiltonian it is useful to work first with fermions
in momentum space

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (412)
  -- -------- -------- -------- -- -------

where @xmath with @xmath for @xmath even and @xmath for @xmath odd.
Check that these still obey the fermion rules:

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      (413)
     @xmath   @xmath   @xmath      
  -- -------- -------- -------- -- -------

We can compute that

  -- -------- -- -------
     @xmath      (414)
  -- -------- -- -------

So that

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (415)
  -- -------- -------- -------- -- -------

Thus we find that

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
              @xmath   @xmath   
  -- -------- -------- -------- --

To diagonalize this Hamiltonian we apply a Bogoliubov transformation

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (417)
  -- -------- -------- -------- -- -------

where @xmath everywhere and @xmath are both real. We require that the
@xmath are fermionic operators:

  -- -------- -- -------
     @xmath      (418)
  -- -------- -- -------

Thus we parameterize @xmath and @xmath via @xmath . The inverse
transformation to the Bogoliubov fermions is given by

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (419)
  -- -------- -------- -------- -- -------

Which can be used to rewrite the Hamiltonian in terms of the Bogoliubov
fermions:

  -- -------- -------- -------- --
     @xmath   @xmath   @xmath   
                       @xmath   
                       @xmath   
                       @xmath   
              @xmath   @xmath   
                       @xmath   
  -- -------- -------- -------- --

up to a constant vacuum energy. We can make the off-diagonal terms
vanish if

  -- -------- -- -------
     @xmath      (421)
  -- -------- -- -------

Thus

  -- -------- -- -------
     @xmath      (422)
  -- -------- -- -------

or

  -- -------- -- -------
     @xmath      (423)
  -- -------- -- -------

We can recover the constant vacuum energy by noting that the original
Hamiltonian was traceless and the trace should be preserved under the
canonical transformations we have performed. Since @xmath we find that

  -- -------- -- -------
     @xmath      (424)
  -- -------- -- -------

The vacuum (ground) state of this system has no Bogoliubov fermions
occupying any sites. Note that there is a gap between this state and
excited states. Further note that the energy of this vacuum state is
really dependent on @xmath :

  -- -------- -- -------
     @xmath      (425)
  -- -------- -- -------

We note that @xmath because each term in the sum is greater than unity.
Thus if we compare a Ising chain in a transverse field to one which is
simply in a transverse field the Ising chain in the transverse field
always has a lower energy ground state. Further we note that @xmath if
@xmath .

Let us return to the correction term @xmath in Eq. ( 410 ). When we
express this term in momentum space we find that

  -- -------- -- -------
     @xmath      (426)
  -- -------- -- -------

The first observation is that for large @xmath , this term becomes a
small correction to the energy derived above. Furthermore, each given
term has an eigenvalue @xmath which has a value between @xmath . This
implies that the correction to our expression Eq. ( 424 ) will be bound
from above by @xmath . Thus we have found that

  -- -------- -- -------
     @xmath      (427)
  -- -------- -- -------

#### 84 Clusters, clusters, everywhere

Having nearly exactly calculated the spectra of the Ising with
transverse field Hamiltonian of length @xmath we understand the spectrum
of the total spin ladder Hamiltonian. For each subspace corresponding to
a specification of @xmath we can construct the binary string @xmath
labeling the structure of the Hamiltonian on the @xmath specified
subspace. Each such string can further be specified by the values where
the elements take the value @xmath and, in particular, we wish to simply
label such a subspace by the structure of such @xmath clusters. A @xmath
cluster from the @xmath th to the @xmath qubit will be denoted by @xmath
. Thus every string will correspond to some cluster structure @xmath
where @xmath is the number of @xmath clusters in a string. Thus, for
example @xmath which has @xmath @xmath clusters, two of length @xmath
and one of length @xmath . For each cluster labeling the spectrum of the
Hamiltonian @xmath has a structure related only to the number and size
of the clusters. In particular if two subspaces have identical cluster
structure (number of cluster of a given length is identical) then they
have an identical spectrum (with different eigenstates however). This is
because, for a given cluster of length @xmath , the Hamiltonian takes on
the structure of an Ising chain with a transverse magnetic field which
we have analyzed above. Let us label the cluster structure by @xmath
where @xmath is the number of clusters of length @xmath . Clearly @xmath
. Let @xmath label the ground state energy of a cluster of length @xmath
physical qubits which corresponds to a cluster of @xmath in the bit
string @xmath . In particular from the previous section we know that

  -- -------- -- -------
     @xmath      (428)
  -- -------- -- -------

For elements which are not members acted upon by a cluster, only the
@xmath Hamiltonian contributes to the spectrum of these sights. For a
given cluster structure @xmath the vacuum state of the Hamiltonian has
an energy

  -- -------- -- -------
     @xmath      (429)
  -- -------- -- -------

It is easy to then verify that the global ground state corresponds to
the subspace where @xmath , i.e. the full cluster situation.

Further we note that the for every cluster configuration @xmath
corresponds to two different @xmath configurations and thus all of the
levels of our Hamiltonian are two-fold degenerate. To see this note that
@xmath is unchanged if the value of every element in @xmath flip signs.
Every element of the spin ladder Hamiltonian, therefore, is two-fold
degenerate. The ground state of the system then corresponds to the
Hamiltonian over the subspace defined by @xmath and also by @xmath .

#### 85 Quantum error correcting properties

Let us now examine the error detecting and correcting properties of the
spin ladders ground state. We will examine the error properties of
information encoded into the degeneracy of the ground state of the
Hamiltonian.

Instead of using the basis @xmath it is convenient to work with the
basis @xmath where @xmath where we recall that @xmath . The ground state
is therefore labeled by @xmath where @xmath is the ground state of the
full cluster Hamiltonian, @xmath represents @xmath and @xmath now labels
the degeneracy of this ground state.

The first thing to notice is that any operator which acts as identity on
the degeneracy is a detectable error. In other words

  -- -------- -- -------
     @xmath      (430)
     @xmath      
  -- -------- -- -------

where @xmath is the matrix element @xmath .

We will now show that

  -- -------- -- -------
     @xmath      (431)
  -- -------- -- -------

where @xmath is any product of a single @xmath operator and up to @xmath
@xmath or @xmath operators.

First note that any product of up to @xmath @xmath or @xmath operators
is a product of up to @xmath @xmath operators and @xmath @xmath
operators. Let us examine the case where @xmath contains a @xmath
operator and then we will examine the case where @xmath does not appear
in @xmath . A single @xmath is either @xmath or @xmath . Under the
Jordan-Wigner transformation, @xmath is a sum of a product of an odd
number of Bogoliubov fermions. Furthermore any product of @xmath ’s is
given by a sum of an even number of Bogoliubov fermions. Multiplying
together a single @xmath and any number of @xmath operators, we thus
create an operator with a sum over an odd number of Bogoliubov fermions.
It is an elementary result of fermion operators, then, that an error
@xmath constructed from @xmath and any number of @xmath has a vanishing
matrix element over the ground state

  -- -------- -- -------
     @xmath      (432)
  -- -------- -- -------

Furthermore, multiplying such an error @xmath any product of @xmath and
@xmath operators does not change this result because these operators act
on a different tensor product subsystem. We therefore see that any error
which contains a single @xmath any combination of @xmath ’s satisfies
the error detection criteria, Eq. ( 431 ).

Next let us examine the case where @xmath does not appear in the error
@xmath , but the product of @xmath @xmath operators do appear in error
@xmath . Every such error will be a product of up to @xmath @xmath
operators and @xmath @xmath operators. @xmath @xmath operators acting on
the ground state @xmath changes at lest one value of @xmath . Therefore
if @xmath is the product of @xmath @xmath operators and operators @xmath
,

  -- -------- -- -------
     @xmath      (433)
  -- -------- -- -------

as long as @xmath contains at least one @xmath . If, on the other hand
@xmath contains only @xmath , then

  -- -------- -- -------
     @xmath      (434)
  -- -------- -- -------

because @xmath acts only on the first tensor product of the ground
state. @xmath is some constant independent of @xmath and @xmath .

We have therefore shown that the ground state of the spin ladder is an
error detecting code for any product of a single @xmath and @xmath
products of @xmath . This result is equivalent to saying that the code
is an error detecting code for single @xmath operators and is an error
correcting code for @xmath @xmath operators.

#### 86 Supercoherent properties of the spin ladder ground state

We have now shown that the ground state of the spin ladder is an error
detecting code for single @xmath errors and error detecting for @xmath
@xmath errors. In order for this to qualify as a supercoherent spin
ladder, there must be a gap between the ground state energy and higher
energy levels. We know that this is true because we have found that a
unique ground state. However, it is useful to qualify the size of this
gap.

As we calculated in Section 84 the ground state of the spin ladder
occupies a specific subspace assignment of @xmath . Specifically the
ground state corresponded to @xmath which is the “full cluster”
subspace. There are two types of excitations which can occur on this
ground state. The first type of excitation is where operators maintain
this subspace. These operators will act as Bogoliubov excitations on the
ground state. Recall that the Hamiltonian for this full cluster is given
by

  -- -------- -- -------
     @xmath      (435)
  -- -------- -- -------

Now @xmath varies from @xmath to @xmath . Thus there is always an energy
gap in between the vacuum of this subspace and any Bogoliubov
excitations of this vacuum. The size of such a gap is @xmath . Note that
this is true for any Bogoliubov excitations in any of the subspaces
corresponding to a particular @xmath .

The second type of excitation which can occur is from the ground state
to a state with a different @xmath . This type of excitation has a gap
which is the difference in the vacuum energies of the ground state and
the new state. The smallest such gap occurs when only one element of
@xmath is flipped. This will then divide the system into two clusters.
One of length @xmath and the other of length @xmath . The energy of the
vacuum for this configuration is given by

  -- -------- -- -------
     @xmath      (436)
  -- -------- -- -------

if the element of @xmath which was flipped was not @xmath or @xmath . If
the element which was flipped was at the end, then there is a single
qubit which just feels a transverse field. The difference between the
ground state vacuum and all of the other vacuums can easily be estimated
to be approximately @xmath . Figure 24 shows this gap for @xmath even.

We have therefore seen that the ground state of the spin ladder is
separated from all excitations by @xmath . Thus, for the excitations
which are error detecting all of these errors take the state up in
energy.

An interesting property of this spin ladder was the fact that not only
was the ground state error detecting for the @xmath errors, the spin
ladder is also error correcting for a limited number of @xmath errors.
When such Pauli phase error will be suppressed at low temperatures as in
the supercoherent case, but it is also possible to now correct these
errors. To see how this is done, we note that a @xmath error takes the
ground state causes only an excitation which changes the subspace
labeled by @xmath . Therefore correcting these error corresponds to
making a measurement of the operators corresponding to @xmath . These
are the operators

  -- -------- -- -------
     @xmath      (437)
  -- -------- -- -------

Measurement of these observable diagnoses the flipped @xmath elements
and this can be used to flip these elements back and hence correct to
the error.

We have thus seen that the spin ladder we have constructed has some
amazing properties. The ground state of the spin ladder is doubly
degenerate and separated from all other states by an energy of @xmath .
All single @xmath error act to take the state from its ground state to a
state of higher energy and at low temperatures these errors should be
suppressed. Similarly multiple @xmath errors do not break the degeneracy
of this ground state. Furthermore if @xmath of these @xmath errors
occur, measurements can be performed such that all of these errors can
be corrected. Thus this spin ladder is a hybrid with both supercoherent
and error correcting properties. Since @xmath errors are generally more
damaging to the coherence of a system, the remarkable error correcting
property should make this spin chain extremely useful for protecting
quantum information.

#### 87 Encoded operations

Having shown that the ground state of the spin ladder supports a
supercoherent qubit with the extra property that it can error correct
certain errors we now ask the question of what are the encoded
operations on this degeneracy.

In fact, we could have begun our discussion of this spin ladder by
examining the degeneracy of the spin ladder. The operators

  -- -------- -- -------
     @xmath      (438)
  -- -------- -- -------

commute with the spin-ladder Hamiltonian @xmath . Since each of these
operators square to identity we know that these operators generate
@xmath -dimensional representations of the Pauli group on one qubit. In
other words they act like @xmath dimensional single qubit operations.
Since these operators commute with @xmath we therefore know that these
operators act on the two-fold degeneracy of @xmath .

A further important point is necessary here. Every state in @xmath is
two-fold degenerate. Not only the @xmath and @xmath given above commute
with this Hamiltonian, but also @xmath for @xmath and @xmath for @xmath
. All of these operators enact an encoded @xmath or @xmath on the
degeneracy, however, each may enact a different representation of these
operators on the different levels of @xmath . For any given level,
however, the action of all of these operators is identical. Therefore
one can enact an encoded @xmath via either the operator @xmath or the
operator @xmath . The action of this operator on the ground state is
identical.

Unfortunately, while we could easily implement @xmath as a Hamiltonian
on the code, the operator @xmath is not so easily to implement as a
Hamiltonian on this code (see [ 133 , 134 ] for possible methods). Thus,
like our earlier Pauli stabilizer code example, we are left we a very
good quantum memory without the ability to manipulate the information.

Another interesting problem with this spin chain is that while @xmath
@xmath errors can be corrected, it is possible for the environment to
enact and error which cannot be corrected by using only @xmath energy.
We will not delve into the derivation of this result now as this point
will be taken up in Chapter III where we discuss natural fault-tolerant
quantum computation.

#### 88 The supercoherent spin ladder

In this chapter we studied an interesting spin ladder. This spin ladder
has a supercoherent ground state, and this ground state also has
additional error correcting properties. This is an important first step
towards incorporating more than just the error detection properties of
supercoherence but also error correction. Unfortunately this spin
ladder’s information is not useful for quantum computation because
encoded actions cannot be enacted on the ground state. Further it is
unfortunate that only phase errors can be corrected. Bit flip errors are
only detectable and robustness to these errors must come from the low
temperature of the environment. In the next chapter we will see how it
is possible to encode a full single qubit quantum error correcting code
into the degenerate ground state of a system.

### Chapter \thechapter A Naturally Quantum Error Correcting Ground
State

  To err is human; to forget, divine

  –J. H. Goldfuss

In this chapter we demonstrate a spin lattice system whose ground state
is a single qubit quantum error correcting code. This is the first
example of a fully quantum error correcting ground state constructed
with only two-qubit interaction in the Hamiltonian. The spectrum of the
Hamiltonian is presented using a simplified Stabilizer encoding and it
is shown that the ground state of this system is indeed a quantum error
correcting code for single qubit errors. We discuss the natural error
correcting properties of this spin lattice ground state and encoded
operations on this code. Finally we discuss how adiabatic passage can be
used to prepare the ground state of the spin lattice.

#### 89 The three-by-three quantum error correcting ground state

Consider a three-by-three square lattice with qubits on the vertices of
the lattice (nine qubits total). We label the elements by the row and
column indices @xmath respectively and an operator @xmath which acts on
this qubit tensored with identity on all other qubits is @xmath . The
Hamiltonian we are interested is given by @xmath

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
              @xmath   @xmath      
     @xmath   @xmath   @xmath      (439)
  -- -------- -------- -------- -- -------

This spin-lattice system is sketched in Figure 25 .

##### 89.1 Stabilizer encoding

Once again, in order to understand this Hamiltonian it is useful to work
in a different basis. Particularly useful in this case is a Pauli
stabilized quantum error correction code (see Appendix G ). In
particular consider the stabilizer code with stabilizer elements
generated by the operators

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (440)
  -- -------- -------- -------- -- -------

and corresponding to this code are the five logical operators

  -- -------- -------- -------- -- -------
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      
     @xmath   @xmath   @xmath      (441)
  -- -------- -------- -------- -- -------

Using this code, we can express that Hamiltonian as

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (442)
                                @xmath   
  -- -------- -------- -------- -------- -------

Notice, as in the original supercoherent Pauli example, the fifth
encoded qubit does not appear in this Hamiltonian. This will be
degenerate codespace we will use to store the quantum information.

Unfortunately, even after the reduction to four encoded qubits, we have
not found the exact eigenvalues and eigenstates of this Hamiltonian.
Instead we resort to the mathematical package Mathematica to calculate
the spectrum.

#### 90 The spin-lattice spectrum

Corresponding to the eigenvalues of @xmath , @xmath , @xmath , and
@xmath , Eq. ( 442 ) has a specific form. Moreover, @xmath , @xmath ,
@xmath , and @xmath can be simultaneously diagonalized. We label each of
the subspaces defined by these operators via their eigenvalues @xmath .
For an assignment of @xmath , @xmath , @xmath , @xmath , the four qubit
Hamiltonian in Eq. ( 442 ) The spectrum of the four qubit Hamiltonian
Eq. ( 442 ) was calculated using the program Mathematica. These energies
are assembled in Table 7 .

We see from Table 7 that the ground state of @xmath over the four
encoded qubits is unique and inhabits the @xmath subspace. As mentioned
above, the fifth encoded qubit is not involved in @xmath and therefore
all of the states in Table 7 will be two-fold degenerate corresponding
to this encoded qubit.

In order to label the states of the spin-lattice we use the basis @xmath
where @xmath are the @xmath eigenvalues of @xmath , @xmath labels the
energy levels sorted from @xmath the lowest energy to @xmath the highest
energy (and picking some arbitrary ordering and basis for the degenerate
states), and @xmath is the @xmath eigenvalue of @xmath .

#### 91 Ground state error correcting properties

The two-fold degenerate ground state of the spin-lattice system is given
by the state @xmath . We will now show that this state is an error
correcting code for all single qubit errors. The condition that the
ground state is an error correcting code for all single qubit errors is
given by

  -- -------- -- -------
     @xmath      (443)
  -- -------- -- -------

where @xmath . Notice we allow the identity operators in this
expression.

Every operator of the form @xmath where @xmath anticommutes with at
least one element of the stabilizer generators @xmath . This implies
that

  -- -------- -- -------
     @xmath      (444)
  -- -------- -- -------

This follows from the standard reasoning about stabilizer codes. If the
error element anticommutes with one of the stabilizer elements, the
action of this error is to flip the value of the corresponding @xmath
eigenvalue. Therefore the matrix element vanishes.

Thus we need only concern ourselves with the @xmath elements. The
identity case, @xmath is trivially filled. Some of these elements
anticommute with a generator of the stabilizer @xmath and therefore, via
the argument of the previous paragraph satisfy Eq .( 443 ). It is easy
to check that all of the elements which do not anticommute with a
generator of the stabilizer @xmath can be written as a product of the
first four encoded qubit operators and the stabilizer elements

  -- -------- -- -------
     @xmath      (445)
  -- -------- -- -------

where @xmath or @xmath and @xmath . Therefore this operator only acts on
the first four encoded qubits and not the encoded qubit. Therefore we
see that for these elements

  -- -------- -- -------
     @xmath      (446)
  -- -------- -- -------

where @xmath does not depend on @xmath or @xmath and therefore satisfies
the error correcting requirement.

We have thus seen that the ground state of the spin-lattice system is a
error correcting code for single qubit errors.

How does one perform the error correction procedure for this ground
state? One manner is as follows. There are two kinds of errors. The
first type of error takes the state from the @xmath subspace to another
@xmath labeled subspace. By measuring the stabilizer elements, these
errors can be detected and corrected. The second type of error preserves
@xmath subspace but acts as an excitation on the four qubit encoded
Hamiltonian. One way to determine if there error has occurred is to
measure the Hamiltonian itself @xmath . If the value is not that of the
ground state, then appropriate manipulations can be applied to restore
the system to the ground state. This method of error correction is,
however, appears very difficult to implement on the ground state.
However, in the next section we shall argue that the system will apply
much of the error correction procedure through the naturally evolution
of the system plus environment.

#### 92 Natural error correction

Inspection of Table 7 shows that the ground state is separated from
states reached by an error @xmath . All single qubit errors, as in
supercoherence, take the system from the global ground state to a state
of higher energy. There is an important consequence, however, of the
fact that the ground state of the spin-lattice is a quantum error
correcting code.

Consider supercoherence first. Suppose a single qubit error occurs on
the supercoherent ground state. The state will then be excited to higher
energy levels. Since the supercoherent ground state is only error
detecting, it is in general impossible to restore the system to the
ground state without destroying the quantum information stored into the
degeneracy of the supercoherent system. In supercoherence then, a single
qubit error will occur and any relaxation of the system back to the
ground state will occur in such a way that the degeneracy is acted upon
nontrivially. Once an error has happened on the supercoherent ground
state, the supercoherent information is in trouble of being decohered.

Now consider the spin lattice we have described above. As in the
supercoherent case if a single qubit error occurs on the ground state of
the spin-lattice the state will be excited to higher energy levels. Now,
however, because the ground state is error correcting there is the
possibility of restoring the information to the ground state without
decohering the information stored in the degeneracy. In fact, one of the
relaxation pathways open to a system which decoheres back to the ground
state will be exactly the error correction procedure necessary to
restore the system to the ground state without destroying the degeneracy
of the system. The fact that one of the open system evolution pathways
open to the system is the error correcting procedure follows directly
from the Hermiticity of the Hamiltonian. It is important to note that in
our spin-lattice case the relaxation back to the ground state is not
always error correcting. It is possible for the state to take a
relaxation pathway which goes through other energy levels and thus
destroys the degeneracy of the ground state. This corresponds to a two
qubit error which our single qubit error correcting code is not designed
to correct. However, the Hermiticity of the Hamiltonian implies that the
relaxation pathway which fixed the error is open an thus evolution of
the spin-lattice has a non-negligible component along the error
correction pathways.

In Figures 26 and 27 we show a schematic of the difference between
supercoherence and the quantum error correcting spin-lattice.

The ability of a system to self-correct decoherence processes is an
interesting property of our spin-lattice system. In fact, our
spin-lattice system is the first example of such automatic or natural
error correction which uses only two-body interactions between qubits.
There are two precedents for such automatic error correction, one by
Barnes and Warren [ 14 ] and the other from Kitaev and coworkers [ 112 ,
114 , 34 , 85 ] .

Barnes and Warren [ 14 ] present a scheme where errors are automatically
corrected. These authors present an NMR implementation whose ground
state is an error correcting code. We note, however, that this
implementation only corrects limited types of errors. In particular
their system does not correct single qubit phase errors. In fact, as we
will discuss in Chapter III , the system presented by Barnes and Warren
is not any more special than a two-dimensional Ising system. In contrast
to the proposal of Barnes and Warren, the spin lattice we present can
correct all single qubit errors. On the other hand, our system has the
shortcoming that correction does not always succeed.

The second precedent for our spin lattice is the work of Kitaev and
coworkers [ 112 , 114 , 34 , 161 , 154 , 85 ] . In this work, codes are
constructed which have a ground state which is quantum error correcting.
However, in these systems the interactions needed in order to make this
system naturally error correcting require either interactions between
greater than three subsystems or require two-body interactions between
subsystems with greater than @xmath levels for each subsystem! The
benefit of our spin-lattice system should be obvious in this respect as
it removes this many-body or many-level restriction.

#### 93 Encoded operations

The encoded operation on the degeneracy are easy to find. The encoded
@xmath and @xmath are simply the @xmath and @xmath operators. As in the
spin ladder system, we see that there is a difficulty in implementing
the operators on this spin lattice. We shall not delve into method for
fixing this problem here. Needless to say, it is possible to construct
lattices which are error correct but for which can also be manipulated.

However, let us note two interesting properties of the encoded
operators. Suppose we wanted to perform the gate @xmath on the
degeneracy. This corresponds to the operator @xmath (or such an operator
times a stabilizer element. One way in which this gate can be enacted is
by performing single qubit rotations on each of the listed qubits.
Suppose that one of these single qubit rotations was over rotated. Such
an over rotation now becomes an error on the ground state. But this
error will be correctable (either naturally or by our error correction
procedure). This then is a form of fault-tolerance . The gate we use to
implement the rotation can be faulty and we still will obtain the
correct operation. We will have a chance to considerably extend this
notion in Chapter III .

Second we note that systems much like the spin-lattice we have
constructed here can most easily be constructed from the encoded
operations backwards. In particular, the encoded operations will be the
operations which are errors on the system. Thus given encoded Pauli
operators, constructing operations which are products of the remaining
Pauli operators guarantees the error correcting properties of the ground
state. This is a powerful tool for constructing such codes: work with
the operators on the code first!

#### 94 Preparation via adiabatic passage

An interesting question which arises in the context of using the
information the ground state of the spin lattice is the question how to
prepare the information. A method for doing this can be achieved using
the adiabatic theorem. Suppose, for instance that we could completely
turn off the @xmath operators in @xmath and then slowly turn these
operators back on. In particular consider the ability to enact the time
dependent Hamiltonian

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (447)
                                @xmath   
                                @xmath   
  -- -------- -------- -------- -------- -------

where @xmath is constant with units of time.

The adiabatic theorem [ 146 ] states that a system which is in an
eigenstate of a time dependent Hamiltonian will remain the instantaneous
eigenstate of the system if variation of this Hamiltonian is slow enough
and the energies of the Hamiltonian do not cross. In Figure 28 we see
that the ground state does not cross any other state. Thus for
sufficiently long @xmath , if we can prepare the state into the ground
state of @xmath we can then guarantee that we end up in the ground of
the spin lattice Hamiltonian @xmath . Furthermore, the degeneracy of the
system will remain intact throughout this evolution. But preparation
into the ground state of @xmath with a given degeneracy is easy. In
particular the state where every qubit is @xmath is such a ground state.
How slow do we have to ramp up the field? From the adiabatic theorem [
146 ] we find that we require @xmath . Thus there is an easy method for
preparing the state via the adiabatic theorem.

#### 95 Natural quantum error correction

In this chapter we have presented the first example of a ground state
which is a full single qubit quantum error correcting code. This ground
state has the intriguing property that all single qubit error excite the
system to an energy level of higher energy and there is a non-vanishing
probability that the system will then decay back to the ground state in
such a way as the correct the error. Clearly the next step along these
lines is to demonstrate how one can obtain perfect automatic error
correction where each single error is always corrected unless the system
is excited to a higher energy. Furthermore the issue of how to robustly
perform operations on the spin lattice ground state was not
satisfactorily addressed. In the next chapter we will have the chance to
address these issues from the context of a more distanced perspective.

### Chapter \thechapter Towards Naturally Fault-tolerant Systems

  What passes for optimism is most often the effect of an intellectual
  error

  –Raymond Aron, The Opium of the Intellectuals [ 6 ]

Before the discovery of quantum error correction and fault-tolerant
quantum computation, there was much reason to be pessimistic [ 190 , 129
] about the future technological prospects of the construction of a
quantum computer. Having discovered quantum error correction followed by
the penning of the threshold theorem for indefinite fault-tolerant
quantum computation, the prospects for building a quantum computer has
brightened considerably. The influence of the discovery of quantum error
correction, however, has not had much of an impact on the experimental
proposals for quantum computation. True, many proposals now mention the
explicit requirement that parallel operations are necessary for
fault-tolerant quantum computation [ 2 ] , but the notions of
fault-tolerance are mostly viewed as an eventual goal of a given
physical proposal. Calculate your error rate, demonstrate you have
universal control, and you have a quantum computer! To proceed in this
manner calls on the argument of technological inevitability, but is it
not possible that there are systems which are naturally fault-tolerant
for quantum computation just as such system exist for classical
computers? In this chapter we lay out the schematics for such a
naturally fault-tolerant quantum system built not from the single qubit
up but from large numbers of qubits whose collective properties are used
for quantum information manipulation.

#### 96 The classical stability of information

Why is it that classical computers are, to date, so overly robust to
interaction with their environment? In fact, it is a mistake to say that
all classical computers are robust to interactions with their
environment. One need only take a standard household personal computer
out into the hard radiation of space to see that classical computers are
only robust in certain environments. Further it is also obvious that the
actual physical implementation of the classical computer is essential to
the robustness of the classical computer: building a classical computer
out of billiard balls is possible, but then substantial error correction
is needed to make the system robust to small deviations in the
trajectories of the billiard balls. So we should really ask, why are
today’s silicon-based computers with magnetic recording devices so
robust to sufficiently non-harsh environments?

We will begin by examining the question of what make the robust
long-term storage of classical information possible.

##### 96.1 Classical memory, security in numbers, and the lesson of
dimensionality

Today’s classical memory devices come in two forms, read-only and
read-write memories. In a read-only memory, information is imprinted
once and can be read out but not changed without substantial technical
prowess. We will focus on the read-write memories where classical
information can both be imprinted and easily manipulated. In particular
we will focus on the use of magnetic media which is the media used for
storage in most hard drives.

Information on a hard drive is stored in spatially distinct grains of a
ferromagnetic substance. The grains of the ferromagnetic substance
consist of complete magnetic domains and are magnetized in one of two
possible directions which are the logical @xmath and @xmath of the
classical information. This information is read and written using a
device known as a read-write head. This head can read the information by
sensing the direction of the magnetized domains and writes information
by applying a magnetic field magnetizes the domain.

The question of the stability of such a memory is therefore a question
of the stability of the magnetization of a ferromagnetic substance. The
properties of a ferromagnetic substance are dominated by an exchange
energy between the electron spins of the substance

  -- -------- -- -------
     @xmath      (448)
  -- -------- -- -------

In addition to this energy, most materials have a magnetocrystalline
energy (or anisotropy energy) in which different directions of
magnetization have a preferential (lower) energy. The exchange energy,
however, dominates the ferromagnetic properties of the substance. The
exchange energy is minimized when all of the spins are completely
aligned. This is the origin of domains in magnetization of a
ferromagnetic material: the electrons would rather align with each
other. The magnetocrystalline energy is essential in determining which
directions within the solid are preferred.

Let us now show how such ferromagnetic substances can be understood to
be a classical automatic error correcting code. In order to see this,
consider the simplified model of a ferromagnet given by the Ising model
[ 103 ] . In this Ising model, spins on a lattice are assumed to point
in one of two directions @xmath and the energy of system is given by
nearest neighbor interactions of the form

  -- -------- -- -------
     @xmath      (449)
  -- -------- -- -------

where @xmath is the energy of the nearest neighbor bonds @xmath and
@xmath is an applied field. In the absence of an applied field @xmath ,
the ground state of this system is a two-fold degenerate with all of the
spins parallel. In the presence of a magnetic field, the ground state is
one of the two configuration with all of the spins parallel determined
by sign of the applied field @xmath . Let us ignore @xmath for now but
we will return to nonzero @xmath later.

The degenerate ground state of the Ising model with no magnetic field
can be considered an encoding of classical information. Let us define
logical @xmath as the case where @xmath for all lattice sites @xmath and
logical @xmath as the case where @xmath for all lattice sites @xmath .
An important consideration enters into the stability of this encoded
information: the dimensionality of the lattice of spins. For now we will
assume that this dimension is greater than or equal to two. At @xmath
(i.e. completely isolated from any environment), the ground states will
just stay where they are. But as the temperature is turned up @xmath ,
it is possible for the environment to excite the spins in the system and
destroy the information encoded into this degeneracy. What is it that
protects the information encoded into this degeneracy from such errors?

Define the spontaneous magnetization as the expectation value of all of
the lattice spins @xmath where @xmath is the number of spins in the
lattice. For the two-dimensional Ising system on a square lattice, for
example, it is possible to exactly solve for the spontaneous
magnetization [ 159 ] which is given by

  -- -------- -------- -------- -------- -------
     @xmath   @xmath   @xmath            (450)
                       @xmath   @xmath   
  -- -------- -------- -------- -------- -------

where @xmath . At low enough temperatures, @xmath , the spontaneous
magnetization of the system persists. Even though there the environment
can heat the system, the information stored in the total magnetization
is unaffected by these fluctuations. In ferromagnetic materials, the
temperature @xmath is the Currie temperature of the material: usually on
the order of a thousand Kelvin. So the mystery has become why does this
magnetization persist at non-zero temperature.

Consider taking a two-dimensional Ising model with all of the spins
parallel and flipping a single one of the spins. This will result in a
change of energy of the system by @xmath where @xmath is the number of
neighbors to which the spin is attached. This is the lowest energy
excitation which can occur on the system without flipping @xmath out of
@xmath spins. The second of these options, flipping @xmath out of @xmath
spins requires an extraordinary amount of energy which just is not
available. Suppose after we flip the single spin, we flip another spin.
The energy of this new configuration must now be even higher than the
system with just one spin flipped. To see this, first note that if the
next spin flipped is not a neighbor of the first spin flipped, then
there is certainly an increase in energy. If the second spin is a
neighbor of the first spin, because the dimension of the spin lattice is
greater than one the total number of violated Ising energies must
increase. See Figure 29 .

We can now see how the Ising model in greater than two dimensions can be
viewed as an automatic error correcting code. The codewords are the
majority labeled states with all of the spins aligned in parallel. Each
bit flip error that occurs on the system, until over @xmath spins have
been flipped, causes an increase in the energy of the system. Therefore
the tendency of the system is to self correct the errors which have
occurred. There is security in numbers here and one sees the most
trivial error correcting code, the majority code, at work. When one
performs thermodynamical calculations of the magnetization of this
system, the unlikelyhood of spin flips which flip between the @xmath and
@xmath states is reflected in the persistence of spontaneous
magnetization. At low enough temperature, this magnetization thus
persists. Long rang off diagonal order [ 144 ] is therefore an
indication of the ability of the system to self-correct errors on the
system. We also see how an applied field can change the state of
affairs. If the applied field is strong enough, then it can overcome the
Ising bonds and flip the information encoded into the degeneracy of the
ground state. Note also that even the states which have up to @xmath
qubits flip still maintain the information about the classical
information. It is only when the sign of the total magnetization flips
sign does the classical information get destroyed.

Of central importance in the argument for the stability of the
information in the degeneracy of the Ising model was the dimension of
the system. When a spin is flipped in the two dimensional Ising model
from the ground state, the energy of the system is proportional to the
number of bonds with nearest neighbors broken. More generally domains of
flipped spins have an energy greater than the ground state energy which
is proportional to the area of the perimeter of the domain. In @xmath
dimensions, the energy of a domain is proportional to the @xmath
dimensional surface area of a domain. For one dimension, we therefore
see that this energy is a constant. This implies that it is possible to
exchange a minimal amount of energy between the environment and the
system while destroying the information stored in the degeneracy.
Consider the one dimensional Ising model. One can flip a single spin
which requires only the bond energy @xmath , and then proceed to flip
neighboring spins without expending any energy. Thus it is possible to
use only @xmath energy in destroying the degeneracy of the ground state.
This is shown in Figure 30 . The condensed matter theorist would say,
“there is no long range order at nonzero temperature for the one
dimensional Ising model” which we see is equivalent to the statement
that the system will not automatically correct its own errors. We will
return to this question when we consider quantum models, but we note
here that all of the examples we have demonstrated in Part III of this
thesis are analogous to the one dimensional Ising case in that errors
(now quantum) can occur which only exert a minimal amount of energy in
order to decohere the degenerate quantum information.

We have thus seen that classical information stored in a magnetic media
is robust due to a robust automatic error correcting code. This
information is robust because errors which occur to the information are
robustly fixed. Further the information can be written on by the
application of a field which breaks the degeneracy of the information
and further changed the energetics of the system which allowed for the
degeneracy to be protected.

##### 96.2 Classical gates

Next we ask the question of what makes the classical manipulation of
information so robust to error. Classical computation occurs on the
manipulation of current in an integrated circuit and the important
manipulation of the current is that of a simple switch. The prototype of
such manipulation is the transistor. Consider, for example a standard
bipolar junction transistor. In such a transistor, a small voltage bias
between the emitter and the base can lead to a large change in the
current running from (for a npn transistor) the collector to the
emitter.

There are two lessons to be learned from the manipulation of information
by a transistor. The first lesson comes from the use of current to
represent information. It is important to realize that current
represents a majority voting correcting code in a method similar to that
encountered in magnetic medium above. Surely current can run the wrong
way in a circuit, but only at the expense of energy conservation. If
insufficient energy is provided by an environment, then the majority of
electrons will flow in the correct direction. The second lesson taken
from the transistor is that a small change in one information carrier
can make a large change in the information of another information
carrier. In particular this change must be digital in the sense that the
system is robust to small variations in the controlling mechanism. The
transistor either does or does not allow current flow between the
collector and emitter. This is a very important property of a
fault-tolerant system: applying the gate and not applying the gate are
two macroscopically separate actions.

Classical gates therefore rely on a form of natural error correction by
majority manipulation of the information as well as a completely digital
manipulation of the information.

#### 97 Natural quantum error correction

Having briskly described the reasons why classical computers are so
robust we now seek to extend these notions to quantum systems. The
lesson of quantum error correction is that quantum information is a bit
more complicated, but very similar to classical information. Quantum
error correction works because it deals not just with the bit flips of
classical error correction but also because it deals with phase errors.
It would not be surprising then to find that, just as there are natural
classical error correcting codes, there may be natural quantum error
correcting codes.

For simplicity we will assume a collection of qubits which we desire to
be naturally endowned with error correction. Obvious generalizations are
possible to other subsystems and we shall leave these generalization
implicit.

A natural quantum error correcting code is a collection of @xmath qubits
and a system Hamiltonian @xmath which satisfies

1.  The ground state of the Hamiltonian @xmath is degenerate.

2.  The ground state of the Hamiltonian @xmath is a quantum error
    correcting code for @xmath qubit errors.

3.  Let @xmath denote the energy of the lowest level reachable by @xmath
    single qubit errors on the ground state. For @xmath less than the
    number of correctable errors, @xmath and @xmath

Item 1 and 2 insure that information can be encoded into the ground
state and is a quantum error correcting code. Item 3 insures that each
error must supply energy from the environment to the system and that the
total energy needed to induce an error on the ground state is an
extensive variable. This last requirement is extremely important for
natural error correction as it requires that the amount of energy needed
to break the degeneracy is a macroscopic amount of energy in the sense
that it depends on the size of the system. Finally we note that due to
the Hermiticity of the system-environment Hamiltonian, error pathways
are always accompanied by correction pathways. The basic idea is there
that of the automatic error correction of Barnes and Warren [ 14 ] where
errors are automatically fixed as they move up in energy. We must stress
again, however, that the example of Barnes and Warren is only a
classical error correcting code (just because a system is quantum this
does not make the dynamics uniquely quantum). Here we would like to
fully extend the notion to quantum error correction. Furthermore we
would also like to stress the requirement that breaking the degeneracy
of the system require a macroscopic expenditure of energy. This
requirement protects the quantum information from all but the most
energetic environmental fluctuations.

One of the best ways to examine an error correcting code is to examine
the encoded operations which manipulate the code. Encoded operations
must consist of operators which act on greater than the number of qubits
which the error correcting code can correct. This requirement implies
that all encoded operators must be of size @xmath on a natural error
correcting code. By examining the smallest encoded operations on the
code it is possible to determine whether the code can satisfy the
natural quantum error correcting criteria.

Consider, for example, an extension of the Pauli supercoherent example
of Chapter III and the quantum error correcting ground state of Chapter
III . Given a @xmath square lattice with sites @xmath acted upon by the
Hamiltonian

  -- -------- -- -------
     @xmath      (451)
  -- -------- -- -------

This Hamiltonian has a degenerate ground state for the following reason.
The smallest Pauli operators which commute with @xmath are the column
@xmath operators: @xmath and the row @xmath operators: @xmath . Take any
two of these operators. Since they square to identity and form a group
isomorphic to the single qubit Pauli group, these operators act as
@xmath @xmath -dimensional irreps of the Pauli group. Therefore the
Hamiltonian @xmath must have a degenerate ground state which is at least
two-fold degenerate. The degeneracy of this ground state may, in fact,
be more than this two-fold degeneracy. But notice that we have shown
that there are operations on the degenerate ground state which involve
@xmath single qubit operators on a system with @xmath qubits. This
system, then, does not satisfy the requirement that the system is an
error correcting code for @xmath

It is perhaps best, then, when constructing a naturally quantum error
correcting code to start from the operators which manipulate the
information and work backwards. Further we note that naturally quantum
error correcting codes do in fact exist [ 160 ] . However, the known
constructions involve four dimensional spatial configurations as well as
unreasonably complicated many-body or many-level interactions. The
challenge of natural quantum error correction is to achieve a naturally
error correcting code without these unphysical assumptions.

Finally we would like to note some physical properties of a natural
quantum error correcting code. The quantum error correcting code
condition implies that for a naturally quantum error correcting code

  -- -------- -- -------
     @xmath      (452)
  -- -------- -- -------

where @xmath and @xmath are the ground state codewords and the sum is
over all lattice sites. If, for example, each qubit is a spin, this
would imply that the codewords all have the same net magnetization. It
is therefore impossible to measure the information encoded into the
degeneracy by simply measuring the bulk magnetization of such a
naturally error correcting code. The question of the readout of
information will be addressed in the next section where we discuss
fault-tolerant quantum computation.

#### 98 Natural fault-tolerant quantum computation

The notion of natural quantum error correction is not enough for quantum
computation. Natural quantum error correcting codes will protect the
quantum information, but this says nothing about preparing the
information, manipulating the information, and reading out the
information in a robust manner.

In classical information manipulation, we saw that there were two
requirements for fault-tolerance: the digital nature of manipulations as
well as the self correcting energetics like standard quantum error
correction.

Suppose we are given a natural quantum error correcting code and wish to
perform a manipulation of the information stored in the code. This will
be achieved by turning on some Hamiltonian which manipulates the
information. Due to the natural error correcting criteria specified
above the only operators which can affect the degeneracy of the code
states are those which involve qubit operators which are of size @xmath
. This gate will enact and operation on @xmath qubits. A set of gates
@xmath is said to be a fault-tolerant gate set if

1.  Every gate can be implemented in a manner that faulty gates
    correspond to errors which can be corrected by the natural quantum
    error correcting code.

2.  Any two gates are separated from each other by @xmath qubit
    operators.

When item 1 is fulfilled, faulty gate creation corresponds to errors
which can and will be naturally corrected by the code. This is the
requirement of energetics: a macroscopic expenditure of energy enacts
the operation and fluctuations in this enacting cannot destroy the
quantum information unless these fluctuations convey a macroscopic
amount of energy to the system. The second requirement is the
requirement of the digital nature of the gate set. It must not be
possible for different encoded actions to be enacted which are close
together in the space of errors.

Consider, as an example, a code on @xmath qubits in which an encoded
action is performed by enacting the @xmath operator which consists of a
@xmath on every qubit @xmath . Now suppose that these operators @xmath
are created using a Hamiltonian @xmath : @xmath where @xmath is a fixed
constant. Now suppose that an over rotation in the enacting of this gate
occurs. Instead of @xmath on each qubit, the gates enacted are @xmath .
For small @xmath this can be expressed as @xmath . The full evolution if
each gate is overrotated by @xmath is given by

  -- -------- -- -------
     @xmath      (453)
  -- -------- -- -------

The major corrections to the evolution are therefore single, two, etc.
qubit errors. If the error correcting code can naturally correct @xmath
errors, then the only evolution which escapes detection is a correction
@xmath which is exponentially small. Thus microscopically faulty errors
will not be able to destroy the quantum information.

Two issues remain to be addressed for a naturally fault-tolerant quantum
computer. The first is preparation and the second is measurement. An
important realization for a natural quantum error correcting code is
that preparation does not mean perfect preparation of the degenerate
ground state, but instead means perfect preparation of the degenerate
ground state plus a minimal amount of errors occurring on to this ground
state. The important point of fault-tolerant preparation is that
preparation should prepare a state which may have errors but none of
these errors are macroscopic errors which act nontrivially on the
degeneracy. One method which appears to be extremely useful for
preparation and measurement of information in a naturally fault-tolerant
code is the use adiabatic continuity. In order to prepare a state, the
degeneracy of the ground state should be macroscopically broken. This
then will correspond to a macroscopic breaking of the degeneracy of the
ground state. By adiabatically changing the system Hamiltonian it should
be possible to move from a state were this degeneracy is broken to the
state where this degeneracy is not broken while maintaining a robust
error correcting criteria. Finally reversing this process adiabatically
the degeneracy can again be restored and a measurement of a macroscopic
variable can be used to read out the quantum information.

#### 99 The road ahead

  We can’t solve problems by using the same kind of thinking we used
  when we created them.

  –Albert Einstein

In this chapter we have sketched out a road map for the possibility of
natural quantum computing systems. There is much work to be done!
Besides the obvious physical consequences of natural fault-tolerant
quantum computation, the uniformity of such natural fault-tolerant
system can serve as a good test bed for a rigorous proof of the quantum
computing threshold. There are also interesting connections between the
idea of natural fault-tolerant quantum computation and non-abelian gauge
fields [ 114 , 154 ] . Of particular interest are theories of
high-temperature superconductivity [ 170 , 171 , 172 ] and nonabelian
effects in the fractional quantum Hall effect [ 85 , 150 ] which support
discrete gauge groups.

The path towards building a quantum computer will by no means be an easy
journey. Certainly the technological revolution of modern classical
computers was an amazingly complex and difficult revolution. However, it
is unclear that all of the present experimental proposals for a quantum
computer, which build the quantum computer from the qubit up, will be
the ultimate manner in which a quantum computer will be built. In part
III of this thesis we have given simple examples of systems which begin
to exhibit many of the conditions necessary for natural fault-tolerant
quantum computation. The natural assumption that a quantum computer must
be an entirely different type of device than a classical computer is, we
believe, a fallacy born of the mystery attributed to quantum theory.

### Chapter \thechapter Conclusion

  We will either find a way or make one.

  –Hannibal

In the beginning there was Alan Turing, poking away at the foundations
of computer science, dreaming that machines could perform amazing feats
of calculation. Among Turing’s other interests were the foundations of
quantum mechanics [ 102 ] ⁴ ⁴ 4 Alan Turing in fact rediscovered the
Zeno paradox in quantum mechanics [ 102 ] . . Today we stand in the
middle of a computer revolution far outstripping anything possibly
imagined by Turing. There is a hint, however, that Alan’s other
interest, the quantum theory of nature may hold even more revolutionary
computational power than his basic insights into classical computer
science. In this thesis we have, hopefully, provided helpful steps
towards the construction of a quantum computer. Someday, we may even
dream, we may even be as lucky as Alan Turing: the pokings of this
thesis may turn into the revolutionary technologies of tomorrow.